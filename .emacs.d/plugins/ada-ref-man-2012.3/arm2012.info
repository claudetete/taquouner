This is arm2012.info, produced by texi2any version 6.3 from
arm2012.texinfo.

INFO-DIR-SECTION GNU Ada tools
START-INFO-DIR-ENTRY
* Ada Reference Manual TC1: (arm2012).
* Annotated ARM TC1: (arm2012).
END-INFO-DIR-ENTRY


File: arm2012.info,  Node: Top,  Next: Front Matter,  Up: (dir)

Ada Reference Manual
********************

Ada Reference Manual, ISO/IEC 8652:2012(E) with COR.1:2016

                         Ada Reference Manual

                         ISO/IEC 8652:2012(E)

                     with Technical Corrigendum 1

                    Language and Standard Libraries

* Menu:

* Front Matter:: Copyright, Foreword, etc.
* 1 ::        General
* 2 ::        Lexical Elements
* 3 ::        Declarations and Types
* 4 ::        Names and Expressions
* 5 ::        Statements
* 6 ::        Subprograms
* 7 ::        Packages
* 8 ::        Visibility Rules
* 9 ::        Tasks and Synchronization
* 10 ::       Program Structure and Compilation Issues
* 11 ::       Exceptions
* 12 ::       Generic Units
* 13 ::       Representation Issues
* Annex A ::  Predefined Language Environment
* Annex B ::  Interface to Other Languages
* Annex C ::  Systems Programming
* Annex D ::  Real-Time Systems
* Annex E ::  Distributed Systems
* Annex F ::  Information Systems
* Annex G ::  Numerics
* Annex H ::  High Integrity Systems
* Annex J ::  Obsolescent Features
* Annex K ::  Language-Defined Aspects and Attributes
* Annex L ::  Language-Defined Pragmas
* Annex M ::  Summary of Documentation Requirements
* Annex N ::  Glossary
* Annex P ::  Syntax Summary
* Annex Q ::  Language-Defined Entities
* Index ::    Index


File: arm2012.info,  Node: Front Matter,  Next: 1,  Prev: Top,  Up: Top

Front Matter
************

Copyright © 1992, 1993, 1994, 1995 Intermetrics, Inc.

Copyright © 2000 The MITRE Corporation, Inc.

Copyright © 2004, 2005, 2006 AXE Consultants

Copyright © 2004, 2005, 2006 Ada-Europe

Copyright © 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 AXE
Consultants

 





Ada Reference Manual - Language and Standard Libraries

Copyright © 1992, 1993, 1994, 1995, Intermetrics, Inc.

This copyright is assigned to the U.S. Government.  All rights reserved.

This document may be copied, in whole or in part, in any form or by any
means, as is or with alterations, provided that (1) alterations are
clearly marked as alterations and (2) this copyright notice is included
unmodified in any copy.  Compiled copies of standard library units and
examples need not contain this copyright notice so long as the notice is
included in all copies of source code and documentation.

-------  

Technical Corrigendum 1

Copyright © 2000, The MITRE Corporation.  All Rights Reserved.

This document may be copied, in whole or in part, in any form or by any
means, as is, or with alterations, provided that (1) alterations are
clearly marked as alterations and (2) this copyright notice is included
unmodified in any copy.  Any other use or distribution of this document
is prohibited without the prior express permission of MITRE.

You use this document on the condition that you indemnify and hold
harmless MITRE, its Board of Trustees, officers, agents, and employees,
from any and all liability or damages to yourself or your hardware or
software, or third parties, including attorneys' fees, court costs, and
other related costs and expenses, arising out of your use of this
document irrespective of the cause of said liability.

MITRE MAKES THIS DOCUMENT AVAILABLE ON AN "AS IS" BASIS AND MAKES NO
WARRANTY, EXPRESS OR IMPLIED, AS TO THE ACCURACY, CAPABILITY, EFFICIENCY
MERCHANTABILITY, OR FUNCTIONING OF THIS DOCUMENT. IN NO EVENT WILL MITRE
BE LIABLE FOR ANY GENERAL, CONSEQUENTIAL, INDIRECT, INCIDENTAL,
EXEMPLARY, OR SPECIAL DAMAGES, EVEN IF MITRE HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

 

Amendment 1

Copyright © 2004, 2005, 2006, 2007, AXE Consultants.  All Rights
Reserved.

This document may be copied, in whole or in part, in any form or by any
means, as is, or with alterations, provided that (1) alterations are
clearly marked as alterations and (2) this copyright notice is included
unmodified in any copy.  Any other use or distribution of this document
is prohibited without the prior express permission of AXE.

You use this document on the condition that you indemnify and hold
harmless AXE, its board, officers, agents, and employees, from any and
all liability or damages to yourself or your hardware or software, or
third parties, including attorneys' fees, court costs, and other related
costs and expenses, arising out of your use of this document
irrespective of the cause of said liability.

AXE MAKES THIS DOCUMENT AVAILABLE ON AN "AS IS" BASIS AND MAKES NO
WARRANTY, EXPRESS OR IMPLIED, AS TO THE ACCURACY, CAPABILITY, EFFICIENCY
MERCHANTABILITY, OR FUNCTIONING OF THIS DOCUMENT. IN NO EVENT WILL AXE
BE LIABLE FOR ANY GENERAL, CONSEQUENTIAL, INDIRECT, INCIDENTAL,
EXEMPLARY, OR SPECIAL DAMAGES, EVEN IF AXE HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

Third Edition

Copyright © 2008, 2009, 2010, 2011, 2012 AXE Consultants.  All Rights
Reserved.

This document may be copied, in whole or in part, in any form or by any
means, as is, or with alterations, provided that (1) alterations are
clearly marked as alterations and (2) this copyright notice is included
unmodified in any copy.  Any other use or distribution of this document
is prohibited without the prior express permission of AXE.

You use this document on the condition that you indemnify and hold
harmless AXE, its board, officers, agents, and employees, from any and
all liability or damages to yourself or your hardware or software, or
third parties, including attorneys' fees, court costs, and other related
costs and expenses, arising out of your use of this document
irrespective of the cause of said liability.

AXE MAKES THIS DOCUMENT AVAILABLE ON AN "AS IS" BASIS AND MAKES NO
WARRANTY, EXPRESS OR IMPLIED, AS TO THE ACCURACY, CAPABILITY, EFFICIENCY
MERCHANTABILITY, OR FUNCTIONING OF THIS DOCUMENT. IN NO EVENT WILL AXE
BE LIABLE FOR ANY GENERAL, CONSEQUENTIAL, INDIRECT, INCIDENTAL,
EXEMPLARY, OR SPECIAL DAMAGES, EVEN IF AXE HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

Technical Corrigendum 1 for Ada 2012

Copyright © 2013, 2014, 2015, 2016 AXE Consultants.  All Rights
Reserved.

This document may be copied, in whole or in part, in any form or by any
means, as is, or with alterations, provided that (1) alterations are
clearly marked as alterations and (2) this copyright notice is included
unmodified in any copy.  Any other use or distribution of this document
is prohibited without the prior express permission of AXE.

You use this document on the condition that you indemnify and hold
harmless AXE, its board, officers, agents, and employees, from any and
all liability or damages to yourself or your hardware or software, or
third parties, including attorneys' fees, court costs, and other related
costs and expenses, arising out of your use of this document
irrespective of the cause of said liability.

AXE MAKES THIS DOCUMENT AVAILABLE ON AN "AS IS" BASIS AND MAKES NO
WARRANTY, EXPRESS OR IMPLIED, AS TO THE ACCURACY, CAPABILITY, EFFICIENCY
MERCHANTABILITY, OR FUNCTIONING OF THIS DOCUMENT. IN NO EVENT WILL AXE
BE LIABLE FOR ANY GENERAL, CONSEQUENTIAL, INDIRECT, INCIDENTAL,
EXEMPLARY, OR SPECIAL DAMAGES, EVEN IF AXE HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

 

Ada 2005 Consolidated Standard

Copyright © 2004, 2005, 2006, Ada-Europe.

This document may be copied, in whole or in part, in any form or by any
means, as is, or with alterations, provided that (1) alterations are
clearly marked as alterations and (2) this copyright notice is included
unmodified in any copy.  Any other use or distribution of this document
is prohibited without the prior express permission of Ada-Europe.

You use this document on the condition that you indemnify and hold
harmless Ada-Europe and its Board from any and all liability or damages
to yourself or your hardware or software, or third parties, including
attorneys' fees, court costs, and other related costs and expenses,
arising out of your use of this document irrespective of the cause of
said liability.

ADA-EUROPE MAKES THIS DOCUMENT AVAILABLE ON AN "AS IS" BASIS AND MAKES
NO WARRANTY, EXPRESS OR IMPLIED, AS TO THE ACCURACY, CAPABILITY,
EFFICIENCY MERCHANTABILITY, OR FUNCTIONING OF THIS DOCUMENT. IN NO EVENT
WILL ADA-EUROPE BE LIABLE FOR ANY GENERAL, CONSEQUENTIAL, INDIRECT,
INCIDENTAL, EXEMPLARY, OR SPECIAL DAMAGES, EVEN IF ADA-EUROPE HAS BEEN
ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

* Menu:

* 0.1 :: Foreword to this version of the Ada Reference Manual
* 0.2 :: Foreword
* 0.3 :: Introduction
* 0.99 :: International Standard


File: arm2012.info,  Node: 0.1,  Next: 0.2,  Up: Front Matter

0.1 Foreword to this version of the Ada Reference Manual
========================================================

0.1/4
The International Standard for the programming language Ada is ISO/IEC
8652:2012(E).

0.2/4
The Ada Working Group ISO/IEC JTC 1/SC 22/WG 9 is tasked by ISO with the
work item to interpret and maintain the International Standard and to
produce Technical Corrigenda, as appropriate.  The technical work on the
International Standard is performed by the Ada Rapporteur Group (ARG) of
WG 9.  In June 2015, WG 9 approved and forwarded Technical Corrigendum 1
to SC 22 for ISO approval, which was granted in December 2015.
Technical Corrigendum 1 was published in February 2016.

0.4/4
The Technical Corrigendum lists the individual changes that need to be
made to the text of the International Standard to correct errors,
omissions or inconsistencies.  The corrections specified in Technical
Corrigendum 1 are part of the International Standard ISO/IEC
8652:2012(E).

0.6/4
When ISO published Technical Corrigendum 1, it did not also publish a
document that merges the changes from the Technical Corrigendum into the
text of the International Standard.  However, ISO rules require that the
project editor for the International Standard be able to produce such a
document on demand.

0.7/4
This version of the Ada Reference Manual is what the project editor
would provide to ISO in response to such a request.  It incorporates the
changes specified in the Technical Corrigendum into the text of ISO/IEC
8652:2012(E). It should be understood that the publication of any ISO
document involves changes in general format, boilerplate, headers, etc.,
as well as a review by professional editors that may introduce editorial
changes to the text.  This version of the Ada Reference Manual is
therefore neither an official ISO document, nor a version guaranteed to
be identical to an official ISO document, should ISO decide to reprint
the International Standard incorporating an approved Technical
Corrigendum.  It is nevertheless a best effort to be as close as
possible to the technical content of such an updated document.  In the
case of a conflict between this document and Technical Corrigendum 1 as
approved by ISO (or between this document and the original 8652:2012 in
the case of paragraphs not changed by Technical Corrigendum 1), the
other documents contain the official text of the International Standard
ISO/IEC 8652:2012(E).

0.8/4
As it is very inconvenient to have the Reference Manual for Ada
specified in two documents, this consolidated version of the Ada
Reference Manual is made available to the public.


File: arm2012.info,  Node: 0.2,  Next: 0.3,  Prev: 0.1,  Up: Front Matter

0.2 Foreword
============

1/3
ISO (the International Organization for Standardization) and IEC (the
International Electrotechnical Commission) form the specialized system
for worldwide standardization.  National bodies that are members of ISO
or IEC participate in the development of International Standards through
technical committees established by the respective organization to deal
with particular fields of technical activity.  ISO and IEC technical
committees collaborate in fields of mutual interest.  Other
international organizations, governmental and non-governmental, in
liaison with ISO and IEC, also take part in the work.  In the field of
information technology, ISO and IEC have established a joint technical
committee, ISO/IEC JTC 1.

1.1/3
International Standards are drafted in accordance with the rules given
in the ISO/IEC Directives, Part 2.

2/3
The main task of the joint technical committee is to prepare
International Standards.  Draft International Standards adopted by the
joint technical committee are circulated to national bodies for voting.
Publication as an International Standard requires approval by at least
75 % of the national bodies casting a vote.

2.1/3
Attention is drawn to the possibility that some of the elements of this
document may be the subject of patent rights.  ISO and IEC shall not be
held responsible for identifying any or all such patent rights.

3/3
International Standard ISO/IEC 8652 was prepared by Joint Technical
Committee ISO/IEC JTC 1, Information Technology Subcommittee SC22,
Programming languages, their environments and system software
interfaces.

4/4
This consolidated edition updates the third edition (ISO/IEC 8652:2012).


File: arm2012.info,  Node: 0.3,  Next: 0.99,  Prev: 0.2,  Up: Front Matter

0.3 Introduction
================

1
This is the Ada Reference Manual.

2
Other available Ada documents include:

3/3
   * Ada 2012 Rationale.  This gives an introduction to the changes and
     new features in Ada 2012, and explains the rationale behind them.
     Programmers should read this rationale before reading this Standard
     in depth.  Rationales for Ada 83, Ada 95, and Ada 2005 are also
     available.

4/1
   * This paragraph was deleted.

5/3
   * The Annotated Ada Reference Manual (AARM). The AARM contains all of
     the text in this International Standard, plus various annotations.
     It is intended primarily for compiler writers, validation test
     writers, and others who wish to study the fine details.  The
     annotations include detailed rationale for individual rules and
     explanations of some of the more arcane interactions among the
     rules.

Design Goals

6/3
Ada was originally designed with three overriding concerns: program
reliability and maintenance, programming as a human activity, and
efficiency.  The 1995 revision to the language was designed to provide
greater flexibility and extensibility, additional control over storage
management and synchronization, and standardized packages oriented
toward supporting important application areas, while at the same time
retaining the original emphasis on reliability, maintainability, and
efficiency.  This third edition provides further flexibility and adds
more standardized packages within the framework provided by the 1995
revision.

7
The need for languages that promote reliability and simplify maintenance
is well established.  Hence emphasis was placed on program readability
over ease of writing.  For example, the rules of the language require
that program variables be explicitly declared and that their type be
specified.  Since the type of a variable is invariant, compilers can
ensure that operations on variables are compatible with the properties
intended for objects of the type.  Furthermore, error-prone notations
have been avoided, and the syntax of the language avoids the use of
encoded forms in favor of more English-like constructs.  Finally, the
language offers support for separate compilation of program units in a
way that facilitates program development and maintenance, and which
provides the same degree of checking between units as within a unit.

8
Concern for the human programmer was also stressed during the design.
Above all, an attempt was made to keep to a relatively small number of
underlying concepts integrated in a consistent and systematic way while
continuing to avoid the pitfalls of excessive involution.  The design
especially aims to provide language constructs that correspond
intuitively to the normal expectations of users.

9
Like many other human activities, the development of programs is
becoming ever more decentralized and distributed.  Consequently, the
ability to assemble a program from independently produced software
components continues to be a central idea in the design.  The concepts
of packages, of private types, and of generic units are directly related
to this idea, which has ramifications in many other aspects of the
language.  An allied concern is the maintenance of programs to match
changing requirements; type extension and the hierarchical library
enable a program to be modified while minimizing disturbance to existing
tested and trusted components.

10
No language can avoid the problem of efficiency.  Languages that require
over-elaborate compilers, or that lead to the inefficient use of storage
or execution time, force these inefficiencies on all machines and on all
programs.  Every construct of the language was examined in the light of
present implementation techniques.  Any proposed construct whose
implementation was unclear or that required excessive machine resources
was rejected.

Language Summary

11
An Ada program is composed of one or more program units.  Program units
may be subprograms (which define executable algorithms), packages (which
define collections of entities), task units (which define concurrent
computations), protected units (which define operations for the
coordinated sharing of data between tasks), or generic units (which
define parameterized forms of packages and subprograms).  Each program
unit normally consists of two parts: a specification, containing the
information that must be visible to other units, and a body, containing
the implementation details, which need not be visible to other units.
Most program units can be compiled separately.

12
This distinction of the specification and body, and the ability to
compile units separately, allows a program to be designed, written, and
tested as a set of largely independent software components.

13
An Ada program will normally make use of a library of program units of
general utility.  The language provides means whereby individual
organizations can construct their own libraries.  All libraries are
structured in a hierarchical manner; this enables the logical
decomposition of a subsystem into individual components.  The text of a
separately compiled program unit must name the library units it
requires.

14
Program Units

15
A subprogram is the basic unit for expressing an algorithm.  There are
two kinds of subprograms: procedures and functions.  A procedure is the
means of invoking a series of actions.  For example, it may read data,
update variables, or produce some output.  It may have parameters, to
provide a controlled means of passing information between the procedure
and the point of call.  A function is the means of invoking the
computation of a value.  It is similar to a procedure, but in addition
will return a result.

16
A package is the basic unit for defining a collection of logically
related entities.  For example, a package can be used to define a set of
type declarations and associated operations.  Portions of a package can
be hidden from the user, thus allowing access only to the logical
properties expressed by the package specification.

17
Subprogram and package units may be compiled separately and arranged in
hierarchies of parent and child units giving fine control over
visibility of the logical properties and their detailed implementation.

18
A task unit is the basic unit for defining a task whose sequence of
actions may be executed concurrently with those of other tasks.  Such
tasks may be implemented on multicomputers, multiprocessors, or with
interleaved execution on a single processor.  A task unit may define
either a single executing task or a task type permitting the creation of
any number of similar tasks.

19/2
A protected unit is the basic unit for defining protected operations for
the coordinated use of data shared between tasks.  Simple mutual
exclusion is provided automatically, and more elaborate sharing
protocols can be defined.  A protected operation can either be a
subprogram or an entry.  A protected entry specifies a Boolean
expression (an entry barrier) that must be True before the body of the
entry is executed.  A protected unit may define a single protected
object or a protected type permitting the creation of several similar
objects.

20
Declarations and Statements

21
The body of a program unit generally contains two parts: a declarative
part, which defines the logical entities to be used in the program unit,
and a sequence of statements, which defines the execution of the program
unit.

22
The declarative part associates names with declared entities.  For
example, a name may denote a type, a constant, a variable, or an
exception.  A declarative part also introduces the names and parameters
of other nested subprograms, packages, task units, protected units, and
generic units to be used in the program unit.

23
The sequence of statements describes a sequence of actions that are to
be performed.  The statements are executed in succession (unless a
transfer of control causes execution to continue from another place).

24
An assignment statement changes the value of a variable.  A procedure
call invokes execution of a procedure after associating any actual
parameters provided at the call with the corresponding formal
parameters.

25
Case statements and if statements allow the selection of an enclosed
sequence of statements based on the value of an expression or on the
value of a condition.

26
The loop statement provides the basic iterative mechanism in the
language.  A loop statement specifies that a sequence of statements is
to be executed repeatedly as directed by an iteration scheme, or until
an exit statement is encountered.

27
A block statement comprises a sequence of statements preceded by the
declaration of local entities used by the statements.

28
Certain statements are associated with concurrent execution.  A delay
statement delays the execution of a task for a specified duration or
until a specified time.  An entry call statement is written as a
procedure call statement; it requests an operation on a task or on a
protected object, blocking the caller until the operation can be
performed.  A called task may accept an entry call by executing a
corresponding accept statement, which specifies the actions then to be
performed as part of the rendezvous with the calling task.  An entry
call on a protected object is processed when the corresponding entry
barrier evaluates to true, whereupon the body of the entry is executed.
The requeue statement permits the provision of a service as a number of
related activities with preference control.  One form of the select
statement allows a selective wait for one of several alternative
rendezvous.  Other forms of the select statement allow conditional or
timed entry calls and the asynchronous transfer of control in response
to some triggering event.

29
Execution of a program unit may encounter error situations in which
normal program execution cannot continue.  For example, an arithmetic
computation may exceed the maximum allowed value of a number, or an
attempt may be made to access an array component by using an incorrect
index value.  To deal with such error situations, the statements of a
program unit can be textually followed by exception handlers that
specify the actions to be taken when the error situation arises.
Exceptions can be raised explicitly by a raise statement.

30
Data Types

31
Every object in the language has a type, which characterizes a set of
values and a set of applicable operations.  The main classes of types
are elementary types (comprising enumeration, numeric, and access types)
and composite types (including array and record types).

32/2
An enumeration type defines an ordered set of distinct enumeration
literals, for example a list of states or an alphabet of characters.
The enumeration types Boolean, Character, Wide_Character, and
Wide_Wide_Character are predefined.

33
Numeric types provide a means of performing exact or approximate
numerical computations.  Exact computations use integer types, which
denote sets of consecutive integers.  Approximate computations use
either fixed point types, with absolute bounds on the error, or floating
point types, with relative bounds on the error.  The numeric types
Integer, Float, and Duration are predefined.

34/2
Composite types allow definitions of structured objects with related
components.  The composite types in the language include arrays and
records.  An array is an object with indexed components of the same
type.  A record is an object with named components of possibly different
types.  Task and protected types are also forms of composite types.  The
array types String, Wide_String, and Wide_Wide_String are predefined.

35
Record, task, and protected types may have special components called
discriminants which parameterize the type.  Variant record structures
that depend on the values of discriminants can be defined within a
record type.

36
Access types allow the construction of linked data structures.  A value
of an access type represents a reference to an object declared as
aliased or to an object created by the evaluation of an allocator.
Several variables of an access type may designate the same object, and
components of one object may designate the same or other objects.  Both
the elements in such linked data structures and their relation to other
elements can be altered during program execution.  Access types also
permit references to subprograms to be stored, passed as parameters, and
ultimately dereferenced as part of an indirect call.

37
Private types permit restricted views of a type.  A private type can be
defined in a package so that only the logically necessary properties are
made visible to the users of the type.  The full structural details that
are externally irrelevant are then only available within the package and
any child units.

38
From any type a new type may be defined by derivation.  A type, together
with its derivatives (both direct and indirect) form a derivation class.
Class-wide operations may be defined that accept as a parameter an
operand of any type in a derivation class.  For record and private
types, the derivatives may be extensions of the parent type.  Types that
support these object-oriented capabilities of class-wide operations and
type extension must be tagged, so that the specific type of an operand
within a derivation class can be identified at run time.  When an
operation of a tagged type is applied to an operand whose specific type
is not known until run time, implicit dispatching is performed based on
the tag of the operand.

38.1/2
Interface types provide abstract models from which other interfaces and
types may be composed and derived.  This provides a reliable form of
multiple inheritance.  Interface types may also be implemented by task
types and protected types thereby enabling concurrent programming and
inheritance to be merged.

39
The concept of a type is further refined by the concept of a subtype,
whereby a user can constrain the set of allowed values of a type.
Subtypes can be used to define subranges of scalar types, arrays with a
limited set of index values, and records and private types with
particular discriminant values.

40
Other Facilities

41/2
Aspect clauses can be used to specify the mapping between types and
features of an underlying machine.  For example, the user can specify
that objects of a given type must be represented with a given number of
bits, or that the components of a record are to be represented using a
given storage layout.  Other features allow the controlled use of low
level, nonportable, or implementation-dependent aspects, including the
direct insertion of machine code.

42/2
The predefined environment of the language provides for input-output and
other capabilities by means of standard library packages.  Input-output
is supported for values of user-defined as well as of predefined types.
Standard means of representing values in display form are also provided.

42.1/2
The predefined standard library packages provide facilities such as
string manipulation, containers of various kinds (vectors, lists, maps,
etc.), mathematical functions, random number generation, and access to
the execution environment.

42.2/2
The specialized annexes define further predefined library packages and
facilities with emphasis on areas such as real-time scheduling,
interrupt handling, distributed systems, numerical computation, and
high-integrity systems.

43
Finally, the language provides a powerful means of parameterization of
program units, called generic program units.  The generic parameters can
be types and subprograms (as well as objects and packages) and so allow
general algorithms and data structures to be defined that are applicable
to all types of a given class.

Language Changes

Paragraphs 44 through 57 have been removed as they described differences
from the first edition of Ada (Ada 83).

57.1/3
This International Standard replaces the second edition of 1995.  It
modifies the previous edition by making changes and additions that
improve the capability of the language and the reliability of programs
written in the language.  This edition incorporates the changes from
Amendment 1 (ISO/IEC 8652:1995:AMD 1:2007), which were designed to
improve the portability of programs, interfacing to other languages, and
both the object-oriented and real-time capabilities.

57.2/3
Significant changes originating in Amendment 1 are incorporated:

57.3/3
   * Support for program text is extended to cover the entire ISO/IEC
     10646:2003 repertoire.  Execution support now includes the 32-bit
     character set.  See subclauses *note 2.1::, *note 3.5.2::, *note
     3.6.3::, *note A.1::, *note A.3::, and *note A.4::.

57.4/3
   * The object-oriented model has been improved by the addition of an
     interface facility which provides multiple inheritance and
     additional flexibility for type extensions.  See subclauses *note
     3.4::, *note 3.9::, and *note 7.3::.  An alternative notation for
     calling operations more akin to that used in other languages has
     also been added.  See subclause *note 4.1.3::.

57.5/3
   * Access types have been further extended to unify properties such as
     the ability to access constants and to exclude null values.  See
     clause *note 3.10::.  Anonymous access types are now permitted more
     freely and anonymous access-to-subprogram types are introduced.
     See subclauses *note 3.3::, *note 3.6::, *note 3.10::, and *note
     8.5.1::.

57.6/3
   * The control of structure and visibility has been enhanced to permit
     mutually dependent references between units and finer control over
     access from the private part of a package.  See subclauses *note
     3.10.1:: and *note 10.1.2::.  In addition, limited types have been
     made more useful by the provision of aggregates, constants, and
     constructor functions.  See subclauses *note 4.3::, *note 6.5::,
     and *note 7.5::.

57.7/3
   * The predefined environment has been extended to include additional
     time and calendar operations, improved string handling, a
     comprehensive container library, file and directory management, and
     access to environment variables.  See subclauses *note 9.6.1::,
     *note A.4::, *note A.16::, *note A.17::, and *note A.18::.

57.8/3
   * Two of the Specialized Needs Annexes have been considerably
     enhanced:

57.9/2
             * The Real-Time Systems Annex now includes the Ravenscar
               profile for high-integrity systems, further dispatching
               policies such as Round Robin and Earliest Deadline First,
               support for timing events, and support for control of CPU
               time utilization.  See subclauses *note D.2::, *note
               D.13::, *note D.14::, and *note D.15::.

57.10/3
             * The Numerics Annex now includes support for real and
               complex vectors and matrices as previously defined in
               ISO/IEC 13813:1997 plus further basic operations for
               linear algebra.  See subclause *note G.3::.

57.11/3
   * The overall reliability of the language has been enhanced by a
     number of improvements.  These include new syntax which detects
     accidental overloading, as well as pragmas for making assertions
     and giving better control over the suppression of checks.  See
     subclauses *note 6.1::, *note 11.4.2::, and *note 11.5::.

57.12/3
In addition, this third edition makes enhancements to address two
important issues, namely, the particular problems of multiprocessor
architectures, and the need to further increase the capabilities
regarding assertions for correctness.  It also makes additional changes
and additions that improve the capability of the language and the
reliability of programs written in the language.

57.13/3
The following significant changes with respect to the 1995 edition as
amended by Amendment 1 are incorporated:

57.14/3
   * New syntax (the aspect specification) is introduced to enable
     properties to be specified for various entities in a more
     structured manner than through pragmas.  See subclause *note
     13.1.1::.

57.15/4
   * The concept of assertions introduced in the 2005 edition is
     extended with the ability to specify preconditions and
     postconditions for subprograms, and invariants for private types
     and interfaces.  The concept of constraints in defining subtypes is
     supplemented with subtype predicates that enable subsets to be
     specified other than as simple ranges.  These properties are all
     indicated using aspect specifications.  See subclauses *note
     3.2.4::, *note 6.1.1::, and *note 7.3.2::.

57.16/4
   * New forms of expressions are introduced.  These are if expressions,
     case expressions, quantified expressions, expression functions, and
     raise expressions.  As well as being useful for programming in
     general by avoiding the introduction of unnecessary assignments,
     they are especially valuable in conditions and invariants since
     they avoid the need to introduce auxiliary functions.  See
     subclauses *note 4.5.7::, *note 4.5.8::, *note 6.8::, and *note
     11.3::.  Membership tests are also made more flexible.  See
     subclauses *note 4.4:: and *note 4.5.2::.

57.17/3
   * A number of changes are made to subprogram parameters.  Functions
     may now have parameters of all modes.  In order to mitigate
     consequent (and indeed existing) problems of inadvertent order
     dependence, rules are introduced to reduce aliasing.  A parameter
     may now be explicitly marked as aliased and the type of a parameter
     may be incomplete in certain circumstances.  See subclauses *note
     3.10.1::, *note 6.1::, and *note 6.4.1::.

57.18/3
   * The use of access types is now more flexible.  The rules for
     accessibility and certain conversions are improved.  See subclauses
     *note 3.10.2::, *note 4.5.2::, *note 4.6::, and *note 8.6::.
     Furthermore, better control of storage pools is provided.  See
     subclause *note 13.11.4::.

57.19/3
   * The Real-Time Systems Annex now includes facilities for defining
     domains of processors and assigning tasks to them.  Improvements
     are made to scheduling and budgeting facilities.  See subclauses
     *note D.10.1::, *note D.14::, and *note D.16::.

57.20/3
   * A number of important improvements are made to the standard
     library.  These include packages for conversions between strings
     and UTF encodings, and classification functions for wide and wide
     wide characters.  Internationalization is catered for by a package
     giving locale information.  See subclauses *note A.3::, *note
     A.4.11::, and *note A.19::.  The container library is extended to
     include bounded forms of the existing containers and new containers
     for indefinite objects, multiway trees, and queues.  See subclause
     *note A.18::.

57.21/3
   * Finally, certain features are added primarily to ease the use of
     containers, such as the ability to iterate over all elements in a
     container without having to encode the iteration.  These can also
     be used for iteration over arrays, and within quantified
     expressions.  See subclauses *note 4.1.5::, *note 4.1.6::, *note
     5.5.1::, and *note 5.5.2::.

Instructions for Comment Submission

58/1
Informal comments on this International Standard may be sent via e-mail
to ada-comment@ada-auth.org.  If appropriate, the Project Editor will
initiate the defect correction procedure.

59
Comments should use the following format:

60/3
        !topic Title summarizing comment
        !reference Ada 2012 RMss.ss(pp)
        !from Author Name yy-mm-dd
        !keywords keywords related to topic
        !discussion

        text of discussion

61/3
where ss.ss is the clause or subclause number, pp is the paragraph
number where applicable, and yy-mm-dd is the date the comment was sent.
The date is optional, as is the !keywords line.

62/1
Please use a descriptive "Subject" in your e-mail message, and limit
each message to a single comment.

63
When correcting typographical errors or making minor wording
suggestions, please put the correction directly as the topic of the
comment; use square brackets [ ] to indicate text to be omitted and
curly braces { } to indicate text to be added, and provide enough
context to make the nature of the suggestion self-evident or put
additional information in the body of the comment, for example:

64
        !topic [c]{C}haracter
        !topic it[']s meaning is not defined

65
Formal requests for interpretations and for reporting defects in this
International Standard may be made in accordance with the ISO/IEC JTC 1
Directives and the ISO/IEC JTC 1/SC 22 policy for interpretations.
National Bodies may submit a Defect Report to ISO/IEC JTC 1/SC 22 for
resolution under the JTC 1 procedures.  A response will be provided and,
if appropriate, a Technical Corrigendum will be issued in accordance
with the procedures.

Acknowledgements for the Ada 83 edition

65.1/3
Ada is the result of a collective effort to design a common language for
programming large scale and real-time systems.

65.2/3
The common high order language program began in 1974.  The requirements
of the United States Department of Defense were formalized in a series
of documents which were extensively reviewed by the Services, industrial
organizations, universities, and foreign military departments.  The Ada
language was designed in accordance with the final (1978) form of these
requirements, embodied in the Steelman specification.

65.3/3
The Ada design team was led by Jean D. Ichbiah and has included Bernd
Krieg-Brueckner, Brian A. Wichmann, Henry F. Ledgard, Jean-Claude
Heliard, Jean-Loup Gailly, Jean-Raymond Abrial, John G.P. Barnes, Mike
Woodger, Olivier Roubine, Paul N. Hilfinger, and Robert Firth.

65.4/3
At various stages of the project, several people closely associated with
the design team made major contributions.  They include J.B. Goodenough,
R.F. Brender, M.W. Davis, G. Ferran, K. Lester, L. MacLaren, E. Morel,
I.R. Nassi, I.C. Pyle, S.A. Schuman, and S.C. Vestal.

65.5/3
Two parallel efforts that were started in the second phase of this
design had a deep influence on the language.  One was the development of
a formal definition using denotational semantics, with the participation
of V. Donzeau-Gouge, G. Kahn, and B. Lang.  The other was the design of
a test translator with the participation of K. Ripken, P. Boullier, P.
Cadiou, J. Holden, J.F. Hueras, R.G. Lange, and D.T. Cornhill.  The
entire effort benefitted from the dedicated assistance of Lyn Churchill
and Marion Myers, and the effective technical support of B. Gravem, W.L.
Heimerdinger, and P. Cleve.  H.G. Schmitz served as program manager.

65.6/3
Over the five years spent on this project, several intense week-long
design reviews were conducted, with the participation of P. Belmont, B.
Brosgol, P. Cohen, R. Dewar, A. Evans, G. Fisher, H. Harte, A.L. Hisgen,
P. Knueven, M. Kronental, N. Lomuto, E. Ploedereder, G. Seegmueller, V.
Stenning, D. Taffs, and also F. Belz, R. Converse, K. Correll, A.N.
Habermann, J. Sammet, S. Squires, J. Teller, P. Wegner, and P.R.
Wetherall.

65.7/3
Several persons had a constructive influence with their comments,
criticisms and suggestions.  They include P. Brinch Hansen, G. Goos,
C.A.R. Hoare, Mark Rain, W.A. Wulf, and also E. Boebert, P. Bonnard, H.
Clausen, M. Cox, G. Dismukes, R. Eachus, T. Froggatt, H. Ganzinger, C.
Hewitt, S. Kamin, R. Kotler, O. Lecarme, J.A.N. Lee, J.L. Mansion, F.
Minel, T. Phinney, J. Roehrich, V. Schneider, A. Singer, D. Slosberg,
I.C. Wand, the reviewers of Ada-Europe, AdaTech, Afcet, those of the
LMSC review team, and those of the Ada Tokyo Study Group.

65.8/3
These reviews and comments, the numerous evaluation reports received at
the end of the first and second phase, the nine hundred language issue
reports and test and evaluation reports received from fifteen different
countries during the third phase of the project, the thousands of
comments received during the ANSI Canvass, and the on-going work of the
IFIP Working Group 2.4 on system implementation languages and that of
the Purdue Europe LTPL-E committee, all had a substantial influence on
the final definition of Ada.

65.9/3
The Military Departments and Agencies have provided a broad base of
support including funding, extensive reviews, and countless individual
contributions by the members of the High Order Language Working Group
and other interested personnel.  In particular, William A. Whitaker
provided leadership for the program during the formative stages.  David
A. Fisher was responsible for the successful development and refinement
of the language requirement documents that led to the Steelman
specification.

65.10/3
The Ada 83 language definition was developed by Cii Honeywell Bull and
later Alsys, and by Honeywell Systems and Research Center, under
contract to the United States Department of Defense.  William E. Carlson
and later Larry E. Druffel served as the technical representatives of
the United States Government and effectively coordinated the efforts of
all participants in the Ada program.

Acknowledgements for the Ada 95 edition

66
This International Standard was prepared by the Ada 9X Mapping/Revision
Team based at Intermetrics, Inc., which has included: W. Carlson,
Program Manager; T. Taft, Technical Director; J. Barnes (consultant); B.
Brosgol (consultant); R. Duff (Oak Tree Software); M. Edwards; C.
Garrity; R. Hilliard; O. Pazy (consultant); D. Rosenfeld; L. Shafer; W.
White; M. Woodger.

67
The following consultants to the Ada 9X Project contributed to the
Specialized Needs Annexes: T. Baker (Real-Time/Systems Programming --
SEI, FSU); K. Dritz (Numerics -- Argonne National Laboratory); A.
Gargaro (Distributed Systems -- Computer Sciences); J. Goodenough
(Real-Time/Systems Programming -- SEI); J. McHugh (Secure Systems --
consultant); B. Wichmann (Safety-Critical Systems -- NPL: UK).

68
This work was regularly reviewed by the Ada 9X Distinguished Reviewers
and the members of the Ada 9X Rapporteur Group (XRG): E. Ploedereder,
Chairman of DRs and XRG (University of Stuttgart: Germany); B. Bardin
(Hughes); J. Barnes (consultant: UK); B. Brett (DEC); B. Brosgol
(consultant); R. Brukardt (RR Software); N. Cohen (IBM); R. Dewar (NYU);
G. Dismukes (TeleSoft); A. Evans (consultant); A. Gargaro (Computer
Sciences); M. Gerhardt (ESL); J. Goodenough (SEI); S. Heilbrunner
(University of Salzburg: Austria); P. Hilfinger (UC/Berkeley); B.
Källberg (CelsiusTech: Sweden); M. Kamrad II (Unisys); J. van Katwijk
(Delft University of Technology: The Netherlands); V. Kaufman (Russia);
P. Kruchten (Rational); R. Landwehr (CCI: Germany); C. Lester
(Portsmouth Polytechnic: UK); L. Månsson (TELIA Research: Sweden); S.
Michell (Multiprocessor Toolsmiths: Canada); M. Mills (US Air Force); D.
Pogge (US Navy); K. Power (Boeing); O. Roubine (Verdix: France); A.
Strohmeier (Swiss Fed Inst of Technology: Switzerland); W. Taylor
(consultant: UK); J. Tokar (Tartan); E. Vasilescu (Grumman); J. Vladik
(Prospeks s.r.o.: Czech Republic); S. Van Vlierberghe (OFFIS: Belgium).

69
Other valuable feedback influencing the revision process was provided by
the Ada 9X Language Precision Team (Odyssey Research Associates), the
Ada 9X User/Implementer Teams (AETECH, Tartan, TeleSoft), the Ada 9X
Implementation Analysis Team (New York University) and the Ada
community-at-large.

70
Special thanks go to R. Mathis, Convenor of ISO/IEC JTC 1/SC 22 Working
Group 9.

71
The Ada 9X Project was sponsored by the Ada Joint Program Office.
Christine M. Anderson at the Air Force Phillips Laboratory (Kirtland
AFB, NM) was the project manager.

Acknowledgements for the Corrigendum version

71.1/3
The editor [R. Brukardt (USA)] would like to thank the many people whose
hard work and assistance has made this update possible.

71.2/1
Thanks go out to all of the members of the ISO/IEC JTC 1/SC 22/WG 9 Ada
Rapporteur Group, whose work on creating and editing the wording
corrections was critical to the entire process.  Especially valuable
contributions came from the chairman of the ARG, E. Ploedereder
(Germany), who kept the process moving; J. Barnes (UK) and K. Ishihata
(Japan), whose extremely detailed reviews kept the editor on his toes;
G. Dismukes (USA), M. Kamrad (USA), P. Leroy (France), S. Michell
(Canada), T. Taft (USA), J. Tokar (USA), and other members too numerous
to mention.

71.3/1
Special thanks go to R. Duff (USA) for his explanations of the previous
system of formatting of these documents during the tedious conversion to
more modern formats.  Special thanks also go to the convenor of ISO/IEC
JTC 1/SC 22/WG 9, J. Moore (USA), without whose help and support the
Corrigendum and this consolidated reference manual would not have been
possible.

Acknowledgements for the Amendment 1 version

71.4/3
The editor [R. Brukardt (USA)] would like to thank the many people whose
hard work and assistance has made this update possible.

71.5/2
Thanks go out to all of the members of the ISO/IEC JTC 1/SC 22/WG 9 Ada
Rapporteur Group, whose work on creating and editing the wording
corrections was critical to the entire process.  Especially valuable
contributions came from the chairman of the ARG, P. Leroy (France), who
kept the process on schedule; J. Barnes (UK) whose careful reviews found
many typographical errors; T. Taft (USA), who always seemed to have a
suggestion when we were stuck, and who also was usually able to provide
the valuable service of explaining why things were as they are; S. Baird
(USA), who found many obscure problems with the proposals; and A. Burns
(UK), who pushed many of the real-time proposals to completion.  Other
ARG members who contributed were: R. Dewar (USA), G. Dismukes (USA), R.
Duff (USA), K. Ishihata (Japan), S. Michell (Canada), E. Ploedereder
(Germany), J.P. Rosen (France), E. Schonberg (USA), J. Tokar (USA), and
T. Vardanega (Italy).

71.6/2
Special thanks go to Ada-Europe and the Ada Resource Association,
without whose help and support the Amendment and this consolidated
reference manual would not have been possible.  M. Heaney (USA) requires
special thanks for his tireless work on the containers packages.
Finally, special thanks go to the convenor of ISO/IEC JTC 1/SC 22/WG 9,
J. Moore (USA), who guided the document through the standardization
process.

Acknowledgements for the Ada 2012 edition

71.7/3
The editor [R. Brukardt (USA)] would like to thank the many people whose
hard work and assistance has made this revision possible.

71.8/3
Thanks go out to all of the members of the ISO/IEC JTC 1/SC 22/WG 9 Ada
Rapporteur Group, whose work on creating and editing the wording changes
was critical to the entire process.  Especially valuable contributions
came from the chairman of the ARG, E. Schonberg (USA), who guided the
work; T. Taft (USA), whose insights broke many logjams, both in design
and wording; J. Barnes (UK) whose careful reviews uncovered many
editorial errors; S. Baird (USA), who repeatedly found obscure
interactions with the proposals that the rest of us missed.  Other ARG
members who substantially contributed were: A. Burns (UK), J. Cousins
(UK), R. Dewar (USA), G. Dismukes (USA), R. Duff (USA), P. Leroy
(France), B. Moore (Canada), E. Ploedereder (Germany), J.P. Rosen
(France), B. Thomas (USA), and T. Vardanega (Italy).

71.9/3
Special thanks go to Ada-Europe and the Ada Resource Association,
without whose help and support this third edition of the Ada Standard
would not have been possible.  A special mention has to go to A.
Beneschan (USA) for his efforts in eliminating sloppiness in our
wording.  M. Heaney (USA) also deserves a mention for his efforts to
improve the containers packages.  Finally, special thanks go to the
convenor of ISO/IEC JTC 1/SC 22/WG 9, J. Tokar (USA), who guided the
document through the standardization process.

Acknowledgements for the Ada 2012 Corrigendum 1 version

71.10/4
The editor [R. Brukardt (USA)] would like to thank the many people whose
hard work and assistance has made this update possible.

71.11/4
Thanks go out to all of the members of the ISO/IEC JTC 1/SC 22/WG 9 Ada
Rapporteur Group, whose work on creating and editing the wording changes
was critical to the entire process.  Especially valuable contributions
came from the chairman of the ARG, J. Cousins (UK), who guided the work;
T. Taft (USA), who seems to have the ability to cut any Gordian knot we
encounter in wording; ; J. Barnes (UK) who continues to be able to find
editorial errors invisible to most; S. Baird (USA), who so frequently
finds obscure interactions that we now have named such things for him.
Other ARG members who substantially contributed were: A. Burns (UK), R.
Dewar (USA), G. Dismukes (USA), R. Duff (USA), B. Moore (Canada), E.
Ploedereder (Germany), J.P. Rosen (France), E. Schonberg (USA), and T.
Vardanega (Italy).

71.12/4
Finally, special thanks go to the convenor of ISO/IEC JTC 1/SC 22/WG 9,
J. Tokar (USA), who guided the document through the standardization
process.

Changes

72
The International Standard is the same as this version of the Reference
Manual, except:

73
   * This list of Changes is not included in the International Standard.

74
   * The "Acknowledgements" page is not included in the International
     Standard.

75
   * The text in the running headers and footers on each page is
     slightly different in the International Standard.

76
   * The title page(s) are different in the International Standard.

77
   * This document is formatted for 8.5-by-11-inch paper, whereas the
     International Standard is formatted for A4 paper (210-by-297mm);
     thus, the page breaks are in different places.

77.1/3
   * This paragraph was deleted.

77.2/3
   * The "Using this version of the Ada Reference Manual" subclause is
     not included in the International Standard.

77.3/3
   * Paragraph numbers are not included in the International Standard.

Using this version of the Ada Reference Manual

77.4/4
This document has been revised with the corrections specified in
Technical Corrigendum 1 (ISO/IEC 8652:2012/COR.1:2016).  In addition, a
variety of editorial errors have been corrected.

77.5/4
Changes to the original 8652:1995 can be identified by the version
number following the paragraph number.  Paragraphs with a version number
of /1 were changed by Technical Corrigendum 1 for Ada 95 or were
editorial corrections at that time, while paragraphs with a version
number of /2 were changed by Amendment 1 or were more recent editorial
corrections, and paragraphs with a version number of /3 were changed by
the third (2012) edition of the Standard or were still more recent
editorial corrections.  Paragraphs with a version number of /4 are
changed by Technical Corrigendum 1 for Ada 2012 or were editorial
corrections at that time.  Paragraphs not so marked are unchanged by
Technical Corrigendum 1 for Ada 2012, the third edition, Amendment 1,
Technical Corrigendum 1 for Ada 95, or editorial corrections.  Paragraph
numbers of unchanged paragraphs are the same as in the 1995 edition of
the Ada Reference Manual.  In addition, some versions of this document
include revision bars near the paragraph numbers.  Where paragraphs are
inserted, the paragraph numbers are of the form pp.nn, where pp is the
number of the preceding paragraph, and nn is an insertion number.  For
instance, the first paragraph inserted after paragraph 8 is numbered
8.1, the second paragraph inserted is numbered 8.2, and so on.  Deleted
paragraphs are indicated by the text This paragraph was deleted.
Deleted paragraphs include empty paragraphs that were numbered in the
1995 edition of the Ada Reference Manual.


File: arm2012.info,  Node: 0.99,  Prev: 0.3,  Up: Front Matter

0.99
====

========== INTERNATIONAL STANDARD   ISO/IEC 8652:2012(E) with Cor 1:2016

==========  

Information technology -- Programming
Languages -- Ada

 


File: arm2012.info,  Node: 1,  Next: 2,  Prev: Front Matter,  Up: Top

1 General
*********

* Menu:

* 1.1 ::      Scope
* 1.2 ::      Normative References
* 1.3 ::      Terms and Definitions


File: arm2012.info,  Node: 1.1,  Next: 1.2,  Up: 1

1.1 Scope
=========

1/3
This International Standard specifies the form and meaning of programs
written in Ada.  Its purpose is to promote the portability of Ada
programs to a variety of computing systems.

2/3
Ada is a programming language designed to support the construction of
long-lived, highly reliable software systems.  The language includes
facilities to define packages of related types, objects, and operations.
The packages may be parameterized and the types may be extended to
support the construction of libraries of reusable, adaptable software
components.  The operations may be implemented as subprograms using
conventional sequential control structures, or as entries that include
synchronization of concurrent threads of control as part of their
invocation.  Ada supports object-oriented programming by providing
classes and interfaces, inheritance, polymorphism of variables and
methods, and generic units.  The language treats modularity in the
physical sense as well, with a facility to support separate compilation.

3/4
The language provides rich support for real-time, concurrent
programming, and includes facilities for multicore and multiprocessor
programming.  Errors can be signaled as exceptions and handled
explicitly.  The language also covers systems programming; this requires
precise control over the representation of data and access to
system-dependent properties.  Finally, a predefined environment of
standard packages is provided, including facilities for, among others,
input-output, string manipulation, numeric elementary functions, random
number generation, and definition and use of containers.

* Menu:

* 1.1.1 ::    Extent
* 1.1.2 ::    Structure
* 1.1.3 ::    Conformity of an Implementation with the Standard
* 1.1.4 ::    Method of Description and Syntax Notation
* 1.1.5 ::    Classification of Errors


File: arm2012.info,  Node: 1.1.1,  Next: 1.1.2,  Up: 1.1

1.1.1 Extent
------------

1
This International Standard specifies:

2
   * The form of a program written in Ada;

3
   * The effect of translating and executing such a program;

4
   * The manner in which program units may be combined to form Ada
     programs;

5
   * The language-defined library units that a conforming implementation
     is required to supply;

6
   * The permissible variations within the standard, and the manner in
     which they are to be documented;

7
   * Those violations of the standard that a conforming implementation
     is required to detect, and the effect of attempting to translate or
     execute a program containing such violations;

8
   * Those violations of the standard that a conforming implementation
     is not required to detect.

9
This International Standard does not specify:

10
   * The means whereby a program written in Ada is transformed into
     object code executable by a processor;

11
   * The means whereby translation or execution of programs is invoked
     and the executing units are controlled;

12
   * The size or speed of the object code, or the relative execution
     speed of different language constructs;

13
   * The form or contents of any listings produced by implementations;
     in particular, the form or contents of error or warning messages;

14
   * The effect of unspecified execution.

15
   * The size of a program or program unit that will exceed the capacity
     of a particular conforming implementation.


File: arm2012.info,  Node: 1.1.2,  Next: 1.1.3,  Prev: 1.1.1,  Up: 1.1

1.1.2 Structure
---------------

1/3
This International Standard contains thirteen clauses, fifteen annexes,
and an index.

2
The core of the Ada language consists of:

3/3
   * Clauses 1 through 13

4
   * *note Annex A::, "*note Annex A:: Predefined Language Environment"

5
   * *note Annex B::, "*note Annex B:: Interface to Other Languages"

6
   * *note Annex J::, "*note Annex J:: Obsolescent Features"

7
The following Specialized Needs Annexes define features that are needed
by certain application areas:

8
   * *note Annex C::, "*note Annex C:: Systems Programming"

9
   * *note Annex D::, "*note Annex D:: Real-Time Systems"

10
   * *note Annex E::, "*note Annex E:: Distributed Systems"

11
   * *note Annex F::, "*note Annex F:: Information Systems"

12
   * *note Annex G::, "*note Annex G:: Numerics"

13
   * *note Annex H::, "*note Annex H:: High Integrity Systems"

14
The core language and the Specialized Needs Annexes are normative,
except that the material in each of the items listed below is
informative:

15
   * Text under a NOTES or Examples heading.

16/3
   * Each subclause whose title starts with the word "Example" or
     "Examples".

17
All implementations shall conform to the core language.  In addition, an
implementation may conform separately to one or more Specialized Needs
Annexes.

18
The following Annexes are informative:

19
   * *note Annex K::, "*note Annex K:: Language-Defined Aspects and
     Attributes"

20
   * *note Annex L::, "*note Annex L:: Language-Defined Pragmas"

21/3
   * *note Annex M::, "*note Annex M:: Summary of Documentation
     Requirements"

22
   * *note Annex N::, "*note Annex N:: Glossary"

23
   * *note Annex P::, "*note Annex P:: Syntax Summary"

23.1/3
   * *note Annex Q::, "*note Annex Q:: Language-Defined Entities"

24/4
Each clause is divided into subclauses that have a common structure.
Each clause and subclause first introduces its subject.  After the
introductory text, text is labeled with the following headings:

                               _Syntax_

25
     Syntax rules (indented).

                        _Name Resolution Rules_

26/3
Compile-time rules that are used in name resolution, including overload
resolution.

                           _Legality Rules_

27
Rules that are enforced at compile time. A construct is legal if it
obeys all of the Legality Rules.

                          _Static Semantics_

28
A definition of the compile-time effect of each construct.

                       _Post-Compilation Rules_

29
Rules that are enforced before running a partition. A partition is legal
if its compilation units are legal and it obeys all of the
Post-Compilation Rules.

                          _Dynamic Semantics_

30
A definition of the run-time effect of each construct.

                      _Bounded (Run-Time) Errors_

31
Situations that result in bounded (run-time) errors (see *note 1.1.5::).

                         _Erroneous Execution_

32
Situations that result in erroneous execution (see *note 1.1.5::).

                     _Implementation Requirements_

33
Additional requirements for conforming implementations.

                     _Documentation Requirements_

34
Documentation requirements for conforming implementations.

                               _Metrics_

35
Metrics that are specified for the time/space properties of the
execution of certain language constructs.

                     _Implementation Permissions_

36
Additional permissions given to the implementer.

                        _Implementation Advice_

37
Optional advice given to the implementer.  The word "should" is used to
indicate that the advice is a recommendation, not a requirement.  It is
implementation defined whether or not a given recommendation is obeyed.

     NOTES

38
     1  Notes emphasize consequences of the rules described in the
     (sub)clause or elsewhere.  This material is informative.

                              _Examples_

39
Examples illustrate the possible forms of the constructs described.
This material is informative.


File: arm2012.info,  Node: 1.1.3,  Next: 1.1.4,  Prev: 1.1.2,  Up: 1.1

1.1.3 Conformity of an Implementation with the Standard
-------------------------------------------------------

                     _Implementation Requirements_

1
A conforming implementation shall:

2
   * Translate and correctly execute legal programs written in Ada,
     provided that they are not so large as to exceed the capacity of
     the implementation;

3
   * Identify all programs or program units that are so large as to
     exceed the capacity of the implementation (or raise an appropriate
     exception at run time);

4
   * Identify all programs or program units that contain errors whose
     detection is required by this International Standard;

5
   * Supply all language-defined library units required by this
     International Standard;

6
   * Contain no variations except those explicitly permitted by this
     International Standard, or those that are impossible or impractical
     to avoid given the implementation's execution environment;

7
   * Specify all such variations in the manner prescribed by this
     International Standard.

8
The external effect of the execution of an Ada program is defined in
terms of its interactions with its external environment. The following
are defined as external interactions:

9
   * Any interaction with an external file (see *note A.7::);

10
   * The execution of certain code_statements (see *note 13.8::); which
     code_statements cause external interactions is implementation
     defined.

11
   * Any call on an imported subprogram (see *note Annex B::), including
     any parameters passed to it;

12
   * Any result returned or exception propagated from a main subprogram
     (see *note 10.2::) or an exported subprogram (see *note Annex B::)
     to an external caller;

13
   * Any read or update of an atomic or volatile object (see *note
     C.6::);

14
   * The values of imported and exported objects (see *note Annex B::)
     at the time of any other interaction with the external environment.

15
A conforming implementation of this International Standard shall produce
for the execution of a given Ada program a set of interactions with the
external environment whose order and timing are consistent with the
definitions and requirements of this International Standard for the
semantics of the given program.

16
An implementation that conforms to this Standard shall support each
capability required by the core language as specified.  In addition, an
implementation that conforms to this Standard may conform to one or more
Specialized Needs Annexes (or to none).  Conformance to a Specialized
Needs Annex means that each capability required by the Annex is provided
as specified.

17/3
An implementation conforming to this International Standard may provide
additional aspects, attributes, library units, and pragmas.  However, it
shall not provide any aspect, attribute, library unit, or pragma having
the same name as an aspect, attribute, library unit, or pragma
(respectively) specified in a Specialized Needs Annex unless the
provided construct is either as specified in the Specialized Needs Annex
or is more limited in capability than that required by the Annex.  A
program that attempts to use an unsupported capability of an Annex shall
either be identified by the implementation before run time or shall
raise an exception at run time.

                     _Documentation Requirements_

18
Certain aspects of the semantics are defined to be either implementation
defined or unspecified.  In such cases, the set of possible effects is
specified, and the implementation may choose any effect in the set.
Implementations shall document their behavior in implementation-defined
situations, but documentation is not required for unspecified
situations.  The implementation-defined characteristics are summarized
in *note M.2::.

19
The implementation may choose to document implementation-defined
behavior either by documenting what happens in general, or by providing
some mechanism for the user to determine what happens in a particular
case.

                        _Implementation Advice_

20
If an implementation detects the use of an unsupported Specialized Needs
Annex feature at run time, it should raise Program_Error if feasible.

21
If an implementation wishes to provide implementation-defined extensions
to the functionality of a language-defined library unit, it should
normally do so by adding children to the library unit.

     NOTES

22
     2  The above requirements imply that an implementation conforming
     to this Standard may support some of the capabilities required by a
     Specialized Needs Annex without supporting all required
     capabilities.


File: arm2012.info,  Node: 1.1.4,  Next: 1.1.5,  Prev: 1.1.3,  Up: 1.1

1.1.4 Method of Description and Syntax Notation
-----------------------------------------------

1
The form of an Ada program is described by means of a context-free
syntax together with context-dependent requirements expressed by
narrative rules.

2
The meaning of Ada programs is described by means of narrative rules
defining both the effects of each construct and the composition rules
for constructs.

3
The context-free syntax of the language is described using a simple
variant of Backus-Naur Form.  In particular:

4
   * Lower case words in a sans-serif font, some containing embedded
     underlines, are used to denote syntactic categories, for example:

5
          case_statement

6
   * Boldface words are used to denote reserved words, for example:

7
          array

8
   * Square brackets enclose optional items.  Thus the two following
     rules are equivalent.

9/2
          simple_return_statement ::= return [expression];
          simple_return_statement ::= return; | return expression;

10
   * Curly brackets enclose a repeated item.  The item may appear zero
     or more times; the repetitions occur from left to right as with an
     equivalent left-recursive rule.  Thus the two following rules are
     equivalent.

11
          term ::= factor {multiplying_operator factor}
          term ::= factor | term multiplying_operator factor

12
   * A vertical line separates alternative items unless it occurs
     immediately after an opening curly bracket, in which case it stands
     for itself:

13
          constraint ::= scalar_constraint | composite_constraint
          discrete_choice_list ::= discrete_choice {| discrete_choice}

14
   * If the name of any syntactic category starts with an italicized
     part, it is equivalent to the category name without the italicized
     part.  The italicized part is intended to convey some semantic
     information.  For example subtype_name and task_name are both
     equivalent to name alone.

14.1/3
The delimiters, compound delimiters, reserved words, and
numeric_literals are exclusively made of the characters whose code point
is between 16#20# and 16#7E#, inclusively.  The special characters for
which names are defined in this International Standard (see *note 2.1::)
belong to the same range.  For example, the character E in the
definition of exponent is the character whose name is "LATIN CAPITAL
LETTER E", not "GREEK CAPITAL LETTER EPSILON".

14.2/3
When this International Standard mentions the conversion of some
character or sequence of characters to upper case, it means the
character or sequence of characters obtained by using simple upper case
mapping, as defined by documents referenced in the note in Clause 1 of
ISO/IEC 10646:2011.

15
A syntactic category is a nonterminal in the grammar defined in BNF
under "Syntax."  Names of syntactic categories are set in a different
font, like_this.

16
A construct is a piece of text (explicit or implicit) that is an
instance of a syntactic category defined under "Syntax".

17
A constituent of a construct is the construct itself, or any construct
appearing within it.

18
Whenever the run-time semantics defines certain actions to happen in an
arbitrary order, this means that the implementation shall arrange for
these actions to occur in a way that is equivalent to some sequential
order, following the rules that result from that sequential order.  When
evaluations are defined to happen in an arbitrary order, with conversion
of the results to some subtypes, or with some run-time checks, the
evaluations, conversions, and checks may be arbitrarily interspersed, so
long as each expression is evaluated before converting or checking its
value. Note that the effect of a program can depend on the order chosen
by the implementation.  This can happen, for example, if two actual
parameters of a given call have side effects.

     NOTES

19
     3  The syntax rules describing structured constructs are presented
     in a form that corresponds to the recommended paragraphing.  For
     example, an if_statement is defined as:

20
          if_statement ::=
              if condition then
                sequence_of_statements
             {elsif condition then
                sequence_of_statements}
             [else
                sequence_of_statements]
              end if;

21
     4  The line breaks and indentation in the syntax rules indicate the
     recommended line breaks and indentation in the corresponding
     constructs.  The preferred places for other line breaks are after
     semicolons.


File: arm2012.info,  Node: 1.1.5,  Prev: 1.1.4,  Up: 1.1

1.1.5 Classification of Errors
------------------------------

                     _Implementation Requirements_

1
The language definition classifies errors into several different
categories:

2
   * Errors that are required to be detected prior to run time by every
     Ada implementation;

3
     These errors correspond to any violation of a rule given in this
     International Standard, other than those listed below.  In
     particular, violation of any rule that uses the terms shall,
     allowed, permitted, legal, or illegal belongs to this category.
     Any program that contains such an error is not a legal Ada program;
     on the other hand, the fact that a program is legal does not mean,
     per se, that the program is free from other forms of error.

4
     The rules are further classified as either compile time rules, or
     post compilation rules, depending on whether a violation has to be
     detected at the time a compilation unit is submitted to the
     compiler, or may be postponed until the time a compilation unit is
     incorporated into a partition of a program.

5
   * Errors that are required to be detected at run time by the
     execution of an Ada program;

6
     The corresponding error situations are associated with the names of
     the predefined exceptions.  Every Ada compiler is required to
     generate code that raises the corresponding exception if such an
     error situation arises during program execution.  If such an error
     situation is certain to arise in every execution of a construct,
     then an implementation is allowed (although not required) to report
     this fact at compilation time.

7
   * Bounded errors;

8
     The language rules define certain kinds of errors that need not be
     detected either prior to or during run time, but if not detected,
     the range of possible effects shall be bounded. The errors of this
     category are called bounded errors. The possible effects of a given
     bounded error are specified for each such error, but in any case
     one possible effect of a bounded error is the raising of the
     exception Program_Error.

9
   * Erroneous execution.

10
     In addition to bounded errors, the language rules define certain
     kinds of errors as leading to erroneous execution.  Like bounded
     errors, the implementation need not detect such errors either prior
     to or during run time.  Unlike bounded errors, there is no
     language-specified bound on the possible effect of erroneous
     execution; the effect is in general not predictable.

                     _Implementation Permissions_

11
An implementation may provide nonstandard modes of operation.  Typically
these modes would be selected by a pragma or by a command line switch
when the compiler is invoked.  When operating in a nonstandard mode, the
implementation may reject compilation_units that do not conform to
additional requirements associated with the mode, such as an excessive
number of warnings or violation of coding style guidelines.  Similarly,
in a nonstandard mode, the implementation may apply special
optimizations or alternative algorithms that are only meaningful for
programs that satisfy certain criteria specified by the implementation. 
In any case, an implementation shall support a standard mode that
conforms to the requirements of this International Standard; in
particular, in the standard mode, all legal compilation_units shall be
accepted.

                        _Implementation Advice_

12
If an implementation detects a bounded error or erroneous execution, it
should raise Program_Error.


File: arm2012.info,  Node: 1.2,  Next: 1.3,  Prev: 1.1,  Up: 1

1.2 Normative References
========================

1/3
The following documents, in whole or in part, are normatively referenced
in this document and are indispensable for its application.  For dated
references, only the edition cited applies.  For undated references, the
latest edition of the referenced document (including any amendments)
applies.

1.1/3
ISO 639-3:2007, Codes for the representation of names of languages --
Part 3: Alpha-3 code for comprehensive coverage of languages.

2
ISO/IEC 646:1991, Information technology -- ISO 7-bit coded character
set for information interchange.

3/2
ISO/IEC 1539-1:2004, Information technology -- Programming languages --
Fortran -- Part 1: Base language.

4/2
ISO/IEC 1989:2002, Information technology -- Programming languages --
COBOL.

4.1/3
ISO/IEC 3166-1:2006, Codes for the representation of names of countries
and their subdivisions -- Part 1: Country Codes.

5
ISO/IEC 6429:1992, Information technology -- Control functions for coded
graphic character sets.

5.1/2
ISO 8601:2004, Data elements and interchange formats -- Information
interchange -- Representation of dates and times.

6/3
ISO/IEC 8859-1:1998, Information technology -- 8-bit single-byte coded
graphic character sets -- Part 1: Latin alphabet No.  1.

7/3
ISO/IEC 9899:2011, Information technology -- Programming languages -- C.

8/3
ISO/IEC 10646:2011, Information technology -- Universal Multiple-Octet
Coded Character Set (UCS).

9/3
ISO/IEC 14882:2011, Information technology -- Programming languages --
C++.

10/2
ISO/IEC TR 19769:2004, Information technology -- Programming languages,
their environments and system software interfaces -- Extensions for the
programming language C to support new character data types.


File: arm2012.info,  Node: 1.3,  Prev: 1.2,  Up: 1

1.3 Terms and Definitions
=========================

1/2
Terms are defined throughout this International Standard, indicated by
italic type.  Terms explicitly defined in this International Standard
are not to be presumed to refer implicitly to similar terms defined
elsewhere.  Mathematical terms not defined in this International
Standard are to be interpreted according to the CRC Concise Encyclopedia
of Mathematics, Second Edition.  Other terms not defined in this
International Standard are to be interpreted according to the Webster's
Third New International Dictionary of the English Language.  Informal
descriptions of some terms are also given in *note Annex N::, "*note
Annex N:: Glossary". 


File: arm2012.info,  Node: 2,  Next: 3,  Prev: 1,  Up: Top

2 Lexical Elements
******************

1/3
The text of a program consists of the texts of one or more compilations.
The text of a compilation is a sequence of lexical elements, each
composed of characters; the rules of composition are given in this
clause.  Pragmas, which provide certain information for the compiler,
are also described in this clause.

* Menu:

* 2.1 ::      Character Set
* 2.2 ::      Lexical Elements, Separators, and Delimiters
* 2.3 ::      Identifiers
* 2.4 ::      Numeric Literals
* 2.5 ::      Character Literals
* 2.6 ::      String Literals
* 2.7 ::      Comments
* 2.8 ::      Pragmas
* 2.9 ::      Reserved Words


File: arm2012.info,  Node: 2.1,  Next: 2.2,  Up: 2

2.1 Character Set
=================

1/3
The character repertoire for the text of an Ada program consists of the
entire coding space described by the ISO/IEC 10646:2011 Universal
Multiple-Octet Coded Character Set.  This coding space is organized in
planes, each plane comprising 65536 characters. 

                               _Syntax_

     Paragraphs 2 and 3 were deleted.

3.1/3
     A character is defined by this International Standard for each cell
     in the coding space described by ISO/IEC 10646:2011, regardless of
     whether or not ISO/IEC 10646:2011 allocates a character to that
     cell.

                          _Static Semantics_

4/3
The coded representation for characters is implementation defined (it
need not be a representation defined within ISO/IEC 10646:2011).  A
character whose relative code point in its plane is 16#FFFE# or 16#FFFF#
is not allowed anywhere in the text of a program.  The only characters
allowed outside of comments are those in categories other_format,
format_effector, and graphic_character.

4.1/3
The semantics of an Ada program whose text is not in Normalization Form
KC (as defined by Clause 21 of ISO/IEC 10646:2011) is implementation
defined.

5/3
The description of the language definition in this International
Standard uses the character properties General Category, Simple
Uppercase Mapping, Uppercase Mapping, and Special Case Condition of the
documents referenced by the note in Clause 1 of ISO/IEC 10646:2011.  The
actual set of graphic symbols used by an implementation for the visual
representation of the text of an Ada program is not specified. 

6/3
Characters are categorized as follows:

7/2

               This paragraph was deleted.

8/2
letter_uppercase
               Any character whose General Category is defined to be
               "Letter, Uppercase".

9/2
letter_lowercase
               Any character whose General Category is defined to be
               "Letter, Lowercase".

9.1/2
letter_titlecase
               Any character whose General Category is defined to be
               "Letter, Titlecase".

9.2/2
letter_modifier
               Any character whose General Category is defined to be
               "Letter, Modifier".

9.3/2
letter_other
               Any character whose General Category is defined to be
               "Letter, Other".

9.4/2
mark_non_spacing
               Any character whose General Category is defined to be
               "Mark, Non-Spacing".

9.5/2
mark_spacing_combining
               Any character whose General Category is defined to be
               "Mark, Spacing Combining".

10/2
number_decimal
               Any character whose General Category is defined to be
               "Number, Decimal".

10.1/2
number_letter
               Any character whose General Category is defined to be
               "Number, Letter".

10.2/2
punctuation_connector
               Any character whose General Category is defined to be
               "Punctuation, Connector".

10.3/2
other_format
               Any character whose General Category is defined to be
               "Other, Format".

11/2
separator_space
               Any character whose General Category is defined to be
               "Separator, Space".

12/2
separator_line
               Any character whose General Category is defined to be
               "Separator, Line".

12.1/2
separator_paragraph
               Any character whose General Category is defined to be
               "Separator, Paragraph".

13/3
format_effector
               The characters whose code points are 16#09# (CHARACTER
               TABULATION), 16#0A# (LINE FEED), 16#0B# (LINE
               TABULATION), 16#0C# (FORM FEED), 16#0D# (CARRIAGE
               RETURN), 16#85# (NEXT LINE), and the characters in
               categories separator_line and separator_paragraph. 

13.1/2
other_control
               Any character whose General Category is defined to be
               "Other, Control", and which is not defined to be a
               format_effector.

13.2/2
other_private_use
               Any character whose General Category is defined to be
               "Other, Private Use".

13.3/2
other_surrogate
               Any character whose General Category is defined to be
               "Other, Surrogate".

14/3
graphic_character
               Any character that is not in the categories
               other_control, other_private_use, other_surrogate,
               format_effector, and whose relative code point in its
               plane is neither 16#FFFE# nor 16#FFFF#.

15/3
The following names are used when referring to certain characters (the
first name is that given in ISO/IEC 10646:2011): 

  graphic symbol   name                      graphic symbol   name
         "         quotation mark                   :         colon
         #         number sign                      ;         semicolon
         &         ampersand                        <         less-than sign
         '         apostrophe, tick                 =         equals sign
         (         left parenthesis                 >         greater-than sign
         )         right parenthesis                _         low line, underline
         *         asterisk, multiply               |         vertical line
         +         plus sign                        /         solidus, divide
         ,         comma                            !         exclamation point
         -         hyphen-minus, minus              %         percent sign
         .         full stop, dot, point

                     _Implementation Requirements_

16/3
An Ada implementation shall accept Ada source code in UTF-8 encoding,
with or without a BOM (see *note A.4.11::), where every character is
represented by its code point.  The character pair CARRIAGE RETURN/LINE
FEED (code points 16#0D# 16#0A#) signifies a single end of line (see
*note 2.2::); every other occurrence of a format_effector other than the
character whose code point position is 16#09# (CHARACTER TABULATION)
also signifies a single end of line.

                     _Implementation Permissions_

17/3
The categories defined above, as well as case mapping and folding, may
be based on an implementation-defined version of ISO/IEC 10646 (2003
edition or later).

     NOTES

18/2
     1  The characters in categories other_control, other_private_use,
     and other_surrogate are only allowed in comments.


File: arm2012.info,  Node: 2.2,  Next: 2.3,  Prev: 2.1,  Up: 2

2.2 Lexical Elements, Separators, and Delimiters
================================================

                          _Static Semantics_

1
The text of a program consists of the texts of one or more compilations.
The text of each compilation is a sequence of separate lexical elements.
Each lexical element is formed from a sequence of characters, and is
either a delimiter, an identifier, a reserved word, a numeric_literal, a
character_literal, a string_literal, or a comment.  The meaning of a
program depends only on the particular sequences of lexical elements
that form its compilations, excluding comments.

2/3
The text of a compilation is divided into lines. In general, the
representation for an end of line is implementation defined.  However, a
sequence of one or more format_effectors other than the character whose
code point is 16#09# (CHARACTER TABULATION) signifies at least one end
of line.

3/2
In some cases an explicit separator is required to separate adjacent
lexical elements.  A separator is any of a separator_space, a
format_effector, or the end of a line, as follows:

4/2
   * A separator_space is a separator except within a comment, a
     string_literal, or a character_literal.

5/3
   * The character whose code point is 16#09# (CHARACTER TABULATION) is
     a separator except within a comment.

6
   * The end of a line is always a separator.

7
One or more separators are allowed between any two adjacent lexical
elements, before the first of each compilation, or after the last.  At
least one separator is required between an identifier, a reserved word,
or a numeric_literal and an adjacent identifier, reserved word, or
numeric_literal.

7.1/3
One or more other_format characters are allowed anywhere that a
separator is; any such characters have no effect on the meaning of an
Ada program.

8/2
A delimiter is either one of the following characters:

9
     &    '    (    )    *    +    ,    -    .    /    :    ;    <    =    >    |

10
or one of the following compound delimiters each composed of two
adjacent special characters

11
     =>    ..    **    :=    /=    >=    <=    <<    >>    <>

12
Each of the special characters listed for single character delimiters is
a single delimiter except if this character is used as a character of a
compound delimiter, or as a character of a comment, string_literal,
character_literal, or numeric_literal.

13
The following names are used when referring to compound delimiters:

     delimiter  name=> arrow
.. double dot
** double star, exponentiate
:= assignment (pronounced: "becomes")
/= inequality (pronounced: "not equal")
>= greater than or equal
<= less than or equal
<< left label bracket
>> right label bracket
<> box
                     _Implementation Requirements_

14
An implementation shall support lines of at least 200 characters in
length, not counting any characters used to signify the end of a line.
An implementation shall support lexical elements of at least 200
characters in length.  The maximum supported line length and lexical
element length are implementation defined.


File: arm2012.info,  Node: 2.3,  Next: 2.4,  Prev: 2.2,  Up: 2

2.3 Identifiers
===============

1
Identifiers are used as names.

                               _Syntax_

2/2
     identifier ::=
        identifier_start {identifier_start | identifier_extend}

3/2
     identifier_start ::=
          letter_uppercase
        | letter_lowercase
        | letter_titlecase
        | letter_modifier
        | letter_other
        | number_letter

3.1/3
     identifier_extend ::=
          mark_non_spacing
        | mark_spacing_combining
        | number_decimal
        | punctuation_connector

4/3
     An identifier shall not contain two consecutive characters in
     category punctuation_connector, or end with a character in that
     category.

                          _Static Semantics_

5/3
Two identifiers are considered the same if they consist of the same
sequence of characters after applying locale-independent simple case
folding, as defined by documents referenced in the note in Clause 1 of
ISO/IEC 10646:2011.

5.3/3
After applying simple case folding, an identifier shall not be identical
to a reserved word.

                     _Implementation Permissions_

6
In a nonstandard mode, an implementation may support other upper/lower
case equivalence rules for identifiers, to accommodate local
conventions.

     NOTES

6.1/2
     2  Identifiers differing only in the use of corresponding upper and
     lower case letters are considered the same.

                              _Examples_

7
Examples of identifiers:

8/2
     Count      X    Get_Symbol   Ethelyn   Marion
     Snobol_4   X1   Page_Count   Store_Next_Item
     [Unicode 928][Unicode 955][Unicode 940][Unicode 964][Unicode 969][Unicode 957]      -- Plato
     [Unicode 1063][Unicode 1072][Unicode 1081][Unicode 1082][Unicode 1086][Unicode 1074][Unicode 1089][Unicode 1082][Unicode 1080][Unicode 1081]  -- Tchaikovsky
     [Unicode 952]  [Unicode 966]        -- Angles


File: arm2012.info,  Node: 2.4,  Next: 2.5,  Prev: 2.3,  Up: 2

2.4 Numeric Literals
====================

1
There are two kinds of numeric_literals, real literals and integer
literals. A real literal is a numeric_literal that includes a point; an
integer literal is a numeric_literal without a point.

                               _Syntax_

2
     numeric_literal ::= decimal_literal | based_literal

     NOTES

3
     3  The type of an integer literal is universal_integer.  The type
     of a real literal is universal_real.

* Menu:

* 2.4.1 ::    Decimal Literals
* 2.4.2 ::    Based Literals


File: arm2012.info,  Node: 2.4.1,  Next: 2.4.2,  Up: 2.4

2.4.1 Decimal Literals
----------------------

1
A decimal_literal is a numeric_literal in the conventional decimal
notation (that is, the base is ten).

                               _Syntax_

2
     decimal_literal ::= numeral [.numeral] [exponent]

3
     numeral ::= digit {[underline] digit}

4
     exponent ::= E [+] numeral | E - numeral

4.1/2
     digit ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

5
     An exponent for an integer literal shall not have a minus sign.

                          _Static Semantics_

6
An underline character in a numeric_literal does not affect its meaning.
The letter E of an exponent can be written either in lower case or in
upper case, with the same meaning.

7
An exponent indicates the power of ten by which the value of the
decimal_literal without the exponent is to be multiplied to obtain the
value of the decimal_literal with the exponent.

                              _Examples_

8
Examples of decimal literals:

9
     12        0      1E6    123_456    --  integer literals

     12.0      0.0    0.456  3.14159_26 --  real literals


File: arm2012.info,  Node: 2.4.2,  Prev: 2.4.1,  Up: 2.4

2.4.2 Based Literals
--------------------

1
A based_literal is a numeric_literal expressed in a form that specifies
the base explicitly.

                               _Syntax_

2
     based_literal ::=
        base # based_numeral [.based_numeral] # [exponent]

3
     base ::= numeral

4
     based_numeral ::=
        extended_digit {[underline] extended_digit}

5
     extended_digit ::= digit | A | B | C | D | E | F

                           _Legality Rules_

6
The base (the numeric value of the decimal numeral preceding the first
#) shall be at least two and at most sixteen.  The extended_digits A
through F represent the digits ten through fifteen, respectively.  The
value of each extended_digit of a based_literal shall be less than the
base.

                          _Static Semantics_

7
The conventional meaning of based notation is assumed.  An exponent
indicates the power of the base by which the value of the based_literal
without the exponent is to be multiplied to obtain the value of the
based_literal with the exponent.  The base and the exponent, if any, are
in decimal notation.

8
The extended_digits A through F can be written either in lower case or
in upper case, with the same meaning.

                              _Examples_

9
Examples of based literals:

10
     2#1111_1111#  16#FF#       016#0ff#   --  integer literals of value 255
     16#E#E1       2#1110_0000#            --  integer literals of value 224
     16#F.FF#E+2   2#1.1111_1111_1110#E11  --  real literals of value 4095.0


File: arm2012.info,  Node: 2.5,  Next: 2.6,  Prev: 2.4,  Up: 2

2.5 Character Literals
======================

1
A character_literal is formed by enclosing a graphic character between
two apostrophe characters.

                               _Syntax_

2
     character_literal ::= 'graphic_character'

     NOTES

3
     4  A character_literal is an enumeration literal of a character
     type.  See *note 3.5.2::.

                              _Examples_

4
Examples of character literals:

5/2
     'A'     '*'     '''     ' '
     'L'     '[Unicode 1051]'     '[Unicode 923]'    -- Various els.
     '[Unicode 8734]'     '[Unicode 1488]'            -- Big numbers - infinity and aleph.


File: arm2012.info,  Node: 2.6,  Next: 2.7,  Prev: 2.5,  Up: 2

2.6 String Literals
===================

1
A string_literal is formed by a sequence of graphic characters (possibly
none) enclosed between two quotation marks used as string brackets.
They are used to represent operator_symbols (see *note 6.1::), values of
a string type (see *note 4.2::), and array subaggregates (see *note
4.3.3::). 

                               _Syntax_

2
     string_literal ::= "{string_element}"

3
     string_element ::= "" | non_quotation_mark_graphic_character

4
     A string_element is either a pair of quotation marks (""), or a
     single graphic_character other than a quotation mark.

                          _Static Semantics_

5
The sequence of characters of a string_literal is formed from the
sequence of string_elements between the bracketing quotation marks, in
the given order, with a string_element that is "" becoming a single
quotation mark in the sequence of characters, and any other
string_element being reproduced in the sequence.

6
A null string literal is a string_literal with no string_elements
between the quotation marks.

     NOTES

7
     5  An end of line cannot appear in a string_literal.

7.1/2
     6  No transformation is performed on the sequence of characters of
     a string_literal.

                              _Examples_

8
Examples of string literals:

9/2
     "Message of the day:"

     ""                    --  a null string literal
     " "   "A"   """"      --  three string literals of length 1

     "Characters such as $, %, and } are allowed in string literals"
     "Archimedes said ""[Unicode 917][Unicode 973][Unicode 961][Unicode 951][Unicode 954][Unicode 945]"""
     "Volume of cylinder (PIr²h) = "


File: arm2012.info,  Node: 2.7,  Next: 2.8,  Prev: 2.6,  Up: 2

2.7 Comments
============

1
A comment starts with two adjacent hyphens and extends up to the end of
the line.

                               _Syntax_

2
     comment ::= --{non_end_of_line_character}

3
     A comment may appear on any line of a program.

                          _Static Semantics_

4
The presence or absence of comments has no influence on whether a
program is legal or illegal.  Furthermore, comments do not influence the
meaning of a program; their sole purpose is the enlightenment of the
human reader.

                              _Examples_

5
Examples of comments:

6
     --  the last sentence above echoes the Algol 68 report 

     end;  --  processing of Line is complete 

     --  a long comment may be split onto
     --  two or more consecutive lines   

     ----------------  the first two hyphens start the comment  


File: arm2012.info,  Node: 2.8,  Next: 2.9,  Prev: 2.7,  Up: 2

2.8 Pragmas
===========

1
A pragma is a compiler directive.  There are language-defined pragmas
that give instructions for optimization, listing control, etc.  An
implementation may support additional (implementation-defined) pragmas.

                               _Syntax_

2
     pragma ::=
        pragma identifier [(pragma_argument_association {, 
     pragma_argument_association})];

3/3
     pragma_argument_association ::=
          [pragma_argument_identifier =>] name
        | [pragma_argument_identifier =>] expression
        | pragma_argument_aspect_mark =>  name
        | pragma_argument_aspect_mark =>  expression

4/3
     In a pragma, any pragma_argument_associations without a
     pragma_argument_identifier or pragma_argument_aspect_mark shall
     precede any associations with a pragma_argument_identifier or
     pragma_argument_aspect_mark.

5
     Pragmas are only allowed at the following places in a program:

6
        * After a semicolon delimiter, but not within a formal_part or
          discriminant_part.

7/3
        * At any place where the syntax rules allow a construct defined
          by a syntactic category whose name ends with "declaration",
          "item", "statement", "clause", or "alternative", or one of the
          syntactic categories variant or exception_handler; but not in
          place of such a construct if the construct is required, or is
          part of a list that is required to have at least one such
          construct.

7.1/3
        * In place of a statement in a sequence_of_statements.

7.2/3
        * At any place where a compilation_unit is allowed.

8
     Additional syntax rules and placement restrictions exist for
     specific pragmas.

9
The name of a pragma is the identifier following the reserved word
pragma. The name or expression of a pragma_argument_association is a
pragma argument.

10/3
An identifier specific to a pragma is an identifier or reserved word
that is used in a pragma argument with special meaning for that pragma.

                          _Static Semantics_

11
If an implementation does not recognize the name of a pragma, then it
has no effect on the semantics of the program.  Inside such a pragma,
the only rules that apply are the Syntax Rules.

                          _Dynamic Semantics_

12
Any pragma that appears at the place of an executable construct is
executed.  Unless otherwise specified for a particular pragma, this
execution consists of the evaluation of each evaluable pragma argument
in an arbitrary order.

                     _Implementation Requirements_

13
The implementation shall give a warning message for an unrecognized
pragma name.

                     _Implementation Permissions_

14
An implementation may provide implementation-defined pragmas; the name
of an implementation-defined pragma shall differ from those of the
language-defined pragmas.

15
An implementation may ignore an unrecognized pragma even if it violates
some of the Syntax Rules, if detecting the syntax error is too complex.

                        _Implementation Advice_

16/3
Normally, implementation-defined pragmas should have no semantic effect
for error-free programs; that is, if the implementation-defined pragmas
in a working program are replaced with unrecognized pragmas, the program
should still be legal, and should still have the same semantics.

17
Normally, an implementation should not define pragmas that can make an
illegal program legal, except as follows:

18/3
   * A pragma used to complete a declaration;

19
   * A pragma used to configure the environment by adding, removing, or
     replacing library_items.

                               _Syntax_

20
     The forms of List, Page, and Optimize pragmas are as follows:

21
       pragma List(identifier);

22
       pragma Page;

23
       pragma Optimize(identifier);

24
     Other pragmas are defined throughout this International Standard,
     and are summarized in *note Annex L::.

                          _Static Semantics_

25
A pragma List takes one of the identifiers On or Off as the single
argument.  This pragma is allowed anywhere a pragma is allowed.  It
specifies that listing of the compilation is to be continued or
suspended until a List pragma with the opposite argument is given within
the same compilation.  The pragma itself is always listed if the
compiler is producing a listing.

26
A pragma Page is allowed anywhere a pragma is allowed.  It specifies
that the program text which follows the pragma should start on a new
page (if the compiler is currently producing a listing).

27
A pragma Optimize takes one of the identifiers Time, Space, or Off as
the single argument.  This pragma is allowed anywhere a pragma is
allowed, and it applies until the end of the immediately enclosing
declarative region, or for a pragma at the place of a compilation_unit,
to the end of the compilation.  It gives advice to the implementation as
to whether time or space is the primary optimization criterion, or that
optional optimizations should be turned off.  It is implementation
defined how this advice is followed.

                              _Examples_

28
Examples of pragmas:

29/3
     pragma List(Off); -- turn off listing generation
     pragma Optimize(Off); -- turn off optional optimizations
     pragma Pure(Rational_Numbers); -- set categorization for package
     pragma Assert(Exists(File_Name),
                   Message => "Nonexistent file"); -- assert file exists


File: arm2012.info,  Node: 2.9,  Prev: 2.8,  Up: 2

2.9 Reserved Words
==================

                               _Syntax_

1/1
     This paragraph was deleted.

2/3
     The following are the reserved words.  Within a program, some or
     all of the letters of a reserved word may be in upper case.

abort      else        new          return
abs        elsif       not          reverse
abstract   end         null
accept     entry                    select
access     exception   of           separate
aliased    exit        or           some
all                    others       subtype
and        for         out          synchronized
array      function    overriding
at                                  tagged
           generic     package      task
begin      goto        pragma       terminate
body                   private      then
           if          procedure    type
case       in          protected
constant   interface                until
           is          raise        use
declare                range
delay      limited     record       when
delta      loop        rem          while
digits                 renames      with
do         mod         requeue
                                    xor

     NOTES

3
     7  The reserved words appear in lower case boldface in this
     International Standard, except when used in the designator of an
     attribute (see *note 4.1.4::).  Lower case boldface is also used
     for a reserved word in a string_literal used as an operator_symbol.
     This is merely a convention -- programs may be written in whatever
     typeface is desired and available.


File: arm2012.info,  Node: 3,  Next: 4,  Prev: 2,  Up: Top

3 Declarations and Types
************************

1/3
This clause describes the types in the language and the rules for
declaring constants, variables, and named numbers.

* Menu:

* 3.1 ::      Declarations
* 3.2 ::      Types and Subtypes
* 3.3 ::      Objects and Named Numbers
* 3.4 ::      Derived Types and Classes
* 3.5 ::      Scalar Types
* 3.6 ::      Array Types
* 3.7 ::      Discriminants
* 3.8 ::      Record Types
* 3.9 ::      Tagged Types and Type Extensions
* 3.10 ::     Access Types
* 3.11 ::     Declarative Parts


File: arm2012.info,  Node: 3.1,  Next: 3.2,  Up: 3

3.1 Declarations
================

1
The language defines several kinds of named entities that are declared
by declarations. The entity's name is defined by the declaration,
usually by a defining_identifier (*note 3.1: S0022.), but sometimes by a
defining_character_literal (*note 3.5.1: S0040.) or
defining_operator_symbol (*note 6.1: S0171.).

2
There are several forms of declaration.  A basic_declaration is a form
of declaration defined as follows.

                               _Syntax_

3/3
     basic_declaration ::=
          type_declaration   | subtype_declaration
        | object_declaration   | number_declaration
        | subprogram_declaration   | abstract_subprogram_declaration
        | null_procedure_declaration   | expression_function_declaration
        | package_declaration   | renaming_declaration
        | exception_declaration   | generic_declaration
        | generic_instantiation

4
     defining_identifier ::= identifier

                          _Static Semantics_

5
A declaration is a language construct that associates a name with (a
view of) an entity. A declaration may appear explicitly in the program
text (an explicit declaration), or may be supposed to occur at a given
place in the text as a consequence of the semantics of another construct
(an implicit declaration).

6/3
Each of the following is defined to be a declaration: any
basic_declaration (*note 3.1: S0021.); an
enumeration_literal_specification (*note 3.5.1: S0039.); a
discriminant_specification (*note 3.7: S0062.); a component_declaration
(*note 3.8: S0070.); a loop_parameter_specification (*note 5.5: S0158.);
an iterator_specification (*note 5.5.2: S0159.); a
parameter_specification (*note 6.1: S0175.); a subprogram_body (*note
6.3: S0177.); an extended_return_object_declaration (*note 6.5: S0185.);
an entry_declaration (*note 9.5.2: S0218.); an entry_index_specification
(*note 9.5.2: S0224.); a choice_parameter_specification (*note 11.2:
S0267.); a generic_formal_parameter_declaration (*note 12.1: S0275.).

7
All declarations contain a definition for a view of an entity.  A view
consists of an identification of the entity (the entity of the view),
plus view-specific characteristics that affect the use of the entity
through that view (such as mode of access to an object, formal parameter
names and defaults for a subprogram, or visibility to components of a
type).  In most cases, a declaration also contains the definition for
the entity itself (a renaming_declaration is an example of a declaration
that does not define a new entity, but instead defines a view of an
existing entity (see *note 8.5::)).

7.1/3
When it is clear from context, the term object is used in place of view
of an object.  Similarly, the terms type and subtype are used in place
of view of a type and view of a subtype, respectively.

8
For each declaration, the language rules define a certain region of text
called the scope of the declaration (see *note 8.2::).  Most
declarations associate an identifier with a declared entity.  Within its
scope, and only there, there are places where it is possible to use the
identifier to refer to the declaration, the view it defines, and the
associated entity; these places are defined by the visibility rules (see
*note 8.3::). At such places the identifier is said to be a name of the
entity (the direct_name or selector_name); the name is said to denote
the declaration, the view, and the associated entity (see *note 8.6::).
The declaration is said to declare the name, the view, and in most
cases, the entity itself.

9
As an alternative to an identifier, an enumeration literal can be
declared with a character_literal as its name (see *note 3.5.1::), and a
function can be declared with an operator_symbol as its name (see *note
6.1::).

10
The syntax rules use the terms defining_identifier,
defining_character_literal (*note 3.5.1: S0040.), and
defining_operator_symbol (*note 6.1: S0171.) for the defining occurrence
of a name; these are collectively called defining names. The terms
direct_name and selector_name are used for usage occurrences of
identifiers, character_literals, and operator_symbols.  These are
collectively called usage names.

                          _Dynamic Semantics_

11
The process by which a construct achieves its run-time effect is called
execution. This process is also called elaboration for declarations and
evaluation for expressions.  One of the terms execution, elaboration, or
evaluation is defined by this International Standard for each construct
that has a run-time effect.

     NOTES

12
     1  At compile time, the declaration of an entity declares the
     entity. At run time, the elaboration of the declaration creates the
     entity.


File: arm2012.info,  Node: 3.2,  Next: 3.3,  Prev: 3.1,  Up: 3

3.2 Types and Subtypes
======================

                          _Static Semantics_

1
A type is characterized by a set of values, and a set of primitive
operations which implement the fundamental aspects of its semantics. An
object of a given type is a run-time entity that contains (has) a value
of the type.

2/2
Types are grouped into categories of types. There exist several
language-defined categories of types (see NOTES below), reflecting the
similarity of their values and primitive operations.  Most categories of
types form classes of types. Elementary types are those whose values are
logically indivisible; composite types are those whose values are
composed of component values. 

3
The elementary types are the scalar types (discrete and real) and the
access types (whose values provide access to objects or subprograms). 
Discrete types are either integer types or are defined by enumeration of
their values (enumeration types). Real types are either floating point
types or fixed point types.

4/2
The composite types are the record types, record extensions, array
types, interface types, task types, and protected types.

4.1/2
There can be multiple views of a type with varying sets of operations.
An incomplete type represents an incomplete view (see *note 3.10.1::) of
a type with a very restricted usage, providing support for recursive
data structures.  A private type or private extension represents a
partial view (see *note 7.3::) of a type, providing support for data
abstraction.  The full view (see *note 3.2.1::) of a type represents its
complete definition.  An incomplete or partial view is considered a
composite type, even if the full view is not.

5/2
Certain composite types (and views thereof) have special components
called discriminants whose values affect the presence, constraints, or
initialization of other components.  Discriminants can be thought of as
parameters of the type.

6/2
The term subcomponent is used in this International Standard in place of
the term component to indicate either a component, or a component of
another subcomponent.  Where other subcomponents are excluded, the term
component is used instead. Similarly, a part of an object or value is
used to mean the whole object or value, or any set of its subcomponents.
The terms component, subcomponent, and part are also applied to a type
meaning the component, subcomponent, or part of objects and values of
the type.

7/2
The set of possible values for an object of a given type can be
subjected to a condition that is called a constraint (the case of a null
constraint that specifies no restriction is also included); the rules
for which values satisfy a given kind of constraint are given in *note
3.5:: for range_constraints, *note 3.6.1:: for index_constraints, and
*note 3.7.1:: for discriminant_constraints.  The set of possible values
for an object of an access type can also be subjected to a condition
that excludes the null value (see *note 3.10::).

8/2
A subtype of a given type is a combination of the type, a constraint on
values of the type, and certain attributes specific to the subtype.  The
given type is called the type of the subtype. Similarly, the associated
constraint is called the constraint of the subtype.   The set of values
of a subtype consists of the values of its type that satisfy its
constraint and any exclusion of the null value. Such values belong to
the subtype. 

9
A subtype is called an unconstrained subtype if its type has unknown
discriminants, or if its type allows range, index, or discriminant
constraints, but the subtype does not impose such a constraint;
otherwise, the subtype is called a constrained subtype (since it has no
unconstrained characteristics).

     NOTES

10/2
     2  Any set of types can be called a "category" of types, and any
     set of types that is closed under derivation (see *note 3.4::) can
     be called a "class" of types.  However, only certain categories and
     classes are used in the description of the rules of the language --
     generally those that have their own particular set of primitive
     operations (see *note 3.2.3::), or that correspond to a set of
     types that are matched by a given kind of generic formal type (see
     *note 12.5::). The following are examples of "interesting"
     language-defined classes: elementary, scalar, discrete,
     enumeration, character, boolean, integer, signed integer, modular,
     real, floating point, fixed point, ordinary fixed point, decimal
     fixed point, numeric, access, access-to-object,
     access-to-subprogram, composite, array, string, (untagged) record,
     tagged, task, protected, nonlimited.  Special syntax is provided to
     define types in each of these classes.  In addition to these
     classes, the following are examples of "interesting"
     language-defined categories: abstract, incomplete, interface,
     limited, private, record.

11/2
     These language-defined categories are organized like this:

12/2
          all types
             elementary
                scalar
                   discrete
                      enumeration
                         character
                         boolean
                         other enumeration
                      integer
                         signed integer
                         modular integer
                   real
                      floating point
                      fixed point
                         ordinary fixed point
                         decimal fixed point
                access
                   access-to-object
                   access-to-subprogram
             composite
                untagged
                   array
                      string
                      other array
                   record
                   task
                   protected
                tagged (including interfaces)
                   nonlimited tagged record
                   limited tagged
                      limited tagged record
                      synchronized tagged
                         tagged task
                         tagged protected

13/2
     There are other categories, such as "numeric" and "discriminated",
     which represent other categorization dimensions, but do not fit
     into the above strictly hierarchical picture.

* Menu:

* 3.2.1 ::    Type Declarations
* 3.2.2 ::    Subtype Declarations
* 3.2.3 ::    Classification of Operations
* 3.2.4 ::    Subtype Predicates


File: arm2012.info,  Node: 3.2.1,  Next: 3.2.2,  Up: 3.2

3.2.1 Type Declarations
-----------------------

1
A type_declaration declares a type and its first subtype.

                               _Syntax_

2
     type_declaration ::=  full_type_declaration
        | incomplete_type_declaration
        | private_type_declaration
        | private_extension_declaration

3/3
     full_type_declaration ::=
          type defining_identifier [known_discriminant_part] is 
     type_definition
             [aspect_specification];
        | task_type_declaration
        | protected_type_declaration

4/2
     type_definition ::=
          enumeration_type_definition   | integer_type_definition
        | real_type_definition   | array_type_definition
        | record_type_definition   | access_type_definition
        | derived_type_definition   | interface_type_definition

                           _Legality Rules_

5
A given type shall not have a subcomponent whose type is the given type
itself.

                          _Static Semantics_

6
The defining_identifier (*note 3.1: S0022.) of a type_declaration (*note
3.2.1: S0023.) denotes the first subtype of the type.  The
known_discriminant_part (*note 3.7: S0061.), if any, defines the
discriminants of the type (see *note 3.7::, "*note 3.7::
Discriminants").  The remainder of the type_declaration (*note 3.2.1:
S0023.) defines the remaining characteristics of (the view of) the type.

7/2
A type defined by a type_declaration (*note 3.2.1: S0023.) is a named
type; such a type has one or more nameable subtypes. Certain other forms
of declaration also include type definitions as part of the declaration
for an object.  The type defined by such a declaration is anonymous --
it has no nameable subtypes. For explanatory purposes, this
International Standard sometimes refers to an anonymous type by a
pseudo-name, written in italics, and uses such pseudo-names at places
where the syntax normally requires an identifier.  For a named type
whose first subtype is T, this International Standard sometimes refers
to the type of T as simply "the type T".

8/2
A named type that is declared by a full_type_declaration (*note 3.2.1:
S0024.), or an anonymous type that is defined by an access_definition or
as part of declaring an object of the type, is called a full type.  The
declaration of a full type also declares the full view of the type.  The
type_definition (*note 3.2.1: S0025.), task_definition (*note 9.1:
S0207.), protected_definition (*note 9.4: S0212.), or access_definition
(*note 3.10: S0084.) that defines a full type is called a full type
definition.  Types declared by other forms of type_declaration (*note
3.2.1: S0023.) are not separate types; they are partial or incomplete
views of some full type.

9
The definition of a type implicitly declares certain predefined
operators that operate on the type, according to what classes the type
belongs, as specified in *note 4.5::, "*note 4.5:: Operators and
Expression Evaluation".

10
The predefined types (for example the types Boolean, Wide_Character,
Integer, root_integer, and universal_integer) are the types that are
defined in a predefined library package called Standard; this package
also includes the (implicit) declarations of their predefined operators.
The package Standard is described in *note A.1::.

                          _Dynamic Semantics_

11
The elaboration of a full_type_declaration consists of the elaboration
of the full type definition. Each elaboration of a full type definition
creates a distinct type and its first subtype.

                              _Examples_

12
Examples of type definitions:

13
     (White, Red, Yellow, Green, Blue, Brown, Black)
     range 1 .. 72
     array(1 .. 10) of Integer

14
Examples of type declarations:

15
     type Color  is (White, Red, Yellow, Green, Blue, Brown, Black);
     type Column is range 1 .. 72;
     type Table  is array(1 .. 10) of Integer;

     NOTES

16
     3  Each of the above examples declares a named type.  The
     identifier given denotes the first subtype of the type.  Other
     named subtypes of the type can be declared with
     subtype_declarations (see *note 3.2.2::).  Although names do not
     directly denote types, a phrase like "the type Column" is sometimes
     used in this International Standard to refer to the type of Column,
     where Column denotes the first subtype of the type.  For an example
     of the definition of an anonymous type, see the declaration of the
     array Color_Table in *note 3.3.1::; its type is anonymous -- it has
     no nameable subtypes.


File: arm2012.info,  Node: 3.2.2,  Next: 3.2.3,  Prev: 3.2.1,  Up: 3.2

3.2.2 Subtype Declarations
--------------------------

1
A subtype_declaration declares a subtype of some previously declared
type, as defined by a subtype_indication.

                               _Syntax_

2/3
     subtype_declaration ::=
        subtype defining_identifier is subtype_indication
             [aspect_specification];

3/2
     subtype_indication ::=  [null_exclusion] subtype_mark [constraint]

4
     subtype_mark ::= subtype_name

5
     constraint ::= scalar_constraint | composite_constraint

6
     scalar_constraint ::=
          range_constraint | digits_constraint | delta_constraint

7
     composite_constraint ::=
          index_constraint | discriminant_constraint

                        _Name Resolution Rules_

8
A subtype_mark shall resolve to denote a subtype. The type determined by
a subtype_mark is the type of the subtype denoted by the subtype_mark.

                          _Dynamic Semantics_

9
The elaboration of a subtype_declaration consists of the elaboration of
the subtype_indication. The elaboration of a subtype_indication creates
a new subtype.  If the subtype_indication does not include a constraint,
the new subtype has the same (possibly null) constraint as that denoted
by the subtype_mark.  The elaboration of a subtype_indication that
includes a constraint proceeds as follows:

10
   * The constraint is first elaborated.

11
   * A check is then made that the constraint is compatible with the
     subtype denoted by the subtype_mark.

12
The condition imposed by a constraint is the condition obtained after
elaboration of the constraint. The rules defining compatibility are
given for each form of constraint in the appropriate subclause.  These
rules are such that if a constraint is compatible with a subtype, then
the condition imposed by the constraint cannot contradict any condition
already imposed by the subtype on its values. The exception
Constraint_Error is raised if any check of compatibility fails.

     NOTES

13
     4  A scalar_constraint may be applied to a subtype of an
     appropriate scalar type (see *note 3.5::, *note 3.5.9::, and *note
     J.3::), even if the subtype is already constrained.  On the other
     hand, a composite_constraint may be applied to a composite subtype
     (or an access-to-composite subtype) only if the composite subtype
     is unconstrained (see *note 3.6.1:: and *note 3.7.1::).

                              _Examples_

14
Examples of subtype declarations:

15/2
     subtype Rainbow   is Color range Red .. Blue;        --  see *note 3.2.1::
     subtype Red_Blue  is Rainbow;
     subtype Int       is Integer;
     subtype Small_Int is Integer range -10 .. 10;
     subtype Up_To_K   is Column range 1 .. K;            --  see *note 3.2.1::
     subtype Square    is Matrix(1 .. 10, 1 .. 10);       --  see *note 3.6::
     subtype Male      is Person(Sex => M);               --  see *note 3.10.1::
     subtype Binop_Ref is not null Binop_Ptr;             --  see *note 3.10::


File: arm2012.info,  Node: 3.2.3,  Next: 3.2.4,  Prev: 3.2.2,  Up: 3.2

3.2.3 Classification of Operations
----------------------------------

                          _Static Semantics_

1/2
An operation operates on a type T if it yields a value of type T, if it
has an operand whose expected type (see *note 8.6::) is T, or if it has
an access parameter or access result type (see *note 6.1::) designating
T. A predefined operator, or other language-defined operation such as
assignment or a membership test, that operates on a type, is called a
predefined operation of the type. The primitive operations of a type are
the predefined operations of the type, plus any user-defined primitive
subprograms.

2
The primitive subprograms of a specific type are defined as follows:

3
   * The predefined operators of the type (see *note 4.5::);

4
   * For a derived type, the inherited (see *note 3.4::) user-defined
     subprograms;

5
   * For an enumeration type, the enumeration literals (which are
     considered parameterless functions -- see *note 3.5.1::);

6
   * For a specific type declared immediately within a
     package_specification, any subprograms (in addition to the
     enumeration literals) that are explicitly declared immediately
     within the same package_specification and that operate on the type;

6.1/3
   * For a specific type with an explicitly declared primitive "="
     operator whose result type is Boolean, the corresponding "/="
     operator (see *note 6.6::);

7/2
   * For a nonformal type, any subprograms not covered above that are
     explicitly declared immediately within the same declarative region
     as the type and that override (see *note 8.3::) other implicitly
     declared primitive subprograms of the type.

8
A primitive subprogram whose designator is an operator_symbol is called
a primitive operator.


File: arm2012.info,  Node: 3.2.4,  Prev: 3.2.3,  Up: 3.2

3.2.4 Subtype Predicates
------------------------

1/3
The language-defined predicate aspects Static_Predicate and
Dynamic_Predicate may be used to define properties of subtypes.  A
predicate specification is an aspect_specification for one of the two
predicate aspects.  General rules for aspects and aspect_specifications
are found in Clause *note 13:: (*note 13.1:: and *note 13.1.1::
respectively).

                        _Name Resolution Rules_

2/3
The expected type for a predicate aspect expression is any boolean type.

                          _Static Semantics_

3/3
A predicate specification may be given on a type_declaration or a
subtype_declaration, and applies to the declared subtype.  In addition,
predicate specifications apply to certain other subtypes:

4/4
   * For a (first) subtype defined by a type declaration, any predicates
     of parent or progenitor subtypes apply.

5/3
   * For a subtype created by a subtype_indication, the predicate of the
     subtype denoted by the subtype_mark applies.

6/4
This paragraph was deleted.

7/3
Predicate checks are defined to be enabled or disabled for a given
subtype as follows:

8/3
   * If a subtype is declared by a type_declaration or
     subtype_declaration that includes a predicate specification, then:

9/3
        * if performing checks is required by the Static_Predicate
          assertion policy (see *note 11.4.2::) and the declaration
          includes a Static_Predicate specification, then predicate
          checks are enabled for the subtype;

10/3
        * if performing checks is required by the Dynamic_Predicate
          assertion policy (see *note 11.4.2::) and the declaration
          includes a Dynamic_Predicate specification, then predicate
          checks are enabled for the subtype;

11/3
        * otherwise, predicate checks are disabled for the subtype,
          regardless of whether predicate checking is enabled for any
          other subtypes mentioned in the declaration;

12/4
   * If a subtype is defined by a type declaration that does not include
     a predicate specification, then predicate checks are enabled for
     the subtype if and only if any predicate checks are enabled for
     parent or progenitor subtypes;

13/3
   * If a subtype is created by a subtype_indication other than in one
     of the previous cases, then predicate checks are enabled for the
     subtype if and only if predicate checks are enabled for the subtype
     denoted by the subtype_mark;

14/3
   * Otherwise, predicate checks are disabled for the given subtype.

14.1/4
For a subtype with a directly-specified predicate aspect, the following
additional language-defined aspect may be specified with an
aspect_specification (see *note 13.1.1::):

14.2/4
Predicate_Failure
               This aspect shall be specified by an expression, which
               determines the action to be performed when a predicate
               check fails because a directly-specified predicate aspect
               of the subtype evaluates to False, as explained below.

                        _Name Resolution Rules_

14.3/4
The expected type for the Predicate_Failure expression is String.

                           _Legality Rules_

15/3
The expression of a Static_Predicate specification shall be
predicate-static; that is, one of the following:

16/3
   * a static expression;

17/4
   * a membership test whose tested_simple_expression is the current
     instance, and whose membership_choice_list meets the requirements
     for a static membership test (see *note 4.9::);

18/3
   * a case_expression whose selecting_expression is the current
     instance, and whose dependent_expressions are static expressions;

19/3
   * a call to a predefined equality or ordering operator, where one
     operand is the current instance, and the other is a static
     expression;

20/4
   * a call to a predefined boolean operator and, or, xor, or not, where
     each operand is predicate-static;

21/3
   * a short-circuit control form where both operands are
     predicate-static; or

22/3
   * a parenthesized predicate-static expression.

23/3
A predicate shall not be specified for an incomplete subtype.

24/3
If a predicate applies to a subtype, then that predicate shall not
mention any other subtype to which the same predicate applies.

25/3
An index subtype, discrete_range of an index_constraint or slice, or a
discrete_subtype_definition of a constrained_array_definition,
entry_declaration, or entry_index_specification shall not denote a
subtype to which predicate specifications apply.

26/3
The prefix of an attribute_reference whose attribute_designator is
First, Last, or Range shall not denote a scalar subtype to which
predicate specifications apply.

27/3
The discrete_subtype_definition of a loop_parameter_specification shall
not denote a nonstatic subtype to which predicate specifications apply
or any subtype to which Dynamic_Predicate specifications apply.

28/3
The discrete_choice of a named_array_aggregate shall not denote a
nonstatic subtype to which predicate specifications apply.

29/3
In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules apply also in the private part of an instance of a
generic unit.

                          _Dynamic Semantics_

29.1/4
If any of the above Legality Rules is violated in an instance of a
generic unit, Program_Error is raised at the point of the violation.

29.2/4
To determine whether a value satisfies the predicates of a subtype S,
the following tests are performed in the following order, until one of
the tests fails, in which case the predicates are not satisfied and no
further tests are performed, or all of the tests succeed, in which case
the predicates are satisfied:

29.3/4
   * the value is first tested to determine whether it satisfies any
     constraints or any null exclusion of S;

29.4/4
   * then:

29.5/4
        * if S is a first subtype, the value is tested to determine
          whether it satisfies the predicates of the parent and
          progenitor subtypes (if any) of S (in an arbitrary order);

29.6/4
        * if S is defined by a subtype_indication, the value is tested
          to determine whether it satisfies the predicates of the
          subtype denoted by the subtype_mark of the subtype_indication;

29.7/4
   * finally, if S is defined by a declaration to which one or more
     predicate specifications apply, the predicates are evaluated (in an
     arbitrary order) to test that all of them yield True for the given
     value.

30/3
If predicate checks are enabled for a given subtype, then:

31/4
          On every subtype conversion, a check is performed that the
          operand satisfies the predicates of the target subtype.  This
          includes all parameter passing, except for certain parameters
          passed by reference, which are covered by the following rule:
          After normal completion and leaving of a subprogram, for each
          in out or out parameter that is passed by reference, a check
          is performed that the value of the parameter satisfies the
          predicates of the subtype of the actual.  For an object
          created by an object_declaration with no explicit
          initialization expression, or by an uninitialized allocator,
          if any subcomponents have default_expressions, a check is
          performed that the value of the created object satisfies the
          predicates of the nominal subtype.

31.1/4
          If any of the predicate checks fail, Assertion_Error is
          raised, unless the subtype whose directly-specified predicate
          aspect evaluated to False also has a directly-specified
          Predicate_Failure aspect.  In that case, the specified
          Predicate_Failure expression is evaluated; if the evaluation
          of the Predicate_Failure expression propagates an exception
          occurrence, then this occurrence is propagated for the failure
          of the predicate check; otherwise, Assertion_Error is raised,
          with an associated message string defined by the value of the
          Predicate_Failure expression.  In the absence of such a
          Predicate_Failure aspect, an implementation-defined message
          string is associated with the Assertion_Error exception.

32/4
This paragraph was deleted.

33/4
This paragraph was deleted.

     NOTES

34/3
     5  A predicate specification does not cause a subtype to be
     considered constrained.

35/3
     6  A Static_Predicate, like a constraint, always remains True for
     all objects of the subtype, except in the case of uninitialized
     variables and other invalid values.  A Dynamic_Predicate, on the
     other hand, is checked as specified above, but can become False at
     other times.  For example, the predicate of a record subtype is not
     checked when a subcomponent is modified.

36/4
     7  No predicates apply to the base subtype of a scalar type; every
     value of a scalar type T is considered to satisfy the predicates of
     T'Base.

37/4
     8  Predicate_Failure expressions are never evaluated during the
     evaluation of a membership test (see *note 4.5.2::) or Valid
     attribute (see *note 13.9.2::).

38/4
     9  A Predicate_Failure expression can be a raise_expression (see
     *note 11.3::).

                              _Examples_

39/4
     subtype Basic_Letter is Character -- See *note A.3.2:: for "basic letter".
        with Static_Predicate => Basic_Letter in 'A'..'Z' | 'a'..'z' | 'Æ' | 'æ' | 'Ð' | 'ð' | 'Þ' | 'þ' | 'ß';

40/4
     subtype Even_Integer is Integer
        with Dynamic_Predicate => Even_Integer mod 2 = 0,
            Predicate_Failure => "Even_Integer must be a multiple of 2";

41/4
Text_IO (see *note A.10.1::) could have used predicates to describe some
common exceptional conditions as follows:

42/4
     with Ada.IO_Exceptions;
     package Ada.Text_IO is

43/4
        type File_Type is limited private;

44/4
        subtype Open_File_Type is File_Type
           with Dynamic_Predicate => Is_Open (Open_File_Type),
                Predicate_Failure => raise Status_Error with "File not open";
        subtype Input_File_Type is Open_File_Type
           with Dynamic_Predicate => Mode (Input_File_Type) = In_File,
                Predicate_Failure => raise Mode_Error with "Cannot read file: " &
                   Name (Input_File_Type);
        subtype Output_File_Type is Open_File_Type
           with Dynamic_Predicate => Mode (Output_File_Type) /= In_File,
                Predicate_Failure => raise Mode_Error with "Cannot write file: " &
                   Name (Output_File_Type);

45/4
        ...

46/4
        function Mode (File : in Open_File_Type) return File_Mode;
        function Name (File : in Open_File_Type) return String;
        function Form (File : in Open_File_Type) return String;

47/4
        ...

48/4
        procedure Get (File : in Input_File_Type; Item : out Character);

49/4
        procedure Put (File : in Output_File_Type; Item : in Character);

50/4
        ...

51/4
        -- Similarly for all of the other input and output subprograms.


File: arm2012.info,  Node: 3.3,  Next: 3.4,  Prev: 3.2,  Up: 3

3.3 Objects and Named Numbers
=============================

1
Objects are created at run time and contain a value of a given type. An
object can be created and initialized as part of elaborating a
declaration, evaluating an allocator, aggregate, or function_call, or
passing a parameter by copy.  Prior to reclaiming the storage for an
object, it is finalized if necessary (see *note 7.6.1::).

                          _Static Semantics_

2
All of the following are objects:

3
   * the entity declared by an object_declaration;

4
   * a formal parameter of a subprogram, entry, or generic subprogram;

5
   * a generic formal object;

6
   * a loop parameter;

7
   * a choice parameter of an exception_handler;

8
   * an entry index of an entry_body;

9
   * the result of dereferencing an access-to-object value (see *note
     4.1::);

10/3
   * the return object of a function;

11
   * the result of evaluating an aggregate;

11.1/3
   * a qualified_expression whose operand denotes an object;

12
   * a component, slice, or view conversion of another object.

13/3
An object is either a constant object or a variable object.  Similarly,
a view of an object is either a constant or a variable.  All views of a
constant elementary object are constant.  All views of a constant
composite object are constant, except for parts that are of controlled
or immutably limited types; variable views of those parts and their
subcomponents may exist.  In this sense, objects of controlled and
immutably limited types are inherently mutable.  A constant view of an
object cannot be used to modify its value.  The terms constant and
variable by themselves refer to constant and variable views of objects.

14
The value of an object is read when the value of any part of the object
is evaluated, or when the value of an enclosing object is evaluated. The
value of a variable is updated when an assignment is performed to any
part of the variable, or when an assignment is performed to an enclosing
object.

15
Whether a view of an object is constant or variable is determined by the
definition of the view.  The following (and no others) represent
constants:

16
   * an object declared by an object_declaration with the reserved word
     constant;

17
   * a formal parameter or generic formal object of mode in;

18
   * a discriminant;

18.1/3
   * a loop parameter unless specified to be a variable for a
     generalized loop (see *note 5.5.2::);

19/3
   * a choice parameter or entry index;

20
   * the dereference of an access-to-constant value;

20.1/3
   * the return object declared by an extended_return_statement with the
     reserved word constant;

21/3
   * the object denoted by a function_call or an aggregate;

21.1/3
   * the result of evaluating a qualified_expression;

21.2/3
   * within the body of a protected function (or a function declared
     immediately within a protected_body), the current instance of the
     enclosing protected unit;

22
   * a selected_component, indexed_component, slice, or view conversion
     of a constant.

23/3
At the place where a view of an object is defined, a nominal subtype is
associated with the view. The object's actual subtype (that is, its
subtype) can be more restrictive than the nominal subtype of the view;
it always is if the nominal subtype is an indefinite subtype. A subtype
is an indefinite subtype if it is an unconstrained array subtype, or if
it has unknown discriminants or unconstrained discriminants without
defaults (see *note 3.7::); otherwise, the subtype is a definite subtype
(all elementary subtypes are definite subtypes).  A class-wide subtype
is defined to have unknown discriminants, and is therefore an indefinite
subtype.  An indefinite subtype does not by itself provide enough
information to create an object; an additional constraint or explicit
initialization expression is necessary (see *note 3.3.1::).  A component
cannot have an indefinite nominal subtype.

23.1/3
A view of a composite object is known to be constrained if:

23.2/3
   * its nominal subtype is constrained, and is not an untagged partial
     view; or

23.3/3
   * its nominal subtype is indefinite; or

23.4/3
   * its type is immutably limited (see *note 7.5::); or

23.5/3
   * it is part of a stand-alone constant (including a generic formal
     object of mode in); or

23.6/3
   * it is part of a formal parameter of mode in; or

23.7/3
   * it is part of the object denoted by a function_call or aggregate;
     or

23.8/3
   * it is part of a constant return object of an
     extended_return_statement; or

23.9/3
   * it is a dereference of a pool-specific access type, and there is no
     ancestor of its type that has a constrained partial view.

23.10/3
For the purposes of determining within a generic body whether an object
is known to be constrained:

23.11/3
   * if a subtype is a descendant of an untagged generic formal private
     or derived type, and the subtype is not an unconstrained array
     subtype, it is not considered indefinite and is considered to have
     a constrained partial view;

23.12/3
   * if a subtype is a descendant of a formal access type, it is not
     considered pool-specific.

24
A named number provides a name for a numeric value known at compile
time.  It is declared by a number_declaration.

     NOTES

25
     10  A constant cannot be the target of an assignment operation, nor
     be passed as an in out or out parameter, between its initialization
     and finalization, if any.

25.1/3
     11  The value of a constant object cannot be changed after its
     initialization, except in some cases where the object has a
     controlled or immutably limited part (see *note 7.5::, *note 7.6::,
     and *note 13.9.1::).

26/3
     12  The nominal and actual subtypes of an elementary object are
     always the same.  For a discriminated or array object, if the
     nominal subtype is constrained, then so is the actual subtype.

* Menu:

* 3.3.1 ::    Object Declarations
* 3.3.2 ::    Number Declarations


File: arm2012.info,  Node: 3.3.1,  Next: 3.3.2,  Up: 3.3

3.3.1 Object Declarations
-------------------------

1/3
An object_declaration declares a stand-alone object with a given nominal
subtype and, optionally, an explicit initial value given by an
initialization expression. For an array, access, task, or protected
object, the object_declaration may include the definition of the
(anonymous) type of the object.

                               _Syntax_

2/3
     object_declaration ::=
         defining_identifier_list : [aliased] [constant] 
     subtype_indication [:= expression]
             [aspect_specification];
       | defining_identifier_list : [aliased] [constant] 
     access_definition [:= expression]
             [aspect_specification];
       | defining_identifier_list : [aliased] [constant] 
     array_type_definition [:= expression]
             [aspect_specification];
       | single_task_declaration
       | single_protected_declaration

3
     defining_identifier_list ::=
       defining_identifier {, defining_identifier}

                        _Name Resolution Rules_

4
For an object_declaration with an expression following the compound
delimiter :=, the type expected for the expression is that of the
object. This expression is called the initialization expression. 

                           _Legality Rules_

5/2
An object_declaration without the reserved word constant declares a
variable object.  If it has a subtype_indication or an
array_type_definition that defines an indefinite subtype, then there
shall be an initialization expression.

                          _Static Semantics_

6/3
An object_declaration with the reserved word constant declares a
constant object. If it has an initialization expression, then it is
called a full constant declaration. Otherwise, it is called a deferred
constant declaration.  The rules for deferred constant declarations are
given in subclause *note 7.4::.  The rules for full constant
declarations are given in this subclause.

7
Any declaration that includes a defining_identifier_list with more than
one defining_identifier is equivalent to a series of declarations each
containing one defining_identifier from the list, with the rest of the
text of the declaration copied for each declaration in the series, in
the same order as the list.  The remainder of this International
Standard relies on this equivalence; explanations are given for
declarations with a single defining_identifier.

8/2
The subtype_indication, access_definition, or full type definition of an
object_declaration defines the nominal subtype of the object.  The
object_declaration declares an object of the type of the nominal
subtype.

8.1/2
A component of an object is said to require late initialization if it
has an access discriminant value constrained by a per-object expression,
or if it has an initialization expression that includes a name denoting
the current instance of the type or denoting an access discriminant.

                          _Dynamic Semantics_

9/2
If a composite object declared by an object_declaration has an
unconstrained nominal subtype, then if this subtype is indefinite or the
object is constant the actual subtype of this object is constrained.
The constraint is determined by the bounds or discriminants (if any) of
its initial value; the object is said to be constrained by its initial
value. When not constrained by its initial value, the actual and nominal
subtypes of the object are the same. If its actual subtype is
constrained, the object is called a constrained object.

10
For an object_declaration without an initialization expression, any
initial values for the object or its subcomponents are determined by the
implicit initial values defined for its nominal subtype, as follows:

11
   * The implicit initial value for an access subtype is the null value
     of the access type.

11.1/3
   * The implicit initial value for a scalar subtype that has the
     Default_Value aspect specified is the value of that aspect
     converted to the nominal subtype (which might raise
     Constraint_Error -- see *note 4.6::, "*note 4.6:: Type
     Conversions");

12
   * The implicit initial (and only) value for each discriminant of a
     constrained discriminated subtype is defined by the subtype.

13/3
   * For a (definite) composite subtype, the implicit initial value of
     each component with a default_expression is obtained by evaluation
     of this expression and conversion to the component's nominal
     subtype (which might raise Constraint_Error), unless the component
     is a discriminant of a constrained subtype (the previous case), or
     is in an excluded variant (see *note 3.8.1::). For each component
     that does not have a default_expression, if the composite subtype
     has the Default_Component_Value aspect specified, the implicit
     initial value is the value of that aspect converted to the
     component's nominal subtype; otherwise, any implicit initial values
     are those determined by the component's nominal subtype.

14
   * For a protected or task subtype, there is an implicit component (an
     entry queue) corresponding to each entry, with its implicit initial
     value being an empty queue.

15
The elaboration of an object_declaration proceeds in the following
sequence of steps:

16/2
     1.  The subtype_indication (*note 3.2.2: S0027.), access_definition
     (*note 3.10: S0084.), array_type_definition (*note 3.6: S0051.),
     single_task_declaration (*note 9.1: S0206.), or
     single_protected_declaration (*note 9.4: S0211.) is first
     elaborated.  This creates the nominal subtype (and the anonymous
     type in the last four cases).

17
     2.  If the object_declaration includes an initialization
     expression, the (explicit) initial value is obtained by evaluating
     the expression and converting it to the nominal subtype (which
     might raise Constraint_Error -- see *note 4.6::). 

18/2
     3.  The object is created, and, if there is not an initialization
     expression, the object is initialized by default. When an object is
     initialized by default, any per-object constraints (see *note
     3.8::) are elaborated and any implicit initial values for the
     object or for its subcomponents are obtained as determined by the
     nominal subtype. Any initial values (whether explicit or implicit)
     are assigned to the object or to the corresponding subcomponents.
     As described in *note 5.2:: and *note 7.6::, Initialize and Adjust
     procedures can be called. 

19/2
       This paragraph was deleted.

20/2
For the third step above, evaluations and assignments are performed in
an arbitrary order subject to the following restrictions:

20.1/2
   * Assignment to any part of the object is preceded by the evaluation
     of the value that is to be assigned.

20.2/2
   * The evaluation of a default_expression that includes the name of a
     discriminant is preceded by the assignment to that discriminant.

20.3/2
   * The evaluation of the default_expression for any component that
     depends on a discriminant is preceded by the assignment to that
     discriminant.

20.4/3
   * The assignments to any components, including implicit components,
     not requiring late initialization precede the initial value
     evaluations for any components requiring late initialization; if
     two components both require late initialization, then assignments
     to parts of the component occurring earlier in the order of the
     component declarations precede the initial value evaluations of the
     component occurring later.

21/3
There is no implicit initial value defined for a scalar subtype unless
the Default_Value aspect has been specified for the type. In the absence
of an explicit initialization or the specification of the Default_Value
aspect, a newly created scalar object might have a value that does not
belong to its subtype (see *note 13.9.1:: and *note H.1::).

     NOTES

22
     13  Implicit initial values are not defined for an indefinite
     subtype, because if an object's nominal subtype is indefinite, an
     explicit initial value is required.

23/3
     14  As indicated above, a stand-alone object is an object declared
     by an object_declaration.  Similar definitions apply to
     "stand-alone constant" and "stand-alone variable."  A subcomponent
     of an object is not a stand-alone object, nor is an object that is
     created by an allocator.  An object declared by a
     loop_parameter_specification, iterator_specification,
     parameter_specification, entry_index_specification,
     choice_parameter_specification, extended_return_statement, or a
     formal_object_declaration of mode in out is not considered a
     stand-alone object.

24
     15  The type of a stand-alone object cannot be abstract (see *note
     3.9.3::).

                              _Examples_

25
Example of a multiple object declaration:

26
     --  the multiple object declaration 

27/2
     John, Paul : not null Person_Name := new Person(Sex => M);  --  see *note 3.10.1::

28
     --  is equivalent to the two single object declarations in the order given

29/2
     John : not null Person_Name := new Person(Sex => M);
     Paul : not null Person_Name := new Person(Sex => M);

30
Examples of variable declarations:

31/2
     Count, Sum  : Integer;
     Size        : Integer range 0 .. 10_000 := 0;
     Sorted      : Boolean := False;
     Color_Table : array(1 .. Max) of Color;
     Option      : Bit_Vector(1 .. 10) := (others => True);
     Hello       : aliased String := "Hi, world.";
     [Unicode 952], [Unicode 966]        : Float range -PI .. +PI;

32
Examples of constant declarations:

33/2
     Limit     : constant Integer := 10_000;
     Low_Limit : constant Integer := Limit/10;
     Tolerance : constant Real := Dispersion(1.15);
     Hello_Msg : constant access String := Hello'Access; -- see *note 3.10.2::


File: arm2012.info,  Node: 3.3.2,  Prev: 3.3.1,  Up: 3.3

3.3.2 Number Declarations
-------------------------

1
A number_declaration declares a named number.

                               _Syntax_

2
     number_declaration ::=
          defining_identifier_list : constant := static_expression;

                        _Name Resolution Rules_

3
The static_expression given for a number_declaration is expected to be
of any numeric type.

                           _Legality Rules_

4/3
The static_expression given for a number declaration shall be a static
expression, as defined by subclause *note 4.9::.

                          _Static Semantics_

5
The named number denotes a value of type universal_integer if the type
of the static_expression is an integer type.  The named number denotes a
value of type universal_real if the type of the static_expression is a
real type.

6
The value denoted by the named number is the value of the
static_expression, converted to the corresponding universal type. 

                          _Dynamic Semantics_

7
The elaboration of a number_declaration has no effect.

                              _Examples_

8
Examples of number declarations:

9
     Two_Pi        : constant := 2.0*Ada.Numerics.Pi;   -- a real number (see *note A.5::)

10/2
     Max           : constant := 500;                   -- an integer number
     Max_Line_Size : constant := Max/6;                 -- the integer 83
     Power_16      : constant := 2**16;                 -- the integer 65_536
     One, Un, Eins : constant := 1;                     -- three different names for 1


File: arm2012.info,  Node: 3.4,  Next: 3.5,  Prev: 3.3,  Up: 3

3.4 Derived Types and Classes
=============================

1/2
A derived_type_definition defines a derived type (and its first subtype)
whose characteristics are derived from those of a parent type, and
possibly from progenitor types. 

1.1/2
A class of types is a set of types that is closed under derivation; that
is, if the parent or a progenitor type of a derived type belongs to a
class, then so does the derived type.  By saying that a particular group
of types forms a class, we are saying that all derivatives of a type in
the set inherit the characteristics that define that set.  The more
general term category of types is used for a set of types whose defining
characteristics are not necessarily inherited by derivatives; for
example, limited, abstract, and interface are all categories of types,
but not classes of types.

                               _Syntax_

2/2
     derived_type_definition ::=
         [abstract] [limited] new parent_subtype_indication [[and 
     interface_list] record_extension_part]

                           _Legality Rules_

3/2
The parent_subtype_indication defines the parent subtype; its type is
the parent type.  The interface_list defines the progenitor types (see
*note 3.9.4::).  A derived type has one parent type and zero or more
progenitor types.

4
A type shall be completely defined (see *note 3.11.1::) prior to being
specified as the parent type in a derived_type_definition -- the
full_type_declarations for the parent type and any of its subcomponents
have to precede the derived_type_definition.

5/2
If there is a record_extension_part, the derived type is called a record
extension of the parent type.  A record_extension_part shall be provided
if and only if the parent type is a tagged type.  An interface_list
shall be provided only if the parent type is a tagged type.

5.1/3
If the reserved word limited appears in a derived_type_definition, the
parent type shall be a limited type.  If the parent type is a tagged
formal type, then in addition to the places where Legality Rules
normally apply (see *note 12.3::), this rule applies also in the private
part of an instance of a generic unit.

                          _Static Semantics_

6
The first subtype of the derived type is unconstrained if a
known_discriminant_part is provided in the declaration of the derived
type, or if the parent subtype is unconstrained. Otherwise, the
constraint of the first subtype corresponds to that of the parent
subtype in the following sense: it is the same as that of the parent
subtype except that for a range constraint (implicit or explicit), the
value of each bound of its range is replaced by the corresponding value
of the derived type.

6.1/2
The first subtype of the derived type excludes null (see *note 3.10::)
if and only if the parent subtype excludes null.

7/3
The characteristics and implicitly declared primitive subprograms of the
derived type are defined as follows:

8/2
   * If the parent type or a progenitor type belongs to a class of
     types, then the derived type also belongs to that class.  The
     following sets of types, as well as any higher-level sets composed
     from them, are classes in this sense, and hence the characteristics
     defining these classes are inherited by derived types from their
     parent or progenitor types: signed integer, modular integer,
     ordinary fixed, decimal fixed, floating point, enumeration,
     boolean, character, access-to-constant, general access-to-variable,
     pool-specific access-to-variable, access-to-subprogram, array,
     string, non-array composite, nonlimited, untagged record, tagged,
     task, protected, and synchronized tagged.

9
   * If the parent type is an elementary type or an array type, then the
     set of possible values of the derived type is a copy of the set of
     possible values of the parent type.  For a scalar type, the base
     range of the derived type is the same as that of the parent type.

10
   * If the parent type is a composite type other than an array type,
     then the components, protected subprograms, and entries that are
     declared for the derived type are as follows:

11
             * The discriminants specified by a new
               known_discriminant_part, if there is one; otherwise, each
               discriminant of the parent type (implicitly declared in
               the same order with the same specifications) -- in the
               latter case, the discriminants are said to be inherited,
               or if unknown in the parent, are also unknown in the
               derived type;

12
             * Each nondiscriminant component, entry, and protected
               subprogram of the parent type, implicitly declared in the
               same order with the same declarations; these components,
               entries, and protected subprograms are said to be
               inherited;

13
             * Each component declared in a record_extension_part, if
               any.

14
     Declarations of components, protected subprograms, and entries,
     whether implicit or explicit, occur immediately within the
     declarative region of the type, in the order indicated above,
     following the parent subtype_indication.

15/2
   * This paragraph was deleted.

16
   * For each predefined operator of the parent type, there is a
     corresponding predefined operator of the derived type.

17/2
   * For each user-defined primitive subprogram (other than a
     user-defined equality operator -- see below) of the parent type or
     of a progenitor type that already exists at the place of the
     derived_type_definition, there exists a corresponding inherited
     primitive subprogram of the derived type with the same defining
     name. Primitive user-defined equality operators of the parent type
     and any progenitor types are also inherited by the derived type,
     except when the derived type is a nonlimited record extension, and
     the inherited operator would have a profile that is type conformant
     with the profile of the corresponding predefined equality operator;
     in this case, the user-defined equality operator is not inherited,
     but is rather incorporated into the implementation of the
     predefined equality operator of the record extension (see *note
     4.5.2::). 

18/3
     The profile of an inherited subprogram (including an inherited
     enumeration literal) is obtained from the profile of the
     corresponding (user-defined) primitive subprogram of the parent or
     progenitor type, after systematic replacement of each subtype of
     its profile (see *note 6.1::) that is of the parent or progenitor
     type, other than those subtypes found in the designated profile of
     an access_definition, with a corresponding subtype of the derived
     type. For a given subtype of the parent or progenitor type, the
     corresponding subtype of the derived type is defined as follows:

19
             * If the declaration of the derived type has neither a
               known_discriminant_part nor a record_extension_part, then
               the corresponding subtype has a constraint that
               corresponds (as defined above for the first subtype of
               the derived type) to that of the given subtype.

20
             * If the derived type is a record extension, then the
               corresponding subtype is the first subtype of the derived
               type.

21
             * If the derived type has a new known_discriminant_part but
               is not a record extension, then the corresponding subtype
               is constrained to those values that when converted to the
               parent type belong to the given subtype (see *note
               4.6::). 

22/2
     The same formal parameters have default_expressions in the profile
     of the inherited subprogram.  Any type mismatch due to the
     systematic replacement of the parent or progenitor type by the
     derived type is handled as part of the normal type conversion
     associated with parameter passing -- see *note 6.4.1::.

23/2
If a primitive subprogram of the parent or progenitor type is visible at
the place of the derived_type_definition, then the corresponding
inherited subprogram is implicitly declared immediately after the
derived_type_definition.  Otherwise, the inherited subprogram is
implicitly declared later or not at all, as explained in *note 7.3.1::.

24
A derived type can also be defined by a private_extension_declaration
(*note 7.3: S0194.) (see *note 7.3::) or a
formal_derived_type_definition (*note 12.5.1: S0286.) (see *note
12.5.1::).  Such a derived type is a partial view of the corresponding
full or actual type.

25
All numeric types are derived types, in that they are implicitly derived
from a corresponding root numeric type (see *note 3.5.4:: and *note
3.5.6::).

                          _Dynamic Semantics_

26
The elaboration of a derived_type_definition creates the derived type
and its first subtype, and consists of the elaboration of the
subtype_indication (*note 3.2.2: S0027.) and the record_extension_part
(*note 3.9.1: S0075.), if any.  If the subtype_indication (*note 3.2.2:
S0027.) depends on a discriminant, then only those expressions that do
not depend on a discriminant are evaluated.

27/2
For the execution of a call on an inherited subprogram, a call on the
corresponding primitive subprogram of the parent or progenitor type is
performed; the normal conversion of each actual parameter to the subtype
of the corresponding formal parameter (see *note 6.4.1::) performs any
necessary type conversion as well.  If the result type of the inherited
subprogram is the derived type, the result of calling the subprogram of
the parent or progenitor is converted to the derived type, or in the
case of a null extension, extended to the derived type using the
equivalent of an extension_aggregate with the original result as the
ancestor_part and null record as the record_component_association_list. 

     NOTES

28
     16  Classes are closed under derivation -- any class that contains
     a type also contains its derivatives.  Operations available for a
     given class of types are available for the derived types in that
     class.

29
     17  Evaluating an inherited enumeration literal is equivalent to
     evaluating the corresponding enumeration literal of the parent
     type, and then converting the result to the derived type.  This
     follows from their equivalence to parameterless functions. 

30
     18  A generic subprogram is not a subprogram, and hence cannot be a
     primitive subprogram and cannot be inherited by a derived type.  On
     the other hand, an instance of a generic subprogram can be a
     primitive subprogram, and hence can be inherited.

31
     19  If the parent type is an access type, then the parent and the
     derived type share the same storage pool; there is a null access
     value for the derived type and it is the implicit initial value for
     the type.  See *note 3.10::.

32
     20  If the parent type is a boolean type, the predefined relational
     operators of the derived type deliver a result of the predefined
     type Boolean (see *note 4.5.2::).  If the parent type is an integer
     type, the right operand of the predefined exponentiation operator
     is of the predefined type Integer (see *note 4.5.6::).

33
     21  Any discriminants of the parent type are either all inherited,
     or completely replaced with a new set of discriminants.

34
     22  For an inherited subprogram, the subtype of a formal parameter
     of the derived type need not have any value in common with the
     first subtype of the derived type.

35
     23  If the reserved word abstract is given in the declaration of a
     type, the type is abstract (see *note 3.9.3::).

35.1/2
     24  An interface type that has a progenitor type "is derived from"
     that type.  A derived_type_definition, however, never defines an
     interface type.

35.2/2
     25  It is illegal for the parent type of a derived_type_definition
     to be a synchronized tagged type.

                              _Examples_

36
Examples of derived type declarations:

37
     type Local_Coordinate is new Coordinate;   --  two different types
     type Midweek is new Day range Tue .. Thu;  --  see *note 3.5.1::
     type Counter is new Positive;              --  same range as Positive 

38
     type Special_Key is new Key_Manager.Key;   --  see *note 7.3.1::
       -- the inherited subprograms have the following specifications: 
       --         procedure Get_Key(K : out Special_Key);
       --         function "<"(X,Y : Special_Key) return Boolean;

* Menu:

* 3.4.1 ::    Derivation Classes


File: arm2012.info,  Node: 3.4.1,  Up: 3.4

3.4.1 Derivation Classes
------------------------

1
In addition to the various language-defined classes of types, types can
be grouped into derivation classes.

                          _Static Semantics_

2/2
A derived type is derived from its parent type directly; it is derived
indirectly from any type from which its parent type is derived.  A
derived type, interface type, type extension, task type, protected type,
or formal derived type is also derived from every ancestor of each of
its progenitor types, if any. The derivation class of types for a type T
(also called the class rooted at T) is the set consisting of T (the root
type of the class) and all types derived from T (directly or indirectly)
plus any associated universal or class-wide types (defined below).

3/2
Every type is either a specific type, a class-wide type, or a universal
type. A specific type is one defined by a type_declaration, a
formal_type_declaration, or a full type definition embedded in another
construct.  Class-wide and universal types are implicitly defined, to
act as representatives for an entire class of types, as follows:

4
Class-wide types
               Class-wide types are defined for (and belong to) each
               derivation class rooted at a tagged type (see *note
               3.9::).  Given a subtype S of a tagged type T, S'Class is
               the subtype_mark for a corresponding subtype of the
               tagged class-wide type T'Class.  Such types are called
               "class-wide" because when a formal parameter is defined
               to be of a class-wide type T'Class, an actual parameter
               of any type in the derivation class rooted at T is
               acceptable (see *note 8.6::).

5
               The set of values for a class-wide type T'Class is the
               discriminated union of the set of values of each specific
               type in the derivation class rooted at T (the tag acts as
               the implicit discriminant -- see *note 3.9::).
               Class-wide types have no primitive subprograms of their
               own.  However, as explained in *note 3.9.2::, operands of
               a class-wide type T'Class can be used as part of a
               dispatching call on a primitive subprogram of the type T.
               The only components (including discriminants) of T'Class
               that are visible are those of T. If S is a first subtype,
               then S'Class is a first subtype.

6/2
Universal types
               Universal types are defined for (and belong to) the
               integer, real, fixed point, and access classes, and are
               referred to in this standard as respectively,
               universal_integer, universal_real, universal_fixed, and
               universal_access.  These are analogous to class-wide
               types for these language-defined elementary classes.  As
               with class-wide types, if a formal parameter is of a
               universal type, then an actual parameter of any type in
               the corresponding class is acceptable.  In addition, a
               value of a universal type (including an integer or real
               numeric_literal, or the literal null) is "universal" in
               that it is acceptable where some particular type in the
               class is expected (see *note 8.6::).

7
               The set of values of a universal type is the
               undiscriminated union of the set of values possible for
               any definable type in the associated class.  Like
               class-wide types, universal types have no primitive
               subprograms of their own.  However, their "universality"
               allows them to be used as operands with the primitive
               subprograms of any type in the corresponding class.

8
The integer and real numeric classes each have a specific root type in
addition to their universal type, named respectively root_integer and
root_real.

9
A class-wide or universal type is said to cover all of the types in its
class.  A specific type covers only itself.

10/2
A specific type T2 is defined to be a descendant of a type T1 if T2 is
the same as T1, or if T2 is derived (directly or indirectly) from T1.  A
class-wide type T2'Class is defined to be a descendant of type T1 if T2
is a descendant of T1.  Similarly, the numeric universal types are
defined to be descendants of the root types of their classes. If a type
T2 is a descendant of a type T1, then T1 is called an ancestor of T2. An
ultimate ancestor of a type is an ancestor of that type that is not
itself a descendant of any other type.  Every untagged type has a unique
ultimate ancestor.

11
An inherited component (including an inherited discriminant) of a
derived type is inherited from a given ancestor of the type if the
corresponding component was inherited by each derived type in the chain
of derivations going back to the given ancestor.

     NOTES

12
     26  Because operands of a universal type are acceptable to the
     predefined operators of any type in their class, ambiguity can
     result.  For universal_integer and universal_real, this potential
     ambiguity is resolved by giving a preference (see *note 8.6::) to
     the predefined operators of the corresponding root types
     (root_integer and root_real, respectively).  Hence, in an
     apparently ambiguous expression like

13
          1 + 4 < 7

14
     where each of the literals is of type universal_integer, the
     predefined operators of root_integer will be preferred over those
     of other specific integer types, thereby resolving the ambiguity.


File: arm2012.info,  Node: 3.5,  Next: 3.6,  Prev: 3.4,  Up: 3

3.5 Scalar Types
================

1
Scalar types comprise enumeration types, integer types, and real types.
Enumeration types and integer types are called discrete types; each
value of a discrete type has a position number which is an integer
value. Integer types and real types are called numeric types.  All
scalar types are ordered, that is, all relational operators are
predefined for their values.

                               _Syntax_

2
     range_constraint ::=  range range

3
     range ::=  range_attribute_reference
        | simple_expression .. simple_expression

4
A range has a lower bound and an upper bound and specifies a subset of
the values of some scalar type (the type of the range).  A range with
lower bound L and upper bound R is described by "L ..  R". If R is less
than L, then the range is a null range, and specifies an empty set of
values.  Otherwise, the range specifies the values of the type from the
lower bound to the upper bound, inclusive. A value belongs to a range if
it is of the type of the range, and is in the subset of values specified
by the range. A value satisfies a range constraint if it belongs to the
associated range. One range is included in another if all values that
belong to the first range also belong to the second.

                        _Name Resolution Rules_

5
For a subtype_indication containing a range_constraint, either directly
or as part of some other scalar_constraint, the type of the range shall
resolve to that of the type determined by the subtype_mark of the
subtype_indication. For a range of a given type, the simple_expressions
of the range (likewise, the simple_expressions of the equivalent range
for a range_attribute_reference) are expected to be of the type of the
range.

                          _Static Semantics_

6
The base range of a scalar type is the range of finite values of the
type that can be represented in every unconstrained object of the type;
it is also the range supported at a minimum for intermediate values
during the evaluation of expressions involving predefined operators of
the type.

7
A constrained scalar subtype is one to which a range constraint applies.
The range of a constrained scalar subtype is the range associated with
the range constraint of the subtype.  The range of an unconstrained
scalar subtype is the base range of its type.

                          _Dynamic Semantics_

8
A range is compatible with a scalar subtype if and only if it is either
a null range or each bound of the range belongs to the range of the
subtype. A range_constraint is compatible with a scalar subtype if and
only if its range is compatible with the subtype.

9
The elaboration of a range_constraint consists of the evaluation of the
range. The evaluation of a range determines a lower bound and an upper
bound.  If simple_expressions are given to specify bounds, the
evaluation of the range evaluates these simple_expressions in an
arbitrary order, and converts them to the type of the range. If a
range_attribute_reference is given, the evaluation of the range consists
of the evaluation of the range_attribute_reference.

10
Attributes

11
For every scalar subtype S, the following attributes are defined:

12
S'First
               S'First denotes the lower bound of the range of S. The
               value of this attribute is of the type of S.

13
S'Last
               S'Last denotes the upper bound of the range of S. The
               value of this attribute is of the type of S.

14
S'Range
               S'Range is equivalent to the range S'First ..  S'Last.

15
S'Base
               S'Base denotes an unconstrained subtype of the type of S.
               This unconstrained subtype is called the base subtype of
               the type. 

16
S'Min
               S'Min denotes a function with the following
               specification:

17
                    function S'Min(Left, Right : S'Base)
                      return S'Base

18
               The function returns the lesser of the values of the two
               parameters.

19
S'Max
               S'Max denotes a function with the following
               specification:

20
                    function S'Max(Left, Right : S'Base)
                      return S'Base

21
               The function returns the greater of the values of the two
               parameters.

22
S'Succ
               S'Succ denotes a function with the following
               specification:

23
                    function S'Succ(Arg : S'Base)
                      return S'Base

24
               For an enumeration type, the function returns the value
               whose position number is one more than that of the value
               of Arg; Constraint_Error is raised if there is no such
               value of the type.  For an integer type, the function
               returns the result of adding one to the value of Arg.
               For a fixed point type, the function returns the result
               of adding small to the value of Arg.  For a floating
               point type, the function returns the machine number (as
               defined in *note 3.5.7::) immediately above the value of
               Arg; Constraint_Error is raised if there is no such
               machine number.

25
S'Pred
               S'Pred denotes a function with the following
               specification:

26
                    function S'Pred(Arg : S'Base)
                      return S'Base

27
               For an enumeration type, the function returns the value
               whose position number is one less than that of the value
               of Arg; Constraint_Error is raised if there is no such
               value of the type.  For an integer type, the function
               returns the result of subtracting one from the value of
               Arg.  For a fixed point type, the function returns the
               result of subtracting small from the value of Arg.  For a
               floating point type, the function returns the machine
               number (as defined in *note 3.5.7::) immediately below
               the value of Arg; Constraint_Error is raised if there is
               no such machine number.

27.1/2
S'Wide_Wide_Image
               S'Wide_Wide_Image denotes a function with the following
               specification:

27.2/2
                    function S'Wide_Wide_Image(Arg : S'Base)
                      return Wide_Wide_String

27.3/2
               The function returns an image of the value of Arg, that
               is, a sequence of characters representing the value in
               display form.  The lower bound of the result is one.

27.4/2
               The image of an integer value is the corresponding
               decimal literal, without underlines, leading zeros,
               exponent, or trailing spaces, but with a single leading
               character that is either a minus sign or a space.

27.5/2
               The image of an enumeration value is either the
               corresponding identifier in upper case or the
               corresponding character literal (including the two
               apostrophes); neither leading nor trailing spaces are
               included.  For a nongraphic character (a value of a
               character type that has no enumeration literal associated
               with it), the result is a corresponding language-defined
               name in upper case (for example, the image of the
               nongraphic character identified as nul is "NUL" -- the
               quotes are not part of the image).

27.6/2
               The image of a floating point value is a decimal real
               literal best approximating the value (rounded away from
               zero if halfway between) with a single leading character
               that is either a minus sign or a space, a single digit
               (that is nonzero unless the value is zero), a decimal
               point, S'Digits-1 (see *note 3.5.8::) digits after the
               decimal point (but one if S'Digits is one), an upper case
               E, the sign of the exponent (either + or -), and two or
               more digits (with leading zeros if necessary)
               representing the exponent.  If S'Signed_Zeros is True,
               then the leading character is a minus sign for a
               negatively signed zero.

27.7/2
               The image of a fixed point value is a decimal real
               literal best approximating the value (rounded away from
               zero if halfway between) with a single leading character
               that is either a minus sign or a space, one or more
               digits before the decimal point (with no redundant
               leading zeros), a decimal point, and S'Aft (see *note
               3.5.10::) digits after the decimal point.

28
S'Wide_Image
               S'Wide_Image denotes a function with the following
               specification:

29
                    function S'Wide_Image(Arg : S'Base)
                      return Wide_String

30/3
               The function returns an image of the value of Arg as a
               Wide_String.  The lower bound of the result is one.  The
               image has the same sequence of graphic characters as
               defined for S'Wide_Wide_Image if all the graphic
               characters are defined in Wide_Character; otherwise, the
               sequence of characters is implementation defined (but no
               shorter than that of S'Wide_Wide_Image for the same value
               of Arg).

               Paragraphs 31 through 34 were moved to Wide_Wide_Image.

35
S'Image
               S'Image denotes a function with the following
               specification:

36
                    function S'Image(Arg : S'Base)
                      return String

37/3
               The function returns an image of the value of Arg as a
               String.  The lower bound of the result is one.  The image
               has the same sequence of graphic characters as that
               defined for S'Wide_Wide_Image if all the graphic
               characters are defined in Character; otherwise, the
               sequence of characters is implementation defined (but no
               shorter than that of S'Wide_Wide_Image for the same value
               of Arg).

37.1/2
S'Wide_Wide_Width
               S'Wide_Wide_Width denotes the maximum length of a
               Wide_Wide_String returned by S'Wide_Wide_Image over all
               values of the subtype S. It denotes zero for a subtype
               that has a null range.  Its type is universal_integer.

38
S'Wide_Width
               S'Wide_Width denotes the maximum length of a Wide_String
               returned by S'Wide_Image over all values of the subtype
               S. It denotes zero for a subtype that has a null range.
               Its type is universal_integer.

39
S'Width
               S'Width denotes the maximum length of a String returned
               by S'Image over all values of the subtype S. It denotes
               zero for a subtype that has a null range.  Its type is
               universal_integer.

39.1/2
S'Wide_Wide_Value
               S'Wide_Wide_Value denotes a function with the following
               specification:

39.2/2
                    function S'Wide_Wide_Value(Arg : Wide_Wide_String)
                      return S'Base

39.3/2
               This function returns a value given an image of the value
               as a Wide_Wide_String, ignoring any leading or trailing
               spaces.

39.4/3
               For the evaluation of a call on S'Wide_Wide_Value for an
               enumeration subtype S, if the sequence of characters of
               the parameter (ignoring leading and trailing spaces) has
               the syntax of an enumeration literal and if it
               corresponds to a literal of the type of S (or corresponds
               to the result of S'Wide_Wide_Image for a nongraphic
               character of the type), the result is the corresponding
               enumeration value; otherwise, Constraint_Error is raised.

39.5/3
               For the evaluation of a call on S'Wide_Wide_Value for an
               integer subtype S, if the sequence of characters of the
               parameter (ignoring leading and trailing spaces) has the
               syntax of an integer literal, with an optional leading
               sign character (plus or minus for a signed type; only
               plus for a modular type), and the corresponding numeric
               value belongs to the base range of the type of S, then
               that value is the result; otherwise, Constraint_Error is
               raised.

39.6/2
               For the evaluation of a call on S'Wide_Wide_Value for a
               real subtype S, if the sequence of characters of the
               parameter (ignoring leading and trailing spaces) has the
               syntax of one of the following:

39.7/2
                  * numeric_literal

39.8/2
                  * numeral.[exponent]

39.9/2
                  * .numeral[exponent]

39.10/2
                  * base#based_numeral.#[exponent]

39.11/2
                  * base#.based_numeral#[exponent]

39.12/3
               with an optional leading sign character (plus or minus),
               and if the corresponding numeric value belongs to the
               base range of the type of S, then that value is the
               result; otherwise, Constraint_Error is raised.  The sign
               of a zero value is preserved (positive if none has been
               specified) if S'Signed_Zeros is True.

40
S'Wide_Value
               S'Wide_Value denotes a function with the following
               specification:

41
                    function S'Wide_Value(Arg : Wide_String)
                      return S'Base

42
               This function returns a value given an image of the value
               as a Wide_String, ignoring any leading or trailing
               spaces.

43/3
               For the evaluation of a call on S'Wide_Value for an
               enumeration subtype S, if the sequence of characters of
               the parameter (ignoring leading and trailing spaces) has
               the syntax of an enumeration literal and if it
               corresponds to a literal of the type of S (or corresponds
               to the result of S'Wide_Image for a value of the type),
               the result is the corresponding enumeration value; 
               otherwise, Constraint_Error is raised.  For a numeric
               subtype S, the evaluation of a call on S'Wide_Value with
               Arg of type Wide_String is equivalent to a call on
               S'Wide_Wide_Value for a corresponding Arg of type
               Wide_Wide_String.

               Paragraphs 44 through 51 were moved to Wide_Wide_Value.

52
S'Value
               S'Value denotes a function with the following
               specification:

53
                    function S'Value(Arg : String)
                      return S'Base

54
               This function returns a value given an image of the value
               as a String, ignoring any leading or trailing spaces.

55/3
               For the evaluation of a call on S'Value for an
               enumeration subtype S, if the sequence of characters of
               the parameter (ignoring leading and trailing spaces) has
               the syntax of an enumeration literal and if it
               corresponds to a literal of the type of S (or corresponds
               to the result of S'Image for a value of the type), the
               result is the corresponding enumeration value; otherwise,
               Constraint_Error is raised.  For a numeric subtype S, the
               evaluation of a call on S'Value with Arg of type String
               is equivalent to a call on S'Wide_Wide_Value for a
               corresponding Arg of type Wide_Wide_String.

55.1/4
For a prefix X that denotes an object of a scalar type (after any
implicit dereference), the following attributes are defined:

55.2/4
X'Wide_Wide_Image
               X'Wide_Wide_Image denotes the result of calling function
               S'Wide_Wide_Image with Arg being X, where S is the
               nominal subtype of X.

55.3/4
X'Wide_Image
               X'Wide_Image denotes the result of calling function
               S'Wide_Image with Arg being X, where S is the nominal
               subtype of X.

55.4/4
X'Image
               X'Image denotes the result of calling function S'Image
               with Arg being X, where S is the nominal subtype of X.

                     _Implementation Permissions_

56/2
An implementation may extend the Wide_Wide_Value, Wide_Value, Value,
Wide_Wide_Image, Wide_Image, and Image attributes of a floating point
type to support special values such as infinities and NaNs.

56.1/3
An implementation may extend the Wide_Wide_Value, Wide_Value, and Value
attributes of a character type to accept strings of the form
"Hex_hhhhhhhh" (ignoring case) for any character (not just the ones for
which Wide_Wide_Image would produce that form -- see *note 3.5.2::), as
well as three-character strings of the form "'X'", where X is any
character, including nongraphic characters.

                          _Static Semantics_

56.2/3
For a scalar type, the following language-defined representation aspect
may be specified with an aspect_specification (see *note 13.1.1::):

56.3/3
Default_Value
               This aspect shall be specified by a static expression,
               and that expression shall be explicit, even if the aspect
               has a boolean type.  Default_Value shall be specified
               only on a full_type_declaration.

56.4/3
If a derived type with no primitive subprograms inherits a boolean
Default_Value aspect, the aspect may be specified to have any value for
the derived type.

                        _Name Resolution Rules_

56.5/3
The expected type for the expression specified for the Default_Value
aspect is the type defined by the full_type_declaration on which it
appears.

     NOTES

57
     27  The evaluation of S'First or S'Last never raises an exception.
     If a scalar subtype S has a nonnull range, S'First and S'Last
     belong to this range.  These values can, for example, always be
     assigned to a variable of subtype S.

58
     28  For a subtype of a scalar type, the result delivered by the
     attributes Succ, Pred, and Value might not belong to the subtype;
     similarly, the actual parameters of the attributes Succ, Pred, and
     Image need not belong to the subtype.

59
     29  For any value V (including any nongraphic character) of an
     enumeration subtype S, S'Value(S'Image(V)) equals V, as do
     S'Wide_Value(S'Wide_Image(V)) and
     S'Wide_Wide_Value(S'Wide_Wide_Image(V)). None of these expressions
     ever raise Constraint_Error.

                              _Examples_

60
Examples of ranges:

61
     -10 .. 10
     X .. X + 1
     0.0 .. 2.0*Pi
     Red .. Green     -- see *note 3.5.1::
     1 .. 0           -- a null range
     Table'Range      -- a range attribute reference (see *note 3.6::)

62
Examples of range constraints:

63
     range -999.0 .. +999.0
     range S'First+1 .. S'Last-1

* Menu:

* 3.5.1 ::    Enumeration Types
* 3.5.2 ::    Character Types
* 3.5.3 ::    Boolean Types
* 3.5.4 ::    Integer Types
* 3.5.5 ::    Operations of Discrete Types
* 3.5.6 ::    Real Types
* 3.5.7 ::    Floating Point Types
* 3.5.8 ::    Operations of Floating Point Types
* 3.5.9 ::    Fixed Point Types
* 3.5.10 ::   Operations of Fixed Point Types


File: arm2012.info,  Node: 3.5.1,  Next: 3.5.2,  Up: 3.5

3.5.1 Enumeration Types
-----------------------

1
An enumeration_type_definition defines an enumeration type.

                               _Syntax_

2
     enumeration_type_definition ::=
        (enumeration_literal_specification {, 
     enumeration_literal_specification})

3
     enumeration_literal_specification ::=  defining_identifier | 
     defining_character_literal

4
     defining_character_literal ::= character_literal

                           _Legality Rules_

5/3
The defining_identifiers in upper case and the
defining_character_literals listed in an enumeration_type_definition
shall be distinct.

                          _Static Semantics_

6/3
Each enumeration_literal_specification is the explicit declaration of
the corresponding enumeration literal: it declares a parameterless
function, whose defining name is the defining_identifier (*note 3.1:
S0022.) or defining_character_literal (*note 3.5.1: S0040.), and whose
result subtype is the base subtype of the enumeration type.

7
Each enumeration literal corresponds to a distinct value of the
enumeration type, and to a distinct position number. The position number
of the value of the first listed enumeration literal is zero; the
position number of the value of each subsequent enumeration literal is
one more than that of its predecessor in the list.

8
The predefined order relations between values of the enumeration type
follow the order of corresponding position numbers.

9
If the same defining_identifier or defining_character_literal is
specified in more than one enumeration_type_definition (*note 3.5.1:
S0038.), the corresponding enumeration literals are said to be
overloaded.  At any place where an overloaded enumeration literal occurs
in the text of a program, the type of the enumeration literal has to be
determinable from the context (see *note 8.6::).

                          _Dynamic Semantics_

10
The elaboration of an enumeration_type_definition creates the
enumeration type and its first subtype, which is constrained to the base
range of the type.

11
When called, the parameterless function associated with an enumeration
literal returns the corresponding value of the enumeration type.

     NOTES

12
     30  If an enumeration literal occurs in a context that does not
     otherwise suffice to determine the type of the literal, then
     qualification by the name of the enumeration type is one way to
     resolve the ambiguity (see *note 4.7::).

                              _Examples_

13
Examples of enumeration types and subtypes:

14
     type Day    is (Mon, Tue, Wed, Thu, Fri, Sat, Sun);
     type Suit   is (Clubs, Diamonds, Hearts, Spades);
     type Gender is (M, F);
     type Level  is (Low, Medium, Urgent);
     type Color  is (White, Red, Yellow, Green, Blue, Brown, Black);
     type Light  is (Red, Amber, Green); -- Red and Green are overloaded

15
     type Hexa   is ('A', 'B', 'C', 'D', 'E', 'F');
     type Mixed  is ('A', 'B', '*', B, None, '?', '%');

16
     subtype Weekday is Day   range Mon .. Fri;
     subtype Major   is Suit  range Hearts .. Spades;
     subtype Rainbow is Color range Red .. Blue;  --  the Color Red, not the Light


File: arm2012.info,  Node: 3.5.2,  Next: 3.5.3,  Prev: 3.5.1,  Up: 3.5

3.5.2 Character Types
---------------------

                          _Static Semantics_

1
An enumeration type is said to be a character type if at least one of
its enumeration literals is a character_literal.

2/3
The predefined type Character is a character type whose values
correspond to the 256 code points of Row 00 (also known as Latin-1) of
the ISO/IEC 10646:2011 Basic Multilingual Plane (BMP). Each of the
graphic characters of Row 00 of the BMP has a corresponding
character_literal in Character.  Each of the nongraphic characters of
Row 00 has a corresponding language-defined name, which is not usable as
an enumeration literal, but which is usable with the attributes Image,
Wide_Image, Wide_Wide_Image, Value, Wide_Value, and Wide_Wide_Value;
these names are given in the definition of type Character in *note
A.1::, "*note A.1:: The Package Standard", but are set in italics. 

3/3
The predefined type Wide_Character is a character type whose values
correspond to the 65536 code points of the ISO/IEC 10646:2011 Basic
Multilingual Plane (BMP). Each of the graphic characters of the BMP has
a corresponding character_literal in Wide_Character.  The first 256
values of Wide_Character have the same character_literal or
language-defined name as defined for Character.  Each of the
graphic_characters has a corresponding character_literal.

4/3
The predefined type Wide_Wide_Character is a character type whose values
correspond to the 2147483648 code points of the ISO/IEC 10646:2011
character set.  Each of the graphic_characters has a corresponding
character_literal in Wide_Wide_Character.  The first 65536 values of
Wide_Wide_Character have the same character_literal or language-defined
name as defined for Wide_Character.

5/3
The characters whose code point is larger than 16#FF# and which are not
graphic_characters have language-defined names which are formed by
appending to the string "Hex_" the representation of their code point in
hexadecimal as eight extended digits.  As with other language-defined
names, these names are usable only with the attributes (Wide_)Wide_Image
and (Wide_)Wide_Value; they are not usable as enumeration literals.

Paragraphs 6 and 7 were deleted.

     NOTES

8
     31  The language-defined library package Characters.Latin_1 (see
     *note A.3.3::) includes the declaration of constants denoting
     control characters, lower case characters, and special characters
     of the predefined type Character.

9/3
     32  A conventional character set such as EBCDIC can be declared as
     a character type; the internal codes of the characters can be
     specified by an enumeration_representation_clause as explained in
     subclause *note 13.4::.

                              _Examples_

10
Example of a character type:

11
     type Roman_Digit is ('I', 'V', 'X', 'L', 'C', 'D', 'M');


File: arm2012.info,  Node: 3.5.3,  Next: 3.5.4,  Prev: 3.5.2,  Up: 3.5

3.5.3 Boolean Types
-------------------

                          _Static Semantics_

1
There is a predefined enumeration type named Boolean, declared in the
visible part of package Standard. It has the two enumeration literals
False and True ordered with the relation False < True. Any descendant of
the predefined type Boolean is called a boolean type.


File: arm2012.info,  Node: 3.5.4,  Next: 3.5.5,  Prev: 3.5.3,  Up: 3.5

3.5.4 Integer Types
-------------------

1
An integer_type_definition defines an integer type; it defines either a
signed integer type, or a modular integer type.  The base range of a
signed integer type includes at least the values of the specified range.
A modular type is an integer type with all arithmetic modulo a specified
positive modulus; such a type corresponds to an unsigned type with
wrap-around semantics. 

                               _Syntax_

2
     integer_type_definition ::= signed_integer_type_definition | 
     modular_type_definition

3
     signed_integer_type_definition ::= range static_
     simple_expression .. static_simple_expression

4
     modular_type_definition ::= mod static_expression

                        _Name Resolution Rules_

5
Each simple_expression in a signed_integer_type_definition is expected
to be of any integer type; they need not be of the same type. The
expression in a modular_type_definition is likewise expected to be of
any integer type.

                           _Legality Rules_

6
The simple_expressions of a signed_integer_type_definition shall be
static, and their values shall be in the range System.Min_Int ..
System.Max_Int.

7
The expression of a modular_type_definition shall be static, and its
value (the modulus) shall be positive, and shall be no greater than
System.Max_Binary_Modulus if a power of 2, or no greater than
System.Max_Nonbinary_Modulus if not.

                          _Static Semantics_

8
The set of values for a signed integer type is the (infinite) set of
mathematical integers, though only values of the base range of the type
are fully supported for run-time operations.  The set of values for a
modular integer type are the values from 0 to one less than the modulus,
inclusive.

9
A signed_integer_type_definition defines an integer type whose base
range includes at least the values of the simple_expressions and is
symmetric about zero, excepting possibly an extra negative value. A
signed_integer_type_definition also defines a constrained first subtype
of the type, with a range whose bounds are given by the values of the
simple_expressions, converted to the type being defined.

10
A modular_type_definition defines a modular type whose base range is
from zero to one less than the given modulus. A modular_type_definition
also defines a constrained first subtype of the type with a range that
is the same as the base range of the type.

11
There is a predefined signed integer subtype named Integer, declared in
the visible part of package Standard.  It is constrained to the base
range of its type.

12
Integer has two predefined subtypes, declared in the visible part of
package Standard:

13
     subtype Natural  is Integer range 0 .. Integer'Last;
     subtype Positive is Integer range 1 .. Integer'Last;

14
A type defined by an integer_type_definition is implicitly derived from
root_integer, an anonymous predefined (specific) integer type, whose
base range is System.Min_Int ..  System.Max_Int.  However, the base
range of the new type is not inherited from root_integer, but is instead
determined by the range or modulus specified by the
integer_type_definition. Integer literals are all of the type
universal_integer, the universal type (see *note 3.4.1::) for the class
rooted at root_integer, allowing their use with the operations of any
integer type.

15
The position number of an integer value is equal to the value.

16/2
For every modular subtype S, the following attributes are defined:

16.1/2
S'Mod
               S'Mod denotes a function with the following
               specification:

16.2/2
                    function S'Mod (Arg : universal_integer)
                      return S'Base

16.3/2
               This function returns Arg mod S'Modulus, as a value of
               the type of S.

17
S'Modulus
               S'Modulus yields the modulus of the type of S, as a value
               of the type universal_integer.

                          _Dynamic Semantics_

18
The elaboration of an integer_type_definition creates the integer type
and its first subtype.

19
For a modular type, if the result of the execution of a predefined
operator (see *note 4.5::) is outside the base range of the type, the
result is reduced modulo the modulus of the type to a value that is
within the base range of the type.

20
For a signed integer type, the exception Constraint_Error is raised by
the execution of an operation that cannot deliver the correct result
because it is outside the base range of the type. For any integer type,
Constraint_Error is raised by the operators "/", "rem", and "mod" if the
right operand is zero.

                     _Implementation Requirements_

21
In an implementation, the range of Integer shall include the range
-2**15+1 ..  +2**15-1.

22
If Long_Integer is predefined for an implementation, then its range
shall include the range -2**31+1 ..  +2**31-1.

23
System.Max_Binary_Modulus shall be at least 2**16.

                     _Implementation Permissions_

24
For the execution of a predefined operation of a signed integer type,
the implementation need not raise Constraint_Error if the result is
outside the base range of the type, so long as the correct result is
produced.

25
An implementation may provide additional predefined signed integer
types, declared in the visible part of Standard, whose first subtypes
have names of the form Short_Integer, Long_Integer, Short_Short_Integer,
Long_Long_Integer, etc.  Different predefined integer types are allowed
to have the same base range.  However, the range of Integer should be no
wider than that of Long_Integer.  Similarly, the range of Short_Integer
(if provided) should be no wider than Integer.  Corresponding
recommendations apply to any other predefined integer types.  There need
not be a named integer type corresponding to each distinct base range
supported by an implementation.  The range of each first subtype should
be the base range of its type.

26
An implementation may provide nonstandard integer types, descendants of
root_integer that are declared outside of the specification of package
Standard, which need not have all the standard characteristics of a type
defined by an integer_type_definition.  For example, a nonstandard
integer type might have an asymmetric base range or it might not be
allowed as an array or loop index (a very long integer).  Any type
descended from a nonstandard integer type is also nonstandard.  An
implementation may place arbitrary restrictions on the use of such
types; it is implementation defined whether operators that are
predefined for "any integer type" are defined for a particular
nonstandard integer type.  In any case, such types are not permitted as
explicit_generic_actual_parameters for formal scalar types -- see *note
12.5.2::.

27
For a one's complement machine, the high bound of the base range of a
modular type whose modulus is one less than a power of 2 may be equal to
the modulus, rather than one less than the modulus.  It is
implementation defined for which powers of 2, if any, this permission is
exercised.

27.1/1
For a one's complement machine, implementations may support nonbinary
modulus values greater than System.Max_Nonbinary_Modulus.  It is
implementation defined which specific values greater than
System.Max_Nonbinary_Modulus, if any, are supported.

                        _Implementation Advice_

28
An implementation should support Long_Integer in addition to Integer if
the target machine supports 32-bit (or longer) arithmetic.  No other
named integer subtypes are recommended for package Standard.  Instead,
appropriate named integer subtypes should be provided in the library
package Interfaces (see *note B.2::).

29
An implementation for a two's complement machine should support modular
types with a binary modulus up to System.Max_Int*2+2.  An implementation
should support a nonbinary modulus up to Integer'Last.

     NOTES

30
     33  Integer literals are of the anonymous predefined integer type
     universal_integer.  Other integer types have no literals.  However,
     the overload resolution rules (see *note 8.6::, "*note 8.6:: The
     Context of Overload Resolution") allow expressions of the type
     universal_integer whenever an integer type is expected.

31
     34  The same arithmetic operators are predefined for all signed
     integer types defined by a signed_integer_type_definition (see
     *note 4.5::, "*note 4.5:: Operators and Expression Evaluation").
     For modular types, these same operators are predefined, plus
     bit-wise logical operators (and, or, xor, and not).  In addition,
     for the unsigned types declared in the language-defined package
     Interfaces (see *note B.2::), functions are defined that provide
     bit-wise shifting and rotating.

32
     35  Modular types match a generic_formal_parameter_declaration of
     the form "type T is mod <>;"; signed integer types match "type T is
     range <>;" (see *note 12.5.2::).

                              _Examples_

33
Examples of integer types and subtypes:

34
     type Page_Num  is range 1 .. 2_000;
     type Line_Size is range 1 .. Max_Line_Size;

35
     subtype Small_Int   is Integer   range -10 .. 10;
     subtype Column_Ptr  is Line_Size range 1 .. 10;
     subtype Buffer_Size is Integer   range 0 .. Max;

36
     type Byte        is mod 256; -- an unsigned byte
     type Hash_Index  is mod 97;  -- modulus is prime


File: arm2012.info,  Node: 3.5.5,  Next: 3.5.6,  Prev: 3.5.4,  Up: 3.5

3.5.5 Operations of Discrete Types
----------------------------------

                          _Static Semantics_

1
For every discrete subtype S, the following attributes are defined:

2
S'Pos
               S'Pos denotes a function with the following
               specification:

3
                    function S'Pos(Arg : S'Base)
                      return universal_integer

4
               This function returns the position number of the value of
               Arg, as a value of type universal_integer.

5
S'Val
               S'Val denotes a function with the following
               specification:

6
                    function S'Val(Arg : universal_integer)
                      return S'Base

7
               This function returns a value of the type of S whose
               position number equals the value of Arg. For the
               evaluation of a call on S'Val, if there is no value in
               the base range of its type with the given position
               number, Constraint_Error is raised.

7.1/4
For every static discrete subtype S for which there exists at least one
value belonging to S that satisfies the predicates of S, the following
attributes are defined:

7.2/4
S'First_Valid
               S'First_Valid denotes the smallest value that belongs to
               S and satisfies the predicates of S. The value of this
               attribute is of the type of S.

7.3/4
S'Last_Valid
               S'Last_Valid denotes the largest value that belongs to S
               and satisfies the predicates of S. The value of this
               attribute is of the type of S.

7.4/3
First_Valid and Last_Valid attribute_references are always static
expressions.  Any explicit predicate of S can only have been specified
by a Static_Predicate aspect.

                        _Implementation Advice_

8
For the evaluation of a call on S'Pos for an enumeration subtype, if the
value of the operand does not correspond to the internal code for any
enumeration literal of its type (perhaps due to an uninitialized
variable), then the implementation should raise Program_Error. This is
particularly important for enumeration types with noncontiguous internal
codes specified by an enumeration_representation_clause (*note 13.4:
S0311.).

     NOTES

9
     36  Indexing and loop iteration use values of discrete types.

10/3
     37  The predefined operations of a discrete type include the
     assignment operation, qualification, the membership tests, and the
     relational operators; for a boolean type they include the
     short-circuit control forms and the logical operators; for an
     integer type they include type conversion to and from other numeric
     types, as well as the binary and unary adding operators - and +,
     the multiplying operators, the unary operator abs, and the
     exponentiation operator.  The assignment operation is described in
     *note 5.2::.  The other predefined operations are described in
     Clause *note 4::.

11
     38  As for all types, objects of a discrete type have Size and
     Address attributes (see *note 13.3::).

12
     39  For a subtype of a discrete type, the result delivered by the
     attribute Val might not belong to the subtype; similarly, the
     actual parameter of the attribute Pos need not belong to the
     subtype.  The following relations are satisfied (in the absence of
     an exception) by these attributes:

13
             S'Val(S'Pos(X)) = X
             S'Pos(S'Val(N)) = N

                              _Examples_

14
Examples of attributes of discrete subtypes:

15
     --  For the types and subtypes declared in subclause *note 3.5.1:: the following hold: 

16
     --  Color'First   = White,   Color'Last   = Black
     --  Rainbow'First = Red,     Rainbow'Last = Blue

17
     --  Color'Succ(Blue) = Rainbow'Succ(Blue) = Brown
     --  Color'Pos(Blue)  = Rainbow'Pos(Blue)  = 4
     --  Color'Val(0)     = Rainbow'Val(0)     = White


File: arm2012.info,  Node: 3.5.6,  Next: 3.5.7,  Prev: 3.5.5,  Up: 3.5

3.5.6 Real Types
----------------

1
Real types provide approximations to the real numbers, with relative
bounds on errors for floating point types, and with absolute bounds for
fixed point types.

                               _Syntax_

2
     real_type_definition ::=
        floating_point_definition | fixed_point_definition

                          _Static Semantics_

3
A type defined by a real_type_definition is implicitly derived from
root_real, an anonymous predefined (specific) real type.  Hence, all
real types, whether floating point or fixed point, are in the derivation
class rooted at root_real.

4
Real literals are all of the type universal_real, the universal type
(see *note 3.4.1::) for the class rooted at root_real, allowing their
use with the operations of any real type. Certain multiplying operators
have a result type of universal_fixed (see *note 4.5.5::), the universal
type for the class of fixed point types, allowing the result of the
multiplication or division to be used where any specific fixed point
type is expected.

                          _Dynamic Semantics_

5
The elaboration of a real_type_definition consists of the elaboration of
the floating_point_definition or the fixed_point_definition.

                     _Implementation Requirements_

6
An implementation shall perform the run-time evaluation of a use of a
predefined operator of root_real with an accuracy at least as great as
that of any floating point type definable by a
floating_point_definition.

                     _Implementation Permissions_

7/2
For the execution of a predefined operation of a real type, the
implementation need not raise Constraint_Error if the result is outside
the base range of the type, so long as the correct result is produced,
or the Machine_Overflows attribute of the type is False (see *note
G.2::).

8
An implementation may provide nonstandard real types, descendants of
root_real that are declared outside of the specification of package
Standard, which need not have all the standard characteristics of a type
defined by a real_type_definition.  For example, a nonstandard real type
might have an asymmetric or unsigned base range, or its predefined
operations might wrap around or "saturate" rather than overflow (modular
or saturating arithmetic), or it might not conform to the accuracy model
(see *note G.2::).  Any type descended from a nonstandard real type is
also nonstandard.  An implementation may place arbitrary restrictions on
the use of such types; it is implementation defined whether operators
that are predefined for "any real type" are defined for a particular
nonstandard real type.  In any case, such types are not permitted as
explicit_generic_actual_parameters for formal scalar types -- see *note
12.5.2::.

     NOTES

9
     40  As stated, real literals are of the anonymous predefined real
     type universal_real.  Other real types have no literals.  However,
     the overload resolution rules (see *note 8.6::) allow expressions
     of the type universal_real whenever a real type is expected.


File: arm2012.info,  Node: 3.5.7,  Next: 3.5.8,  Prev: 3.5.6,  Up: 3.5

3.5.7 Floating Point Types
--------------------------

1
For floating point types, the error bound is specified as a relative
precision by giving the required minimum number of significant decimal
digits.

                               _Syntax_

2
     floating_point_definition ::=
       digits static_expression [real_range_specification]

3
     real_range_specification ::=
       range static_simple_expression .. static_simple_expression

                        _Name Resolution Rules_

4
The requested decimal precision, which is the minimum number of
significant decimal digits required for the floating point type, is
specified by the value of the expression given after the reserved word
digits. This expression is expected to be of any integer type.

5
Each simple_expression of a real_range_specification is expected to be
of any real type; the types need not be the same.

                           _Legality Rules_

6
The requested decimal precision shall be specified by a static
expression whose value is positive and no greater than
System.Max_Base_Digits.  Each simple_expression of a
real_range_specification shall also be static. If the
real_range_specification is omitted, the requested decimal precision
shall be no greater than System.Max_Digits.

7
A floating_point_definition is illegal if the implementation does not
support a floating point type that satisfies the requested decimal
precision and range.

                          _Static Semantics_

8
The set of values for a floating point type is the (infinite) set of
rational numbers. The machine numbers of a floating point type are the
values of the type that can be represented exactly in every
unconstrained variable of the type. The base range (see *note 3.5::) of
a floating point type is symmetric around zero, except that it can
include some extra negative values in some implementations.

9
The base decimal precision of a floating point type is the number of
decimal digits of precision representable in objects of the type. The
safe range of a floating point type is that part of its base range for
which the accuracy corresponding to the base decimal precision is
preserved by all predefined operations.

10
A floating_point_definition defines a floating point type whose base
decimal precision is no less than the requested decimal precision. If a
real_range_specification is given, the safe range of the floating point
type (and hence, also its base range) includes at least the values of
the simple expressions given in the real_range_specification.  If a
real_range_specification is not given, the safe (and base) range of the
type includes at least the values of the range -10.0**(4*D) ..
+10.0**(4*D) where D is the requested decimal precision.  The safe range
might include other values as well.  The attributes Safe_First and
Safe_Last give the actual bounds of the safe range.

11
A floating_point_definition also defines a first subtype of the type. If
a real_range_specification is given, then the subtype is constrained to
a range whose bounds are given by a conversion of the values of the
simple_expressions of the real_range_specification to the type being
defined.  Otherwise, the subtype is unconstrained.

12
There is a predefined, unconstrained, floating point subtype named
Float, declared in the visible part of package Standard.

                          _Dynamic Semantics_

13
The elaboration of a floating_point_definition creates the floating
point type and its first subtype.

                     _Implementation Requirements_

14
In an implementation that supports floating point types with 6 or more
digits of precision, the requested decimal precision for Float shall be
at least 6.

15
If Long_Float is predefined for an implementation, then its requested
decimal precision shall be at least 11.

                     _Implementation Permissions_

16
An implementation is allowed to provide additional predefined floating
point types, declared in the visible part of Standard, whose
(unconstrained) first subtypes have names of the form Short_Float,
Long_Float, Short_Short_Float, Long_Long_Float, etc.  Different
predefined floating point types are allowed to have the same base
decimal precision.  However, the precision of Float should be no greater
than that of Long_Float.  Similarly, the precision of Short_Float (if
provided) should be no greater than Float.  Corresponding
recommendations apply to any other predefined floating point types.
There need not be a named floating point type corresponding to each
distinct base decimal precision supported by an implementation.

                        _Implementation Advice_

17
An implementation should support Long_Float in addition to Float if the
target machine supports 11 or more digits of precision.  No other named
floating point subtypes are recommended for package Standard.  Instead,
appropriate named floating point subtypes should be provided in the
library package Interfaces (see *note B.2::).

     NOTES

18
     41  If a floating point subtype is unconstrained, then assignments
     to variables of the subtype involve only Overflow_Checks, never
     Range_Checks.

                              _Examples_

19
Examples of floating point types and subtypes:

20
     type Coefficient is digits 10 range -1.0 .. 1.0;

21
     type Real is digits 8;
     type Mass is digits 7 range 0.0 .. 1.0E35;

22
     subtype Probability is Real range 0.0 .. 1.0;   --   a subtype with a smaller range


File: arm2012.info,  Node: 3.5.8,  Next: 3.5.9,  Prev: 3.5.7,  Up: 3.5

3.5.8 Operations of Floating Point Types
----------------------------------------

                          _Static Semantics_

1
The following attribute is defined for every floating point subtype S:

2/1
S'Digits
               S'Digits denotes the requested decimal precision for the
               subtype S. The value of this attribute is of the type
               universal_integer.  The requested decimal precision of
               the base subtype of a floating point type T is defined to
               be the largest value of d for which
               ceiling(d * log(10) / log(T'Machine_Radix)) + g <=
               T'Model_Mantissa
               where g is 0 if Machine_Radix is a positive power of 10
               and 1 otherwise.

     NOTES

3
     42  The predefined operations of a floating point type include the
     assignment operation, qualification, the membership tests, and
     explicit conversion to and from other numeric types.  They also
     include the relational operators and the following predefined
     arithmetic operators: the binary and unary adding operators - and
     +, certain multiplying operators, the unary operator abs, and the
     exponentiation operator.

4
     43  As for all types, objects of a floating point type have Size
     and Address attributes (see *note 13.3::).  Other attributes of
     floating point types are defined in *note A.5.3::.


File: arm2012.info,  Node: 3.5.9,  Next: 3.5.10,  Prev: 3.5.8,  Up: 3.5

3.5.9 Fixed Point Types
-----------------------

1
A fixed point type is either an ordinary fixed point type, or a decimal
fixed point type. The error bound of a fixed point type is specified as
an absolute value, called the delta of the fixed point type.

                               _Syntax_

2
     fixed_point_definition ::= ordinary_fixed_point_definition | 
     decimal_fixed_point_definition

3
     ordinary_fixed_point_definition ::=
        delta static_expression  real_range_specification

4
     decimal_fixed_point_definition ::=
        delta static_expression digits static_expression [
     real_range_specification]

5/4
     digits_constraint ::=
        digits static_simple_expression [range_constraint]

                        _Name Resolution Rules_

6
For a type defined by a fixed_point_definition, the delta of the type is
specified by the value of the expression given after the reserved word
delta; this expression is expected to be of any real type. For a type
defined by a decimal_fixed_point_definition (a decimal fixed point
type), the number of significant decimal digits for its first subtype
(the digits of the first subtype) is specified by the expression given
after the reserved word digits; this expression is expected to be of any
integer type.

6.1/4
The simple_expression of a digits_constraint is expected to be of any
integer type.

                           _Legality Rules_

7
In a fixed_point_definition or digits_constraint, the expressions given
after the reserved words delta and digits shall be static; their values
shall be positive.

8/2
The set of values of a fixed point type comprise the integral multiples
of a number called the small of the type.  The machine numbers of a
fixed point type are the values of the type that can be represented
exactly in every unconstrained variable of the type. For a type defined
by an ordinary_fixed_point_definition (an ordinary fixed point type),
the small may be specified by an attribute_definition_clause (*note
13.3: S0310.) (see *note 13.3::); if so specified, it shall be no
greater than the delta of the type.  If not specified, the small of an
ordinary fixed point type is an implementation-defined power of two less
than or equal to the delta.

9
For a decimal fixed point type, the small equals the delta; the delta
shall be a power of 10.  If a real_range_specification is given, both
bounds of the range shall be in the range -(10**digits-1)*delta ..
+(10**digits-1)*delta.

10
A fixed_point_definition is illegal if the implementation does not
support a fixed point type with the given small and specified range or
digits.

11
For a subtype_indication with a digits_constraint, the subtype_mark
shall denote a decimal fixed point subtype.

                          _Static Semantics_

12
The base range (see *note 3.5::) of a fixed point type is symmetric
around zero, except possibly for an extra negative value in some
implementations.

13
An ordinary_fixed_point_definition defines an ordinary fixed point type
whose base range includes at least all multiples of small that are
between the bounds specified in the real_range_specification.  The base
range of the type does not necessarily include the specified bounds
themselves. An ordinary_fixed_point_definition (*note 3.5.9: S0048.)
also defines a constrained first subtype of the type, with each bound of
its range given by the closer to zero of:

14
   * the value of the conversion to the fixed point type of the
     corresponding expression of the real_range_specification; 

15
   * the corresponding bound of the base range.

16
A decimal_fixed_point_definition defines a decimal fixed point type
whose base range includes at least the range -(10**digits-1)*delta ..
+(10**digits-1)*delta. A decimal_fixed_point_definition also defines a
constrained first subtype of the type.  If a real_range_specification is
given, the bounds of the first subtype are given by a conversion of the
values of the expressions of the real_range_specification. Otherwise,
the range of the first subtype is -(10**digits-1)*delta ..
+(10**digits-1)*delta.

                          _Dynamic Semantics_

17
The elaboration of a fixed_point_definition creates the fixed point type
and its first subtype.

18/4
For a digits_constraint on a decimal fixed point subtype with a given
delta, if it does not have a range_constraint, then it specifies an
implicit range -(10**D-1)*delta ..  +(10**D-1)*delta, where D is the
value of the simple_expression. A digits_constraint is compatible with a
decimal fixed point subtype if the value of the simple_expression is no
greater than the digits of the subtype, and if it specifies (explicitly
or implicitly) a range that is compatible with the subtype.

19/4
The elaboration of a digits_constraint consists of the elaboration of
the range_constraint, if any. If a range_constraint is given, a check is
made that the bounds of the range are both in the range -(10**D-1)*delta
..  +(10**D-1)*delta, where D is the value of the (static)
simple_expression given after the reserved word digits. If this check
fails, Constraint_Error is raised.

                     _Implementation Requirements_

20
The implementation shall support at least 24 bits of precision
(including the sign bit) for fixed point types.

                     _Implementation Permissions_

21
Implementations are permitted to support only smalls that are a power of
two.  In particular, all decimal fixed point type declarations can be
disallowed.  Note however that conformance with the Information Systems
Annex requires support for decimal smalls, and decimal fixed point type
declarations with digits up to at least 18.

     NOTES

22
     44  The base range of an ordinary fixed point type need not include
     the specified bounds themselves so that the range specification can
     be given in a natural way, such as:

23
             type Fraction is delta 2.0**(-15) range -1.0 .. 1.0;
  

24
     With 2's complement hardware, such a type could have a signed
     16-bit representation, using 1 bit for the sign and 15 bits for
     fraction, resulting in a base range of -1.0 ..  1.0-2.0**(-15).

                              _Examples_

25
Examples of fixed point types and subtypes:

26
     type Volt is delta 0.125 range 0.0 .. 255.0;

27
       -- A pure fraction which requires all the available
       -- space in a word can be declared as the type Fraction:
     type Fraction is delta System.Fine_Delta range -1.0 .. 1.0;
       -- Fraction'Last = 1.0 - System.Fine_Delta

28
     type Money is delta 0.01 digits 15;  -- decimal fixed point
     subtype Salary is Money digits 10;
       -- Money'Last = 10.0**13 - 0.01, Salary'Last = 10.0**8 - 0.01


File: arm2012.info,  Node: 3.5.10,  Prev: 3.5.9,  Up: 3.5

3.5.10 Operations of Fixed Point Types
--------------------------------------

                          _Static Semantics_

1
The following attributes are defined for every fixed point subtype S:

2/1
S'Small
               S'Small denotes the small of the type of S. The value of
               this attribute is of the type universal_real. Small may
               be specified for nonderived ordinary fixed point types
               via an attribute_definition_clause (*note 13.3: S0310.)
               (see *note 13.3::); the expression of such a clause shall
               be static.

3
S'Delta
               S'Delta denotes the delta of the fixed point subtype S.
               The value of this attribute is of the type
               universal_real.

4
S'Fore
               S'Fore yields the minimum number of characters needed
               before the decimal point for the decimal representation
               of any value of the subtype S, assuming that the
               representation does not include an exponent, but includes
               a one-character prefix that is either a minus sign or a
               space.  (This minimum number does not include superfluous
               zeros or underlines, and is at least 2.)  The value of
               this attribute is of the type universal_integer.

5
S'Aft
               S'Aft yields the number of decimal digits needed after
               the decimal point to accommodate the delta of the subtype
               S, unless the delta of the subtype S is greater than 0.1,
               in which case the attribute yields the value one.  (S'Aft
               is the smallest positive integer N for which
               (10**N)*S'Delta is greater than or equal to one.)  The
               value of this attribute is of the type universal_integer.

6
The following additional attributes are defined for every decimal fixed
point subtype S:

7
S'Digits
               S'Digits denotes the digits of the decimal fixed point
               subtype S, which corresponds to the number of decimal
               digits that are representable in objects of the subtype.
               The value of this attribute is of the type
               universal_integer.  Its value is determined as follows: 

8
                  * For a first subtype or a subtype defined by a
                    subtype_indication with a digits_constraint, the
                    digits is the value of the expression given after
                    the reserved word digits;

9
                  * For a subtype defined by a subtype_indication
                    without a digits_constraint, the digits of the
                    subtype is the same as that of the subtype denoted
                    by the subtype_mark in the subtype_indication.

10
                  * The digits of a base subtype is the largest integer
                    D such that the range -(10**D-1)*delta ..
                    +(10**D-1)*delta is included in the base range of
                    the type.

11
S'Scale
               S'Scale denotes the scale of the subtype S, defined as
               the value N such that S'Delta = 10.0**(-N). The scale
               indicates the position of the point relative to the
               rightmost significant digits of values of subtype S. The
               value of this attribute is of the type universal_integer.

12
S'Round
               S'Round denotes a function with the following
               specification:

13
                    function S'Round(X : universal_real)
                      return S'Base

14
               The function returns the value obtained by rounding X
               (away from 0, if X is midway between two values of the
               type of S).

     NOTES

15
     45  All subtypes of a fixed point type will have the same value for
     the Delta attribute, in the absence of delta_constraints (see *note
     J.3::).

16
     46  S'Scale is not always the same as S'Aft for a decimal subtype;
     for example, if S'Delta = 1.0 then S'Aft is 1 while S'Scale is 0.

17
     47  The predefined operations of a fixed point type include the
     assignment operation, qualification, the membership tests, and
     explicit conversion to and from other numeric types.  They also
     include the relational operators and the following predefined
     arithmetic operators: the binary and unary adding operators - and
     +, multiplying operators, and the unary operator abs.

18
     48  As for all types, objects of a fixed point type have Size and
     Address attributes (see *note 13.3::).  Other attributes of fixed
     point types are defined in *note A.5.4::.


File: arm2012.info,  Node: 3.6,  Next: 3.7,  Prev: 3.5,  Up: 3

3.6 Array Types
===============

1
An array object is a composite object consisting of components which all
have the same subtype.  The name for a component of an array uses one or
more index values belonging to specified discrete types.  The value of
an array object is a composite value consisting of the values of the
components.

                               _Syntax_

2
     array_type_definition ::=
        unconstrained_array_definition | constrained_array_definition

3
     unconstrained_array_definition ::=
        array(index_subtype_definition {, index_subtype_definition}) of 
     component_definition

4
     index_subtype_definition ::= subtype_mark range <>

5
     constrained_array_definition ::=
        array (discrete_subtype_definition {, 
     discrete_subtype_definition}) of component_definition

6
     discrete_subtype_definition ::= discrete_subtype_indication | range

7/2
     component_definition ::=
        [aliased] subtype_indication
      | [aliased] access_definition

                        _Name Resolution Rules_

8
For a discrete_subtype_definition that is a range, the range shall
resolve to be of some specific discrete type; which discrete type shall
be determined without using any context other than the bounds of the
range itself (plus the preference for root_integer -- see *note 8.6::).

                           _Legality Rules_

9
Each index_subtype_definition or discrete_subtype_definition in an
array_type_definition defines an index subtype; its type (the index
type) shall be discrete.

10
The subtype defined by the subtype_indication of a component_definition
(the component subtype) shall be a definite subtype.

11/2
This paragraph was deleted.

                          _Static Semantics_

12
An array is characterized by the number of indices (the dimensionality
of the array), the type and position of each index, the lower and upper
bounds for each index, and the subtype of the components.  The order of
the indices is significant.

13
A one-dimensional array has a distinct component for each possible index
value.  A multidimensional array has a distinct component for each
possible sequence of index values that can be formed by selecting one
value for each index position (in the given order).  The possible values
for a given index are all the values between the lower and upper bounds,
inclusive; this range of values is called the index range. The bounds of
an array are the bounds of its index ranges. The length of a dimension
of an array is the number of values of the index range of the dimension
(zero for a null range). The length of a one-dimensional array is the
length of its only dimension.

14
An array_type_definition defines an array type and its first subtype.
For each object of this array type, the number of indices, the type and
position of each index, and the subtype of the components are as in the
type definition; the values of the lower and upper bounds for each index
belong to the corresponding index subtype of its type, except for null
arrays (see *note 3.6.1::).

15
An unconstrained_array_definition defines an array type with an
unconstrained first subtype.  Each index_subtype_definition (*note 3.6:
S0053.) defines the corresponding index subtype to be the subtype
denoted by the subtype_mark (*note 3.2.2: S0028.). The compound
delimiter <> (called a box) of an index_subtype_definition stands for an
undefined range (different objects of the type need not have the same
bounds).

16
A constrained_array_definition defines an array type with a constrained
first subtype.  Each discrete_subtype_definition (*note 3.6: S0055.)
defines the corresponding index subtype, as well as the corresponding
index range for the constrained first subtype. The constraint of the
first subtype consists of the bounds of the index ranges.

17
The discrete subtype defined by a discrete_subtype_definition (*note
3.6: S0055.) is either that defined by the subtype_indication (*note
3.2.2: S0027.), or a subtype determined by the range as follows:

18
   * If the type of the range resolves to root_integer, then the
     discrete_subtype_definition defines a subtype of the predefined
     type Integer with bounds given by a conversion to Integer of the
     bounds of the range; 

19
   * Otherwise, the discrete_subtype_definition defines a subtype of the
     type of the range, with the bounds given by the range.

20
The component_definition of an array_type_definition defines the nominal
subtype of the components.  If the reserved word aliased appears in the
component_definition, then each component of the array is aliased (see
*note 3.10::).

                          _Dynamic Semantics_

21
The elaboration of an array_type_definition creates the array type and
its first subtype, and consists of the elaboration of any
discrete_subtype_definition (*note 3.6: S0055.)s and the
component_definition (*note 3.6: S0056.).

22/2
The elaboration of a discrete_subtype_definition that does not contain
any per-object expressions creates the discrete subtype, and consists of
the elaboration of the subtype_indication (*note 3.2.2: S0027.) or the
evaluation of the range.  The elaboration of a
discrete_subtype_definition that contains one or more per-object
expressions is defined in *note 3.8::. The elaboration of a
component_definition (*note 3.6: S0056.) in an array_type_definition
(*note 3.6: S0051.) consists of the elaboration of the
subtype_indication (*note 3.2.2: S0027.) or access_definition.  The
elaboration of any discrete_subtype_definition (*note 3.6: S0055.)s and
the elaboration of the component_definition (*note 3.6: S0056.) are
performed in an arbitrary order.

                          _Static Semantics_

22.1/3
For an array type with a scalar component type, the following
language-defined representation aspect may be specified with an
aspect_specification (see *note 13.1.1::):

22.2/3
Default_Component_Value
               This aspect shall be specified by a static expression,
               and that expression shall be explicit, even if the aspect
               has a boolean type.  Default_Component_Value shall be
               specified only on a full_type_declaration.

22.3/3
If a derived type with no primitive subprograms inherits a boolean
Default_Component_Value aspect, the aspect may be specified to have any
value for the derived type.

                        _Name Resolution Rules_

22.4/3
The expected type for the expression specified for the
Default_Component_Value aspect is the component type of the array type
defined by the full_type_declaration on which it appears.

     NOTES

23
     49  All components of an array have the same subtype.  In
     particular, for an array of components that are one-dimensional
     arrays, this means that all components have the same bounds and
     hence the same length.

24
     50  Each elaboration of an array_type_definition creates a distinct
     array type.  A consequence of this is that each object whose
     object_declaration contains an array_type_definition is of its own
     unique type.

                              _Examples_

25
Examples of type declarations with unconstrained array definitions:

26
     type Vector     is array(Integer  range <>) of Real;
     type Matrix     is array(Integer  range <>, Integer range <>) of Real;
     type Bit_Vector is array(Integer  range <>) of Boolean;
     type Roman      is array(Positive range <>) of Roman_Digit; -- see *note 3.5.2::

27
Examples of type declarations with constrained array definitions:

28
     type Table    is array(1 .. 10) of Integer;
     type Schedule is array(Day) of Boolean;
     type Line     is array(1 .. Max_Line_Size) of Character;

29
Examples of object declarations with array type definitions:

30/2
     Grid      : array(1 .. 80, 1 .. 100) of Boolean;
     Mix       : array(Color range Red .. Green) of Boolean;
     Msg_Table : constant array(Error_Code) of access constant String :=
           (Too_Big => new String'("Result too big"), Too_Small => ...);
     Page      : array(Positive range <>) of Line :=  --  an array of arrays
       (1 | 50  => Line'(1 | Line'Last => '+', others => '-'),  -- see *note 4.3.3::
        2 .. 49 => Line'(1 | Line'Last => '|', others => ' '));
         -- Page is constrained by its initial value to (1..50)

* Menu:

* 3.6.1 ::    Index Constraints and Discrete Ranges
* 3.6.2 ::    Operations of Array Types
* 3.6.3 ::    String Types


File: arm2012.info,  Node: 3.6.1,  Next: 3.6.2,  Up: 3.6

3.6.1 Index Constraints and Discrete Ranges
-------------------------------------------

1
An index_constraint determines the range of possible values for every
index of an array subtype, and thereby the corresponding array bounds.

                               _Syntax_

2
     index_constraint ::=  (discrete_range {, discrete_range})

3
     discrete_range ::= discrete_subtype_indication | range

                        _Name Resolution Rules_

4
The type of a discrete_range is the type of the subtype defined by the
subtype_indication, or the type of the range. For an index_constraint,
each discrete_range shall resolve to be of the type of the corresponding
index.

                           _Legality Rules_

5
An index_constraint shall appear only in a subtype_indication whose
subtype_mark denotes either an unconstrained array subtype, or an
unconstrained access subtype whose designated subtype is an
unconstrained array subtype; in either case, the index_constraint shall
provide a discrete_range for each index of the array type.

                          _Static Semantics_

6
A discrete_range defines a range whose bounds are given by the range, or
by the range of the subtype defined by the subtype_indication.

                          _Dynamic Semantics_

7
An index_constraint is compatible with an unconstrained array subtype if
and only if the index range defined by each discrete_range is compatible
(see *note 3.5::) with the corresponding index subtype. If any of the
discrete_ranges defines a null range, any array thus constrained is a
null array, having no components. An array value satisfies an
index_constraint if at each index position the array value and the
index_constraint have the same index bounds.

8
The elaboration of an index_constraint consists of the evaluation of the
discrete_range(s), in an arbitrary order. The evaluation of a
discrete_range consists of the elaboration of the subtype_indication or
the evaluation of the range.

     NOTES

9
     51  The elaboration of a subtype_indication consisting of a
     subtype_mark followed by an index_constraint checks the
     compatibility of the index_constraint with the subtype_mark (see
     *note 3.2.2::).

10
     52  Even if an array value does not satisfy the index constraint of
     an array subtype, Constraint_Error is not raised on conversion to
     the array subtype, so long as the length of each dimension of the
     array value and the array subtype match.  See *note 4.6::.

                              _Examples_

11
Examples of array declarations including an index constraint:

12
     Board     : Matrix(1 .. 8,  1 .. 8);  --  see *note 3.6::
     Rectangle : Matrix(1 .. 20, 1 .. 30);
     Inverse   : Matrix(1 .. N,  1 .. N);  --  N need not be static 

13
     Filter    : Bit_Vector(0 .. 31);

14
Example of array declaration with a constrained array subtype:

15
     My_Schedule : Schedule;  --  all arrays of type Schedule have the same bounds

16
Example of record type with a component that is an array:

17
     type Var_Line(Length : Natural) is
        record
           Image : String(1 .. Length);
        end record;

18
     Null_Line : Var_Line(0);  --  Null_Line.Image is a null array


File: arm2012.info,  Node: 3.6.2,  Next: 3.6.3,  Prev: 3.6.1,  Up: 3.6

3.6.2 Operations of Array Types
-------------------------------

                           _Legality Rules_

1
The argument N used in the attribute_designators for the N-th dimension
of an array shall be a static expression of some integer type.  The
value of N shall be positive (nonzero) and no greater than the
dimensionality of the array.

                          _Static Semantics_

2/1
The following attributes are defined for a prefix A that is of an array
type (after any implicit dereference), or denotes a constrained array
subtype:

3
A'First
               A'First denotes the lower bound of the first index range;
               its type is the corresponding index type.

4
A'First(N)
               A'First(N) denotes the lower bound of the N-th index
               range; its type is the corresponding index type.

5
A'Last
               A'Last denotes the upper bound of the first index range;
               its type is the corresponding index type.

6
A'Last(N)
               A'Last(N) denotes the upper bound of the N-th index
               range; its type is the corresponding index type.

7
A'Range
               A'Range is equivalent to the range A'First ..  A'Last,
               except that the prefix A is only evaluated once.

8
A'Range(N)
               A'Range(N) is equivalent to the range A'First(N) ..
               A'Last(N), except that the prefix A is only evaluated
               once.

9
A'Length
               A'Length denotes the number of values of the first index
               range (zero for a null range); its type is
               universal_integer.

10
A'Length(N)
               A'Length(N) denotes the number of values of the N-th
               index range (zero for a null range); its type is
               universal_integer.

                        _Implementation Advice_

11/3
An implementation should normally represent multidimensional arrays in
row-major order, consistent with the notation used for multidimensional
array aggregates (see *note 4.3.3::).  However, if convention Fortran is
specified for a multidimensional array type, then column-major order
should be used instead (see *note B.5::, "*note B.5:: Interfacing with
Fortran").

     NOTES

12
     53  The attribute_references A'First and A'First(1) denote the same
     value.  A similar relation exists for the attribute_references
     A'Last, A'Range, and A'Length.  The following relation is satisfied
     (except for a null array) by the above attributes if the index type
     is an integer type:

13
             A'Length(N) = A'Last(N) - A'First(N) + 1

14
     54  An array type is limited if its component type is limited (see
     *note 7.5::).

15
     55  The predefined operations of an array type include the
     membership tests, qualification, and explicit conversion.  If the
     array type is not limited, they also include assignment and the
     predefined equality operators.  For a one-dimensional array type,
     they include the predefined concatenation operators (if nonlimited)
     and, if the component type is discrete, the predefined relational
     operators; if the component type is boolean, the predefined logical
     operators are also included.

16/2
     56  A component of an array can be named with an indexed_component.
     A value of an array type can be specified with an array_aggregate.
     For a one-dimensional array type, a slice of the array can be
     named; also, string literals are defined if the component type is a
     character type.

                              _Examples_

17
Examples (using arrays declared in the examples of subclause *note
3.6.1::):

18
     --  Filter'First      =   0   Filter'Last       =  31   Filter'Length =  32
     --  Rectangle'Last(1) =  20   Rectangle'Last(2) =  30


File: arm2012.info,  Node: 3.6.3,  Prev: 3.6.2,  Up: 3.6

3.6.3 String Types
------------------

                          _Static Semantics_

1
A one-dimensional array type whose component type is a character type is
called a string type.

2/2
There are three predefined string types, String, Wide_String, and
Wide_Wide_String, each indexed by values of the predefined subtype
Positive; these are declared in the visible part of package Standard:

3
     subtype Positive is Integer range 1 .. Integer'Last;

4/2
     type String is array(Positive range <>) of Character;
     type Wide_String is array(Positive range <>) of Wide_Character;
     type Wide_Wide_String is array(Positive range <>) of Wide_Wide_Character;


     NOTES

5
     57  String literals (see *note 2.6:: and *note 4.2::) are defined
     for all string types.  The concatenation operator & is predefined
     for string types, as for all nonlimited one-dimensional array
     types.  The ordering operators <, <=, >, and >= are predefined for
     string types, as for all one-dimensional discrete array types;
     these ordering operators correspond to lexicographic order (see
     *note 4.5.2::).

                              _Examples_

6
Examples of string objects:

7
     Stars      : String(1 .. 120) := (1 .. 120 => '*' );
     Question   : constant String  := "How many characters?";
        -- Question'First = 1, Question'Last = 20
        -- Question'Length = 20 (the number of characters)

8
     Ask_Twice  : String  := Question & Question;   -- constrained to (1..40)
     Ninety_Six : constant Roman   := "XCVI";   -- see *note 3.5.2:: and *note 3.6::


File: arm2012.info,  Node: 3.7,  Next: 3.8,  Prev: 3.6,  Up: 3

3.7 Discriminants
=================

1/2
A composite type (other than an array or interface type) can have
discriminants, which parameterize the type.  A known_discriminant_part
specifies the discriminants of a composite type.  A discriminant of an
object is a component of the object, and is either of a discrete type or
an access type.  An unknown_discriminant_part in the declaration of a
view of a type specifies that the discriminants of the type are unknown
for the given view; all subtypes of such a view are indefinite subtypes.

                               _Syntax_

2/2
     discriminant_part ::= unknown_discriminant_part | 
     known_discriminant_part

3
     unknown_discriminant_part ::= (<>)

4
     known_discriminant_part ::=
        (discriminant_specification {; discriminant_specification})

5/2
     discriminant_specification ::=
        defining_identifier_list : [null_exclusion] subtype_mark [:= 
     default_expression]
      | defining_identifier_list : access_definition [:= 
     default_expression]

6
     default_expression ::= expression

                        _Name Resolution Rules_

7
The expected type for the default_expression of a
discriminant_specification is that of the corresponding discriminant.

                           _Legality Rules_

8/2
A discriminant_part is only permitted in a declaration for a composite
type that is not an array or interface type (this includes generic
formal types).  A type declared with a known_discriminant_part is called
a discriminated type, as is a type that inherits (known) discriminants.

9/2
The subtype of a discriminant may be defined by an optional
null_exclusion and a subtype_mark, in which case the subtype_mark shall
denote a discrete or access subtype, or it may be defined by an
access_definition. A discriminant that is defined by an
access_definition is called an access discriminant and is of an
anonymous access type.

9.1/3
Default_expressions shall be provided either for all or for none of the
discriminants of a known_discriminant_part (*note 3.7: S0061.).  No
default_expression (*note 3.7: S0063.)s are permitted in a
known_discriminant_part (*note 3.7: S0061.) in a declaration of a
nonlimited tagged type or a generic formal type.

10/3
A discriminant_specification for an access discriminant may have a
default_expression only in the declaration for an immutably limited type
(see *note 7.5::).  In addition to the places where Legality Rules
normally apply (see *note 12.3::), this rule applies also in the private
part of an instance of a generic unit.

11/2
This paragraph was deleted.

12
For a type defined by a derived_type_definition, if a
known_discriminant_part is provided in its declaration, then:

13
   * The parent subtype shall be constrained;

14
   * If the parent type is not a tagged type, then each discriminant of
     the derived type shall be used in the constraint defining the
     parent subtype;

15
   * If a discriminant is used in the constraint defining the parent
     subtype, the subtype of the discriminant shall be statically
     compatible (see *note 4.9.1::) with the subtype of the
     corresponding parent discriminant.

16/3
This paragraph was deleted.

                          _Static Semantics_

17
A discriminant_specification declares a discriminant; the subtype_mark
denotes its subtype unless it is an access discriminant, in which case
the discriminant's subtype is the anonymous access-to-variable subtype
defined by the access_definition.

18
For a type defined by a derived_type_definition, each discriminant of
the parent type is either inherited, constrained to equal some new
discriminant of the derived type, or constrained to the value of an
expression. When inherited or constrained to equal some new
discriminant, the parent discriminant and the discriminant of the
derived type are said to correspond.  Two discriminants also correspond
if there is some common discriminant to which they both correspond.  A
discriminant corresponds to itself as well. If a discriminant of a
parent type is constrained to a specific value by a
derived_type_definition, then that discriminant is said to be specified
by that derived_type_definition.

19
A constraint that appears within the definition of a discriminated type
depends on a discriminant of the type if it names the discriminant as a
bound or discriminant value.  A component_definition depends on a
discriminant if its constraint depends on the discriminant, or on a
discriminant that corresponds to it.

20
A component depends on a discriminant if:

21
   * Its component_definition depends on the discriminant; or

22
   * It is declared in a variant_part that is governed by the
     discriminant; or

23
   * It is a component inherited as part of a derived_type_definition,
     and the constraint of the parent_subtype_indication depends on the
     discriminant; or

24
   * It is a subcomponent of a component that depends on the
     discriminant.

25
Each value of a discriminated type includes a value for each component
of the type that does not depend on a discriminant; this includes the
discriminants themselves.  The values of discriminants determine which
other component values are present in the value of the discriminated
type.

26
A type declared with a known_discriminant_part is said to have known
discriminants; its first subtype is unconstrained. A type declared with
an unknown_discriminant_part is said to have unknown discriminants.  A
type declared without a discriminant_part has no discriminants, unless
it is a derived type; if derived, such a type has the same sort of
discriminants (known, unknown, or none) as its parent (or ancestor)
type.  A tagged class-wide type also has unknown discriminants. Any
subtype of a type with unknown discriminants is an unconstrained and
indefinite subtype (see *note 3.2:: and *note 3.3::).

                          _Dynamic Semantics_

27/2
For an access discriminant, its access_definition is elaborated when the
value of the access discriminant is defined: by evaluation of its
default_expression, by elaboration of a discriminant_constraint, or by
an assignment that initializes the enclosing object. 

     NOTES

28
     58  If a discriminated type has default_expressions for its
     discriminants, then unconstrained variables of the type are
     permitted, and the values of the discriminants can be changed by an
     assignment to such a variable.  If defaults are not provided for
     the discriminants, then all variables of the type are constrained,
     either by explicit constraint or by their initial value; the values
     of the discriminants of such a variable cannot be changed after
     initialization.

29
     59  The default_expression for a discriminant of a type is
     evaluated when an object of an unconstrained subtype of the type is
     created.

30
     60  Assignment to a discriminant of an object (after its
     initialization) is not allowed, since the name of a discriminant is
     a constant; neither assignment_statements nor assignments inherent
     in passing as an in out or out parameter are allowed.  Note however
     that the value of a discriminant can be changed by assigning to the
     enclosing object, presuming it is an unconstrained variable.

31
     61  A discriminant that is of a named access type is not called an
     access discriminant; that term is used only for discriminants
     defined by an access_definition.

                              _Examples_

32
Examples of discriminated types:

33
     type Buffer(Size : Buffer_Size := 100)  is        -- see *note 3.5.4::
        record
           Pos   : Buffer_Size := 0;
           Value : String(1 .. Size);
        end record;

34
     type Matrix_Rec(Rows, Columns : Integer) is
        record
           Mat : Matrix(1 .. Rows, 1 .. Columns);       -- see *note 3.6::
        end record;

35
     type Square(Side : Integer) is new
        Matrix_Rec(Rows => Side, Columns => Side);

36
     type Double_Square(Number : Integer) is
        record
           Left  : Square(Number);
           Right : Square(Number);
        end record;

37/3
     task type Worker(Prio : System.Priority; Buf : access Buffer)
        with Priority => Prio is -- see *note D.1::
        -- discriminants used to parameterize the task type (see *note 9.1::)
        entry Fill;
        entry Drain;
     end Worker;

* Menu:

* 3.7.1 ::    Discriminant Constraints
* 3.7.2 ::    Operations of Discriminated Types


File: arm2012.info,  Node: 3.7.1,  Next: 3.7.2,  Up: 3.7

3.7.1 Discriminant Constraints
------------------------------

1
A discriminant_constraint specifies the values of the discriminants for
a given discriminated type.

                               _Syntax_

2
     discriminant_constraint ::=
        (discriminant_association {, discriminant_association})

3
     discriminant_association ::=
        [discriminant_selector_name {| discriminant_selector_name} =>] 
     expression

4
     A discriminant_association is said to be named if it has one or
     more discriminant_selector_names; it is otherwise said to be
     positional.  In a discriminant_constraint, any positional
     associations shall precede any named associations.

                        _Name Resolution Rules_

5
Each selector_name of a named discriminant_association (*note 3.7.1:
S0065.) shall resolve to denote a discriminant of the subtype being
constrained; the discriminants so named are the associated discriminants
of the named association. For a positional association, the associated
discriminant is the one whose discriminant_specification (*note 3.7:
S0062.) occurred in the corresponding position in the
known_discriminant_part (*note 3.7: S0061.) that defined the
discriminants of the subtype being constrained.

6
The expected type for the expression in a discriminant_association is
that of the associated discriminant(s).

                           _Legality Rules_

7/3
A discriminant_constraint is only allowed in a subtype_indication whose
subtype_mark denotes either an unconstrained discriminated subtype, or
an unconstrained access subtype whose designated subtype is an
unconstrained discriminated subtype.  However, in the case of an access
subtype, a discriminant_constraint (*note 3.7.1: S0064.) is legal only
if any dereference of a value of the access type is known to be
constrained (see *note 3.3::).  In addition to the places where Legality
Rules normally apply (see *note 12.3::), these rules apply also in the
private part of an instance of a generic unit.

8
A named discriminant_association with more than one selector_name is
allowed only if the named discriminants are all of the same type.  A
discriminant_constraint shall provide exactly one value for each
discriminant of the subtype being constrained.

9/3
This paragraph was deleted.

                          _Dynamic Semantics_

10
A discriminant_constraint is compatible with an unconstrained
discriminated subtype if each discriminant value belongs to the subtype
of the corresponding discriminant.

11
A composite value satisfies a discriminant constraint if and only if
each discriminant of the composite value has the value imposed by the
discriminant constraint.

12
For the elaboration of a discriminant_constraint, the expressions in the
discriminant_associations are evaluated in an arbitrary order and
converted to the type of the associated discriminant (which might raise
Constraint_Error -- see *note 4.6::); the expression of a named
association is evaluated (and converted) once for each associated
discriminant. The result of each evaluation and conversion is the value
imposed by the constraint for the associated discriminant.

     NOTES

13
     62  The rules of the language ensure that a discriminant of an
     object always has a value, either from explicit or implicit
     initialization.

                              _Examples_

14/3
Examples (using types declared above in subclause *note 3.7::):

15
     Large   : Buffer(200);  --  constrained, always 200 characters
                             --   (explicit discriminant value)
     Message : Buffer;       --  unconstrained, initially 100 characters
                             --   (default discriminant value)
     Basis   : Square(5);    --  constrained, always 5 by 5
     Illegal : Square;       --  illegal, a Square has to be constrained


File: arm2012.info,  Node: 3.7.2,  Prev: 3.7.1,  Up: 3.7

3.7.2 Operations of Discriminated Types
---------------------------------------

1
If a discriminated type has default_expressions for its discriminants,
then unconstrained variables of the type are permitted, and the
discriminants of such a variable can be changed by assignment to the
variable.  For a formal parameter of such a type, an attribute is
provided to determine whether the corresponding actual parameter is
constrained or unconstrained.

                          _Static Semantics_

2
For a prefix A that is of a discriminated type (after any implicit
dereference), the following attribute is defined:

3/3
A'Constrained
               Yields the value True if A denotes a constant, a value, a
               tagged object, or a constrained variable, and False
               otherwise.

                         _Erroneous Execution_

4
The execution of a construct is erroneous if the construct has a
constituent that is a name denoting a subcomponent that depends on
discriminants, and the value of any of these discriminants is changed by
this execution between evaluating the name and the last use (within this
execution) of the subcomponent denoted by the name.


File: arm2012.info,  Node: 3.8,  Next: 3.9,  Prev: 3.7,  Up: 3

3.8 Record Types
================

1
A record object is a composite object consisting of named components.
The value of a record object is a composite value consisting of the
values of the components. 

                               _Syntax_

2
     record_type_definition ::= [[abstract] tagged] [limited] 
     record_definition

3
     record_definition ::=
         record
            component_list
         end record
       | null record

4
     component_list ::=
           component_item {component_item}
        | {component_item} variant_part
        |  null;

5/1
     component_item ::= component_declaration | aspect_clause

6/3
     component_declaration ::=
        defining_identifier_list : component_definition [:= 
     default_expression]
             [aspect_specification];

                        _Name Resolution Rules_

7
The expected type for the default_expression, if any, in a
component_declaration is the type of the component.

                           _Legality Rules_

8/2
This paragraph was deleted.

9/2
Each component_declaration declares a component of the record type.
Besides components declared by component_declarations, the components of
a record type include any components declared by
discriminant_specifications of the record type declaration.  The
identifiers of all components of a record type shall be distinct.

10
Within a type_declaration, a name that denotes a component, protected
subprogram, or entry of the type is allowed only in the following cases:

11/3
   * A name that denotes any component, protected subprogram, or entry
     is allowed within an aspect_specification, an operational item, or
     a representation item that occurs within the declaration of the
     composite type.

12/3
   * A name that denotes a noninherited discriminant is allowed within
     the declaration of the type, but not within the discriminant_part.
     If the discriminant is used to define the constraint of a
     component, the bounds of an entry family, or the constraint of the
     parent subtype in a derived_type_definition, then its name shall
     appear alone as a direct_name (not as part of a larger expression
     or expanded name).  A discriminant shall not be used to define the
     constraint of a scalar component.

13
If the name of the current instance of a type (see *note 8.6::) is used
to define the constraint of a component, then it shall appear as a
direct_name that is the prefix of an attribute_reference whose result is
of an access type, and the attribute_reference shall appear alone.

                          _Static Semantics_

13.1/3
If a record_type_definition includes the reserved word limited, the type
is called an explicitly limited record type.

14
The component_definition of a component_declaration defines the
(nominal) subtype of the component.  If the reserved word aliased
appears in the component_definition, then the component is aliased (see
*note 3.10::).

15
If the component_list of a record type is defined by the reserved word
null and there are no discriminants, then the record type has no
components and all records of the type are null records.  A
record_definition of null record is equivalent to record null; end
record.

                          _Dynamic Semantics_

16
The elaboration of a record_type_definition creates the record type and
its first subtype, and consists of the elaboration of the
record_definition. The elaboration of a record_definition consists of
the elaboration of its component_list, if any.

17
The elaboration of a component_list consists of the elaboration of the
component_items and variant_part, if any, in the order in which they
appear. The elaboration of a component_declaration consists of the
elaboration of the component_definition.

18/2
Within the definition of a composite type, if a component_definition or
discrete_subtype_definition (see *note 9.5.2::) includes a name that
denotes a discriminant of the type, or that is an attribute_reference
whose prefix denotes the current instance of the type, the expression
containing the name is called a per-object expression, and the
constraint or range being defined is called a per-object constraint. For
the elaboration of a component_definition of a component_declaration or
the discrete_subtype_definition (*note 3.6: S0055.) of an
entry_declaration (*note 9.5.2: S0218.) for an entry family (see *note
9.5.2::), if the component subtype is defined by an access_definition or
if the constraint or range of the subtype_indication or
discrete_subtype_definition (*note 3.6: S0055.) is not a per-object
constraint, then the access_definition, subtype_indication, or
discrete_subtype_definition (*note 3.6: S0055.) is elaborated.  On the
other hand, if the constraint or range is a per-object constraint, then
the elaboration consists of the evaluation of any included expression
that is not part of a per-object expression.  Each such expression is
evaluated once unless it is part of a named association in a
discriminant constraint, in which case it is evaluated once for each
associated discriminant.

18.1/1
When a per-object constraint is elaborated (as part of creating an
object), each per-object expression of the constraint is evaluated.  For
other expressions, the values determined during the elaboration of the
component_definition (*note 3.6: S0056.) or entry_declaration (*note
9.5.2: S0218.) are used.  Any checks associated with the enclosing
subtype_indication or discrete_subtype_definition are performed,
including the subtype compatibility check (see *note 3.2.2::), and the
associated subtype is created.

     NOTES

19
     63  A component_declaration with several identifiers is equivalent
     to a sequence of single component_declarations, as explained in
     *note 3.3.1::.

20
     64  The default_expression of a record component is only evaluated
     upon the creation of a default-initialized object of the record
     type (presuming the object has the component, if it is in a
     variant_part -- see *note 3.3.1::).

21
     65  The subtype defined by a component_definition (see *note 3.6::)
     has to be a definite subtype.

22
     66  If a record type does not have a variant_part, then the same
     components are present in all values of the type.

23
     67  A record type is limited if it has the reserved word limited in
     its definition, or if any of its components are limited (see *note
     7.5::).

24
     68  The predefined operations of a record type include membership
     tests, qualification, and explicit conversion.  If the record type
     is nonlimited, they also include assignment and the predefined
     equality operators.

25/2
     69  A component of a record can be named with a selected_component.
     A value of a record can be specified with a record_aggregate.

                              _Examples_

26
Examples of record type declarations:

27
     type Date is
        record
           Day   : Integer range 1 .. 31;
           Month : Month_Name;
           Year  : Integer range 0 .. 4000;
        end record;

28
     type Complex is
        record
           Re : Real := 0.0;
           Im : Real := 0.0;
        end record;

29
Examples of record variables:

30
     Tomorrow, Yesterday : Date;
     A, B, C : Complex;

31
     -- both components of A, B, and C are implicitly initialized to zero 

* Menu:

* 3.8.1 ::    Variant Parts and Discrete Choices


File: arm2012.info,  Node: 3.8.1,  Up: 3.8

3.8.1 Variant Parts and Discrete Choices
----------------------------------------

1
A record type with a variant_part specifies alternative lists of
components.  Each variant defines the components for the value or values
of the discriminant covered by its discrete_choice_list.

                               _Syntax_

2
     variant_part ::=
        case discriminant_direct_name is
            variant
           {variant}
        end case;

3
     variant ::=
        when discrete_choice_list =>
           component_list

4
     discrete_choice_list ::= discrete_choice {| discrete_choice}

5/3
     discrete_choice ::= choice_expression | discrete_
     subtype_indication | range | others

                        _Name Resolution Rules_

6
The discriminant_direct_name shall resolve to denote a discriminant
(called the discriminant of the variant_part) specified in the
known_discriminant_part of the full_type_declaration that contains the
variant_part. The expected type for each discrete_choice in a variant is
the type of the discriminant of the variant_part.

                           _Legality Rules_

7
The discriminant of the variant_part shall be of a discrete type.

8/3
The choice_expressions, subtype_indications, and ranges given as
discrete_choices in a variant_part shall be static.  The discrete_choice
others shall appear alone in a discrete_choice_list, and such a
discrete_choice_list, if it appears, shall be the last one in the
enclosing construct.

9
A discrete_choice is defined to cover a value in the following cases:

10/3
   * A discrete_choice that is a choice_expression covers a value if the
     value equals the value of the choice_expression converted to the
     expected type.

10.1/4
   * A discrete_choice that is a subtype_indication covers all values
     (possibly none) that belong to the subtype and that satisfy the
     static predicates of the subtype (see *note 3.2.4::).

11/3
   * A discrete_choice that is a range covers all values (possibly none)
     that belong to the range.

12
   * The discrete_choice others covers all values of its expected type
     that are not covered by previous discrete_choice_lists of the same
     construct.

13
A discrete_choice_list covers a value if one of its discrete_choices
covers the value.

14
The possible values of the discriminant of a variant_part shall be
covered as follows:

15/4
   * If the discriminant is of a static constrained scalar subtype then,
     except within an instance of a generic unit, each non-others
     discrete_choice (*note 3.8.1: S0074.) shall cover only values in
     that subtype that satisfy its predicates, and each value of that
     subtype that satisfies its predicates shall be covered by some
     discrete_choice (*note 3.8.1: S0074.) (either explicitly or by
     others);

16/3
   * If the type of the discriminant is a descendant of a generic formal
     scalar type, then the variant_part shall have an others
     discrete_choice;

17
   * Otherwise, each value of the base range of the type of the
     discriminant shall be covered (either explicitly or by others).

18
Two distinct discrete_choices of a variant_part shall not cover the same
value.

                          _Static Semantics_

19
If the component_list of a variant is specified by null, the variant has
no components.

20
The discriminant of a variant_part is said to govern the variant_part
and its variants.  In addition, the discriminant of a derived type
governs a variant_part and its variants if it corresponds (see *note
3.7::) to the discriminant of the variant_part.

                          _Dynamic Semantics_

21
A record value contains the values of the components of a particular
variant only if the value of the discriminant governing the variant is
covered by the discrete_choice_list of the variant.  This rule applies
in turn to any further variant that is, itself, included in the
component_list of the given variant.

21.1/3
When an object of a discriminated type T is initialized by default,
Constraint_Error is raised if no discrete_choice_list of any variant of
a variant_part of T covers the value of the discriminant that governs
the variant_part.  When a variant_part appears in the component_list of
another variant V, this test is only applied if the value of the
discriminant governing V is covered by the discrete_choice_list of V.

22
The elaboration of a variant_part consists of the elaboration of the
component_list of each variant in the order in which they appear.

                              _Examples_

23
Example of record type with a variant part:

24
     type Device is (Printer, Disk, Drum);
     type State  is (Open, Closed);

25
     type Peripheral(Unit : Device := Disk) is
        record
           Status : State;
           case Unit is
              when Printer =>
                 Line_Count : Integer range 1 .. Page_Size;
              when others =>
                 Cylinder   : Cylinder_Index;
                 Track      : Track_Number;
              end case;
           end record;

26
Examples of record subtypes:

27
     subtype Drum_Unit is Peripheral(Drum);
     subtype Disk_Unit is Peripheral(Disk);

28
Examples of constrained record variables:

29
     Writer   : Peripheral(Unit  => Printer);
     Archive  : Disk_Unit;


File: arm2012.info,  Node: 3.9,  Next: 3.10,  Prev: 3.8,  Up: 3

3.9 Tagged Types and Type Extensions
====================================

1
Tagged types and type extensions support object-oriented programming,
based on inheritance with extension and run-time polymorphism via
dispatching operations. 

                          _Static Semantics_

2/2
A record type or private type that has the reserved word tagged in its
declaration is called a tagged type.  In addition, an interface type is
a tagged type, as is a task or protected type derived from an interface
(see *note 3.9.4::).  When deriving from a tagged type, as for any
derived type, additional primitive subprograms may be defined, and
inherited primitive subprograms may be overridden. The derived type is
called an extension of its ancestor types, or simply a type extension.

2.1/2
Every type extension is also a tagged type, and is a record extension or
a private extension of some other tagged type, or a noninterface
synchronized tagged type (see *note 3.9.4::).  A record extension is
defined by a derived_type_definition with a record_extension_part (see
*note 3.9.1::), which may include the definition of additional
components.  A private extension, which is a partial view of a record
extension or of a synchronized tagged type, can be declared in the
visible part of a package (see *note 7.3::) or in a generic formal part
(see *note 12.5.1::).

3
An object of a tagged type has an associated (run-time) tag that
identifies the specific tagged type used to create the object
originally.  The tag of an operand of a class-wide tagged type T'Class
controls which subprogram body is to be executed when a primitive
subprogram of type T is applied to the operand (see *note 3.9.2::);
using a tag to control which body to execute is called dispatching. 

4/2
The tag of a specific tagged type identifies the full_type_declaration
of the type, and for a type extension, is sufficient to uniquely
identify the type among all descendants of the same ancestor.  If a
declaration for a tagged type occurs within a
generic_package_declaration, then the corresponding type declarations in
distinct instances of the generic package are associated with distinct
tags.  For a tagged type that is local to a generic package body and
with all of its ancestors (if any) also local to the generic body, the
language does not specify whether repeated instantiations of the generic
body result in distinct tags.

5
The following language-defined library package exists:

6/2
     package Ada.Tags is
         pragma Preelaborate(Tags);
         type Tag is private;
         pragma Preelaborable_Initialization(Tag);

6.1/2
         No_Tag : constant Tag;

7/2
         function Expanded_Name(T : Tag) return String;
         function Wide_Expanded_Name(T : Tag) return Wide_String;
         function Wide_Wide_Expanded_Name(T : Tag) return Wide_Wide_String;
         function External_Tag(T : Tag) return String;
         function Internal_Tag(External : String) return Tag;

7.1/2
         function Descendant_Tag(External : String; Ancestor : Tag) return Tag;
         function Is_Descendant_At_Same_Level(Descendant, Ancestor : Tag)
             return Boolean;

7.2/2
         function Parent_Tag (T : Tag) return Tag;

7.3/2
         type Tag_Array is array (Positive range <>) of Tag;

7.4/2
         function Interface_Ancestor_Tags (T : Tag) return Tag_Array;

7.5/3
         function Is_Abstract (T : Tag) return Boolean;

8
         Tag_Error : exception;

9
     private
        ... -- not specified by the language
     end Ada.Tags;

9.1/2
No_Tag is the default initial value of type Tag.

10/2
The function Wide_Wide_Expanded_Name returns the full expanded name of
the first subtype of the specific type identified by the tag, in upper
case, starting with a root library unit.  The result is implementation
defined if the type is declared within an unnamed block_statement.

10.1/2
The function Expanded_Name (respectively, Wide_Expanded_Name) returns
the same sequence of graphic characters as that defined for
Wide_Wide_Expanded_Name, if all the graphic characters are defined in
Character (respectively, Wide_Character); otherwise, the sequence of
characters is implementation defined, but no shorter than that returned
by Wide_Wide_Expanded_Name for the same value of the argument.

11
The function External_Tag returns a string to be used in an external
representation for the given tag.  The call External_Tag(S'Tag) is
equivalent to the attribute_reference S'External_Tag (see *note 13.3::).

11.1/2
The string returned by the functions Expanded_Name, Wide_Expanded_Name,
Wide_Wide_Expanded_Name, and External_Tag has lower bound 1.

12/2
The function Internal_Tag returns a tag that corresponds to the given
external tag, or raises Tag_Error if the given string is not the
external tag for any specific type of the partition.  Tag_Error is also
raised if the specific type identified is a library-level type whose tag
has not yet been created (see *note 13.14::).

12.1/3
The function Descendant_Tag returns the (internal) tag for the type that
corresponds to the given external tag and is both a descendant of the
type identified by the Ancestor tag and has the same accessibility level
as the identified ancestor.  Tag_Error is raised if External is not the
external tag for such a type.  Tag_Error is also raised if the specific
type identified is a library-level type whose tag has not yet been
created, or if the given external tag identifies more than one type that
has the appropriate Ancestor and accessibility level.

12.2/2
The function Is_Descendant_At_Same_Level returns True if the Descendant
tag identifies a type that is both a descendant of the type identified
by Ancestor and at the same accessibility level.  If not, it returns
False.

12.3/3
For the purposes of the dynamic semantics of functions Descendant_Tag
and Is_Descendant_At_Same_Level, a tagged type T2 is a descendant of a
type T1 if it is the same as T1, or if its parent type or one of its
progenitor types is a descendant of type T1 by this rule, even if at the
point of the declaration of T2, one of the derivations in the chain is
not visible.

12.4/4
The function Parent_Tag returns the tag of the parent type of the type
whose tag is T. If the type does not have a parent type (that is, it was
not defined by a derived_type_definition), then No_Tag is returned.

12.5/3
The function Interface_Ancestor_Tags returns an array containing the tag
of each interface ancestor type of the type whose tag is T, other than T
itself.  The lower bound of the returned array is 1, and the order of
the returned tags is unspecified.  Each tag appears in the result
exactly once.  If the type whose tag is T has no interface ancestors, a
null array is returned.

12.6/3
The function Is_Abstract returns True if the type whose tag is T is
abstract, and False otherwise.

13
For every subtype S of a tagged type T (specific or class-wide), the
following attributes are defined:

14
S'Class
               S'Class denotes a subtype of the class-wide type (called
               T'Class in this International Standard) for the class
               rooted at T (or if S already denotes a class-wide
               subtype, then S'Class is the same as S).

15
               S'Class is unconstrained.  However, if S is constrained,
               then the values of S'Class are only those that when
               converted to the type T belong to S.

16
S'Tag
               S'Tag denotes the tag of the type T (or if T is
               class-wide, the tag of the root type of the corresponding
               class).  The value of this attribute is of type Tag.

17
Given a prefix X that is of a class-wide tagged type (after any implicit
dereference), the following attribute is defined:

18
X'Tag
               X'Tag denotes the tag of X. The value of this attribute
               is of type Tag.

18.1/2
The following language-defined generic function exists:

18.2/3
     generic
         type T (<>) is abstract tagged limited private;
         type Parameters (<>) is limited private;
         with function Constructor (Params : not null access Parameters)
             return T is abstract;
     function Ada.Tags.Generic_Dispatching_Constructor
        (The_Tag : Tag;
         Params  : not null access Parameters) return T'Class
        with Convention => Intrinsic;
     pragma Preelaborate(Generic_Dispatching_Constructor);

18.3/2
Tags.Generic_Dispatching_Constructor provides a mechanism to create an
object of an appropriate type from just a tag value.  The function
Constructor is expected to create the object given a reference to an
object of type Parameters.

                          _Dynamic Semantics_

19
The tag associated with an object of a tagged type is determined as
follows:

20
   * The tag of a stand-alone object, a component, or an aggregate of a
     specific tagged type T identifies T.

21
   * The tag of an object created by an allocator for an access type
     with a specific designated tagged type T, identifies T.

22
   * The tag of an object of a class-wide tagged type is that of its
     initialization expression.

23
   * The tag of the result returned by a function whose result type is a
     specific tagged type T identifies T.

24/2
   * The tag of the result returned by a function with a class-wide
     result type is that of the return object.

25
The tag is preserved by type conversion and by parameter passing.  The
tag of a value is the tag of the associated object (see *note 6.2::).

25.1/3
Tag_Error is raised by a call of Descendant_Tag, Expanded_Name,
External_Tag, Interface_Ancestor_Tags, Is_Abstract,
Is_Descendant_At_Same_Level, Parent_Tag, Wide_Expanded_Name, or
Wide_Wide_Expanded_Name if any tag passed is No_Tag.

25.2/2
An instance of Tags.Generic_Dispatching_Constructor raises Tag_Error if
The_Tag does not represent a concrete descendant of T or if the
innermost master (see *note 7.6.1::) of this descendant is not also a
master of the instance.  Otherwise, it dispatches to the primitive
function denoted by the formal Constructor for the type identified by
The_Tag, passing Params, and returns the result.  Any exception raised
by the function is propagated.

                         _Erroneous Execution_

25.3/2
If an internal tag provided to an instance of
Tags.Generic_Dispatching_Constructor or to any subprogram declared in
package Tags identifies either a type that is not library-level and
whose tag has not been created (see *note 13.14::), or a type that does
not exist in the partition at the time of the call, then execution is
erroneous.

                     _Implementation Permissions_

26/2
The implementation of Internal_Tag and Descendant_Tag may raise
Tag_Error if no specific type corresponding to the string External
passed as a parameter exists in the partition at the time the function
is called, or if there is no such type whose innermost master is a
master of the point of the function call.

                        _Implementation Advice_

26.1/3
Internal_Tag should return the tag of a type, if one exists, whose
innermost master is a master of the point of the function call.

     NOTES

27
     70  A type declared with the reserved word tagged should normally
     be declared in a package_specification, so that new primitive
     subprograms can be declared for it.

28
     71  Once an object has been created, its tag never changes.

29
     72  Class-wide types are defined to have unknown discriminants (see
     *note 3.7::).  This means that objects of a class-wide type have to
     be explicitly initialized (whether created by an object_declaration
     or an allocator), and that aggregates have to be explicitly
     qualified with a specific type when their expected type is
     class-wide.

30/2
     73  The capability provided by Tags.Generic_Dispatching_Constructor
     is sometimes known as a factory.

                              _Examples_

31
Examples of tagged record types:

32
     type Point is tagged
       record
         X, Y : Real := 0.0;
       end record;

33
     type Expression is tagged null record;
       -- Components will be added by each extension

* Menu:

* 3.9.1 ::    Type Extensions
* 3.9.2 ::    Dispatching Operations of Tagged Types
* 3.9.3 ::    Abstract Types and Subprograms
* 3.9.4 ::    Interface Types


File: arm2012.info,  Node: 3.9.1,  Next: 3.9.2,  Up: 3.9

3.9.1 Type Extensions
---------------------

1/2
Every type extension is a tagged type, and is a record extension or a
private extension of some other tagged type, or a noninterface
synchronized tagged type.

                               _Syntax_

2
     record_extension_part ::= with record_definition

                           _Legality Rules_

3/2
The parent type of a record extension shall not be a class-wide type nor
shall it be a synchronized tagged type (see *note 3.9.4::).  If the
parent type or any progenitor is nonlimited, then each of the components
of the record_extension_part shall be nonlimited. In addition to the
places where Legality Rules normally apply (see *note 12.3::), these
rules apply also in the private part of an instance of a generic unit.

4/2
Within the body of a generic unit, or the body of any of its descendant
library units, a tagged type shall not be declared as a descendant of a
formal type declared within the formal part of the generic unit.

                          _Static Semantics_

4.1/2
A record extension is a null extension if its declaration has no
known_discriminant_part and its record_extension_part includes no
component_declarations.

                          _Dynamic Semantics_

5
The elaboration of a record_extension_part consists of the elaboration
of the record_definition.

     NOTES

6
     74  The term "type extension" refers to a type as a whole.  The
     term "extension part" refers to the piece of text that defines the
     additional components (if any) the type extension has relative to
     its specified ancestor type.

7/2
     75  When an extension is declared immediately within a body,
     primitive subprograms are inherited and are overridable, but new
     primitive subprograms cannot be added.

8
     76  A name that denotes a component (including a discriminant) of
     the parent type is not allowed within the record_extension_part.
     Similarly, a name that denotes a component defined within the
     record_extension_part is not allowed within the
     record_extension_part.  It is permissible to use a name that
     denotes a discriminant of the record extension, providing there is
     a new known_discriminant_part in the enclosing type declaration.
     (The full rule is given in *note 3.8::.)

9
     77  Each visible component of a record extension has to have a
     unique name, whether the component is (visibly) inherited from the
     parent type or declared in the record_extension_part (see *note
     8.3::).

                              _Examples_

10
Examples of record extensions (of types defined above in *note 3.9::):

11
     type Painted_Point is new Point with
       record
         Paint : Color := White;
       end record;
         -- Components X and Y are inherited

12
     Origin : constant Painted_Point := (X | Y => 0.0, Paint => Black);

13
     type Literal is new Expression with
       record                 -- a leaf in an Expression tree
         Value : Real;
       end record;

14
     type Expr_Ptr is access all Expression'Class;
                                    -- see *note 3.10::

15
     type Binary_Operation is new Expression with
       record                 -- an internal node in an Expression tree
         Left, Right : Expr_Ptr;
       end record;

16
     type Addition is new Binary_Operation with null record;
     type Subtraction is new Binary_Operation with null record;
       -- No additional components needed for these extensions

17
     Tree : Expr_Ptr :=         -- A tree representation of "5.0 + (13.0-7.0)"
        new Addition'(
           Left  => new Literal'(Value => 5.0),
           Right => new Subtraction'(
              Left  => new Literal'(Value => 13.0),
              Right => new Literal'(Value => 7.0)));


File: arm2012.info,  Node: 3.9.2,  Next: 3.9.3,  Prev: 3.9.1,  Up: 3.9

3.9.2 Dispatching Operations of Tagged Types
--------------------------------------------

1/2
The primitive subprograms of a tagged type, the subprograms declared by
formal_abstract_subprogram_declaration (*note 12.6: S0298.)s, and the
stream attributes of a specific tagged type that are available (see
*note 13.13.2::) at the end of the declaration list where the type is
declared are called dispatching operations.  A dispatching operation can
be called using a statically determined controlling tag, in which case
the body to be executed is determined at compile time.  Alternatively,
the controlling tag can be dynamically determined, in which case the
call dispatches to a body that is determined at run time; such a call is
termed a dispatching call.  As explained below, the properties of the
operands and the context of a particular call on a dispatching operation
determine how the controlling tag is determined, and hence whether or
not the call is a dispatching call.  Run-time polymorphism is achieved
when a dispatching operation is called by a dispatching call. 

                          _Static Semantics_

2/3
A call on a dispatching operation is a call whose name or prefix denotes
the declaration of a dispatching operation. A controlling operand in a
call on a dispatching operation of a tagged type T is one whose
corresponding formal parameter is of type T or is of an anonymous access
type with designated type T; the corresponding formal parameter is
called a controlling formal parameter.  If the controlling formal
parameter is an access parameter, the controlling operand is the object
designated by the actual parameter, rather than the actual parameter
itself. If the call is to a (primitive) function with result type T (a
function with a controlling result), then the call has a controlling
result -- the context of the call can control the dispatching.
Similarly, if the call is to a function with an access result type
designating T (a function with a controlling access result), then the
call has a controlling access result, and the context can similarly
control dispatching.

3
A name or expression of a tagged type is either statically tagged,
dynamically tagged, or tag indeterminate, according to whether, when
used as a controlling operand, the tag that controls dispatching is
determined statically by the operand's (specific) type, dynamically by
its tag at run time, or from context.  A qualified_expression or
parenthesized expression is statically, dynamically, or indeterminately
tagged according to its operand.  For other kinds of names and
expressions, this is determined as follows:

4/2
   * The name or expression is statically tagged if it is of a specific
     tagged type and, if it is a call with a controlling result or
     controlling access result, it has at least one statically tagged
     controlling operand;

5/2
   * The name or expression is dynamically tagged if it is of a
     class-wide type, or it is a call with a controlling result or
     controlling access result and at least one dynamically tagged
     controlling operand;

6/2
   * The name or expression is tag indeterminate if it is a call with a
     controlling result or controlling access result, all of whose
     controlling operands (if any) are tag indeterminate.

7/1
A type_conversion is statically or dynamically tagged according to
whether the type determined by the subtype_mark is specific or
class-wide, respectively.  For an object that is designated by an
expression whose expected type is an anonymous access-to-specific tagged
type, the object is dynamically tagged if the expression, ignoring
enclosing parentheses, is of the form X'Access, where X is of a
class-wide type, or is of the form new T'(...), where T denotes a
class-wide subtype.  Otherwise, the object is statically or dynamically
tagged according to whether the designated type of the type of the
expression is specific or class-wide, respectively.

                           _Legality Rules_

8
A call on a dispatching operation shall not have both dynamically tagged
and statically tagged controlling operands.

9/1
If the expected type for an expression or name is some specific tagged
type, then the expression or name shall not be dynamically tagged unless
it is a controlling operand in a call on a dispatching operation.
Similarly, if the expected type for an expression is an anonymous
access-to-specific tagged type, then the object designated by the
expression shall not be dynamically tagged unless it is a controlling
operand in a call on a dispatching operation.

10/2
In the declaration of a dispatching operation of a tagged type,
everywhere a subtype of the tagged type appears as a subtype of the
profile (see *note 6.1::), it shall statically match the first subtype
of the tagged type. If the dispatching operation overrides an inherited
subprogram, it shall be subtype conformant with the inherited
subprogram. The convention of an inherited dispatching operation is the
convention of the corresponding primitive operation of the parent or
progenitor type.  The default convention of a dispatching operation that
overrides an inherited primitive operation is the convention of the
inherited operation; if the operation overrides multiple inherited
operations, then they shall all have the same convention.  An explicitly
declared dispatching operation shall not be of convention Intrinsic.

11/2
The default_expression for a controlling formal parameter of a
dispatching operation shall be tag indeterminate.

11.1/2
If a dispatching operation is defined by a
subprogram_renaming_declaration or the instantiation of a generic
subprogram, any access parameter of the renamed subprogram or the
generic subprogram that corresponds to a controlling access parameter of
the dispatching operation, shall have a subtype that excludes null.

12
A given subprogram shall not be a dispatching operation of two or more
distinct tagged types.

13
The explicit declaration of a primitive subprogram of a tagged type
shall occur before the type is frozen (see *note 13.14::).  For example,
new dispatching operations cannot be added after objects or values of
the type exist, nor after deriving a record extension from it, nor after
a body.

                          _Dynamic Semantics_

14
For the execution of a call on a dispatching operation of a type T, the
controlling tag value determines which subprogram body is executed.  The
controlling tag value is defined as follows:

15
   * If one or more controlling operands are statically tagged, then the
     controlling tag value is statically determined to be the tag of T.

16
   * If one or more controlling operands are dynamically tagged, then
     the controlling tag value is not statically determined, but is
     rather determined by the tags of the controlling operands. If there
     is more than one dynamically tagged controlling operand, a check is
     made that they all have the same tag. If this check fails,
     Constraint_Error is raised unless the call is a function_call whose
     name denotes the declaration of an equality operator (predefined or
     user defined) that returns Boolean, in which case the result of the
     call is defined to indicate inequality, and no subprogram_body is
     executed.  This check is performed prior to evaluating any
     tag-indeterminate controlling operands.

17/2
   * If all of the controlling operands (if any) are tag-indeterminate,
     then:

18/2
             * If the call has a controlling result or controlling
               access result and is itself, or designates, a (possibly
               parenthesized or qualified) controlling operand of an
               enclosing call on a dispatching operation of a descendant
               of type T, then its controlling tag value is determined
               by the controlling tag value of this enclosing call;

18.1/2
             * If the call has a controlling result or controlling
               access result and (possibly parenthesized, qualified, or
               dereferenced) is the expression of an
               assignment_statement whose target is of a class-wide
               type, then its controlling tag value is determined by the
               target;

19
             * Otherwise, the controlling tag value is statically
               determined to be the tag of type T.

20/3
For the execution of a call on a dispatching operation, the action
performed is determined by the properties of the corresponding
dispatching operation of the specific type identified by the controlling
tag value:

20.1/3
   * if the corresponding operation is explicitly declared for this
     type, even if the declaration occurs in a private part, then the
     action comprises an invocation of the explicit body for the
     operation;

20.2/3
   * if the corresponding operation is implicitly declared for this type
     and is implemented by an entry or protected subprogram (see *note
     9.1:: and *note 9.4::), then the action comprises a call on this
     entry or protected subprogram, with the target object being given
     by the first actual parameter of the call, and the actual
     parameters of the entry or protected subprogram being given by the
     remaining actual parameters of the call, if any;

20.3/3
   * if the corresponding operation is a predefined operator then the
     action comprises an invocation of that operator;

20.4/3
   * otherwise, the action is the same as the action for the
     corresponding operation of the parent type or progenitor type from
     which the operation was inherited except that additional invariant
     checks (see *note 7.3.2::) and class-wide postcondition checks (see
     *note 6.1.1::) may apply.  If there is more than one such
     corresponding operation, the action is that for the operation that
     is not a null procedure, if any; otherwise, the action is that of
     an arbitrary one of the operations.

     NOTES

21
     78  The body to be executed for a call on a dispatching operation
     is determined by the tag; it does not matter whether that tag is
     determined statically or dynamically, and it does not matter
     whether the subprogram's declaration is visible at the place of the
     call.

22/2
     79  This subclause covers calls on dispatching subprograms of a
     tagged type.  Rules for tagged type membership tests are described
     in *note 4.5.2::.  Controlling tag determination for an
     assignment_statement is described in *note 5.2::.

23
     80  A dispatching call can dispatch to a body whose declaration is
     not visible at the place of the call.

24
     81  A call through an access-to-subprogram value is never a
     dispatching call, even if the access value designates a dispatching
     operation.  Similarly a call whose prefix denotes a
     subprogram_renaming_declaration cannot be a dispatching call unless
     the renaming itself is the declaration of a primitive subprogram.


File: arm2012.info,  Node: 3.9.3,  Next: 3.9.4,  Prev: 3.9.2,  Up: 3.9

3.9.3 Abstract Types and Subprograms
------------------------------------

1/2
An abstract type is a tagged type intended for use as an ancestor of
other types, but which is not allowed to have objects of its own. An
abstract subprogram is a subprogram that has no body, but is intended to
be overridden at some point when inherited.  Because objects of an
abstract type cannot be created, a dispatching call to an abstract
subprogram always dispatches to some overriding body.

                               _Syntax_

1.1/3
     abstract_subprogram_declaration ::=
         [overriding_indicator]
         subprogram_specification is abstract
             [aspect_specification];

                          _Static Semantics_

1.2/2
Interface types (see *note 3.9.4::) are abstract types.  In addition, a
tagged type that has the reserved word abstract in its declaration is an
abstract type.  The class-wide type (see *note 3.4.1::) rooted at an
abstract type is not itself an abstract type.

                           _Legality Rules_

2/2
Only a tagged type shall have the reserved word abstract in its
declaration.

3/2
A subprogram declared by an abstract_subprogram_declaration (*note
3.9.3: S0076.) or a formal_abstract_subprogram_declaration (*note 12.6:
S0298.) (see *note 12.6::) is an abstract subprogram.  If it is a
primitive subprogram of a tagged type, then the tagged type shall be
abstract.

4/3
If a type has an implicitly declared primitive subprogram that is
inherited or is a predefined operator, and the corresponding primitive
subprogram of the parent or ancestor type is abstract or is a function
with a controlling access result, or if a type other than a nonabstract
null extension inherits a function with a controlling result, then:

5/2
   * If the type is abstract or untagged, the implicitly declared
     subprogram is abstract.

6/4
   * Otherwise, the subprogram shall be overridden with a nonabstract
     subprogram or, in the case of a private extension inheriting a
     nonabstract function with a controlling result, have a full type
     that is a null extension; for a type declared in the visible part
     of a package, the overriding may be either in the visible or the
     private part.  Such a subprogram is said to require overriding.
     However, if the type is a generic formal type, the subprogram need
     not be overridden for the formal type itself; a nonabstract version
     will necessarily be provided by the actual type.

7
A call on an abstract subprogram shall be a dispatching call;
nondispatching calls to an abstract subprogram are not allowed.

8/3
The type of an aggregate, or of an object created by an
object_declaration or an allocator, or a generic formal object of mode
in, shall not be abstract.  The type of the target of an assignment
operation (see *note 5.2::) shall not be abstract.  The type of a
component shall not be abstract.  If the result type of a function is
abstract, then the function shall be abstract.  If a function has an
access result type designating an abstract type, then the function shall
be abstract.  The type denoted by a return_subtype_indication (see *note
6.5::) shall not be abstract.  A generic function shall not have an
abstract result type or an access result type designating an abstract
type.

9
If a partial view is not abstract, the corresponding full view shall not
be abstract.  If a generic formal type is abstract, then for each
primitive subprogram of the formal that is not abstract, the
corresponding primitive subprogram of the actual shall not be abstract.

10/3
For an abstract type declared in a visible part, an abstract primitive
subprogram shall not be declared in the private part, unless it is
overriding an abstract subprogram implicitly declared in the visible
part.  For a tagged type declared in a visible part, a primitive
function with a controlling result or a controlling access result shall
not be declared in the private part, unless it is overriding a function
implicitly declared in the visible part.

11/2
A generic actual subprogram shall not be an abstract subprogram unless
the generic formal subprogram is declared by a
formal_abstract_subprogram_declaration.  The prefix of an
attribute_reference for the Access, Unchecked_Access, or Address
attributes shall not denote an abstract subprogram.

                          _Dynamic Semantics_

11.1/2
The elaboration of an abstract_subprogram_declaration has no effect.

     NOTES

12
     82  Abstractness is not inherited; to declare an abstract type, the
     reserved word abstract has to be used in the declaration of the
     type extension.

13
     83  A class-wide type is never abstract.  Even if a class is rooted
     at an abstract type, the class-wide type for the class is not
     abstract, and an object of the class-wide type can be created; the
     tag of such an object will identify some nonabstract type in the
     class.

                              _Examples_

14
Example of an abstract type representing a set of natural numbers:

15
     package Sets is
         subtype Element_Type is Natural;
         type Set is abstract tagged null record;
         function Empty return Set is abstract;
         function Union(Left, Right : Set) return Set is abstract;
         function Intersection(Left, Right : Set) return Set is abstract;
         function Unit_Set(Element : Element_Type) return Set is abstract;
         procedure Take(Element : out Element_Type;
                        From : in out Set) is abstract;
     end Sets;

     NOTES

16
     84  Notes on the example: Given the above abstract type, one could
     then derive various (nonabstract) extensions of the type,
     representing alternative implementations of a set.  One might use a
     bit vector, but impose an upper bound on the largest element
     representable, while another might use a hash table, trading off
     space for flexibility.


File: arm2012.info,  Node: 3.9.4,  Prev: 3.9.3,  Up: 3.9

3.9.4 Interface Types
---------------------

1/2
An interface type is an abstract tagged type that provides a restricted
form of multiple inheritance.  A tagged type, task type, or protected
type may have one or more interface types as ancestors.

                               _Syntax_

2/2
     interface_type_definition ::=
         [limited | task | protected | synchronized] interface [and 
     interface_list]

3/2
     interface_list ::= interface_subtype_mark {and interface_
     subtype_mark}

                          _Static Semantics_

4/2
An interface type (also called an interface) is a specific abstract
tagged type that is defined by an interface_type_definition.

5/2
An interface with the reserved word limited, task, protected, or
synchronized in its definition is termed, respectively, a limited
interface, a task interface, a protected interface, or a synchronized
interface.  In addition, all task and protected interfaces are
synchronized interfaces, and all synchronized interfaces are limited
interfaces.

6/2
A task or protected type derived from an interface is a tagged type.
Such a tagged type is called a synchronized tagged type, as are
synchronized interfaces and private extensions whose declaration
includes the reserved word synchronized.

7/2
A task interface is an abstract task type.  A protected interface is an
abstract protected type.

8/2
An interface type has no components.

9/2
An interface_subtype_mark in an interface_list names a progenitor
subtype; its type is the progenitor type.  An interface type inherits
user-defined primitive subprograms from each progenitor type in the same
way that a derived type inherits user-defined primitive subprograms from
its progenitor types (see *note 3.4::).

                           _Legality Rules_

10/2
All user-defined primitive subprograms of an interface type shall be
abstract subprograms or null procedures.

11/2
The type of a subtype named in an interface_list shall be an interface
type.

12/2
A type derived from a nonlimited interface shall be nonlimited.

13/2
An interface derived from a task interface shall include the reserved
word task in its definition; any other type derived from a task
interface shall be a private extension or a task type declared by a task
declaration (see *note 9.1::).

14/2
An interface derived from a protected interface shall include the
reserved word protected in its definition; any other type derived from a
protected interface shall be a private extension or a protected type
declared by a protected declaration (see *note 9.4::).

15/2
An interface derived from a synchronized interface shall include one of
the reserved words task, protected, or synchronized in its definition;
any other type derived from a synchronized interface shall be a private
extension, a task type declared by a task declaration, or a protected
type declared by a protected declaration.

16/2
No type shall be derived from both a task interface and a protected
interface.

17/2
In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules apply also in the private part of an instance of a
generic unit.

                          _Dynamic Semantics_

18/3
The elaboration of an interface_type_definition creates the interface
type and its first subtype.

     NOTES

19/2
     85  Nonlimited interface types have predefined nonabstract equality
     operators.  These may be overridden with user-defined abstract
     equality operators.  Such operators will then require an explicit
     overriding for any nonabstract descendant of the interface.

                              _Examples_

20/2
Example of a limited interface and a synchronized interface extending
it:

21/2
     type Queue is limited interface;
     procedure Append(Q : in out Queue; Person : in Person_Name) is abstract;
     procedure Remove_First(Q      : in out Queue;
                            Person : out Person_Name) is abstract;
     function Cur_Count(Q : in Queue) return Natural is abstract;
     function Max_Count(Q : in Queue) return Natural is abstract;
     -- See *note 3.10.1:: for Person_Name.

22/3
     Queue_Error : exception;
     -- Append raises Queue_Error if Cur_Count(Q) = Max_Count(Q)
     -- Remove_First raises Queue_Error if Cur_Count(Q) = 0

23/2
     type Synchronized_Queue is synchronized interface and Queue; -- see *note 9.11::
     procedure Append_Wait(Q      : in out Synchronized_Queue;
                           Person : in Person_Name) is abstract;
     procedure Remove_First_Wait(Q      : in out Synchronized_Queue;
                                 Person : out Person_Name) is abstract;

24/2
     ...

25/2
     procedure Transfer(From   : in out Queue'Class;
                        To     : in out Queue'Class;
                        Number : in     Natural := 1) is
        Person : Person_Name;
     begin
        for I in 1..Number loop
           Remove_First(From, Person);
           Append(To, Person);
        end loop;
     end Transfer;

26/2
This defines a Queue interface defining a queue of people.  (A similar
design could be created to define any kind of queue simply by replacing
Person_Name by an appropriate type.)  The Queue interface has four
dispatching operations, Append, Remove_First, Cur_Count, and Max_Count.
The body of a class-wide operation, Transfer is also shown.  Every
nonabstract extension of Queue must provide implementations for at least
its four dispatching operations, as they are abstract.  Any object of a
type derived from Queue may be passed to Transfer as either the From or
the To operand.  The two operands need not be of the same type in any
given call.

27/2
The Synchronized_Queue interface inherits the four dispatching
operations from Queue and adds two additional dispatching operations,
which wait if necessary rather than raising the Queue_Error exception.
This synchronized interface may only be implemented by a task or
protected type, and as such ensures safe concurrent access.

28/2
Example use of the interface:

29/3
     type Fast_Food_Queue is new Queue with record ...;
     procedure Append(Q : in out Fast_Food_Queue; Person : in Person_Name);
     procedure Remove_First(Q : in out Fast_Food_Queue; Person : out Person_Name);
     function Cur_Count(Q : in Fast_Food_Queue) return Natural;
     function Max_Count(Q : in Fast_Food_Queue) return Natural;

30/2
     ...

31/2
     Cashier, Counter : Fast_Food_Queue;

32/2
     ...
     -- Add George (see *note 3.10.1::) to the cashier's queue:
     Append (Cashier, George);
     -- After payment, move George to the sandwich counter queue:
     Transfer (Cashier, Counter);
     ...

33/2
An interface such as Queue can be used directly as the parent of a new
type (as shown here), or can be used as a progenitor when a type is
derived.  In either case, the primitive operations of the interface are
inherited.  For Queue, the implementation of the four inherited routines
must be provided.  Inside the call of Transfer, calls will dispatch to
the implementations of Append and Remove_First for type Fast_Food_Queue.

34/2
Example of a task interface:

35/2
     type Serial_Device is task interface;  -- see *note 9.1::
     procedure Read (Dev : in Serial_Device; C : out Character) is abstract;
     procedure Write(Dev : in Serial_Device; C : in  Character) is abstract;

36/2
The Serial_Device interface has two dispatching operations which are
intended to be implemented by task entries (see 9.1).


File: arm2012.info,  Node: 3.10,  Next: 3.11,  Prev: 3.9,  Up: 3

3.10 Access Types
=================

1
A value of an access type (an access value) provides indirect access to
the object or subprogram it designates.  Depending on its type, an
access value can designate either subprograms, objects created by
allocators (see *note 4.8::), or more generally aliased objects of an
appropriate type. 

                               _Syntax_

2/2
     access_type_definition ::=
         [null_exclusion] access_to_object_definition
       | [null_exclusion] access_to_subprogram_definition

3
     access_to_object_definition ::=
         access [general_access_modifier] subtype_indication

4
     general_access_modifier ::= all | constant

5
     access_to_subprogram_definition ::=
         access [protected] procedure parameter_profile
       | access [protected] function  parameter_and_result_profile

5.1/2
     null_exclusion ::= not null

6/2
     access_definition ::=
         [null_exclusion] access [constant] subtype_mark
       | [null_exclusion] access [protected] procedure parameter_profile
       | [null_exclusion] access [protected] function 
     parameter_and_result_profile

                          _Static Semantics_

7/1
There are two kinds of access types, access-to-object types, whose
values designate objects, and access-to-subprogram types, whose values
designate subprograms. Associated with an access-to-object type is a
storage pool; several access types may share the same storage pool.  All
descendants of an access type share the same storage pool. A storage
pool is an area of storage used to hold dynamically allocated objects
(called pool elements) created by allocators; storage pools are
described further in *note 13.11::, "*note 13.11:: Storage Management".

8
Access-to-object types are further subdivided into pool-specific access
types, whose values can designate only the elements of their associated
storage pool, and general access types, whose values can designate the
elements of any storage pool, as well as aliased objects created by
declarations rather than allocators, and aliased subcomponents of other
objects.

9/3
A view of an object is defined to be aliased if it is defined by an
object_declaration (*note 3.3.1: S0032.), component_definition (*note
3.6: S0056.), parameter_specification (*note 6.1: S0175.), or
extended_return_object_declaration with the reserved word aliased, or by
a renaming of an aliased view.  In addition, the dereference of an
access-to-object value denotes an aliased view, as does a view
conversion (see *note 4.6::) of an aliased view.  The current instance
of an immutably limited type (see *note 7.5::) is defined to be aliased.
Finally, a formal parameter or generic formal object of a tagged type is
defined to be aliased.  Aliased views are the ones that can be
designated by an access value.

10
An access_to_object_definition defines an access-to-object type and its
first subtype; the subtype_indication (*note 3.2.2: S0027.) defines the
designated subtype of the access type.  If a general_access_modifier
(*note 3.10: S0081.) appears, then the access type is a general access
type. If the modifier is the reserved word constant, then the type is an
access-to-constant type; a designated object cannot be updated through a
value of such a type. If the modifier is the reserved word all, then the
type is an access-to-variable type; a designated object can be both read
and updated through a value of such a type.  If no
general_access_modifier (*note 3.10: S0081.) appears in the
access_to_object_definition (*note 3.10: S0080.), the access type is a
pool-specific access-to-variable type.

11
An access_to_subprogram_definition defines an access-to-subprogram type
and its first subtype; the parameter_profile or
parameter_and_result_profile defines the designated profile of the
access type. There is a calling convention associated with the
designated profile; only subprograms with this calling convention can be
designated by values of the access type.  By default, the calling
convention is "protected" if the reserved word protected appears, and
"Ada" otherwise.  See *note Annex B:: for how to override this default.

12/3
An access_definition defines an anonymous general access type or an
anonymous access-to-subprogram type.  For a general access type, the
subtype_mark denotes its designated subtype; if the
general_access_modifier (*note 3.10: S0081.) constant appears, the type
is an access-to-constant type; otherwise, it is an access-to-variable
type.  For an access-to-subprogram type, the parameter_profile (*note
6.1: S0172.) or parameter_and_result_profile (*note 6.1: S0173.) denotes
its designated profile.

13/2
For each access type, there is a null access value designating no entity
at all, which can be obtained by (implicitly) converting the literal
null to the access type.  The null value of an access type is the
default initial value of the type.  Nonnull values of an
access-to-object type are obtained by evaluating an allocator, which
returns an access value designating a newly created object (see *note
3.10.2::), or in the case of a general access-to-object type, evaluating
an attribute_reference for the Access or Unchecked_Access attribute of
an aliased view of an object.  Nonnull values of an access-to-subprogram
type are obtained by evaluating an attribute_reference for the Access
attribute of a nonintrinsic subprogram.

13.1/2
A null_exclusion in a construct specifies that the null value does not
belong to the access subtype defined by the construct, that is, the
access subtype excludes null.  In addition, the anonymous access subtype
defined by the access_definition for a controlling access parameter (see
*note 3.9.2::) excludes null.  Finally, for a subtype_indication without
a null_exclusion, the subtype denoted by the subtype_indication excludes
null if and only if the subtype denoted by the subtype_mark in the
subtype_indication excludes null.

14/3
All subtypes of an access-to-subprogram type are constrained.  The first
subtype of a type defined by an access_definition or an
access_to_object_definition is unconstrained if the designated subtype
is an unconstrained array or discriminated subtype; otherwise, it is
constrained.

                           _Legality Rules_

14.1/2
If a subtype_indication (*note 3.2.2: S0027.),
discriminant_specification (*note 3.7: S0062.), parameter_specification
(*note 6.1: S0175.), parameter_and_result_profile (*note 6.1: S0173.),
object_renaming_declaration (*note 8.5.1: S0200.), or
formal_object_declaration (*note 12.4: S0280.) has a null_exclusion
(*note 3.10: S0083.), the subtype_mark (*note 3.2.2: S0028.) in that
construct shall denote an access subtype that does not exclude null.

                          _Dynamic Semantics_

15/2
A composite_constraint is compatible with an unconstrained access
subtype if it is compatible with the designated subtype.  A
null_exclusion is compatible with any access subtype that does not
exclude null. An access value satisfies a composite_constraint of an
access subtype if it equals the null value of its type or if it
designates an object whose value satisfies the constraint.  An access
value satisfies an exclusion of the null value if it does not equal the
null value of its type.

16
The elaboration of an access_type_definition creates the access type and
its first subtype.  For an access-to-object type, this elaboration
includes the elaboration of the subtype_indication, which creates the
designated subtype.

17/2
The elaboration of an access_definition creates an anonymous access
type.

     NOTES

18
     86  Access values are called "pointers" or "references" in some
     other languages.

19
     87  Each access-to-object type has an associated storage pool;
     several access types can share the same pool.  An object can be
     created in the storage pool of an access type by an allocator (see
     *note 4.8::) for the access type.  A storage pool (roughly)
     corresponds to what some other languages call a "heap."  See *note
     13.11:: for a discussion of pools.

20
     88  Only index_constraints and discriminant_constraints can be
     applied to access types (see *note 3.6.1:: and *note 3.7.1::).

                              _Examples_

21
Examples of access-to-object types:

22/4
     type Frame is access Matrix;    --  see *note 3.6::
     type Peripheral_Ref is not null access Peripheral;  --  see *note 3.8.1::
     type Binop_Ptr is access all Binary_Operation'Class;
                                                -- general access-to-class-wide, see *note 3.9.1::

23
Example of an access subtype:

24
     subtype Drum_Ref is Peripheral_Ref(Drum);  --  see *note 3.8.1::

25
Example of an access-to-subprogram type:

26
     type Message_Procedure is access procedure (M : in String := "Error!");
     procedure Default_Message_Procedure(M : in String);
     Give_Message : Message_Procedure := Default_Message_Procedure'Access;
     ...
     procedure Other_Procedure(M : in String);
     ...
     Give_Message := Other_Procedure'Access;
     ...
     Give_Message("File not found.");  -- call with parameter (.all is optional)
     Give_Message.all;                 -- call with no parameters

* Menu:

* 3.10.1 ::   Incomplete Type Declarations
* 3.10.2 ::   Operations of Access Types


File: arm2012.info,  Node: 3.10.1,  Next: 3.10.2,  Up: 3.10

3.10.1 Incomplete Type Declarations
-----------------------------------

1
There are no particular limitations on the designated type of an access
type.  In particular, the type of a component of the designated type can
be another access type, or even the same access type.  This permits
mutually dependent and recursive access types.  An
incomplete_type_declaration can be used to introduce a type to be used
as a designated type, while deferring its full definition to a
subsequent full_type_declaration.

                               _Syntax_

2/2
     incomplete_type_declaration ::= type defining_identifier [
     discriminant_part] [is tagged];

                          _Static Semantics_

2.1/4
An incomplete_type_declaration declares an incomplete view of a type and
its first subtype; the first subtype is unconstrained if a
discriminant_part appears.  If the incomplete_type_declaration (*note
3.10.1: S0085.) includes the reserved word tagged, it declares a tagged
incomplete view.  If T denotes a tagged incomplete view, then T'Class
denotes a tagged incomplete view.  An incomplete view of a type is a
limited view of the type (see *note 7.5::).

2.2/2
Given an access type A whose designated type T is an incomplete view, a
dereference of a value of type A also has this incomplete view except
when:

2.3/2
   * it occurs within the immediate scope of the completion of T, or

2.4/3
   * it occurs within the scope of a nonlimited_with_clause that
     mentions a library package in whose visible part the completion of
     T is declared, or

2.5/3
   * it occurs within the scope of the completion of T and T is an
     incomplete view declared by an incomplete_type_declaration.

2.6/3
In these cases, the dereference has the view of T visible at the point
of the dereference.

2.7/3
Similarly, if a subtype_mark denotes a subtype_declaration defining a
subtype of an incomplete view T, the subtype_mark denotes an incomplete
view except under the same three circumstances given above, in which
case it denotes the view of T visible at the point of the subtype_mark.

                           _Legality Rules_

3/3
An incomplete_type_declaration (*note 3.10.1: S0085.) requires a
completion, which shall be a type_declaration (*note 3.2.1: S0023.)
other than an incomplete_type_declaration (*note 3.10.1: S0085.).  If
the incomplete_type_declaration (*note 3.10.1: S0085.) occurs
immediately within either the visible part of a package_specification
(*note 7.1: S0191.) or a declarative_part (*note 3.11: S0086.), then the
type_declaration (*note 3.2.1: S0023.) shall occur later and immediately
within this visible part or declarative_part (*note 3.11: S0086.).  If
the incomplete_type_declaration (*note 3.10.1: S0085.) occurs
immediately within the private part of a given package_specification
(*note 7.1: S0191.), then the type_declaration (*note 3.2.1: S0023.)
shall occur later and immediately within either the private part itself,
or the declarative_part (*note 3.11: S0086.) of the corresponding
package_body (*note 7.2: S0192.).

4/3
If an incomplete_type_declaration (*note 3.10.1: S0085.) includes the
reserved word tagged, then a type_declaration (*note 3.2.1: S0023.) that
completes it shall declare a tagged type.  If an
incomplete_type_declaration (*note 3.10.1: S0085.) has a
known_discriminant_part (*note 3.7: S0061.), then a type_declaration
(*note 3.2.1: S0023.) that completes it shall have a fully conforming
(explicit) known_discriminant_part (*note 3.7: S0061.) (see *note
6.3.1::). If an incomplete_type_declaration (*note 3.10.1: S0085.) has
no discriminant_part (or an unknown_discriminant_part (*note 3.7:
S0060.)), then a corresponding type_declaration (*note 3.2.1: S0023.) is
nevertheless allowed to have discriminants, either explicitly, or
inherited via derivation.

5/2
A name that denotes an incomplete view of a type may be used as follows:

6/3
   * as the subtype_mark in the subtype_indication of an
     access_to_object_definition (*note 3.10: S0080.); the only form of
     constraint allowed in this subtype_indication is a
     discriminant_constraint (a null_exclusion is not allowed);

7/2
   * as the subtype_mark in the subtype_indication of a
     subtype_declaration; the subtype_indication (*note 3.2.2: S0027.)
     shall not have a null_exclusion (*note 3.10: S0083.) or a
     constraint;

8/3
   * as the subtype_mark in an access_definition for an access-to-object
     type;

8.1/3
   * as the subtype_mark defining the subtype of a parameter or result
     in a profile occurring within a basic_declaration;

8.2/3
   * as a generic actual parameter whose corresponding generic formal
     parameter is a formal incomplete type (see *note 12.5.1::).

8.3/2
If such a name denotes a tagged incomplete view, it may also be used:

8.4/3
   * as the subtype_mark defining the subtype of a parameter in the
     profile for a subprogram_body, entry_body, or accept_statement;

9/2
   * as the prefix of an attribute_reference whose attribute_designator
     (*note 4.1.4: S0101.) is Class; such an attribute_reference (*note
     4.1.4: S0100.) is restricted to the uses allowed here; it denotes a
     tagged incomplete view.

9.1/3
This paragraph was deleted.

9.2/3
   * This paragraph was deleted.

9.3/2
If any of the above uses occurs as part of the declaration of a
primitive subprogram of the incomplete view, and the declaration occurs
immediately within the private part of a package, then the completion of
the incomplete view shall also occur immediately within the private
part; it shall not be deferred to the package body.

9.4/2
No other uses of a name that denotes an incomplete view of a type are
allowed.

10/3
A prefix that denotes an object shall not be of an incomplete view.  An
actual parameter in a call shall not be of an untagged incomplete view.
The result object of a function call shall not be of an incomplete view.
A prefix shall not denote a subprogram having a formal parameter of an
untagged incomplete view, nor a return type that is an incomplete view.

Paragraph 11 was deleted.

                          _Dynamic Semantics_

12
The elaboration of an incomplete_type_declaration has no effect.

     NOTES

13
     89  Within a declarative_part, an incomplete_type_declaration and a
     corresponding full_type_declaration cannot be separated by an
     intervening body.  This is because a type has to be completely
     defined before it is frozen, and a body freezes all types declared
     prior to it in the same declarative_part (see *note 13.14::).

13.1/3
     90  A name that denotes an object of an incomplete view is defined
     to be of a limited type.  Hence, the target of an assignment
     statement cannot be of an incomplete view.

                              _Examples_

14
Example of a recursive type:

15
     type Cell;  --  incomplete type declaration
     type Link is access Cell;

16
     type Cell is
        record
           Value  : Integer;
           Succ   : Link;
           Pred   : Link;
        end record;

17
     Head   : Link  := new Cell'(0, null, null);
     Next   : Link  := Head.Succ;

18
Examples of mutually dependent access types:

19/2
     type Person(<>);    -- incomplete type declaration
     type Car is tagged; -- incomplete type declaration

20/2
     type Person_Name is access Person;
     type Car_Name    is access all Car'Class;

21/2
     type Car is tagged
        record
           Number  : Integer;
           Owner   : Person_Name;
        end record;

22
     type Person(Sex : Gender) is
        record
           Name     : String(1 .. 20);
           Birth    : Date;
           Age      : Integer range 0 .. 130;
           Vehicle  : Car_Name;
           case Sex is
              when M => Wife           : Person_Name(Sex => F);
              when F => Husband        : Person_Name(Sex => M);
           end case;
        end record;

23
     My_Car, Your_Car, Next_Car : Car_Name := new Car;  -- see *note 4.8::
     George : Person_Name := new Person(M);
        ...
     George.Vehicle := Your_Car;


File: arm2012.info,  Node: 3.10.2,  Prev: 3.10.1,  Up: 3.10

3.10.2 Operations of Access Types
---------------------------------

1/3
The attribute Access is used to create access values designating aliased
objects and nonintrinsic subprograms.  The "accessibility" rules prevent
dangling references (in the absence of uses of certain unchecked
features -- see Clause *note 13::).

                        _Name Resolution Rules_

2/2
For an attribute_reference with attribute_designator Access (or
Unchecked_Access -- see *note 13.10::), the expected type shall be a
single access type A such that:

2.1/2
   * A is an access-to-object type with designated type D and the type
     of the prefix is D'Class or is covered by D, or

2.2/2
   * A is an access-to-subprogram type whose designated profile is type
     conformant with that of the prefix.

2.3/2
The prefix of such an attribute_reference is never interpreted as an
implicit_dereference or a parameterless function_call (see *note
4.1.4::). The designated type or profile of the expected type of the
attribute_reference is the expected type or profile for the prefix.

                          _Static Semantics_

3/2
The accessibility rules, which prevent dangling references, are written
in terms of accessibility levels, which reflect the run-time nesting of
masters.  As explained in *note 7.6.1::, a master is the execution of a
certain construct, such as a subprogram_body.  An accessibility level is
deeper than another if it is more deeply nested at run time.  For
example, an object declared local to a called subprogram has a deeper
accessibility level than an object declared local to the calling
subprogram.  The accessibility rules for access types require that the
accessibility level of an object designated by an access value be no
deeper than that of the access type.  This ensures that the object will
live at least as long as the access type, which in turn ensures that the
access value cannot later designate an object that no longer exists.
The Unchecked_Access attribute may be used to circumvent the
accessibility rules.

4
A given accessibility level is said to be statically deeper than another
if the given level is known at compile time (as defined below) to be
deeper than the other for all possible executions.  In most cases,
accessibility is enforced at compile time by Legality Rules.  Run-time
accessibility checks are also used, since the Legality Rules do not
cover certain cases involving access parameters and generic packages.

5
Each master, and each entity and view created by it, has an
accessibility level:

6
   * The accessibility level of a given master is deeper than that of
     each dynamically enclosing master, and deeper than that of each
     master upon which the task executing the given master directly
     depends (see *note 9.3::).

7/4
   * An entity or view defined by a declaration and created as part of
     its elaboration has the same accessibility level as the innermost
     master of the declaration except in the cases of renaming and
     derived access types described below.  Other than for an explicitly
     aliased parameter of a function or generic function, a formal
     parameter of a callable entity has the same accessibility level as
     the master representing the invocation of the entity.

8
   * The accessibility level of a view of an object or subprogram
     defined by a renaming_declaration is the same as that of the
     renamed view.

9/2
   * The accessibility level of a view conversion, qualified_expression,
     or parenthesized expression, is the same as that of the operand.

9.1/3
   * The accessibility level of a conditional_expression is the
     accessibility level of the evaluated dependent_expression.

10/4
   * The accessibility level of an aggregate that is used (in its
     entirety) to directly initialize part of an object is that of the
     object being initialized.  In other contexts, the accessibility
     level of an aggregate is that of the innermost master that
     evaluates the aggregate.  Corresponding rules apply to a value
     conversion (see *note 4.6::).

10.1/3
   * The accessibility level of the result of a function call is that of
     the master of the function call, which is determined by the point
     of call as follows:

10.2/3
             * If the result is used (in its entirety) to directly
               initialize part of an object, the master is that of the
               object being initialized.  In the case where the
               initialized object is a coextension (see below) that
               becomes a coextension of another object, the master is
               that of the eventual object to which the coextension will
               be transferred.

10.3/3
             * If the result is of an anonymous access type and is the
               operand of an explicit conversion, the master is that of
               the target type of the conversion;

10.4/3
             * If the result is of an anonymous access type and defines
               an access discriminant, the master is the same as that
               for an object created by an anonymous allocator that
               defines an access discriminant (even if the access result
               is of an access-to-subprogram type).

10.5/3
             * If the call itself defines the result of a function to
               which one of the above rules applies, these rules are
               applied recursively;

10.6/3
             * In other cases, the master of the call is that of the
               innermost master that evaluates the function call.

10.7/3
     In the case of a call to a function whose result type is an
     anonymous access type, the accessibility level of the type of the
     result of the function call is also determined by the point of call
     as described above.

10.8/3
   * Within a return statement, the accessibility level of the return
     object is that of the execution of the return statement.  If the
     return statement completes normally by returning from the function,
     then prior to leaving the function, the accessibility level of the
     return object changes to be a level determined by the point of
     call, as does the level of any coextensions (see below) of the
     return object.

11
   * The accessibility level of a derived access type is the same as
     that of its ultimate ancestor.

11.1/2
   * The accessibility level of the anonymous access type defined by an
     access_definition of an object_renaming_declaration is the same as
     that of the renamed view.

12/2
   * The accessibility level of the anonymous access type of an access
     discriminant in the subtype_indication or qualified_expression of
     an allocator, or in the expression or return_subtype_indication
     (*note 6.5: S0187.) of a return statement is determined as follows:

12.1/2
             * If the value of the access discriminant is determined by
               a discriminant_association in a subtype_indication, the
               accessibility level of the object or subprogram
               designated by the associated value (or library level if
               the value is null);

12.2/3
             * If the value of the access discriminant is determined by
               a default_expression in the declaration of the
               discriminant, the level of the object or subprogram
               designated by the associated value (or library level if
               null);

12.3/3
             * If the value of the access discriminant is determined by
               a record_component_association in an aggregate, the
               accessibility level of the object or subprogram
               designated by the associated value (or library level if
               the value is null);

12.4/3
             * In other cases, where the value of the access
               discriminant is determined by an object with an
               unconstrained nominal subtype, the accessibility level of
               the object.

12.5/3
   * The accessibility level of the anonymous access type of an access
     discriminant in any other context is that of the enclosing object.

13/3
   * The accessibility level of the anonymous access type of an access
     parameter specifying an access-to-object type is the same as that
     of the view designated by the actual (or library-level if the
     actual is null).

13.1/2
   * The accessibility level of the anonymous access type of an access
     parameter specifying an access-to-subprogram type is deeper than
     that of any master; all such anonymous access types have this same
     level.

13.2/4
   * The accessibility level of the anonymous access subtype defined by
     a return_subtype_indication that is an access_definition (see *note
     6.5::) is that of the result subtype of the enclosing function.

13.3/4
   * The accessibility level of the type of a stand-alone object of an
     anonymous access-to-object type is the same as the accessibility
     level of the type of the access value most recently assigned to the
     object; accessibility checks ensure that this is never deeper than
     that of the declaration of the stand-alone object.

13.4/4
   * The accessibility level of an explicitly aliased (see *note 6.1::)
     formal parameter in a function body is determined by the point of
     call; it is the same level that the return object ultimately will
     have.

14/3
   * The accessibility level of an object created by an allocator is the
     same as that of the access type, except for an allocator of an
     anonymous access type (an anonymous allocator) in certain contexts,
     as follows: For an anonymous allocator that defines the result of a
     function with an access result, the accessibility level is
     determined as though the allocator were in place of the call of the
     function; in the special case of a call that is the operand of a
     type conversion, the level is that of the target access type of the
     conversion.  For an anonymous allocator defining the value of an
     access parameter, the accessibility level is that of the innermost
     master of the call.  For an anonymous allocator whose type is that
     of a stand-alone object of an anonymous access-to-object type, the
     accessibility level is that of the declaration of the stand-alone
     object.  For one defining an access discriminant, the accessibility
     level is determined as follows:

14.1/3
             * for an allocator used to define the discriminant of an
               object, the level of the object;

14.2/3
             * for an allocator used to define the constraint in a
               subtype_indication in any other context, the level of the
               master that elaborates the subtype_indication.

14.3/3
             * This paragraph was deleted.

14.4/3
     In the first case, the allocated object is said to be a coextension
     of the object whose discriminant designates it, as well as of any
     object of which the discriminated object is itself a coextension or
     subcomponent.  If the allocated object is a coextension of an
     anonymous object representing the result of an aggregate or
     function call that is used (in its entirety) to directly initialize
     a part of an object, after the result is assigned, the coextension
     becomes a coextension of the object being initialized and is no
     longer considered a coextension of the anonymous object.  All
     coextensions of an object (which have not thus been transfered by
     such an initialization) are finalized when the object is finalized
     (see *note 7.6.1::).

14.5/3
   * Within a return statement, the accessibility level of the anonymous
     access type of an access result is that of the master of the call.

15/3
   * The accessibility level of a view of an object or subprogram
     designated by an access value is the same as that of the access
     type.

16
   * The accessibility level of a component, protected subprogram, or
     entry of (a view of) a composite object is the same as that of (the
     view of) the composite object.

16.1/3
In the above rules, the operand of a view conversion, parenthesized
expression or qualified_expression is considered to be used in a context
if the view conversion, parenthesized expression or qualified_expression
itself is used in that context.  Similarly, a dependent_expression of a
conditional_expression is considered to be used in a context if the
conditional_expression itself is used in that context.

17
One accessibility level is defined to be statically deeper than another
in the following cases:

18
   * For a master that is statically nested within another master, the
     accessibility level of the inner master is statically deeper than
     that of the outer master.

18.1/2
   * The accessibility level of the anonymous access type of an access
     parameter specifying an access-to-subprogram type is statically
     deeper than that of any master; all such anonymous access types
     have this same level.

19/3
   * The statically deeper relationship does not apply to the
     accessibility level of the anonymous type of an access parameter
     specifying an access-to-object type nor does it apply to a
     descendant of a generic formal type; that is, such an accessibility
     level is not considered to be statically deeper, nor statically
     shallower, than any other.

19.1/3
   * The statically deeper relationship does not apply to the
     accessibility level of the type of a stand-alone object of an
     anonymous access-to-object type; that is, such an accessibility
     level is not considered to be statically deeper, nor statically
     shallower, than any other.

19.2/4
   * Inside a return statement that applies to a function or generic
     function F, or the return expression of an expression function F,
     when determining whether the accessibility level of an explicitly
     aliased parameter of F is statically deeper than the level of the
     return object of F, the level of the return object is considered to
     be the same as that of the level of the explicitly aliased
     parameter; for statically comparing with the level of other
     entities, an explicitly aliased parameter of F is considered to
     have the accessibility level of the body of F.

19.3/4
   * For determining whether a level is statically deeper than the level
     of the anonymous access type of an access result of a function or
     generic function F, when within a return statement that applies to
     F or the return expression of expression function F, the level of
     the master of the call is presumed to be the same as that of the
     level of the master that elaborated the body of F.

20
   * or generic function F

21
   * For determining whether one level is statically deeper than another
     when within a generic package body, the generic package is presumed
     to be instantiated at the same level as where it was declared;
     run-time checks are needed in the case of more deeply nested
     instantiations.

22
   * For determining whether one level is statically deeper than another
     when within the declarative region of a type_declaration, the
     current instance of the type is presumed to be an object created at
     a deeper level than that of the type.

23
The accessibility level of all library units is called the library
level; a library-level declaration or entity is one whose accessibility
level is the library level.

24
The following attribute is defined for a prefix X that denotes an
aliased view of an object:

25/1
X'Access
               X'Access yields an access value that designates the
               object denoted by X. The type of X'Access is an
               access-to-object type, as determined by the expected
               type.  The expected type shall be a general access type.
               X shall denote an aliased view of an object, including
               possibly the current instance (see *note 8.6::) of a
               limited type within its definition, or a formal parameter
               or generic formal object of a tagged type.  The view
               denoted by the prefix X shall satisfy the following
               additional requirements, presuming the expected type for
               X'Access is the general access type A with designated
               type D:

26
                  * If A is an access-to-variable type, then the view
                    shall be a variable; on the other hand, if A is an
                    access-to-constant type, the view may be either a
                    constant or a variable.

27/3
                  * The view shall not be a subcomponent that depends on
                    discriminants of an object unless the object is
                    known to be constrained.

28/2
                  * If A is a named access type and D is a tagged type,
                    then the type of the view shall be covered by D; if
                    A is anonymous and D is tagged, then the type of the
                    view shall be either D'Class or a type covered by D;
                    if D is untagged, then the type of the view shall be
                    D, and either:

28.1/2
                            * the designated subtype of A shall
                              statically match the nominal subtype of
                              the view; or

28.2/4
                            * D shall be discriminated in its full view
                              and unconstrained in any partial view, and
                              the designated subtype of A shall be
                              unconstrained.

29/3
                  * The accessibility level of the view shall not be
                    statically deeper than that of the access type A. 

29.1/3
               In addition to the places where Legality Rules normally
               apply (see *note 12.3::), these requirements apply also
               in the private part of an instance of a generic unit.

30
               A check is made that the accessibility level of X is not
               deeper than that of the access type A. If this check
               fails, Program_Error is raised.

31
               If the nominal subtype of X does not statically match the
               designated subtype of A, a view conversion of X to the
               designated subtype is evaluated (which might raise
               Constraint_Error -- see *note 4.6::) and the value of
               X'Access designates that view.

32
The following attribute is defined for a prefix P that denotes a
subprogram:

33/3
P'Access
               P'Access yields an access value that designates the
               subprogram denoted by P. The type of P'Access is an
               access-to-subprogram type (S), as determined by the
               expected type. The accessibility level of P shall not be
               statically deeper than that of S. In addition to the
               places where Legality Rules normally apply (see *note
               12.3::), this rule applies also in the private part of an
               instance of a generic unit.  The profile of P shall be
               subtype conformant with the designated profile of S, and
               shall not be Intrinsic. If the subprogram denoted by P is
               declared within a generic unit, and the expression
               P'Access occurs within the body of that generic unit or
               within the body of a generic unit declared within the
               declarative region of the generic unit, then the ultimate
               ancestor of S shall be either a nonformal type declared
               within the generic unit or an anonymous access type of an
               access parameter.

                           _Legality Rules_

33.1/3
An expression is said to have distributed accessibility if it is

33.2/3
   * a conditional_expression (see *note 4.5.7::); or

33.3/3
   * a view conversion, qualified_expression, or parenthesized
     expression whose operand has distributed accessibility.

33.4/3
The statically deeper relationship does not apply to the accessibility
level of an expression having distributed accessibility; that is, such
an accessibility level is not considered to be statically deeper, nor
statically shallower, than any other.

33.5/3
Any static accessibility requirement that is imposed on an expression
that has distributed accessibility (or on its type) is instead imposed
on the dependent_expressions of the underlying conditional_expression.
This rule is applied recursively if a dependent_expression also has
distributed accessibility.

     NOTES

34
     91  The Unchecked_Access attribute yields the same result as the
     Access attribute for objects, but has fewer restrictions (see *note
     13.10::).  There are other predefined operations that yield access
     values: an allocator can be used to create an object, and return an
     access value that designates it (see *note 4.8::); evaluating the
     literal null yields a null access value that designates no entity
     at all (see *note 4.2::).

35/2
     92  The predefined operations of an access type also include the
     assignment operation, qualification, and membership tests.
     Explicit conversion is allowed between general access types with
     matching designated subtypes; explicit conversion is allowed
     between access-to-subprogram types with subtype conformant profiles
     (see *note 4.6::). Named access types have predefined equality
     operators; anonymous access types do not, but they can use the
     predefined equality operators for universal_access (see *note
     4.5.2::).

36
     93  The object or subprogram designated by an access value can be
     named with a dereference, either an explicit_dereference (*note
     4.1: S0094.) or an implicit_dereference.  See *note 4.1::.

37
     94  A call through the dereference of an access-to-subprogram value
     is never a dispatching call.

38/2
     95  The Access attribute for subprograms and parameters of an
     anonymous access-to-subprogram type may together be used to
     implement "downward closures" -- that is, to pass a more-nested
     subprogram as a parameter to a less-nested subprogram, as might be
     appropriate for an iterator abstraction or numerical integration.
     Downward closures can also be implemented using generic formal
     subprograms (see *note 12.6::).  Note that Unchecked_Access is not
     allowed for subprograms.

39
     96  Note that using an access-to-class-wide tagged type with a
     dispatching operation is a potentially more structured alternative
     to using an access-to-subprogram type.

40
     97  An implementation may consider two access-to-subprogram values
     to be unequal, even though they designate the same subprogram.
     This might be because one points directly to the subprogram, while
     the other points to a special prologue that performs an
     Elaboration_Check and then jumps to the subprogram.  See *note
     4.5.2::.

                              _Examples_

41
Example of use of the Access attribute:

42
     Martha : Person_Name := new Person(F);       -- see *note 3.10.1::
     Cars   : array (1..2) of aliased Car;
        ...
     Martha.Vehicle := Cars(1)'Access;
     George.Vehicle := Cars(2)'Access;


File: arm2012.info,  Node: 3.11,  Prev: 3.10,  Up: 3

3.11 Declarative Parts
======================

1
A declarative_part contains declarative_items (possibly none).

                               _Syntax_

2
     declarative_part ::= {declarative_item}

3
     declarative_item ::=
         basic_declarative_item | body

4/1
     basic_declarative_item ::=
         basic_declaration | aspect_clause | use_clause

5
     body ::= proper_body | body_stub

6
     proper_body ::=
         subprogram_body | package_body | task_body | protected_body

                          _Static Semantics_

6.1/2
The list of declarative_items of a declarative_part is called the
declaration list of the declarative_part.

                          _Dynamic Semantics_

7
The elaboration of a declarative_part consists of the elaboration of the
declarative_items, if any, in the order in which they are given in the
declarative_part.

8
An elaborable construct is in the elaborated state after the normal
completion of its elaboration.  Prior to that, it is not yet elaborated.

9
For a construct that attempts to use a body, a check (Elaboration_Check)
is performed, as follows:

10/1
   * For a call to a (non-protected) subprogram that has an explicit
     body, a check is made that the body is already elaborated.  This
     check and the evaluations of any actual parameters of the call are
     done in an arbitrary order.

11/3
   * For a call to a protected operation of a protected type (that has a
     body -- no check is performed if the protected type is imported --
     see *note B.1::), a check is made that the protected_body is
     already elaborated.  This check and the evaluations of any actual
     parameters of the call are done in an arbitrary order.

12
   * For the activation of a task, a check is made by the activator that
     the task_body is already elaborated.  If two or more tasks are
     being activated together (see *note 9.2::), as the result of the
     elaboration of a declarative_part or the initialization for the
     object created by an allocator, this check is done for all of them
     before activating any of them.

13
   * For the instantiation of a generic unit that has a body, a check is
     made that this body is already elaborated.  This check and the
     evaluation of any explicit_generic_actual_parameters of the
     instantiation are done in an arbitrary order.

14
The exception Program_Error is raised if any of these checks fails.

* Menu:

* 3.11.1 ::   Completions of Declarations


File: arm2012.info,  Node: 3.11.1,  Up: 3.11

3.11.1 Completions of Declarations
----------------------------------

1/3
Declarations sometimes come in two parts. A declaration that requires a
second part is said to require completion. The second part is called the
completion of the declaration (and of the entity declared), and is
either another declaration, a body, or a pragma.  A body is a body, an
entry_body, a null_procedure_declaration or an
expression_function_declaration that completes another declaration, or a
renaming-as-body (see *note 8.5.4::).

                        _Name Resolution Rules_

2
A construct that can be a completion is interpreted as the completion of
a prior declaration only if:

3
   * The declaration and the completion occur immediately within the
     same declarative region;

4
   * The defining name or defining_program_unit_name in the completion
     is the same as in the declaration, or in the case of a pragma, the
     pragma applies to the declaration;

5
   * If the declaration is overloadable, then the completion either has
     a type-conformant profile, or is a pragma. 

                           _Legality Rules_

6/3
An implicit declaration shall not have a completion. For any explicit
declaration that is specified to require completion, there shall be a
corresponding explicit completion, unless the declared entity is
imported (see *note B.1::).

7
At most one completion is allowed for a given declaration.  Additional
requirements on completions appear where each kind of completion is
defined.

8
A type is completely defined at a place that is after its full type
definition (if it has one) and after all of its subcomponent types are
completely defined.  A type shall be completely defined before it is
frozen (see *note 13.14:: and *note 7.3::).

     NOTES

9/3
     98  Completions are in principle allowed for any kind of explicit
     declaration.  However, for some kinds of declaration, the only
     allowed completion is an implementation-defined pragma, and
     implementations are not required to have any such pragmas.

10
     99  There are rules that prevent premature uses of declarations
     that have a corresponding completion.  The Elaboration_Checks of
     *note 3.11:: prevent such uses at run time for subprograms,
     protected operations, tasks, and generic units.  The rules of *note
     13.14::, "*note 13.14:: Freezing Rules" prevent, at compile time,
     premature uses of other entities such as private types and deferred
     constants.


File: arm2012.info,  Node: 4,  Next: 5,  Prev: 3,  Up: Top

4 Names and Expressions
***********************

1/3
The rules applicable to the different forms of name and expression, and
to their evaluation, are given in this clause.

* Menu:

* 4.1 ::      Names
* 4.2 ::      Literals
* 4.3 ::      Aggregates
* 4.4 ::      Expressions
* 4.5 ::      Operators and Expression Evaluation
* 4.6 ::      Type Conversions
* 4.7 ::      Qualified Expressions
* 4.8 ::      Allocators
* 4.9 ::      Static Expressions and Static Subtypes


File: arm2012.info,  Node: 4.1,  Next: 4.2,  Up: 4

4.1 Names
=========

1
Names can denote declared entities, whether declared explicitly or
implicitly (see *note 3.1::).  Names can also denote objects or
subprograms designated by access values; the results of type_conversions
or function_calls; subcomponents and slices of objects and values;
protected subprograms, single entries, entry families, and entries in
families of entries.  Finally, names can denote attributes of any of the
foregoing.

                               _Syntax_

2/3
     name ::=
          direct_name   | explicit_dereference
        | indexed_component   | slice
        | selected_component   | attribute_reference
        | type_conversion   | function_call
        | character_literal   | qualified_expression
        | generalized_reference   | generalized_indexing

3
     direct_name ::= identifier | operator_symbol

4
     prefix ::= name | implicit_dereference

5
     explicit_dereference ::= name.all

6
     implicit_dereference ::= name

7/3
Certain forms of name (indexed_components, selected_components, slices,
and attribute_references) include a prefix that is either itself a name
that denotes some related entity, or an implicit_dereference of an
access value that designates some related entity.

                        _Name Resolution Rules_

8
The name in a dereference (either an implicit_dereference or an
explicit_dereference) is expected to be of any access type.

                          _Static Semantics_

9/3
If the type of the name in a dereference is some access-to-object type
T, then the dereference denotes a view of an object, the nominal subtype
of the view being the designated subtype of T. If the designated subtype
has unconstrained discriminants, the (actual) subtype of the view is
constrained by the values of the discriminants of the designated object,
except when there is a partial view of the type of the designated
subtype that does not have discriminants, in which case the dereference
is not constrained by its discriminant values.

10
If the type of the name in a dereference is some access-to-subprogram
type S, then the dereference denotes a view of a subprogram, the profile
of the view being the designated profile of S.

                          _Dynamic Semantics_

11/2
The evaluation of a name determines the entity denoted by the name.
This evaluation has no other effect for a name that is a direct_name or
a character_literal.

12
The evaluation of a name that has a prefix includes the evaluation of
the prefix. The evaluation of a prefix consists of the evaluation of the
name or the implicit_dereference.  The prefix denotes the entity denoted
by the name or the implicit_dereference.

13
The evaluation of a dereference consists of the evaluation of the name
and the determination of the object or subprogram that is designated by
the value of the name. A check is made that the value of the name is not
the null access value. Constraint_Error is raised if this check fails.
The dereference denotes the object or subprogram designated by the value
of the name.

                              _Examples_

14
Examples of direct names:

15
     Pi    -- the direct name of a number    (see *note 3.3.2::)
     Limit    -- the direct name of a constant    (see *note 3.3.1::)
     Count    -- the direct name of a scalar variable    (see *note 3.3.1::)
     Board    -- the direct name of an array variable    (see *note 3.6.1::)
     Matrix    -- the direct name of a type    (see *note 3.6::)
     Random    -- the direct name of a function    (see *note 6.1::)
     Error    -- the direct name of an exception    (see *note 11.1::)

16
Examples of dereferences:

17
     Next_Car.all   --  explicit dereference denoting the object designated by
                       --  the access variable Next_Car (see *note 3.10.1::)
     Next_Car.Owner    --  selected component with implicit dereference;
                       --  same as Next_Car.all.Owner

* Menu:

* 4.1.1 ::    Indexed Components
* 4.1.2 ::    Slices
* 4.1.3 ::    Selected Components
* 4.1.4 ::    Attributes
* 4.1.5 ::    User-Defined References
* 4.1.6 ::    User-Defined Indexing


File: arm2012.info,  Node: 4.1.1,  Next: 4.1.2,  Up: 4.1

4.1.1 Indexed Components
------------------------

1
An indexed_component denotes either a component of an array or an entry
in a family of entries. 

                               _Syntax_

2
     indexed_component ::= prefix(expression {, expression})

                        _Name Resolution Rules_

3
The prefix of an indexed_component with a given number of expressions
shall resolve to denote an array (after any implicit dereference) with
the corresponding number of index positions, or shall resolve to denote
an entry family of a task or protected object (in which case there shall
be only one expression).

4
The expected type for each expression is the corresponding index type.

                          _Static Semantics_

5
When the prefix denotes an array, the indexed_component denotes the
component of the array with the specified index value(s). The nominal
subtype of the indexed_component is the component subtype of the array
type.

6
When the prefix denotes an entry family, the indexed_component denotes
the individual entry of the entry family with the specified index value.

                          _Dynamic Semantics_

7
For the evaluation of an indexed_component, the prefix and the
expressions are evaluated in an arbitrary order.  The value of each
expression is converted to the corresponding index type. A check is made
that each index value belongs to the corresponding index range of the
array or entry family denoted by the prefix. Constraint_Error is raised
if this check fails.

                              _Examples_

8
Examples of indexed components:

9
      My_Schedule(Sat)     --  a component of a one-dimensional array    (see *note 3.6.1::)
      Page(10)             --  a component of a one-dimensional array    (see *note 3.6::)
      Board(M, J + 1)      --  a component of a two-dimensional array    (see *note 3.6.1::)
      Page(10)(20)         --  a component of a component    (see *note 3.6::)
      Request(Medium)      --  an entry in a family of entries    (see *note 9.1::)
      Next_Frame(L)(M, N)  --  a component of a function call    (see *note 6.1::)

     NOTES

10
     1  Notes on the examples: Distinct notations are used for
     components of multidimensional arrays (such as Board) and arrays of
     arrays (such as Page).  The components of an array of arrays are
     arrays and can therefore be indexed.  Thus Page(10)(20) denotes the
     20th component of Page(10).  In the last example Next_Frame(L) is a
     function call returning an access value that designates a
     two-dimensional array.


File: arm2012.info,  Node: 4.1.2,  Next: 4.1.3,  Prev: 4.1.1,  Up: 4.1

4.1.2 Slices
------------

1
A slice denotes a one-dimensional array formed by a sequence of
consecutive components of a one-dimensional array.  A slice of a
variable is a variable; a slice of a constant is a constant; a slice of
a value is a value.

                               _Syntax_

2
     slice ::= prefix(discrete_range)

                        _Name Resolution Rules_

3
The prefix of a slice shall resolve to denote a one-dimensional array
(after any implicit dereference).

4
The expected type for the discrete_range of a slice is the index type of
the array type.

                          _Static Semantics_

5
A slice denotes a one-dimensional array formed by the sequence of
consecutive components of the array denoted by the prefix, corresponding
to the range of values of the index given by the discrete_range.

6
The type of the slice is that of the prefix.  Its bounds are those
defined by the discrete_range.

                          _Dynamic Semantics_

7
For the evaluation of a slice, the prefix and the discrete_range are
evaluated in an arbitrary order. If the slice is not a null slice (a
slice where the discrete_range is a null range), then a check is made
that the bounds of the discrete_range belong to the index range of the
array denoted by the prefix. Constraint_Error is raised if this check
fails.

     NOTES

8
     2  A slice is not permitted as the prefix of an Access
     attribute_reference, even if the components or the array as a whole
     are aliased.  See *note 3.10.2::.

9
     3  For a one-dimensional array A, the slice A(N ..  N) denotes an
     array that has only one component; its type is the type of A. On
     the other hand, A(N) denotes a component of the array A and has the
     corresponding component type.

                              _Examples_

10
Examples of slices:

11
       Stars(1 .. 15)        --  a slice of 15 characters    (see *note 3.6.3::)
       Page(10 .. 10 + Size) --  a slice of 1 + Size components    (see *note 3.6::)
       Page(L)(A .. B)       --  a slice of the array Page(L)    (see *note 3.6::)
       Stars(1 .. 0)         --  a null slice    (see *note 3.6.3::)
       My_Schedule(Weekday)  --  bounds given by subtype    (see *note 3.6.1:: and *note 3.5.1::)
       Stars(5 .. 15)(K)     --  same as Stars(K)    (see *note 3.6.3::)
                             --  provided that K is in 5 .. 15


File: arm2012.info,  Node: 4.1.3,  Next: 4.1.4,  Prev: 4.1.2,  Up: 4.1

4.1.3 Selected Components
-------------------------

1
Selected_components are used to denote components (including
discriminants), entries, entry families, and protected subprograms; they
are also used as expanded names as described below. 

                               _Syntax_

2
     selected_component ::= prefix . selector_name

3
     selector_name ::= identifier | character_literal | operator_symbol

                        _Name Resolution Rules_

4
A selected_component is called an expanded name if, according to the
visibility rules, at least one possible interpretation of its prefix
denotes a package or an enclosing named construct (directly, not through
a subprogram_renaming_declaration or generic_renaming_declaration).

5
A selected_component that is not an expanded name shall resolve to
denote one of the following:

6
   * A component (including a discriminant):

7
     The prefix shall resolve to denote an object or value of some
     non-array composite type (after any implicit dereference).  The
     selector_name shall resolve to denote a discriminant_specification
     of the type, or, unless the type is a protected type, a
     component_declaration of the type.  The selected_component denotes
     the corresponding component of the object or value.

8
   * A single entry, an entry family, or a protected subprogram:

9
     The prefix shall resolve to denote an object or value of some task
     or protected type (after any implicit dereference).  The
     selector_name shall resolve to denote an entry_declaration or
     subprogram_declaration occurring (implicitly or explicitly) within
     the visible part of that type.  The selected_component denotes the
     corresponding entry, entry family, or protected subprogram.

9.1/2
   * A view of a subprogram whose first formal parameter is of a tagged
     type or is an access parameter whose designated type is tagged:

9.2/3
     The prefix (after any implicit dereference) shall resolve to denote
     an object or value of a specific tagged type T or class-wide type
     T'Class.  The selector_name shall resolve to denote a view of a
     subprogram declared immediately within the declarative region in
     which an ancestor of the type T is declared.  The first formal
     parameter of the subprogram shall be of type T, or a class-wide
     type that covers T, or an access parameter designating one of these
     types.  The designator of the subprogram shall not be the same as
     that of a component of the tagged type visible at the point of the
     selected_component.  The subprogram shall not be an implicitly
     declared primitive operation of type T that overrides an inherited
     subprogram implemented by an entry or protected subprogram visible
     at the point of the selected_component.  The selected_component
     denotes a view of this subprogram that omits the first formal
     parameter.  This view is called a prefixed view of the subprogram,
     and the prefix of the selected_component (after any implicit
     dereference) is called the prefix of the prefixed view. 

10
An expanded name shall resolve to denote a declaration that occurs
immediately within a named declarative region, as follows:

11
   * The prefix shall resolve to denote either a package (including the
     current instance of a generic package, or a rename of a package),
     or an enclosing named construct.

12
   * The selector_name shall resolve to denote a declaration that occurs
     immediately within the declarative region of the package or
     enclosing construct (the declaration shall be visible at the place
     of the expanded name -- see *note 8.3::).  The expanded name
     denotes that declaration.

13
   * If the prefix does not denote a package, then it shall be a
     direct_name or an expanded name, and it shall resolve to denote a
     program unit (other than a package), the current instance of a
     type, a block_statement, a loop_statement, or an accept_statement
     (*note 9.5.2: S0219.) (in the case of an accept_statement (*note
     9.5.2: S0219.) or entry_body (*note 9.5.2: S0221.), no family index
     is allowed); the expanded name shall occur within the declarative
     region of this construct.  Further, if this construct is a callable
     construct and the prefix denotes more than one such enclosing
     callable construct, then the expanded name is ambiguous,
     independently of the selector_name.

                           _Legality Rules_

13.1/2
For a subprogram whose first parameter is an access parameter, the
prefix of any prefixed view shall denote an aliased view of an object.

13.2/2
For a subprogram whose first parameter is of mode in out or out, or of
an anonymous access-to-variable type, the prefix of any prefixed view
shall denote a variable.

                          _Dynamic Semantics_

14
The evaluation of a selected_component includes the evaluation of the
prefix.

15
For a selected_component that denotes a component of a variant, a check
is made that the values of the discriminants are such that the value or
object denoted by the prefix has this component. The exception
Constraint_Error is raised if this check fails.

                              _Examples_

16
Examples of selected components:

17/2
       Tomorrow.Month     --  a record component    (see *note 3.8::)
       Next_Car.Owner     --  a record component    (see *note 3.10.1::)
       Next_Car.Owner.Age --  a record component    (see *note 3.10.1::)
                          --  the previous two lines involve implicit dereferences
       Writer.Unit        --  a record component (a discriminant)    (see *note 3.8.1::)
       Min_Cell(H).Value  --  a record component of the result    (see *note 6.1::)
                          --  of the function call Min_Cell(H)
       Cashier.Append     --  a prefixed view of a procedure    (see *note 3.9.4::)
       Control.Seize      --  an entry of a protected object    (see *note 9.4::)
       Pool(K).Write      --  an entry of the task Pool(K)    (see *note 9.4::)

18
Examples of expanded names:

19
       Key_Manager."<"      --  an operator of the visible part of a package    (see *note 7.3.1::)
       Dot_Product.Sum      --  a variable declared in a function body    (see *note 6.1::)
       Buffer.Pool          --  a variable declared in a protected unit    (see *note 9.11::)
       Buffer.Read          --  an entry of a protected unit    (see *note 9.11::)
       Swap.Temp            --  a variable declared in a block statement    (see *note 5.6::)
       Standard.Boolean     --  the name of a predefined type    (see *note A.1::)


File: arm2012.info,  Node: 4.1.4,  Next: 4.1.5,  Prev: 4.1.3,  Up: 4.1

4.1.4 Attributes
----------------

1
An attribute is a characteristic of an entity that can be queried via an
attribute_reference (*note 4.1.4: S0100.) or a range_attribute_reference
(*note 4.1.4: S0102.).

                               _Syntax_

2
     attribute_reference ::= prefix'attribute_designator

3/2
     attribute_designator ::=
         identifier[(static_expression)]
       | Access | Delta | Digits | Mod

4
     range_attribute_reference ::= prefix'range_attribute_designator

5
     range_attribute_designator ::= Range[(static_expression)]

                        _Name Resolution Rules_

6
In an attribute_reference, if the attribute_designator is for an
attribute defined for (at least some) objects of an access type, then
the prefix is never interpreted as an implicit_dereference; otherwise
(and for all range_attribute_references), if the type of the name within
the prefix is of an access type, the prefix is interpreted as an
implicit_dereference.  Similarly, if the attribute_designator is for an
attribute defined for (at least some) functions, then the prefix is
never interpreted as a parameterless function_call; otherwise (and for
all range_attribute_references), if the prefix consists of a name that
denotes a function, it is interpreted as a parameterless function_call.

7
The expression, if any, in an attribute_designator or
range_attribute_designator is expected to be of any integer type.

                           _Legality Rules_

8
The expression, if any, in an attribute_designator or
range_attribute_designator shall be static.

                          _Static Semantics_

9/4
An attribute_reference denotes a value, an object, a subprogram, or some
other kind of program entity.  Unless explicitly specified otherwise,
for an attribute_reference that denotes a value or an object, if its
type is scalar, then its nominal subtype is the base subtype of the
type; if its type is tagged, its nominal subtype is the first subtype of
the type; otherwise, its nominal subtype is a subtype of the type
without any constraint, null_exclusion, or predicate.  Similarly, unless
explicitly specified otherwise, for an attribute_reference that denotes
a function, when its result type is scalar, its result subtype is the
base subtype of the type, when its result type is tagged, the result
subtype is the first subtype of the type, and when the result type is
some other type, the result subtype is a subtype of the type without any
constraint, null_exclusion, or predicate.

10
A range_attribute_reference X'Range(N) is equivalent to the range
X'First(N) ..  X'Last(N), except that the prefix is only evaluated once.
Similarly, X'Range is equivalent to X'First ..  X'Last, except that the
prefix is only evaluated once.

                          _Dynamic Semantics_

11
The evaluation of an attribute_reference (or range_attribute_reference)
consists of the evaluation of the prefix.

                     _Implementation Permissions_

12/1
An implementation may provide implementation-defined attributes; the
identifier for an implementation-defined attribute shall differ from
those of the language-defined attributes unless supplied for
compatibility with a previous edition of this International Standard.

     NOTES

13
     4  Attributes are defined throughout this International Standard,
     and are summarized in *note K.2::.

14/2
     5  In general, the name in a prefix of an attribute_reference (or a
     range_attribute_reference) has to be resolved without using any
     context.  However, in the case of the Access attribute, the
     expected type for the attribute_reference has to be a single access
     type, and the resolution of the name can use the fact that the type
     of the object or the profile of the callable entity denoted by the
     prefix has to match the designated type or be type conformant with
     the designated profile of the access type. 

                              _Examples_

15
Examples of attributes:

16
     Color'First        -- minimum value of the enumeration type Color    (see *note 3.5.1::)
     Rainbow'Base'First -- same as Color'First    (see *note 3.5.1::)
     Real'Digits        -- precision of the type Real    (see *note 3.5.7::)
     Board'Last(2)      -- upper bound of the second dimension of Board    (see *note 3.6.1::)
     Board'Range(1)     -- index range of the first dimension of Board    (see *note 3.6.1::)
     Pool(K)'Terminated -- True if task Pool(K) is terminated    (see *note 9.1::)
     Date'Size          -- number of bits for records of type Date    (see *note 3.8::)
     Message'Address    -- address of the record variable Message    (see *note 3.7.1::)


File: arm2012.info,  Node: 4.1.5,  Next: 4.1.6,  Prev: 4.1.4,  Up: 4.1

4.1.5 User-Defined References
-----------------------------

                          _Static Semantics_

1/3
Given a discriminated type T, the following type-related operational
aspect may be specified:

2/3
Implicit_Dereference
               This aspect is specified by a name that denotes an access
               discriminant declared for the type T.

3/3
A (view of a) type with a specified Implicit_Dereference aspect is a
reference type.  A reference object is an object of a reference type.
The discriminant named by the Implicit_Dereference aspect is the
reference discriminant of the reference type or reference object.  A
generalized_reference is a name that identifies a reference object, and
denotes the object or subprogram designated by the reference
discriminant of the reference object.

                               _Syntax_

4/3
     generalized_reference ::= reference_object_name

                        _Name Resolution Rules_

5/3
The expected type for the reference_object_name in a
generalized_reference is any reference type.

                          _Static Semantics_

5.1/4
The Implicit_Dereference aspect is nonoverridable (see *note 13.1.1::).

6/3
A generalized_reference denotes a view equivalent to that of a
dereference of the reference discriminant of the reference object.

7/3
Given a reference type T, the Implicit_Dereference aspect is inherited
by descendants of type T if not overridden.  If a descendant type
constrains the value of the reference discriminant of T by a new
discriminant, that new discriminant is the reference discriminant of the
descendant.  If the descendant type constrains the value of the
reference discriminant of T by an expression other than the name of a
new discriminant, a generalized_reference that identifies an object of
the descendant type denotes the object or subprogram designated by the
value of this constraining expression.

                          _Dynamic Semantics_

8/3
The evaluation of a generalized_reference consists of the evaluation of
the reference_object_name and a determination of the object or
subprogram designated by the reference discriminant of the named
reference object. A check is made that the value of the reference
discriminant is not the null access value. Constraint_Error is raised if
this check fails.  The generalized_reference denotes the object or
subprogram designated by the value of the reference discriminant of the
named reference object.

                              _Examples_

9/3
     type Barrel is tagged ...  -- holds objects of type Element

10/3
     type Ref_Element(Data : access Element) is limited private
        with Implicit_Dereference => Data;
           -- This Ref_Element type is a "reference" type.
           -- "Data" is its reference discriminant.

11/3
     function Find (B : aliased in out Barrel; Key : String) return Ref_Element;
        -- Return a reference to an element of a barrel.

12/3
     B: aliased Barrel;

13/3
     ...

14/3
     Find (B, "grape") := Element'(...);  -- Assign through a reference.

15/3
     -- This is equivalent to:
     Find (B, "grape").Data.all := Element'(...);


File: arm2012.info,  Node: 4.1.6,  Prev: 4.1.5,  Up: 4.1

4.1.6 User-Defined Indexing
---------------------------

                          _Static Semantics_

1/3
Given a tagged type T, the following type-related, operational aspects
may be specified:

2/3
Constant_Indexing
               This aspect shall be specified by a name that denotes one
               or more functions declared immediately within the same
               declaration list in which T is declared.  All such
               functions shall have at least two parameters, the first
               of which is of type T or T'Class, or is an
               access-to-constant parameter with designated type T or
               T'Class.

3/3
Variable_Indexing
               This aspect shall be specified by a name that denotes one
               or more functions declared immediately within the same
               declaration list in which T is declared.  All such
               functions shall have at least two parameters, the first
               of which is of type T or T'Class, or is an access
               parameter with designated type T or T'Class.  All such
               functions shall have a return type that is a reference
               type (see *note 4.1.5::), whose reference discriminant is
               of an access-to-variable type.

4/4
These aspects are inherited by descendants of T (including the
class-wide type T'Class).

5/3
An indexable container type is (a view of) a tagged type with at least
one of the aspects Constant_Indexing or Variable_Indexing specified.  An
indexable container object is an object of an indexable container type.
A generalized_indexing is a name that denotes the result of calling a
function named by a Constant_Indexing or Variable_Indexing aspect.

5.1/4
The Constant_Indexing and Variable_Indexing aspects are nonoverridable
(see *note 13.1.1::).

Paragraphs 6 through 9 were deleted.

                               _Syntax_

10/3
     generalized_indexing ::= indexable_container_object_prefix 
     actual_parameter_part

                        _Name Resolution Rules_

11/3
The expected type for the indexable_container_object_prefix of a
generalized_indexing is any indexable container type.

12/3
If the Constant_Indexing aspect is specified for the type of the
indexable_container_object_prefix of a generalized_indexing, then the
generalized_indexing is interpreted as a constant indexing under the
following circumstances:

13/3
   * when the Variable_Indexing aspect is not specified for the type of
     the indexable_container_object_prefix;

14/3
   * when the indexable_container_object_prefix denotes a constant;

15/3
   * when the generalized_indexing is used within a primary where a name
     denoting a constant is permitted.

16/3
Otherwise, the generalized_indexing is interpreted as a variable
indexing.

17/3
When a generalized_indexing is interpreted as a constant (or variable)
indexing, it is equivalent to a call on a prefixed view of one of the
functions named by the Constant_Indexing (or Variable_Indexing) aspect
of the type of the indexable_container_object_prefix with the given
actual_parameter_part, and with the indexable_container_object_prefix as
the prefix of the prefixed view.

     NOTES

18/4
     6  The Constant_Indexing and Variable_Indexing aspects cannot be
     redefined when inherited for a derived type, but the functions that
     they denote can be modified by overriding or overloading.

                              _Examples_

19/3
     type Indexed_Barrel is tagged ...
       with Variable_Indexing => Find;
       -- Indexed_Barrel is an indexable container type,
       -- Find is the generalized indexing operation.

20/3
     function Find (B : aliased in out Indexed_Barrel; Key : String) return Ref_Element;
        -- Return a reference to an element of a barrel (see *note 4.1.5::).

21/3
     IB: aliased Indexed_Barrel;

22/3
     -- All of the following calls are then equivalent:
     Find (IB,"pear").Data.all := Element'(...); -- Traditional call
     IB.Find ("pear").Data.all := Element'(...); -- Call of prefixed view
     IB.Find ("pear")          := Element'(...); -- Implicit dereference (see *note 4.1.5::)
     IB      ("pear")          := Element'(...); -- Implicit indexing and dereference
     IB      ("pear").Data.all := Element'(...); -- Implicit indexing only


File: arm2012.info,  Node: 4.2,  Next: 4.3,  Prev: 4.1,  Up: 4

4.2 Literals
============

1
A literal represents a value literally, that is, by means of notation
suited to its kind.  A literal is either a numeric_literal, a
character_literal, the literal null, or a string_literal. 

                        _Name Resolution Rules_

2/2
This paragraph was deleted.

3
For a name that consists of a character_literal, either its expected
type shall be a single character type, in which case it is interpreted
as a parameterless function_call that yields the corresponding value of
the character type, or its expected profile shall correspond to a
parameterless function with a character result type, in which case it is
interpreted as the name of the corresponding parameterless function
declared as part of the character type's definition (see *note 3.5.1::).
In either case, the character_literal denotes the
enumeration_literal_specification.

4
The expected type for a primary that is a string_literal shall be a
single string type.

                           _Legality Rules_

5
A character_literal that is a name shall correspond to a
defining_character_literal of the expected type, or of the result type
of the expected profile.

6
For each character of a string_literal with a given expected string
type, there shall be a corresponding defining_character_literal of the
component type of the expected string type.

7/2
This paragraph was deleted.

                          _Static Semantics_

8/2
An integer literal is of type universal_integer.  A real literal is of
type universal_real.  The literal null is of type universal_access.

                          _Dynamic Semantics_

9
The evaluation of a numeric literal, or the literal null, yields the
represented value.

10
The evaluation of a string_literal that is a primary yields an array
value containing the value of each character of the sequence of
characters of the string_literal, as defined in *note 2.6::.  The bounds
of this array value are determined according to the rules for
positional_array_aggregates (see *note 4.3.3::), except that for a null
string literal, the upper bound is the predecessor of the lower bound.

11
For the evaluation of a string_literal of type T, a check is made that
the value of each character of the string_literal belongs to the
component subtype of T. For the evaluation of a null string literal, a
check is made that its lower bound is greater than the lower bound of
the base range of the index type. The exception Constraint_Error is
raised if either of these checks fails.

     NOTES

12
     7  Enumeration literals that are identifiers rather than
     character_literals follow the normal rules for identifiers when
     used in a name (see *note 4.1:: and *note 4.1.3::).
     Character_literals used as selector_names follow the normal rules
     for expanded names (see *note 4.1.3::).

                              _Examples_

13
Examples of literals:

14
     3.14159_26536    --  a real literal
     1_345    --  an integer literal
     'A'    --  a character literal
     "Some Text"    --  a string literal 


File: arm2012.info,  Node: 4.3,  Next: 4.4,  Prev: 4.2,  Up: 4

4.3 Aggregates
==============

1
An aggregate combines component values into a composite value of an
array type, record type, or record extension. 

                               _Syntax_

2
     aggregate ::= record_aggregate | extension_aggregate | 
     array_aggregate

                        _Name Resolution Rules_

3/2
The expected type for an aggregate shall be a single array type, record
type, or record extension.

                           _Legality Rules_

4
An aggregate shall not be of a class-wide type.

                          _Dynamic Semantics_

5
For the evaluation of an aggregate, an anonymous object is created and
values for the components or ancestor part are obtained (as described in
the subsequent subclause for each kind of the aggregate) and assigned
into the corresponding components or ancestor part of the anonymous
object. Obtaining the values and the assignments occur in an arbitrary
order.  The value of the aggregate is the value of this object.

6
If an aggregate is of a tagged type, a check is made that its value
belongs to the first subtype of the type. Constraint_Error is raised if
this check fails.

* Menu:

* 4.3.1 ::    Record Aggregates
* 4.3.2 ::    Extension Aggregates
* 4.3.3 ::    Array Aggregates


File: arm2012.info,  Node: 4.3.1,  Next: 4.3.2,  Up: 4.3

4.3.1 Record Aggregates
-----------------------

1
In a record_aggregate, a value is specified for each component of the
record or record extension value, using either a named or a positional
association.

                               _Syntax_

2
     record_aggregate ::= (record_component_association_list)

3
     record_component_association_list ::=
         record_component_association {, record_component_association}
       | null record

4/2
     record_component_association ::=
         [component_choice_list =>] expression
        | component_choice_list => <>

5
     component_choice_list ::=
          component_selector_name {| component_selector_name}
        | others

6
     A record_component_association (*note 4.3.1: S0109.) is a named
     component association if it has a component_choice_list; otherwise,
     it is a positional component association.  Any positional component
     associations shall precede any named component associations.  If
     there is a named association with a component_choice_list of
     others, it shall come last.

7
     In the record_component_association_list (*note 4.3.1: S0108.) for
     a record_aggregate (*note 4.3.1: S0107.), if there is only one
     association, it shall be a named association.

                        _Name Resolution Rules_

8/2
The expected type for a record_aggregate shall be a single record type
or record extension.

9
For the record_component_association_list (*note 4.3.1: S0108.) of a
record_aggregate (*note 4.3.1: S0107.), all components of the composite
value defined by the aggregate are needed; for the association list of
an extension_aggregate, only those components not determined by the
ancestor expression or subtype are needed (see *note 4.3.2::).  Each
selector_name (*note 4.1.3: S0099.) in a record_component_association
(*note 4.3.1: S0109.) shall denote a needed component (including
possibly a discriminant).

10
The expected type for the expression of a record_component_association
(*note 4.3.1: S0109.) is the type of the associated component(s); the
associated component(s) are as follows:

11
   * For a positional association, the component (including possibly a
     discriminant) in the corresponding relative position (in the
     declarative region of the type), counting only the needed
     components;

12
   * For a named association with one or more component_selector_names,
     the named component(s);

13
   * For a named association with the reserved word others, all needed
     components that are not associated with some previous association.

                           _Legality Rules_

14
If the type of a record_aggregate is a record extension, then it shall
be a descendant of a record type, through one or more record extensions
(and no private extensions).

15/3
The reserved words null record may appear only if there are no
components needed in a given record_component_association_list (*note
4.3.1: S0108.).

16/4
Each record_component_association other than an others choice with a <>
shall have at least one associated component, and each needed component
shall be associated with exactly one record_component_association (*note
4.3.1: S0109.).  If a record_component_association (*note 4.3.1: S0109.)
with an expression has two or more associated components, all of them
shall be of the same type, or all of them shall be of anonymous access
types whose subtypes statically match.  In addition, Legality Rules are
enforced separately for each associated component.

17/3
The value of a discriminant that governs a variant_part P shall be given
by a static expression, unless P is nested within a variant V that is
not selected by the discriminant value governing the variant_part
enclosing V.

17.1/2
A record_component_association for a discriminant without a
default_expression shall have an expression rather than <>.

                          _Dynamic Semantics_

18
The evaluation of a record_aggregate consists of the evaluation of the
record_component_association_list (*note 4.3.1: S0108.).

19
For the evaluation of a record_component_association_list (*note 4.3.1:
S0108.), any per-object constraints (see *note 3.8::) for components
specified in the association list are elaborated and any expressions are
evaluated and converted to the subtype of the associated component. Any
constraint elaborations and expression evaluations (and conversions)
occur in an arbitrary order, except that the expression for a
discriminant is evaluated (and converted) prior to the elaboration of
any per-object constraint that depends on it, which in turn occurs prior
to the evaluation and conversion of the expression for the component
with the per-object constraint.

19.1/2
For a record_component_association with an expression, the expression
defines the value for the associated component(s).  For a
record_component_association with <>, if the component_declaration has a
default_expression, that default_expression defines the value for the
associated component(s); otherwise, the associated component(s) are
initialized by default as for a stand-alone object of the component
subtype (see *note 3.3.1::).

20
The expression of a record_component_association is evaluated (and
converted) once for each associated component.

     NOTES

21
     8  For a record_aggregate with positional associations, expressions
     specifying discriminant values appear first since the
     known_discriminant_part is given first in the declaration of the
     type; they have to be in the same order as in the
     known_discriminant_part.

                              _Examples_

22
Example of a record aggregate with positional associations:

23
     (4, July, 1776)                                       --  see *note 3.8:: 

24
Examples of record aggregates with named associations:

25
     (Day => 4, Month => July, Year => 1776)
     (Month => July, Day => 4, Year => 1776)

26
     (Disk, Closed, Track => 5, Cylinder => 12)            --  see *note 3.8.1::
     (Unit => Disk, Status => Closed, Cylinder => 9, Track => 1)

27/2
Examples of component associations with several choices:

28
     (Value => 0, Succ|Pred => new Cell'(0, null, null))    --  see *note 3.10.1::

29
      --  The allocator is evaluated twice: Succ and Pred designate different cells

29.1/2
     (Value => 0, Succ|Pred => <>)    --  see *note 3.10.1::

29.2/2
      --  Succ and Pred will be set to null

30
Examples of record aggregates for tagged types (see *note 3.9:: and
*note 3.9.1::):

31
     Expression'(null record)
     Literal'(Value => 0.0)
     Painted_Point'(0.0, Pi/2.0, Paint => Red)


File: arm2012.info,  Node: 4.3.2,  Next: 4.3.3,  Prev: 4.3.1,  Up: 4.3

4.3.2 Extension Aggregates
--------------------------

1
An extension_aggregate specifies a value for a type that is a record
extension by specifying a value or subtype for an ancestor of the type,
followed by associations for any components not determined by the
ancestor_part.

                               _Syntax_

2
     extension_aggregate ::=
         (ancestor_part with record_component_association_list)

3
     ancestor_part ::= expression | subtype_mark

                        _Name Resolution Rules_

4/2
The expected type for an extension_aggregate shall be a single type that
is a record extension. If the ancestor_part is an expression, it is
expected to be of any tagged type.

                           _Legality Rules_

5/3
If the ancestor_part is a subtype_mark, it shall denote a specific
tagged subtype.  If the ancestor_part is an expression, it shall not be
dynamically tagged.  The type of the extension_aggregate shall be a
descendant of the type of the ancestor_part (the ancestor type), through
one or more record extensions (and no private extensions).  If the
ancestor_part is a subtype_mark, the view of the ancestor type from
which the type is descended (see *note 7.3.1::) shall not have unknown
discriminants.

5.1/3
If the type of the ancestor_part is limited and at least one component
is needed in the record_component_association_list, then the
ancestor_part shall not be:

5.2/3
   * a call to a function with an unconstrained result subtype; nor

5.3/3
   * a parenthesized or qualified expression whose operand would violate
     this rule; nor

5.4/3
   * a conditional_expression having at least one dependent_expression
     that would violate this rule.

                          _Static Semantics_

6
For the record_component_association_list (*note 4.3.1: S0108.) of an
extension_aggregate (*note 4.3.2: S0111.), the only components needed
are those of the composite value defined by the aggregate that are not
inherited from the type of the ancestor_part (*note 4.3.2: S0112.), plus
any inherited discriminants if the ancestor_part (*note 4.3.2: S0112.)
is a subtype_mark (*note 3.2.2: S0028.) that denotes an unconstrained
subtype.

                          _Dynamic Semantics_

7
For the evaluation of an extension_aggregate, the
record_component_association_list (*note 4.3.1: S0108.) is evaluated.
If the ancestor_part is an expression, it is also evaluated; if the
ancestor_part is a subtype_mark, the components of the value of the
aggregate not given by the record_component_association_list (*note
4.3.1: S0108.) are initialized by default as for an object of the
ancestor type.  Any implicit initializations or evaluations are
performed in an arbitrary order, except that the expression for a
discriminant is evaluated prior to any other evaluation or
initialization that depends on it.

8/3
If the type of the ancestor_part has discriminants and the ancestor_part
is not a subtype_mark that denotes an unconstrained subtype, then a
check is made that each discriminant determined by the ancestor_part has
the value specified for a corresponding discriminant, if any, either in
the record_component_association_list (*note 4.3.1: S0108.), or in the
derived_type_definition for some ancestor of the type of the
extension_aggregate. Constraint_Error is raised if this check fails.

     NOTES

9
     9  If all components of the value of the extension_aggregate are
     determined by the ancestor_part, then the
     record_component_association_list (*note 4.3.1: S0108.) is required
     to be simply null record.

10
     10  If the ancestor_part is a subtype_mark, then its type can be
     abstract.  If its type is controlled, then as the last step of
     evaluating the aggregate, the Initialize procedure of the ancestor
     type is called, unless the Initialize procedure is abstract (see
     *note 7.6::).

                              _Examples_

11
Examples of extension aggregates (for types defined in *note 3.9.1::):

12
     Painted_Point'(Point with Red)
     (Point'(P) with Paint => Black)

13
     (Expression with Left => 1.2, Right => 3.4)
     Addition'(Binop with null record)
                  -- presuming Binop is of type Binary_Operation


File: arm2012.info,  Node: 4.3.3,  Prev: 4.3.2,  Up: 4.3

4.3.3 Array Aggregates
----------------------

1
In an array_aggregate, a value is specified for each component of an
array, either positionally or by its index.  For a
positional_array_aggregate, the components are given in increasing-index
order, with a final others, if any, representing any remaining
components.  For a named_array_aggregate, the components are identified
by the values covered by the discrete_choices.

                               _Syntax_

2
     array_aggregate ::=
       positional_array_aggregate | named_array_aggregate

3/2
     positional_array_aggregate ::=
         (expression, expression {, expression})
       | (expression {, expression}, others => expression)
       | (expression {, expression}, others => <>)

4
     named_array_aggregate ::=
         (array_component_association {, array_component_association})

5/2
     array_component_association ::=
         discrete_choice_list => expression
       | discrete_choice_list => <>

6
An n-dimensional array_aggregate is one that is written as n levels of
nested array_aggregates (or at the bottom level, equivalent
string_literals). For the multidimensional case (n >= 2) the
array_aggregates (or equivalent string_literals) at the n-1 lower levels
are called subaggregates of the enclosing n-dimensional array_aggregate.
The expressions of the bottom level subaggregates (or of the
array_aggregate itself if one-dimensional) are called the array
component expressions of the enclosing n-dimensional array_aggregate.

                        _Name Resolution Rules_

7/2
The expected type for an array_aggregate (that is not a subaggregate)
shall be a single array type. The component type of this array type is
the expected type for each array component expression of the
array_aggregate.

8
The expected type for each discrete_choice in any discrete_choice_list
of a named_array_aggregate is the type of the corresponding index; the
corresponding index for an array_aggregate that is not a subaggregate is
the first index of its type; for an (n-m)-dimensional subaggregate
within an array_aggregate of an n-dimensional type, the corresponding
index is the index in position m+1.

                           _Legality Rules_

9
An array_aggregate of an n-dimensional array type shall be written as an
n-dimensional array_aggregate.

10
An others choice is allowed for an array_aggregate only if an applicable
index constraint applies to the array_aggregate. An applicable index
constraint is a constraint provided by certain contexts where an
array_aggregate is permitted that can be used to determine the bounds of
the array value specified by the aggregate.  Each of the following
contexts (and none other) defines an applicable index constraint:

11/4
   * For an explicit_actual_parameter, an
     explicit_generic_actual_parameter, the expression of a return
     statement, the return expression of an expression function, the
     initialization expression in an object_declaration (*note 3.3.1:
     S0032.), or a default_expression (*note 3.7: S0063.) (for a
     parameter or a component), when the nominal subtype of the
     corresponding formal parameter, generic formal parameter, function
     return object, expression function return object, object, or
     component is a constrained array subtype, the applicable index
     constraint is the constraint of the subtype;

12
   * For the expression of an assignment_statement where the name
     denotes an array variable, the applicable index constraint is the
     constraint of the array variable;

13
   * For the operand of a qualified_expression whose subtype_mark
     denotes a constrained array subtype, the applicable index
     constraint is the constraint of the subtype;

14
   * For a component expression in an aggregate, if the component's
     nominal subtype is a constrained array subtype, the applicable
     index constraint is the constraint of the subtype;

15/3
   * For a parenthesized expression, the applicable index constraint is
     that, if any, defined for the expression;

15.1/3
   * For a conditional_expression, the applicable index constraint for
     each dependent_expression is that, if any, defined for the
     conditional_expression.

16
The applicable index constraint applies to an array_aggregate that
appears in such a context, as well as to any subaggregates thereof.  In
the case of an explicit_actual_parameter (or default_expression) for a
call on a generic formal subprogram, no applicable index constraint is
defined.

17/3
The discrete_choice_list of an array_component_association is allowed to
have a discrete_choice that is a nonstatic choice_expression or that is
a subtype_indication or range that defines a nonstatic or null range,
only if it is the single discrete_choice of its discrete_choice_list,
and there is only one array_component_association in the
array_aggregate.

18/3
In a named_array_aggregate where all discrete_choices are static, no two
discrete_choices are allowed to cover the same value (see *note
3.8.1::); if there is no others choice, the discrete_choices taken
together shall exactly cover a contiguous sequence of values of the
corresponding index type.

19
A bottom level subaggregate of a multidimensional array_aggregate of a
given array type is allowed to be a string_literal only if the component
type of the array type is a character type; each character of such a
string_literal shall correspond to a defining_character_literal of the
component type.

                          _Static Semantics_

20
A subaggregate that is a string_literal is equivalent to one that is a
positional_array_aggregate of the same length, with each expression
being the character_literal for the corresponding character of the
string_literal.

                          _Dynamic Semantics_

21
The evaluation of an array_aggregate of a given array type proceeds in
two steps:

22
     1.  Any discrete_choices of this aggregate and of its subaggregates
     are evaluated in an arbitrary order, and converted to the
     corresponding index type; 

23
     2.  The array component expressions of the aggregate are evaluated
     in an arbitrary order and their values are converted to the
     component subtype of the array type; an array component expression
     is evaluated once for each associated component. 

23.1/4
Each expression in an array_component_association defines the value for
the associated component(s).  For an array_component_association with
<>, the associated component(s) are initialized to the
Default_Component_Value of the array type if this aspect has been
specified for the array type; otherwise, they are initialized by default
as for a stand-alone object of the component subtype (see *note
3.3.1::).

24
The bounds of the index range of an array_aggregate (including a
subaggregate) are determined as follows:

25
   * For an array_aggregate with an others choice, the bounds are those
     of the corresponding index range from the applicable index
     constraint;

26
   * For a positional_array_aggregate (or equivalent string_literal)
     without an others choice, the lower bound is that of the
     corresponding index range in the applicable index constraint, if
     defined, or that of the corresponding index subtype, if not; in
     either case, the upper bound is determined from the lower bound and
     the number of expressions (or the length of the string_literal);

27
   * For a named_array_aggregate without an others choice, the bounds
     are determined by the smallest and largest index values covered by
     any discrete_choice_list.

28
For an array_aggregate, a check is made that the index range defined by
its bounds is compatible with the corresponding index subtype.

29/3
For an array_aggregate with an others choice, a check is made that no
expression or <> is specified for an index value outside the bounds
determined by the applicable index constraint.

30
For a multidimensional array_aggregate, a check is made that all
subaggregates that correspond to the same index have the same bounds.

31
The exception Constraint_Error is raised if any of the above checks
fail.

     NOTES

32/3
     11  In an array_aggregate, positional notation may only be used
     with two or more expressions; a single expression in parentheses is
     interpreted as a parenthesized expression.  A
     named_array_aggregate, such as (1 => X), may be used to specify an
     array with a single component.

                              _Examples_

33
Examples of array aggregates with positional associations:

34
     (7, 9, 5, 1, 3, 2, 4, 8, 6, 0)
     Table'(5, 8, 4, 1, others => 0)  --  see *note 3.6:: 

35
Examples of array aggregates with named associations:

36
     (1 .. 5 => (1 .. 8 => 0.0))      --  two-dimensional
     (1 .. N => new Cell)             --  N new cells, in particular for N = 0

37
     Table'(2 | 4 | 10 => 1, others => 0)
     Schedule'(Mon .. Fri => True,  others => False)  --  see *note 3.6::
     Schedule'(Wed | Sun  => False, others => True)
     Vector'(1 => 2.5)                                --  single-component vector

38
Examples of two-dimensional array aggregates:

39
     -- Three aggregates for the same value of subtype Matrix(1..2,1..3) (see *note 3.6::):

40
     ((1.1, 1.2, 1.3), (2.1, 2.2, 2.3))
     (1 => (1.1, 1.2, 1.3), 2 => (2.1, 2.2, 2.3))
     (1 => (1 => 1.1, 2 => 1.2, 3 => 1.3), 2 => (1 => 2.1, 2 => 2.2, 3 => 2.3))

41
Examples of aggregates as initial values:

42
     A : Table := (7, 9, 5, 1, 3, 2, 4, 8, 6, 0);        -- A(1)=7, A(10)=0
     B : Table := (2 | 4 | 10 => 1, others => 0);        -- B(1)=0, B(10)=1
     C : constant Matrix := (1 .. 5 => (1 .. 8 => 0.0)); -- C'Last(1)=5, C'Last(2)=8

43
     D : Bit_Vector(M .. N) := (M .. N => True);         -- see *note 3.6::
     E : Bit_Vector(M .. N) := (others => True);
     F : String(1 .. 1) := (1 => 'F');  -- a one component aggregate: same as "F"

44/2
Example of an array aggregate with defaulted others choice and with an
applicable index constraint provided by an enclosing record aggregate:

45/2
     Buffer'(Size => 50, Pos => 1, Value => String'('x', others => <>))  -- see *note 3.7::


File: arm2012.info,  Node: 4.4,  Next: 4.5,  Prev: 4.3,  Up: 4

4.4 Expressions
===============

1/3
An expression is a formula that defines the computation or retrieval of
a value.  In this International Standard, the term "expression" refers
to a construct of the syntactic category expression or of any of the
following categories: choice_expression, choice_relation, relation,
simple_expression, term, factor, primary, conditional_expression,
quantified_expression. 

                               _Syntax_

2
     expression ::=
          relation {and relation}    | relation {and then relation}
        | relation {or relation}    | relation {or else relation}
        | relation {xor relation}

2.1/3
     choice_expression ::=
          choice_relation {and choice_relation}
        | choice_relation {or choice_relation}
        | choice_relation {xor choice_relation}
        | choice_relation {and then choice_relation}
        | choice_relation {or else choice_relation}

2.2/3
     choice_relation ::=
          simple_expression [relational_operator simple_expression]

3/4
     relation ::=
          simple_expression [relational_operator simple_expression]
        | tested_simple_expression [not] in membership_choice_list
        | raise_expression

3.1/3
     membership_choice_list ::= membership_choice {| membership_choice}

3.2/4
     membership_choice ::= choice_simple_expression | range | 
     subtype_mark

4
     simple_expression ::= [unary_adding_operator] term {
     binary_adding_operator term}

5
     term ::= factor {multiplying_operator factor}

6
     factor ::= primary [** primary] | abs primary | not primary

7/3
     primary ::=
        numeric_literal | null | string_literal | aggregate
      | name | allocator | (expression)
      | (conditional_expression) | (quantified_expression)

                        _Name Resolution Rules_

8
A name used as a primary shall resolve to denote an object or a value.

                          _Static Semantics_

9
Each expression has a type; it specifies the computation or retrieval of
a value of that type.

                          _Dynamic Semantics_

10
The value of a primary that is a name denoting an object is the value of
the object.

                     _Implementation Permissions_

11
For the evaluation of a primary that is a name denoting an object of an
unconstrained numeric subtype, if the value of the object is outside the
base range of its type, the implementation may either raise
Constraint_Error or return the value of the object.

                              _Examples_

12
Examples of primaries:

13
     4.0                --  real literal
     Pi                 --  named number
     (1 .. 10 => 0)     --  array aggregate
     Sum                --  variable
     Integer'Last       --  attribute
     Sine(X)            --  function call
     Color'(Blue)       --  qualified expression
     Real(M*N)          --  conversion
     (Line_Count + 10)  --  parenthesized expression 

14
Examples of expressions:

15/2
     Volume                      -- primary
     not Destroyed               -- factor
     2*Line_Count                -- term
     -4.0                        -- simple expression
     -4.0 + A                    -- simple expression
     B**2 - 4.0*A*C              -- simple expression
     R*Sin([Unicode 952])*Cos([Unicode 966])             -- simple expression
     Password(1 .. 3) = "Bwv"    -- relation
     Count in Small_Int          -- relation
     Count not in Small_Int      -- relation
     Index = 0 or Item_Hit       -- expression
     (Cold and Sunny) or Warm    -- expression (parentheses are required)
     A**(B**C)                   -- expression (parentheses are required)


File: arm2012.info,  Node: 4.5,  Next: 4.6,  Prev: 4.4,  Up: 4

4.5 Operators and Expression Evaluation
=======================================

1
The language defines the following six categories of operators (given in
order of increasing precedence).  The corresponding operator_symbols,
and only those, can be used as designators in declarations of functions
for user-defined operators.  See *note 6.6::, "*note 6.6:: Overloading
of Operators".

                               _Syntax_

2
     logical_operator ::=     and | or  | xor

3
     relational_operator ::=     =   | /=  | <   | <= | > | >=

4
     binary_adding_operator ::=     +   | -   | &

5
     unary_adding_operator ::=     +   | -

6
     multiplying_operator ::=     *   | /   | mod | rem

7
     highest_precedence_operator ::=     **  | abs | not

                          _Static Semantics_

8
For a sequence of operators of the same precedence level, the operators
are associated with their operands in textual order from left to right.
Parentheses can be used to impose specific associations.

9
For each form of type definition, certain of the above operators are
predefined; that is, they are implicitly declared immediately after the
type definition. For each such implicit operator declaration, the
parameters are called Left and Right for binary operators; the single
parameter is called Right for unary operators.  An expression of the
form X op Y, where op is a binary operator, is equivalent to a
function_call of the form "op"(X, Y). An expression of the form op Y,
where op is a unary operator, is equivalent to a function_call of the
form "op"(Y). The predefined operators and their effects are described
in subclauses *note 4.5.1:: through *note 4.5.6::.

                          _Dynamic Semantics_

10
The predefined operations on integer types either yield the
mathematically correct result or raise the exception Constraint_Error.
For implementations that support the Numerics Annex, the predefined
operations on real types yield results whose accuracy is defined in
*note Annex G::, or raise the exception Constraint_Error.

                     _Implementation Requirements_

11
The implementation of a predefined operator that delivers a result of an
integer or fixed point type may raise Constraint_Error only if the
result is outside the base range of the result type.

12
The implementation of a predefined operator that delivers a result of a
floating point type may raise Constraint_Error only if the result is
outside the safe range of the result type.

                     _Implementation Permissions_

13
For a sequence of predefined operators of the same precedence level (and
in the absence of parentheses imposing a specific association), an
implementation may impose any association of the operators with operands
so long as the result produced is an allowed result for the
left-to-right association, but ignoring the potential for failure of
language-defined checks in either the left-to-right or chosen order of
association.

     NOTES

14
     12  The two operands of an expression of the form X op Y, where op
     is a binary operator, are evaluated in an arbitrary order, as for
     any function_call (see *note 6.4::).

                              _Examples_

15
Examples of precedence:

16
     not Sunny or Warm    --  same as (not Sunny) or Warm
     X > 4.0 and Y > 0.0  --  same as (X > 4.0) and (Y > 0.0)

17
     -4.0*A**2            --  same as -(4.0 * (A**2))
     abs(1 + A) + B       --  same as (abs (1 + A)) + B
     Y**(-3)              --  parentheses are necessary
     A / B * C            --  same as (A/B)*C
     A + (B + C)          --  evaluate B + C before adding it to A 

* Menu:

* 4.5.1 ::    Logical Operators and Short-circuit Control Forms
* 4.5.2 ::    Relational Operators and Membership Tests
* 4.5.3 ::    Binary Adding Operators
* 4.5.4 ::    Unary Adding Operators
* 4.5.5 ::    Multiplying Operators
* 4.5.6 ::    Highest Precedence Operators
* 4.5.7 ::    Conditional Expressions
* 4.5.8 ::    Quantified Expressions


File: arm2012.info,  Node: 4.5.1,  Next: 4.5.2,  Up: 4.5

4.5.1 Logical Operators and Short-circuit Control Forms
-------------------------------------------------------

                        _Name Resolution Rules_

1
An expression consisting of two relations connected by and then or or
else (a short-circuit control form) shall resolve to be of some boolean
type; the expected type for both relations is that same boolean type.

                          _Static Semantics_

2
The following logical operators are predefined for every boolean type T,
for every modular type T, and for every one-dimensional array type T
whose component type is a boolean type: 

3
     function "and"(Left, Right : T) return T
     function "or" (Left, Right : T) return T
     function "xor"(Left, Right : T) return T

4
For boolean types, the predefined logical operators and, or, and xor
perform the conventional operations of conjunction, inclusive
disjunction, and exclusive disjunction, respectively.

5
For modular types, the predefined logical operators are defined on a
bit-by-bit basis, using the binary representation of the value of the
operands to yield a binary representation for the result, where zero
represents False and one represents True.  If this result is outside the
base range of the type, a final subtraction by the modulus is performed
to bring the result into the base range of the type.

6
The logical operators on arrays are performed on a
component-by-component basis on matching components (as for equality --
see *note 4.5.2::), using the predefined logical operator for the
component type.  The bounds of the resulting array are those of the left
operand.

                          _Dynamic Semantics_

7
The short-circuit control forms and then and or else deliver the same
result as the corresponding predefined and and or operators for boolean
types, except that the left operand is always evaluated first, and the
right operand is not evaluated if the value of the left operand
determines the result.

8
For the logical operators on arrays, a check is made that for each
component of the left operand there is a matching component of the right
operand, and vice versa. Also, a check is made that each component of
the result belongs to the component subtype. The exception
Constraint_Error is raised if either of the above checks fails.

     NOTES

9
     13  The conventional meaning of the logical operators is given by
     the following truth table:

10
               A     B   (A and B)   (A or B)   (A xor B)

             True     True     True     True     False
             True     False    False    True     True
             False    True     False    True     True
             False    False    False    False    False

                              _Examples_

11
Examples of logical operators:

12
     Sunny or Warm
     Filter(1 .. 10) and Filter(15 .. 24)   --   see *note 3.6.1:: 

13
Examples of short-circuit control forms:

14
     Next_Car.Owner /= null and then Next_Car.Owner.Age > 25   --   see *note 3.10.1::
     N = 0 or else A(N) = Hit_Value


File: arm2012.info,  Node: 4.5.2,  Next: 4.5.3,  Prev: 4.5.1,  Up: 4.5

4.5.2 Relational Operators and Membership Tests
-----------------------------------------------

1
The equality operators = (equals) and /= (not equals) are predefined for
nonlimited types. The other relational_operators are the ordering
operators < (less than), <= (less than or equal), > (greater than), and
>= (greater than or equal). The ordering operators are predefined for
scalar types, and for discrete array types, that is, one-dimensional
array types whose components are of a discrete type.

2/3
A membership test, using in or not in, determines whether or not a value
belongs to any given subtype or range, is equal to any given value, has
a tag that identifies a type that is covered by a given type, or is
convertible to and has an accessibility level appropriate for a given
access type.  Membership tests are allowed for all types.

                        _Name Resolution Rules_

3/3
The tested type of a membership test is determined by the
membership_choices of the membership_choice_list.  Either all
membership_choices of the membership_choice_list shall resolve to the
same type, which is the tested type; or each membership_choice shall be
of an elementary type, and the tested type shall be covered by each of
these elementary types.

3.1/4
If the tested type is tagged, then the tested_simple_expression shall
resolve to be of a type that is convertible (see *note 4.6::) to the
tested type; if untagged, the expected type for the
tested_simple_expression is the tested type.  The expected type of a
choice_simple_expression in a membership_choice, and of a
simple_expression of a range in a membership_choice, is the tested type
of the membership operation.

                           _Legality Rules_

4/4
For a membership test, if the tested_simple_expression is of a tagged
class-wide type, then the tested type shall be (visibly) tagged.

4.1/4
If a membership test includes one or more choice_simple_expressions and
the tested type of the membership test is limited, then the tested type
of the membership test shall have a visible primitive equality operator.

                          _Static Semantics_

5
The result type of a membership test is the predefined type Boolean.

6
The equality operators are predefined for every specific type T that is
not limited, and not an anonymous access type, with the following
specifications:

7
     function "=" (Left, Right : T) return Boolean
     function "/="(Left, Right : T) return Boolean

7.1/2
The following additional equality operators for the universal_access
type are declared in package Standard for use with anonymous access
types:

7.2/2
     function "=" (Left, Right : universal_access) return Boolean
     function "/="(Left, Right : universal_access) return Boolean

8
The ordering operators are predefined for every specific scalar type T,
and for every discrete array type T, with the following specifications:

9
     function "<" (Left, Right : T) return Boolean
     function "<="(Left, Right : T) return Boolean
     function ">" (Left, Right : T) return Boolean
     function ">="(Left, Right : T) return Boolean

                        _Name Resolution Rules_

9.1/2
At least one of the operands of an equality operator for
universal_access shall be of a specific anonymous access type.  Unless
the predefined equality operator is identified using an expanded name
with prefix denoting the package Standard, neither operand shall be of
an access-to-object type whose designated type is D or D'Class, where D
has a user-defined primitive equality operator such that:

9.2/2
   * its result type is Boolean;

9.3/3
   * it is declared immediately within the same declaration list as D or
     any partial or incomplete view of D; and

9.4/2
   * at least one of its operands is an access parameter with designated
     type D.

                           _Legality Rules_

9.5/2
At least one of the operands of the equality operators for
universal_access shall be of type universal_access, or both shall be of
access-to-object types, or both shall be of access-to-subprogram types.
Further:

9.6/2
   * When both are of access-to-object types, the designated types shall
     be the same or one shall cover the other, and if the designated
     types are elementary or array types, then the designated subtypes
     shall statically match;

9.7/2
   * When both are of access-to-subprogram types, the designated
     profiles shall be subtype conformant.

9.8/4
If the profile of an explicitly declared primitive equality operator of
an untagged record type is type conformant with that of the
corresponding predefined equality operator, the declaration shall occur
before the type is frozen. In addition to the places where Legality
Rules normally apply (see *note 12.3::), this rule applies also in the
private part of an instance of a generic unit.

                          _Dynamic Semantics_

10
For discrete types, the predefined relational operators are defined in
terms of corresponding mathematical operations on the position numbers
of the values of the operands.

11
For real types, the predefined relational operators are defined in terms
of the corresponding mathematical operations on the values of the
operands, subject to the accuracy of the type.

12
Two access-to-object values are equal if they designate the same object,
or if both are equal to the null value of the access type.

13
Two access-to-subprogram values are equal if they are the result of the
same evaluation of an Access attribute_reference, or if both are equal
to the null value of the access type.  Two access-to-subprogram values
are unequal if they designate different subprograms. It is unspecified
whether two access values that designate the same subprogram but are the
result of distinct evaluations of Access attribute_references are equal
or unequal.

14/3
For a type extension, predefined equality is defined in terms of the
primitive (possibly user-defined) equals operator for the parent type
and for any components that have a record type in the extension part,
and predefined equality for any other components not inherited from the
parent type.

14.1/3
For a derived type whose parent is an untagged record type, predefined
equality is defined in terms of the primitive (possibly user-defined)
equals operator of the parent type.

15/3
For a private type, if its full type is a record type, predefined
equality is defined in terms of the primitive equals operator of the
full type; otherwise, predefined equality for the private type is that
of its full type.

16
For other composite types, the predefined equality operators (and
certain other predefined operations on composite types -- see *note
4.5.1:: and *note 4.6::) are defined in terms of the corresponding
operation on matching components, defined as follows:

17
   * For two composite objects or values of the same non-array type,
     matching components are those that correspond to the same
     component_declaration or discriminant_specification;

18
   * For two one-dimensional arrays of the same type, matching
     components are those (if any) whose index values match in the
     following sense: the lower bounds of the index ranges are defined
     to match, and the successors of matching indices are defined to
     match;

19
   * For two multidimensional arrays of the same type, matching
     components are those whose index values match in successive index
     positions.

20
The analogous definitions apply if the types of the two objects or
values are convertible, rather than being the same.

21
Given the above definition of matching components, the result of the
predefined equals operator for composite types (other than for those
composite types covered earlier) is defined as follows:

22
   * If there are no components, the result is defined to be True;

23
   * If there are unmatched components, the result is defined to be
     False;

24/3
   * Otherwise, the result is defined in terms of the primitive equals
     operator for any matching components that are records, and the
     predefined equals for any other matching components.

24.1/3
If the primitive equals operator for an untagged record type is
abstract, then Program_Error is raised at the point of any (implicit)
call to that abstract subprogram.

24.2/1
For any composite type, the order in which "=" is called for components
is unspecified.  Furthermore, if the result can be determined before
calling "=" on some components, it is unspecified whether "=" is called
on those components.

25
The predefined "/=" operator gives the complementary result to the
predefined "=" operator.

26/3
For a discrete array type, the predefined ordering operators correspond
to lexicographic order using the predefined order relation of the
component type: A null array is lexicographically less than any array
having at least one component.  In the case of nonnull arrays, the left
operand is lexicographically less than the right operand if the first
component of the left operand is less than that of the right; otherwise,
the left operand is lexicographically less than the right operand only
if their first components are equal and the tail of the left operand is
lexicographically less than that of the right (the tail consists of the
remaining components beyond the first and can be null).

26.1/3
An individual membership test is the membership test of a single
membership_choice.

27/4
For the evaluation of a membership test using in whose
membership_choice_list has a single membership_choice, the
tested_simple_expression and the membership_choice are evaluated in an
arbitrary order; the result is the result of the individual membership
test for the membership_choice.

27.1/4
For the evaluation of a membership test using in whose
membership_choice_list has more than one membership_choice, the
tested_simple_expression of the membership test is evaluated first and
the result of the operation is equivalent to that of a sequence
consisting of an individual membership test on each membership_choice
combined with the short-circuit control form or else.

28/3
An individual membership test yields the result True if:

28.1/4
   * The membership_choice is a choice_simple_expression, and the
     tested_simple_expression is equal to the value of the
     membership_choice.  If the tested type is a record type or a
     limited type, the test uses the primitive equality for the type;
     otherwise, the test uses predefined equality.

28.2/4
   * The membership_choice is a range and the value of the
     tested_simple_expression belongs to the given range.

29/4
   * The membership_choice is a subtype_mark, the tested type is scalar,
     the value of the tested_simple_expression belongs to the range of
     the named subtype, and the value satisfies the predicates of the
     named subtype.

30/4
   * The membership_choice is a subtype_mark, the tested type is not
     scalar, the value of the tested_simple_expression satisfies any
     constraints of the named subtype, the value satisfies the
     predicates of the named subtype, and:

30.1/4
             * if the type of the tested_simple_expression is
               class-wide, the value has a tag that identifies a type
               covered by the tested type;

30.2/4
             * if the tested type is an access type and the named
               subtype excludes null, the value of the
               tested_simple_expression is not null;

30.3/4
             * if the tested type is a general access-to-object type,
               the type of the tested_simple_expression is convertible
               to the tested type and its accessibility level is no
               deeper than that of the tested type; further, if the
               designated type of the tested type is tagged and the
               tested_simple_expression is nonnull, the tag of the
               object designated by the value of the
               tested_simple_expression is covered by the designated
               type of the tested type.

31/3
Otherwise, the test yields the result False.

32
A membership test using not in gives the complementary result to the
corresponding membership test using in.

                     _Implementation Requirements_

32.1/1
For all nonlimited types declared in language-defined packages, the "="
and "/=" operators of the type shall behave as if they were the
predefined equality operators for the purposes of the equality of
composite types and generic formal types.

     NOTES

33/2
     This paragraph was deleted.

34
     14  If a composite type has components that depend on
     discriminants, two values of this type have matching components if
     and only if their discriminants are equal.  Two nonnull arrays have
     matching components if and only if the length of each dimension is
     the same for both.

                              _Examples_

35
Examples of expressions involving relational operators and membership
tests:

36
     X /= Y

37
     "" < "A" and "A" < "Aa"     --  True
     "Aa" < "B" and "A" < "A  "  --  True

38/3
     My_Car = null               -- True if My_Car has been set to null (see *note 3.10.1::)
     My_Car = Your_Car           -- True if we both share the same car
     My_Car.all = Your_Car.all   -- True if the two cars are identical

39/3
     N not in 1 .. 10            -- range membership test
     Today in Mon .. Fri         -- range membership test
     Today in Weekday            -- subtype membership test (see *note 3.5.1::)
     Card in Clubs | Spades      -- list membership test (see *note 3.5.1::)
     Archive in Disk_Unit        -- subtype membership test (see *note 3.8.1::)
     Tree.all in Addition'Class  -- class membership test (see *note 3.9.1::)


File: arm2012.info,  Node: 4.5.3,  Next: 4.5.4,  Prev: 4.5.2,  Up: 4.5

4.5.3 Binary Adding Operators
-----------------------------

                          _Static Semantics_

1
The binary adding operators + (addition) and - (subtraction) are
predefined for every specific numeric type T with their conventional
meaning.  They have the following specifications:

2
     function "+"(Left, Right : T) return T
     function "-"(Left, Right : T) return T

3
The concatenation operators & are predefined for every nonlimited,
one-dimensional array type T with component type C. They have the
following specifications:

4
     function "&"(Left : T; Right : T) return T
     function "&"(Left : T; Right : C) return T
     function "&"(Left : C; Right : T) return T
     function "&"(Left : C; Right : C) return T

                          _Dynamic Semantics_

5
For the evaluation of a concatenation with result type T, if both
operands are of type T, the result of the concatenation is a
one-dimensional array whose length is the sum of the lengths of its
operands, and whose components comprise the components of the left
operand followed by the components of the right operand.  If the left
operand is a null array, the result of the concatenation is the right
operand.  Otherwise, the lower bound of the result is determined as
follows:

6
   * If the ultimate ancestor of the array type was defined by a
     constrained_array_definition, then the lower bound of the result is
     that of the index subtype;

7
   * If the ultimate ancestor of the array type was defined by an
     unconstrained_array_definition, then the lower bound of the result
     is that of the left operand.

8
The upper bound is determined by the lower bound and the length. A check
is made that the upper bound of the result of the concatenation belongs
to the range of the index subtype, unless the result is a null array.
Constraint_Error is raised if this check fails.

9
If either operand is of the component type C, the result of the
concatenation is given by the above rules, using in place of such an
operand an array having this operand as its only component (converted to
the component subtype) and having the lower bound of the index subtype
of the array type as its lower bound. 

10
The result of a concatenation is defined in terms of an assignment to an
anonymous object, as for any function call (see *note 6.5::).

     NOTES

11
     15  As for all predefined operators on modular types, the binary
     adding operators + and - on modular types include a final reduction
     modulo the modulus if the result is outside the base range of the
     type.

                              _Examples_

12
Examples of expressions involving binary adding operators:

13
     Z + 0.1      --  Z has to be of a real type 

14
     "A" & "BCD"  --  concatenation of two string literals
     'A' & "BCD"  --  concatenation of a character literal and a string literal
     'A' & 'A'    --  concatenation of two character literals 


File: arm2012.info,  Node: 4.5.4,  Next: 4.5.5,  Prev: 4.5.3,  Up: 4.5

4.5.4 Unary Adding Operators
----------------------------

                          _Static Semantics_

1
The unary adding operators + (identity) and - (negation) are predefined
for every specific numeric type T with their conventional meaning.  They
have the following specifications:

2
     function "+"(Right : T) return T
     function "-"(Right : T) return T

     NOTES

3
     16  For modular integer types, the unary adding operator -, when
     given a nonzero operand, returns the result of subtracting the
     value of the operand from the modulus; for a zero operand, the
     result is zero.


File: arm2012.info,  Node: 4.5.5,  Next: 4.5.6,  Prev: 4.5.4,  Up: 4.5

4.5.5 Multiplying Operators
---------------------------

                          _Static Semantics_

1
The multiplying operators * (multiplication), / (division), mod
(modulus), and rem (remainder) are predefined for every specific integer
type T:

2
     function "*"  (Left, Right : T) return T
     function "/"  (Left, Right : T) return T
     function "mod"(Left, Right : T) return T
     function "rem"(Left, Right : T) return T

3
Signed integer multiplication has its conventional meaning.

4
Signed integer division and remainder are defined by the relation:

5
     A = (A/B)*B + (A rem B)

6
where (A rem B) has the sign of A and an absolute value less than the
absolute value of B. Signed integer division satisfies the identity:

7
     (-A)/B = -(A/B) = A/(-B)

8/3
The signed integer modulus operator is defined such that the result of A
mod B is either zero, or has the sign of B and an absolute value less
than the absolute value of B; in addition, for some signed integer value
N, this result satisfies the relation:

9
     A = B*N + (A mod B)

10
The multiplying operators on modular types are defined in terms of the
corresponding signed integer operators, followed by a reduction modulo
the modulus if the result is outside the base range of the type (which
is only possible for the "*" operator).

11
Multiplication and division operators are predefined for every specific
floating point type T:

12
     function "*"(Left, Right : T) return T
     function "/"(Left, Right : T) return T

13
The following multiplication and division operators, with an operand of
the predefined type Integer, are predefined for every specific fixed
point type T:

14
     function "*"(Left : T; Right : Integer) return T
     function "*"(Left : Integer; Right : T) return T
     function "/"(Left : T; Right : Integer) return T

15
All of the above multiplying operators are usable with an operand of an
appropriate universal numeric type.  The following additional
multiplying operators for root_real are predefined, and are usable when
both operands are of an appropriate universal or root numeric type, and
the result is allowed to be of type root_real, as in a
number_declaration:

16
     function "*"(Left, Right : root_real) return root_real
     function "/"(Left, Right : root_real) return root_real

17
     function "*"(Left : root_real; Right : root_integer) return root_real
     function "*"(Left : root_integer; Right : root_real) return root_real
     function "/"(Left : root_real; Right : root_integer) return root_real

18
Multiplication and division between any two fixed point types are
provided by the following two predefined operators:

19
     function "*"(Left, Right : universal_fixed) return universal_fixed
     function "/"(Left, Right : universal_fixed) return universal_fixed

                        _Name Resolution Rules_

19.1/2
The above two fixed-fixed multiplying operators shall not be used in a
context where the expected type for the result is itself universal_fixed
-- the context has to identify some other numeric type to which the
result is to be converted, either explicitly or implicitly.  Unless the
predefined universal operator is identified using an expanded name with
prefix denoting the package Standard, an explicit conversion is required
on the result when using the above fixed-fixed multiplication operator
if either operand is of a type having a user-defined primitive
multiplication operator such that:

19.2/3
   * it is declared immediately within the same declaration list as the
     type or any partial or incomplete view thereof; and

19.3/2
   * both of its formal parameters are of a fixed-point type.

19.4/2
A corresponding requirement applies to the universal fixed-fixed
division operator.

Paragraph 20 was deleted.

                          _Dynamic Semantics_

21
The multiplication and division operators for real types have their
conventional meaning.  For floating point types, the accuracy of the
result is determined by the precision of the result type.  For decimal
fixed point types, the result is truncated toward zero if the
mathematical result is between two multiples of the small of the
specific result type (possibly determined by context); for ordinary
fixed point types, if the mathematical result is between two multiples
of the small, it is unspecified which of the two is the result. 

22
The exception Constraint_Error is raised by integer division, rem, and
mod if the right operand is zero.  Similarly, for a real type T with
T'Machine_Overflows True, division by zero raises Constraint_Error.

     NOTES

23
     17  For positive A and B, A/B is the quotient and A rem B is the
     remainder when A is divided by B. The following relations are
     satisfied by the rem operator:

24
               A  rem (-B) =   A rem B
             (-A) rem   B  = -(A rem B)

25
     18  For any signed integer K, the following identity holds:

26
             A mod B   =   (A + K*B) mod B

27
     The relations between signed integer division, remainder, and
     modulus are illustrated by the following table:

28
             A      B   A/B   A rem B  A mod B     A     B    A/B   A rem B   A mod B

29
             10     5    2       0        0       -10    5    -2       0         0
             11     5    2       1        1       -11    5    -2      -1         4
             12     5    2       2        2       -12    5    -2      -2         3
             13     5    2       3        3       -13    5    -2      -3         2
             14     5    2       4        4       -14    5    -2      -4         1

30
             A      B   A/B   A rem B  A mod B     A     B    A/B   A rem B   A mod B

             10    -5   -2       0        0       -10   -5     2       0         0
             11    -5   -2       1       -4       -11   -5     2      -1        -1
             12    -5   -2       2       -3       -12   -5     2      -2        -2
             13    -5   -2       3       -2       -13   -5     2      -3        -3
             14    -5   -2       4       -1       -14   -5     2      -4        -4

                              _Examples_

31
Examples of expressions involving multiplying operators:

32
     I : Integer := 1;
     J : Integer := 2;
     K : Integer := 3;

33
     X : Real := 1.0;                      --     see *note 3.5.7::
     Y : Real := 2.0;

34
     F : Fraction := 0.25;                 --     see *note 3.5.9::
     G : Fraction := 0.5;

35
     Expression     Value     Result Type

     I*J               2         same as I and J, that is, Integer
     K/J               1         same as K and J, that is, Integer
     K mod J     1         same as K and J, that is, Integer

     X/Y               0.5       same as X and Y, that is, Real
     F/2               0.125     same as F, that is, Fraction

     3*F               0.75      same as F, that is, Fraction
     0.75*G            0.375     universal_fixed, implicitly convertible
                                 to any fixed point type
     Fraction(F*G)     0.125     Fraction, as stated by the conversion
     Real(J)*Y         4.0       Real, the type of both operands after
                                 conversion of J


File: arm2012.info,  Node: 4.5.6,  Next: 4.5.7,  Prev: 4.5.5,  Up: 4.5

4.5.6 Highest Precedence Operators
----------------------------------

                          _Static Semantics_

1
The highest precedence unary operator abs (absolute value) is predefined
for every specific numeric type T, with the following specification:

2
     function "abs"(Right : T) return T

3
The highest precedence unary operator not (logical negation) is
predefined for every boolean type T, every modular type T, and for every
one-dimensional array type T whose components are of a boolean type,
with the following specification:

4
     function "not"(Right : T) return T

5
The result of the operator not for a modular type is defined as the
difference between the high bound of the base range of the type and the
value of the operand.  For a binary modulus, this corresponds to a
bit-wise complement of the binary representation of the value of the
operand.

6
The operator not that applies to a one-dimensional array of boolean
components yields a one-dimensional boolean array with the same bounds;
each component of the result is obtained by logical negation of the
corresponding component of the operand (that is, the component that has
the same index value). A check is made that each component of the result
belongs to the component subtype; the exception Constraint_Error is
raised if this check fails.

7
The highest precedence exponentiation operator ** is predefined for
every specific integer type T with the following specification:

8
     function "**"(Left : T; Right : Natural) return T

9
Exponentiation is also predefined for every specific floating point type
as well as root_real, with the following specification (where T is
root_real or the floating point type):

10
     function "**"(Left : T; Right : Integer'Base) return T

11/3
The right operand of an exponentiation is the exponent.  The value of
X**N with the value of the exponent N positive is the same as the value
of X*X*...X (with N-1 multiplications) except that the multiplications
are associated in an arbitrary order.  With N equal to zero, the result
is one.  With the value of N negative (only defined for a floating point
operand), the result is the reciprocal of the result using the absolute
value of N as the exponent.

                     _Implementation Permissions_

12
The implementation of exponentiation for the case of a negative exponent
is allowed to raise Constraint_Error if the intermediate result of the
repeated multiplications is outside the safe range of the type, even
though the final result (after taking the reciprocal) would not be.
(The best machine approximation to the final result in this case would
generally be 0.0.)

     NOTES

13
     19  As implied by the specification given above for exponentiation
     of an integer type, a check is made that the exponent is not
     negative. Constraint_Error is raised if this check fails.


File: arm2012.info,  Node: 4.5.7,  Next: 4.5.8,  Prev: 4.5.6,  Up: 4.5

4.5.7 Conditional Expressions
-----------------------------

1/3
A conditional_expression selects for evaluation at most one of the
enclosed dependent_expressions, depending on a decision among the
alternatives.  One kind of conditional_expression is the if_expression,
which selects for evaluation a dependent_expression depending on the
value of one or more corresponding conditions.  The other kind of
conditional_expression is the case_expression, which selects for
evaluation one of a number of alternative dependent_expressions; the
chosen alternative is determined by the value of a selecting_expression.

                               _Syntax_

2/3
     conditional_expression ::= if_expression | case_expression

3/3
     if_expression ::=
        if condition then dependent_expression
        {elsif condition then dependent_expression}
        [else dependent_expression]

4/3
     condition ::= boolean_expression

5/3
     case_expression ::=
         case selecting_expression is
         case_expression_alternative {,
         case_expression_alternative}

6/3
     case_expression_alternative ::=
         when discrete_choice_list =>
             dependent_expression

7/3
     Wherever the Syntax Rules allow an expression, a
     conditional_expression may be used in place of the expression, so
     long as it is immediately surrounded by parentheses.

                        _Name Resolution Rules_

8/3
If a conditional_expression is expected to be of a type T, then each
dependent_expression of the conditional_expression is expected to be of
type T. Similarly, if a conditional_expression is expected to be of some
class of types, then each dependent_expression of the
conditional_expression is subject to the same expectation.  If a
conditional_expression shall resolve to be of a type T, then each
dependent_expression shall resolve to be of type T.

9/3
The possible types of a conditional_expression are further determined as
follows:

10/3
   * If the conditional_expression is the operand of a type conversion,
     the type of the conditional_expression is the target type of the
     conversion; otherwise,

11/3
   * If all of the dependent_expressions are of the same type, the type
     of the conditional_expression is that type; otherwise,

12/3
   * If a dependent_expression is of an elementary type, the type of the
     conditional_expression shall be covered by that type; otherwise,

13/3
   * If the conditional_expression is expected to be of type T or shall
     resolve to type T, then the conditional_expression is of type T.

14/3
A condition is expected to be of any boolean type.

15/3
The expected type for the selecting_expression and the discrete_choices
are as for case statements (see *note 5.4::). 

                           _Legality Rules_

16/3
All of the dependent_expressions shall be convertible (see *note 4.6::)
to the type of the conditional_expression.

17/3
If the expected type of a conditional_expression is a specific tagged
type, all of the dependent_expressions of the conditional_expression
shall be dynamically tagged, or none shall be dynamically tagged.  In
this case, the conditional_expression is dynamically tagged if all of
the dependent_expressions are dynamically tagged, is tag-indeterminate
if all of the dependent_expressions are tag-indeterminate, and is
statically tagged otherwise.

18/3
If there is no else dependent_expression, the if_expression shall be of
a boolean type.

19/3
All Legality Rules that apply to the discrete_choices of a
case_statement (see *note 5.4::) also apply to the discrete_choices of a
case_expression except within an instance of a generic unit.

                          _Dynamic Semantics_

20/3
For the evaluation of an if_expression, the condition specified after
if, and any conditions specified after elsif, are evaluated in
succession (treating a final else as elsif True then), until one
evaluates to True or all conditions are evaluated and yield False.  If a
condition evaluates to True, the associated dependent_expression is
evaluated, converted to the type of the if_expression, and the resulting
value is the value of the if_expression.  Otherwise (when there is no
else clause), the value of the if_expression is True.

21/3
For the evaluation of a case_expression, the selecting_expression is
first evaluated.  If the value of the selecting_expression is covered by
the discrete_choice_list of some case_expression_alternative, then the
dependent_expression of the case_expression_alternative is evaluated,
converted to the type of the case_expression, and the resulting value is
the value of the case_expression. Otherwise (the value is not covered by
any discrete_choice_list, perhaps due to being outside the base range),
Constraint_Error is raised.


File: arm2012.info,  Node: 4.5.8,  Prev: 4.5.7,  Up: 4.5

4.5.8 Quantified Expressions
----------------------------

0.1/4
Quantified expressions provide a way to write universally and
existentially quantified predicates over containers and arrays.

                               _Syntax_

1/3
     quantified_expression ::= for quantifier 
     loop_parameter_specification => predicate
       | for quantifier iterator_specification => predicate

2/3
     quantifier ::= all | some

3/3
     predicate ::= boolean_expression

4/3
     Wherever the Syntax Rules allow an expression, a
     quantified_expression may be used in place of the expression, so
     long as it is immediately surrounded by parentheses.

                        _Name Resolution Rules_

5/3
The expected type of a quantified_expression is any Boolean type.  The
predicate in a quantified_expression is expected to be of the same type.

                          _Dynamic Semantics_

6/4
For the evaluation of a quantified_expression, the
loop_parameter_specification or iterator_specification is first
elaborated.  The evaluation of a quantified_expression then evaluates
the predicate for the values of the loop parameter in the order
specified by the loop_parameter_specification (see *note 5.5::) or
iterator_specification (see *note 5.5.2::).

7/3
The value of the quantified_expression is determined as follows:

8/4
   * If the quantifier is all, the expression is False if the evaluation
     of any predicate yields False; evaluation of the
     quantified_expression stops at that point.  Otherwise (every
     predicate has been evaluated and yielded True), the expression is
     True.  Any exception raised by evaluation of the predicate is
     propagated.

9/4
   * If the quantifier is some, the expression is True if the evaluation
     of any predicate yields True; evaluation of the
     quantified_expression stops at that point.  Otherwise (every
     predicate has been evaluated and yielded False), the expression is
     False.  Any exception raised by evaluation of the predicate is
     propagated.

                              _Examples_

10/3
The postcondition for a sorting routine on an array A with an index
subtype T can be written:

11/3
     Post => (A'Length < 2 or else
        (for all I in A'First .. T'Pred(A'Last) => A (I) <= A (T'Succ (I))))

12/3
The assertion that a positive number is composite (as opposed to prime)
can be written:

13/3
     pragma Assert (for some X in 2 .. N / 2 => N mod X = 0);


File: arm2012.info,  Node: 4.6,  Next: 4.7,  Prev: 4.5,  Up: 4

4.6 Type Conversions
====================

1/3
Explicit type conversions, both value conversions and view conversions,
are allowed between closely related types as defined below.  This
subclause also defines rules for value and view conversions to a
particular subtype of a type, both explicit ones and those implicit in
other constructs. 

                               _Syntax_

2
     type_conversion ::=
         subtype_mark(expression)
       | subtype_mark(name)

3
The target subtype of a type_conversion is the subtype denoted by the
subtype_mark. The operand of a type_conversion is the expression or name
within the parentheses; its type is the operand type.

4/3
One type is convertible to a second type if a type_conversion with the
first type as operand type and the second type as target type is legal
according to the rules of this subclause.  Two types are convertible if
each is convertible to the other.

5/2
A type_conversion whose operand is the name of an object is called a
view conversion if both its target type and operand type are tagged, or
if it appears in a call as an actual parameter of mode out or in out; 
other type_conversions are called value conversions. 

                        _Name Resolution Rules_

6
The operand of a type_conversion is expected to be of any type.

7
The operand of a view conversion is interpreted only as a name; the
operand of a value conversion is interpreted as an expression.

                           _Legality Rules_

8/2
In a view conversion for an untagged type, the target type shall be
convertible (back) to the operand type.

Paragraphs 9 through 20 were reorganized and moved below.

21/3
If there is a type (other than a root numeric type) that is an ancestor
of both the target type and the operand type, or both types are
class-wide types, then at least one of the following rules shall apply:

21.1/2
   * The target type shall be untagged; or

22
   * The operand type shall be covered by or descended from the target
     type; or

23/2
   * The operand type shall be a class-wide type that covers the target
     type; or

23.1/2
   * The operand and target types shall both be class-wide types and the
     specific type associated with at least one of them shall be an
     interface type.

24/3
If there is no type (other than a root numeric type) that is the
ancestor of both the target type and the operand type, and they are not
both class-wide types, one of the following rules shall apply:

24.1/2
   * If the target type is a numeric type, then the operand type shall
     be a numeric type.

24.2/2
   * If the target type is an array type, then the operand type shall be
     an array type.  Further:

24.3/2
             * The types shall have the same dimensionality;

24.4/2
             * Corresponding index types shall be convertible; 

24.5/2
             * The component subtypes shall statically match; 

24.6/2
             * If the component types are anonymous access types, then
               the accessibility level of the operand type shall not be
               statically deeper than that of the target type; 

24.7/2
             * Neither the target type nor the operand type shall be
               limited;

24.8/2
             * If the target type of a view conversion has aliased
               components, then so shall the operand type; and

24.9/2
             * The operand type of a view conversion shall not have a
               tagged, private, or volatile subcomponent.

24.10/2
   * If the target type is universal_access, then the operand type shall
     be an access type.

24.11/2
   * If the target type is a general access-to-object type, then the
     operand type shall be universal_access or an access-to-object type.
     Further, if the operand type is not universal_access:

24.12/2
             * If the target type is an access-to-variable type, then
               the operand type shall be an access-to-variable type;

24.13/2
             * If the target designated type is tagged, then the operand
               designated type shall be convertible to the target
               designated type; 

24.14/2
             * If the target designated type is not tagged, then the
               designated types shall be the same, and either:

24.15/2
                  * the designated subtypes shall statically match; or

24.16/2
                  * the designated type shall be discriminated in its
                    full view and unconstrained in any partial view, and
                    one of the designated subtypes shall be
                    unconstrained;

24.17/4
             * The accessibility level of the operand type shall not be
               statically deeper than that of the target type, unless
               the target type is an anonymous access type of a
               stand-alone object.  If the target type is that of such a
               stand-alone object, the accessibility level of the
               operand type shall not be statically deeper than that of
               the declaration of the stand-alone object.

24.18/2
   * If the target type is a pool-specific access-to-object type, then
     the operand type shall be universal_access.

24.19/2
   * If the target type is an access-to-subprogram type, then the
     operand type shall be universal_access or an access-to-subprogram
     type.  Further, if the operand type is not universal_access:

24.20/3
             * The designated profiles shall be subtype conformant. 

24.21/4
             * The accessibility level of the operand type shall not be
               statically deeper than that of the target type.  If the
               operand type is declared within a generic body, the
               target type shall be declared within the generic body.

24.22/4
In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules apply also in the private part of an instance of a
generic unit.

                          _Static Semantics_

25
A type_conversion that is a value conversion denotes the value that is
the result of converting the value of the operand to the target subtype.

26/3
A type_conversion that is a view conversion denotes a view of the object
denoted by the operand.  This view is a variable of the target type if
the operand denotes a variable; otherwise, it is a constant of the
target type.

27
The nominal subtype of a type_conversion is its target subtype.

                          _Dynamic Semantics_

28
For the evaluation of a type_conversion that is a value conversion, the
operand is evaluated, and then the value of the operand is converted to
a corresponding value of the target type, if any. If there is no value
of the target type that corresponds to the operand value,
Constraint_Error is raised; this can only happen on conversion to a
modular type, and only when the operand value is outside the base range
of the modular type.  Additional rules follow:

29
   * Numeric Type Conversion

30
             * If the target and the operand types are both integer
               types, then the result is the value of the target type
               that corresponds to the same mathematical integer as the
               operand.

31
             * If the target type is a decimal fixed point type, then
               the result is truncated (toward 0) if the value of the
               operand is not a multiple of the small of the target
               type.

32
             * If the target type is some other real type, then the
               result is within the accuracy of the target type (see
               *note G.2::, "*note G.2:: Numeric Performance
               Requirements", for implementations that support the
               Numerics Annex).

33
             * If the target type is an integer type and the operand
               type is real, the result is rounded to the nearest
               integer (away from zero if exactly halfway between two
               integers).

34
   * Enumeration Type Conversion

35
             * The result is the value of the target type with the same
               position number as that of the operand value.

36
   * Array Type Conversion

37
             * If the target subtype is a constrained array subtype,
               then a check is made that the length of each dimension of
               the value of the operand equals the length of the
               corresponding dimension of the target subtype.  The
               bounds of the result are those of the target subtype.

38
             * If the target subtype is an unconstrained array subtype,
               then the bounds of the result are obtained by converting
               each bound of the value of the operand to the
               corresponding index type of the target type. For each
               nonnull index range, a check is made that the bounds of
               the range belong to the corresponding index subtype.

39
             * In either array case, the value of each component of the
               result is that of the matching component of the operand
               value (see *note 4.5.2::).

39.1/2
             * If the component types of the array types are anonymous
               access types, then a check is made that the accessibility
               level of the operand type is not deeper than that of the
               target type. 

40
   * Composite (Non-Array) Type Conversion

41
             * The value of each nondiscriminant component of the result
               is that of the matching component of the operand value.

42
             * The tag of the result is that of the operand. If the
               operand type is class-wide, a check is made that the tag
               of the operand identifies a (specific) type that is
               covered by or descended from the target type.

43
             * For each discriminant of the target type that corresponds
               to a discriminant of the operand type, its value is that
               of the corresponding discriminant of the operand value; 
               if it corresponds to more than one discriminant of the
               operand type, a check is made that all these
               discriminants are equal in the operand value.

44
             * For each discriminant of the target type that corresponds
               to a discriminant that is specified by the
               derived_type_definition for some ancestor of the operand
               type (or if class-wide, some ancestor of the specific
               type identified by the tag of the operand), its value in
               the result is that specified by the
               derived_type_definition.

45
             * For each discriminant of the operand type that
               corresponds to a discriminant that is specified by the
               derived_type_definition for some ancestor of the target
               type, a check is made that in the operand value it equals
               the value specified for it.

46
             * For each discriminant of the result, a check is made that
               its value belongs to its subtype.

47
   * Access Type Conversion

48/3
             * For an access-to-object type, a check is made that the
               accessibility level of the operand type is not deeper
               than that of the target type, unless the target type is
               an anonymous access type of a stand-alone object.  If the
               target type is that of such a stand-alone object, a check
               is made that the accessibility level of the operand type
               is not deeper than that of the declaration of the
               stand-alone object; then if the check succeeds, the
               accessibility level of the target type becomes that of
               the operand type. 

49/2
             * If the operand value is null, the result of the
               conversion is the null value of the target type.

50
             * If the operand value is not null, then the result
               designates the same object (or subprogram) as is
               designated by the operand value, but viewed as being of
               the target designated subtype (or profile); any checks
               associated with evaluating a conversion to the target
               designated subtype are performed.

51/4
After conversion of the value to the target type, if the target subtype
is constrained, a check is performed that the value satisfies this
constraint.  If the target subtype excludes null, then a check is made
that the value is not null.  If predicate checks are enabled for the
target subtype (see *note 3.2.4::), a check is performed that the value
satisfies the predicates of the target subtype.

52
For the evaluation of a view conversion, the operand name is evaluated,
and a new view of the object denoted by the operand is created, whose
type is the target type; if the target type is composite, checks are
performed as above for a value conversion.

53
The properties of this new view are as follows:

54/1
   * If the target type is composite, the bounds or discriminants (if
     any) of the view are as defined above for a value conversion; each
     nondiscriminant component of the view denotes the matching
     component of the operand object; the subtype of the view is
     constrained if either the target subtype or the operand object is
     constrained, or if the target subtype is indefinite, or if the
     operand type is a descendant of the target type and has
     discriminants that were not inherited from the target type;

55
   * If the target type is tagged, then an assignment to the view
     assigns to the corresponding part of the object denoted by the
     operand; otherwise, an assignment to the view assigns to the
     object, after converting the assigned value to the subtype of the
     object (which might raise Constraint_Error); 

56/4
   * Reading the value of the view yields the result of converting the
     value of the operand object to the target subtype (which might
     raise Constraint_Error), except if the object is of an elementary
     type and the view conversion is passed as an out parameter; in this
     latter case, the value of the operand object may be used to
     initialize the formal parameter without checking against any
     constraint of the target subtype (as described more precisely in
     *note 6.4.1::). 

57/4
If an Accessibility_Check fails, Program_Error is raised.  If a
predicate check fails, the effect is as defined in subclause *note
3.2.4::, "*note 3.2.4:: Subtype Predicates".  Any other check associated
with a conversion raises Constraint_Error if it fails.

58
Conversion to a type is the same as conversion to an unconstrained
subtype of the type.

58.1/4
Evaluation of a value conversion of a composite type either creates a
new anonymous object (similar to the object created by the evaluation of
an aggregate or a function call) or yields a new view of the operand
object without creating a new object:

58.2/4
   * If the target type is a by-reference type and there is a type that
     is an ancestor of both the target type and the operand type then no
     new object is created;

58.3/4
   * If the target type is an array type having aliased components and
     the operand type is an array type having unaliased components, then
     a new object is created;

58.4/4
   * Otherwise, it is unspecified whether a new object is created.

58.5/4
If a new object is created, then the initialization of that object is an
assignment operation.

     NOTES

59
     20  In addition to explicit type_conversions, type conversions are
     performed implicitly in situations where the expected type and the
     actual type of a construct differ, as is permitted by the type
     resolution rules (see *note 8.6::).  For example, an integer
     literal is of the type universal_integer, and is implicitly
     converted when assigned to a target of some specific integer type.
     Similarly, an actual parameter of a specific tagged type is
     implicitly converted when the corresponding formal parameter is of
     a class-wide type.

60
     Even when the expected and actual types are the same, implicit
     subtype conversions are performed to adjust the array bounds (if
     any) of an operand to match the desired target subtype, or to raise
     Constraint_Error if the (possibly adjusted) value does not satisfy
     the constraints of the target subtype.

61/2
     21  A ramification of the overload resolution rules is that the
     operand of an (explicit) type_conversion cannot be an allocator, an
     aggregate, a string_literal, a character_literal, or an
     attribute_reference for an Access or Unchecked_Access attribute.
     Similarly, such an expression enclosed by parentheses is not
     allowed.  A qualified_expression (see *note 4.7::) can be used
     instead of such a type_conversion.

62
     22  The constraint of the target subtype has no effect for a
     type_conversion of an elementary type passed as an out parameter.
     Hence, it is recommended that the first subtype be specified as the
     target to minimize confusion (a similar recommendation applies to
     renaming and generic formal in out objects).

                              _Examples_

63
Examples of numeric type conversion:

64
     Real(2*J)      --  value is converted to floating point
     Integer(1.6)   --  value is 2
     Integer(-0.4)  --  value is 0

65
Example of conversion between derived types:

66
     type A_Form is new B_Form;

67
     X : A_Form;
     Y : B_Form;

68
     X := A_Form(Y);
     Y := B_Form(X);  --  the reverse conversion 

69
Examples of conversions between array types:

70
     type Sequence is array (Integer range <>) of Integer;
     subtype Dozen is Sequence(1 .. 12);
     Ledger : array(1 .. 100) of Integer;

71
     Sequence(Ledger)            --  bounds are those of Ledger
     Sequence(Ledger(31 .. 42))  --  bounds are 31 and 42
     Dozen(Ledger(31 .. 42))     --  bounds are those of Dozen 


File: arm2012.info,  Node: 4.7,  Next: 4.8,  Prev: 4.6,  Up: 4

4.7 Qualified Expressions
=========================

1
A qualified_expression is used to state explicitly the type, and to
verify the subtype, of an operand that is either an expression or an
aggregate. 

                               _Syntax_

2
     qualified_expression ::=
        subtype_mark'(expression) | subtype_mark'aggregate

                        _Name Resolution Rules_

3
The operand (the expression or aggregate) shall resolve to be of the
type determined by the subtype_mark (*note 3.2.2: S0028.), or a
universal type that covers it.

                          _Static Semantics_

3.1/3
If the operand of a qualified_expression denotes an object, the
qualified_expression denotes a constant view of that object.  The
nominal subtype of a qualified_expression is the subtype denoted by the
subtype_mark.

                          _Dynamic Semantics_

4/4
The evaluation of a qualified_expression evaluates the operand (and if
of a universal type, converts it to the type determined by the
subtype_mark) and checks that its value belongs to the subtype denoted
by the subtype_mark. The exception Constraint_Error is raised if this
check fails.  Furthermore, if predicate checks are enabled for the
subtype denoted by the subtype_mark, a check is performed as defined in
subclause *note 3.2.4::, "*note 3.2.4:: Subtype Predicates" that the
value satifies the predicates of the subtype.

     NOTES

5
     23  When a given context does not uniquely identify an expected
     type, a qualified_expression can be used to do so.  In particular,
     if an overloaded name or aggregate is passed to an overloaded
     subprogram, it might be necessary to qualify the operand to resolve
     its type.

                              _Examples_

6
Examples of disambiguating expressions using qualification:

7
     type Mask is (Fix, Dec, Exp, Signif);
     type Code is (Fix, Cla, Dec, Tnz, Sub);

8
     Print (Mask'(Dec));  --  Dec is of type Mask
     Print (Code'(Dec));  --  Dec is of type Code 

9
     for J in Code'(Fix) .. Code'(Dec) loop ... -- qualification needed for either Fix or Dec
     for J in Code range Fix .. Dec loop ...    -- qualification unnecessary
     for J in Code'(Fix) .. Dec loop ...        -- qualification unnecessary for Dec

10
     Dozen'(1 | 3 | 5 | 7 => 2, others => 0) -- see *note 4.6:: 


File: arm2012.info,  Node: 4.8,  Next: 4.9,  Prev: 4.7,  Up: 4

4.8 Allocators
==============

1
The evaluation of an allocator creates an object and yields an access
value that designates the object. 

                               _Syntax_

2/3
     allocator ::=
        new [subpool_specification] subtype_indication
      | new [subpool_specification] qualified_expression

2.1/3
     subpool_specification ::= (subpool_handle_name)

2.2/3
     For an allocator with a subtype_indication, the subtype_indication
     shall not specify a null_exclusion.

                        _Name Resolution Rules_

3/3
The expected type for an allocator shall be a single access-to-object
type with designated type D such that either D covers the type
determined by the subtype_mark of the subtype_indication (*note 3.2.2:
S0027.) or qualified_expression (*note 4.7: S0142.), or the expected
type is anonymous and the determined type is D'Class.  A
subpool_handle_name is expected to be of any type descended from
Subpool_Handle, which is the type used to identify a subpool, declared
in package System.Storage_Pools.Subpools (see *note 13.11.4::).

                           _Legality Rules_

4
An initialized allocator is an allocator with a qualified_expression. An
uninitialized allocator is one with a subtype_indication.  In the
subtype_indication of an uninitialized allocator, a constraint is
permitted only if the subtype_mark denotes an unconstrained composite
subtype; if there is no constraint, then the subtype_mark shall denote a
definite subtype. 

5/2
If the type of the allocator is an access-to-constant type, the
allocator shall be an initialized allocator.

5.1/3
If a subpool_specification is given, the type of the storage pool of the
access type shall be a descendant of Root_Storage_Pool_With_Subpools.

5.2/3
If the designated type of the type of the allocator is class-wide, the
accessibility level of the type determined by the subtype_indication or
qualified_expression shall not be statically deeper than that of the
type of the allocator.

5.3/3
If the subtype determined by the subtype_indication or
qualified_expression of the allocator has one or more access
discriminants, then the accessibility level of the anonymous access type
of each access discriminant shall not be statically deeper than that of
the type of the allocator (see *note 3.10.2::).

5.4/3
An allocator shall not be of an access type for which the Storage_Size
has been specified by a static expression with value zero or is defined
by the language to be zero.

5.5/3
If the designated type of the type of the allocator is limited, then the
allocator shall not be used to define the value of an access
discriminant, unless the discriminated type is immutably limited (see
*note 7.5::).

5.6/3
In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules apply also in the private part of an instance of a
generic unit.

                          _Static Semantics_

6/3
If the designated type of the type of the allocator is elementary, then
the subtype of the created object is the designated subtype.  If the
designated type is composite, then the subtype of the created object is
the designated subtype when the designated subtype is constrained or
there is an ancestor of the designated type that has a constrained
partial view; otherwise, the created object is constrained by its
initial value (even if the designated subtype is unconstrained with
defaults). 

                          _Dynamic Semantics_

7/2
For the evaluation of an initialized allocator, the evaluation of the
qualified_expression is performed first. An object of the designated
type is created and the value of the qualified_expression is converted
to the designated subtype and assigned to the object. 

8
For the evaluation of an uninitialized allocator, the elaboration of the
subtype_indication is performed first.  Then:

9/2
   * If the designated type is elementary, an object of the designated
     subtype is created and any implicit initial value is assigned;

10/2
   * If the designated type is composite, an object of the designated
     type is created with tag, if any, determined by the subtype_mark of
     the subtype_indication.  This object is then initialized by default
     (see *note 3.3.1::) using the subtype_indication to determine its
     nominal subtype. A check is made that the value of the object
     belongs to the designated subtype. Constraint_Error is raised if
     this check fails.  This check and the initialization of the object
     are performed in an arbitrary order.

10.1/3
For any allocator, if the designated type of the type of the allocator
is class-wide, then a check is made that the master of the type
determined by the subtype_indication, or by the tag of the value of the
qualified_expression, includes the elaboration of the type of the
allocator.  If any part of the subtype determined by the
subtype_indication or qualified_expression of the allocator (or by the
tag of the value if the type of the qualified_expression is class-wide)
has one or more access discriminants, then a check is made that the
accessibility level of the anonymous access type of each access
discriminant is not deeper than that of the type of the allocator.
Program_Error is raised if either such check fails. 

10.2/2
If the object to be created by an allocator has a controlled or
protected part, and the finalization of the collection of the type of
the allocator (see *note 7.6.1::) has started, Program_Error is raised. 

10.3/2
If the object to be created by an allocator contains any tasks, and the
master of the type of the allocator is completed, and all of the
dependent tasks of the master are terminated (see *note 9.3::), then
Program_Error is raised. 

10.4/3
If the allocator includes a subpool_handle_name, Constraint_Error is
raised if the subpool handle is null.  Program_Error is raised if the
subpool does not belong (see *note 13.11.4::) to the storage pool of the
access type of the allocator. 

11
If the created object contains any tasks, they are activated (see *note
9.2::).  Finally, an access value that designates the created object is
returned.

                      _Bounded (Run-Time) Errors_

11.1/2
It is a bounded error if the finalization of the collection of the type
(see *note 7.6.1::) of the allocator has started.  If the error is
detected, Program_Error is raised.  Otherwise, the allocation proceeds
normally.

     NOTES

12
     24  Allocators cannot create objects of an abstract type.  See
     *note 3.9.3::.

13
     25  If any part of the created object is controlled, the
     initialization includes calls on corresponding Initialize or Adjust
     procedures.  See *note 7.6::.

14
     26  As explained in *note 13.11::, "*note 13.11:: Storage
     Management", the storage for an object allocated by an allocator
     comes from a storage pool (possibly user defined). The exception
     Storage_Error is raised by an allocator if there is not enough
     storage.  Instances of Unchecked_Deallocation may be used to
     explicitly reclaim storage.

15/3
     27  Implementations are permitted, but not required, to provide
     garbage collection.

                              _Examples_

16
Examples of allocators:

17
     new Cell'(0, null, null)                          -- initialized explicitly, see *note 3.10.1::
     new Cell'(Value => 0, Succ => null, Pred => null) -- initialized explicitly
     new Cell                                          -- not initialized

18
     new Matrix(1 .. 10, 1 .. 20)                      -- the bounds only are given
     new Matrix'(1 .. 10 => (1 .. 20 => 0.0))          -- initialized explicitly

19
     new Buffer(100)                                   -- the discriminant only is given
     new Buffer'(Size => 80, Pos => 0, Value => (1 .. 80 => 'A')) -- initialized explicitly

20
     Expr_Ptr'(new Literal)                  -- allocator for access-to-class-wide type, see *note 3.9.1::
     Expr_Ptr'(new Literal'(Expression with 3.5))      -- initialized explicitly


File: arm2012.info,  Node: 4.9,  Prev: 4.8,  Up: 4

4.9 Static Expressions and Static Subtypes
==========================================

1
Certain expressions of a scalar or string type are defined to be static.
Similarly, certain discrete ranges are defined to be static, and certain
scalar and string subtypes are defined to be static subtypes. Static
means determinable at compile time, using the declared properties or
values of the program entities. 

2
A static expression is a scalar or string expression that is one of the
following:

3
   * a numeric_literal;

4
   * a string_literal of a static string subtype;

5
   * a name that denotes the declaration of a named number or a static
     constant;

6
   * a function_call whose function_name or function_prefix statically
     denotes a static function, and whose actual parameters, if any
     (whether given explicitly or by default), are all static
     expressions;

7
   * an attribute_reference that denotes a scalar value, and whose
     prefix denotes a static scalar subtype;

8
   * an attribute_reference whose prefix statically denotes a statically
     constrained array object or array subtype, and whose
     attribute_designator is First, Last, or Length, with an optional
     dimension;

9
   * a type_conversion whose subtype_mark denotes a static scalar
     subtype, and whose operand is a static expression;

10
   * a qualified_expression whose subtype_mark denotes a static (scalar
     or string) subtype, and whose operand is a static expression;

11/4
   * a membership test whose tested_simple_expression is a static
     expression, and whose membership_choice_list consists only of
     membership_choices that are either static
     choice_simple_expressions, static ranges, or subtype_marks that
     denote a static (scalar or string) subtype;

12
   * a short-circuit control form both of whose relations are static
     expressions;

12.1/3
   * a conditional_expression all of whose conditions,
     selecting_expressions, and dependent_expressions are static
     expressions;

13
   * a static expression enclosed in parentheses.

14
A name statically denotes an entity if it denotes the entity and:

15
   * It is a direct_name, expanded name, or character_literal, and it
     denotes a declaration other than a renaming_declaration; or

16
   * It is an attribute_reference whose prefix statically denotes some
     entity; or

17
   * It denotes a renaming_declaration with a name that statically
     denotes the renamed entity.

18
A static function is one of the following:

19
   * a predefined operator whose parameter and result types are all
     scalar types none of which are descendants of formal scalar types;

20
   * a predefined concatenation operator whose result type is a string
     type;

21
   * an enumeration literal;

22
   * a language-defined attribute that is a function, if the prefix
     denotes a static scalar subtype, and if the parameter and result
     types are scalar.

23
In any case, a generic formal subprogram is not a static function.

24
A static constant is a constant view declared by a full constant
declaration or an object_renaming_declaration (*note 8.5.1: S0200.) with
a static nominal subtype, having a value defined by a static scalar
expression or by a static string expression whose value has a length not
exceeding the maximum length of a string_literal (*note 2.6: S0016.) in
the implementation.

25
A static range is a range whose bounds are static expressions, or a
range_attribute_reference (*note 4.1.4: S0102.) that is equivalent to
such a range. A static discrete_range (*note 3.6.1: S0058.) is one that
is a static range or is a subtype_indication (*note 3.2.2: S0027.) that
defines a static scalar subtype.  The base range of a scalar type is a
static range, unless the type is a descendant of a formal scalar type.

26/3
A static subtype is either a static scalar subtype or a static string
subtype. A static scalar subtype is an unconstrained scalar subtype
whose type is not a descendant of a formal type, or a constrained scalar
subtype formed by imposing a compatible static constraint on a static
scalar subtype. A static string subtype is an unconstrained string
subtype whose index subtype and component subtype are static, or a
constrained string subtype formed by imposing a compatible static
constraint on a static string subtype.  In any case, the subtype of a
generic formal object of mode in out, and the result subtype of a
generic formal function, are not static.  Also, a subtype is not static
if any Dynamic_Predicate specifications apply to it.

27
The different kinds of static constraint are defined as follows:

28
   * A null constraint is always static;

29
   * A scalar constraint is static if it has no range_constraint, or one
     with a static range;

30
   * An index constraint is static if each discrete_range is static, and
     each index subtype of the corresponding array type is static;

31
   * A discriminant constraint is static if each expression of the
     constraint is static, and the subtype of each discriminant is
     static.

31.1/2
In any case, the constraint of the first subtype of a scalar formal type
is neither static nor null.

32
A subtype is statically constrained if it is constrained, and its
constraint is static.  An object is statically constrained if its
nominal subtype is statically constrained, or if it is a static string
constant.

                           _Legality Rules_

32.1/3
An expression is statically unevaluated if it is part of:

32.2/3
   * the right operand of a static short-circuit control form whose
     value is determined by its left operand; or

32.3/3
   * a dependent_expression of an if_expression whose associated
     condition is static and equals False; or

32.4/3
   * a condition or dependent_expression of an if_expression where the
     condition corresponding to at least one preceding
     dependent_expression of the if_expression is static and equals
     True; or

32.5/3
   * a dependent_expression of a case_expression whose
     selecting_expression is static and whose value is not covered by
     the corresponding discrete_choice_list; or

32.6/4
   * a choice_simple_expression (or a simple_expression of a range that
     occurs as a membership_choice of a membership_choice_list) of a
     static membership test that is preceded in the enclosing
     membership_choice_list by another item whose individual membership
     test (see *note 4.5.2::) statically yields True.

33/3
A static expression is evaluated at compile time except when it is
statically unevaluated.  The compile-time evaluation of a static
expression is performed exactly, without performing Overflow_Checks.
For a static expression that is evaluated:

34/3
   * The expression is illegal if its evaluation fails a
     language-defined check other than Overflow_Check.  For the purposes
     of this evaluation, the assertion policy is assumed to be Check.

35/2
   * If the expression is not part of a larger static expression and the
     expression is expected to be of a single specific type, then its
     value shall be within the base range of its expected type.
     Otherwise, the value may be arbitrarily large or small.

36/2
   * If the expression is of type universal_real and its expected type
     is a decimal fixed point type, then its value shall be a multiple
     of the small of the decimal type.  This restriction does not apply
     if the expected type is a descendant of a formal scalar type (or a
     corresponding actual type in an instance).

37/2
In addition to the places where Legality Rules normally apply (see *note
12.3::), the above restrictions also apply in the private part of an
instance of a generic unit.

                     _Implementation Requirements_

38/2
For a real static expression that is not part of a larger static
expression, and whose expected type is not a descendant of a formal
type, the implementation shall round or truncate the value (according to
the Machine_Rounds attribute of the expected type) to the nearest
machine number of the expected type; if the value is exactly half-way
between two machine numbers, the rounding performed is
implementation-defined.  If the expected type is a descendant of a
formal type, or if the static expression appears in the body of an
instance of a generic unit and the corresponding expression is nonstatic
in the corresponding generic body, then no special rounding or
truncating is required -- normal accuracy rules apply (see *note Annex
G::).

                        _Implementation Advice_

38.1/2
For a real static expression that is not part of a larger static
expression, and whose expected type is not a descendant of a formal
type, the rounding should be the same as the default rounding for the
target system.

     NOTES

39
     28  An expression can be static even if it occurs in a context
     where staticness is not required.

40
     29  A static (or run-time) type_conversion from a real type to an
     integer type performs rounding.  If the operand value is exactly
     half-way between two integers, the rounding is performed away from
     zero.

                              _Examples_

41
Examples of static expressions:

42
     1 + 1       -- 2
     abs(-10)*3  -- 30

43
     Kilo : constant := 1000;
     Mega : constant := Kilo*Kilo;   -- 1_000_000
     Long : constant := Float'Digits*2;

44
     Half_Pi    : constant := Pi/2;           -- see *note 3.3.2::
     Deg_To_Rad : constant := Half_Pi/90;
     Rad_To_Deg : constant := 1.0/Deg_To_Rad; -- equivalent to 1.0/((3.14159_26536/2)/90)

* Menu:

* 4.9.1 ::    Statically Matching Constraints and Subtypes


File: arm2012.info,  Node: 4.9.1,  Up: 4.9

4.9.1 Statically Matching Constraints and Subtypes
--------------------------------------------------

                          _Static Semantics_

1/2
A constraint statically matches another constraint if:

1.1/2
   * both are null constraints;

1.2/2
   * both are static and have equal corresponding bounds or discriminant
     values;

1.3/2
   * both are nonstatic and result from the same elaboration of a
     constraint of a subtype_indication (*note 3.2.2: S0027.) or the
     same evaluation of a range of a discrete_subtype_definition (*note
     3.6: S0055.); or

1.4/2
   * both are nonstatic and come from the same formal_type_declaration.

2/3
A subtype statically matches another subtype of the same type if they
have statically matching constraints, all predicate specifications that
apply to them come from the same declarations, and, for access subtypes,
either both or neither exclude null.  Two anonymous access-to-object
subtypes statically match if their designated subtypes statically match,
and either both or neither exclude null, and either both or neither are
access-to-constant.  Two anonymous access-to-subprogram subtypes
statically match if their designated profiles are subtype conformant,
and either both or neither exclude null.

3
Two ranges of the same type statically match if both result from the
same evaluation of a range, or if both are static and have equal
corresponding bounds.

4/3
A constraint is statically compatible with a scalar subtype if it
statically matches the constraint of the subtype, or if both are static
and the constraint is compatible with the subtype. A constraint is
statically compatible with an access or composite subtype if it
statically matches the constraint of the subtype, or if the subtype is
unconstrained.

5/3
Two statically matching subtypes are statically compatible with each
other.  In addition, a subtype S1 is statically compatible with a
subtype S2 if:

6/3
   * the constraint of S1 is statically compatible with S2, and

7/3
   * if S2 excludes null, so does S1, and

8/3
   * either:

9/3
             * all predicate specifications that apply to S2 apply also
               to S1, or

10/4
             * both subtypes are static, every value that satisfies the
               predicates of S1 also satisfies the predicates of S2, and
               it is not the case that both types each have at least one
               applicable predicate specification, predicate checks are
               enabled (see *note 11.4.2::) for S2, and predicate checks
               are not enabled for S1.


File: arm2012.info,  Node: 5,  Next: 6,  Prev: 4,  Up: Top

5 Statements
************

1
A statement defines an action to be performed upon its execution.

2/3
This clause describes the general rules applicable to all statements.
Some statements are discussed in later clauses: Procedure_call_statement
(*note 6.4: S0178.)s and return statements are described in *note 6::,
"*note 6:: Subprograms".  Entry_call_statement (*note 9.5.3: S0225.)s,
requeue_statement (*note 9.5.4: S0226.)s, delay_statement (*note 9.6:
S0227.)s, accept_statement (*note 9.5.2: S0219.)s, select_statement
(*note 9.7: S0230.)s, and abort_statement (*note 9.8: S0245.)s are
described in *note 9::, "*note 9:: Tasks and Synchronization".
Raise_statement (*note 11.3: S0269.)s are described in *note 11::,
"*note 11:: Exceptions", and code_statement (*note 13.8: S0318.)s in
*note 13::.  The remaining forms of statements are presented in this
clause.

* Menu:

* 5.1 ::      Simple and Compound Statements - Sequences of Statements
* 5.2 ::      Assignment Statements
* 5.3 ::      If Statements
* 5.4 ::      Case Statements
* 5.5 ::      Loop Statements
* 5.6 ::      Block Statements
* 5.7 ::      Exit Statements
* 5.8 ::      Goto Statements


File: arm2012.info,  Node: 5.1,  Next: 5.2,  Up: 5

5.1 Simple and Compound Statements - Sequences of Statements
============================================================

1
A statement is either simple or compound.  A simple_statement encloses
no other statement.  A compound_statement can enclose simple_statements
and other compound_statements.

                               _Syntax_

2/3
     sequence_of_statements ::= statement {statement} {label}

3
     statement ::=
        {label} simple_statement | {label} compound_statement

4/2
     simple_statement ::= null_statement
        | assignment_statement   | exit_statement
        | goto_statement   | procedure_call_statement
        | simple_return_statement   | entry_call_statement
        | requeue_statement   | delay_statement
        | abort_statement   | raise_statement
        | code_statement

5/2
     compound_statement ::=
          if_statement   | case_statement
        | loop_statement   | block_statement
        | extended_return_statement
        | accept_statement   | select_statement

6
     null_statement ::= null;

7
     label ::= <<label_statement_identifier>>

8
     statement_identifier ::= direct_name

9
     The direct_name of a statement_identifier shall be an identifier
     (not an operator_symbol).

                        _Name Resolution Rules_

10
The direct_name of a statement_identifier shall resolve to denote its
corresponding implicit declaration (see below).

                           _Legality Rules_

11
Distinct identifiers shall be used for all statement_identifiers that
appear in the same body, including inner block_statements but excluding
inner program units.

                          _Static Semantics_

12
For each statement_identifier, there is an implicit declaration (with
the specified identifier) at the end of the declarative_part of the
innermost block_statement or body that encloses the
statement_identifier.  The implicit declarations occur in the same order
as the statement_identifiers occur in the source text.  If a usage name
denotes such an implicit declaration, the entity it denotes is the
label, loop_statement, or block_statement with the given
statement_identifier.

12.1/3
If one or more labels end a sequence_of_statements, an implicit
null_statement follows the labels before any following constructs.

                          _Dynamic Semantics_

13
The execution of a null_statement has no effect.

14/2
A transfer of control is the run-time action of an exit_statement,
return statement, goto_statement, or requeue_statement, selection of a
terminate_alternative, raising of an exception, or an abort, which
causes the next action performed to be one other than what would
normally be expected from the other rules of the language.  As explained
in *note 7.6.1::, a transfer of control can cause the execution of
constructs to be completed and then left, which may trigger
finalization.

15
The execution of a sequence_of_statements consists of the execution of
the individual statements in succession until the sequence_ is
completed.

     NOTES

16
     1  A statement_identifier that appears immediately within the
     declarative region of a named loop_statement or an accept_statement
     is nevertheless implicitly declared immediately within the
     declarative region of the innermost enclosing body or
     block_statement; in other words, the expanded name for a named
     statement is not affected by whether the statement occurs inside or
     outside a named loop or an accept_statement -- only nesting within
     block_statements is relevant to the form of its expanded name.

                              _Examples_

17
Examples of labeled statements:

18
     <<Here>> <<Ici>> <<Aqui>> <<Hier>> null;

19
     <<After>> X := 1;


File: arm2012.info,  Node: 5.2,  Next: 5.3,  Prev: 5.1,  Up: 5

5.2 Assignment Statements
=========================

1
An assignment_statement replaces the current value of a variable with
the result of evaluating an expression.

                               _Syntax_

2
     assignment_statement ::=
        variable_name := expression;

3
The execution of an assignment_statement includes the evaluation of the
expression and the assignment of the value of the expression into the
target. An assignment operation (as opposed to an assignment_statement
(*note 5.2: S0152.)) is performed in other contexts as well, including
object initialization and by-copy parameter passing. The target of an
assignment operation is the view of the object to which a value is being
assigned; the target of an assignment_statement (*note 5.2: S0152.) is
the variable denoted by the variable_name.

                        _Name Resolution Rules_

4/2
The variable_name of an assignment_statement is expected to be of any
type. The expected type for the expression is the type of the target.

                           _Legality Rules_

5/2
The target denoted by the variable_name shall be a variable of a
nonlimited type.

6
If the target is of a tagged class-wide type T'Class, then the
expression shall either be dynamically tagged, or of type T and
tag-indeterminate (see *note 3.9.2::).

                          _Dynamic Semantics_

7
For the execution of an assignment_statement, the variable_name and the
expression are first evaluated in an arbitrary order.

8
When the type of the target is class-wide:

9
   * If the expression is tag-indeterminate (see *note 3.9.2::), then
     the controlling tag value for the expression is the tag of the
     target;

10
   * Otherwise (the expression is dynamically tagged), a check is made
     that the tag of the value of the expression is the same as that of
     the target; if this check fails, Constraint_Error is raised.

11
The value of the expression is converted to the subtype of the target.
The conversion might raise an exception (see *note 4.6::). 

12
In cases involving controlled types, the target is finalized, and an
anonymous object might be used as an intermediate in the assignment, as
described in *note 7.6.1::, "*note 7.6.1:: Completion and Finalization".
In any case, the converted value of the expression is then assigned to
the target, which consists of the following two steps:

13
   * The value of the target becomes the converted value.

14/3
   * If any part of the target is controlled, its value is adjusted as
     explained in subclause *note 7.6::. 

     NOTES

15
     2  The tag of an object never changes; in particular, an
     assignment_statement does not change the tag of the target.

16/2
     This paragraph was deleted.

                              _Examples_

17
Examples of assignment statements:

18
     Value := Max_Value - 1;
     Shade := Blue;

19
     Next_Frame(F)(M, N) := 2.5;        --  see *note 4.1.1::
     U := Dot_Product(V, W);            --  see *note 6.3::

20/4
     Writer := (Status => Open, Unit => Printer, Line_Count => 60);  -- see *note 3.8.1::
     Next.all := (72074, null, Head);   --  see *note 3.10.1::

21
Examples involving scalar subtype conversions:

22
     I, J : Integer range 1 .. 10 := 5;
     K    : Integer range 1 .. 20 := 15;
      ...

23
     I := J;  --  identical ranges
     K := J;  --  compatible ranges
     J := K;  --  will raise Constraint_Error if K > 10

24
Examples involving array subtype conversions:

25
     A : String(1 .. 31);
     B : String(3 .. 33);
      ...

26
     A := B;  --  same number of components

27
     A(1 .. 9)  := "tar sauce";
     A(4 .. 12) := A(1 .. 9);  --  A(1 .. 12) = "tartar sauce"

     NOTES

28
     3  Notes on the examples: Assignment_statements are allowed even in
     the case of overlapping slices of the same array, because the
     variable_name and expression are both evaluated before copying the
     value into the variable.  In the above example, an implementation
     yielding A(1 ..  12) = "tartartartar" would be incorrect.


File: arm2012.info,  Node: 5.3,  Next: 5.4,  Prev: 5.2,  Up: 5

5.3 If Statements
=================

1
An if_statement selects for execution at most one of the enclosed
sequences_of_statements, depending on the (truth) value of one or more
corresponding conditions.

                               _Syntax_

2
     if_statement ::=
         if condition then
           sequence_of_statements
        {elsif condition then
           sequence_of_statements}
        [else
           sequence_of_statements]
         end if;

Paragraphs 3 and 4 were deleted.

                          _Dynamic Semantics_

5/3
For the execution of an if_statement, the condition specified after if,
and any conditions specified after elsif, are evaluated in succession
(treating a final else as elsif True then), until one evaluates to True
or all conditions are evaluated and yield False.  If a condition
evaluates to True, then the corresponding sequence_of_statements is
executed; otherwise, none of them is executed.

                              _Examples_

6
Examples of if statements:

7
     if Month = December and Day = 31 then
        Month := January;
        Day   := 1;
        Year  := Year + 1;
     end if;

8
     if Line_Too_Short then
        raise Layout_Error;
     elsif Line_Full then
        New_Line;
        Put(Item);
     else
        Put(Item);
     end if;

9
     if My_Car.Owner.Vehicle /= My_Car then            --  see *note 3.10.1::
        Report ("Incorrect data");
     end if;


File: arm2012.info,  Node: 5.4,  Next: 5.5,  Prev: 5.3,  Up: 5

5.4 Case Statements
===================

1
A case_statement selects for execution one of a number of alternative
sequences_of_statements; the chosen alternative is defined by the value
of an expression.

                               _Syntax_

2/3
     case_statement ::=
        case selecting_expression is
            case_statement_alternative
           {case_statement_alternative}
        end case;

3
     case_statement_alternative ::=
        when discrete_choice_list =>
           sequence_of_statements

                        _Name Resolution Rules_

4/3
The selecting_expression is expected to be of any discrete type. The
expected type for each discrete_choice is the type of the
selecting_expression.

                           _Legality Rules_

5/3
The choice_expressions, subtype_indications, and ranges given as
discrete_choices of a case_statement shall be static.  A discrete_choice
others, if present, shall appear alone and in the last
discrete_choice_list.

6/3
The possible values of the selecting_expression shall be covered (see
*note 3.8.1::) as follows:

7/4
   * If the selecting_expression is a name (including a type_conversion,
     qualified_expression, or function_call) having a static and
     constrained nominal subtype, then each non-others discrete_choice
     shall cover only values in that subtype that satisfy its predicates
     (see *note 3.2.4::), and each value of that subtype that satisfies
     its predicates shall be covered by some discrete_choice (either
     explicitly or by others).

8/3
   * If the type of the selecting_expression is root_integer,
     universal_integer, or a descendant of a formal scalar type, then
     the case_statement shall have an others discrete_choice.

9/3
   * Otherwise, each value of the base range of the type of the
     selecting_expression shall be covered (either explicitly or by
     others).

10
Two distinct discrete_choices of a case_statement shall not cover the
same value.

                          _Dynamic Semantics_

11/3
For the execution of a case_statement the selecting_expression is first
evaluated.

12/3
If the value of the selecting_expression is covered by the
discrete_choice_list (*note 3.8.1: S0073.) of some
case_statement_alternative (*note 5.4: S0155.), then the
sequence_of_statements (*note 5.1: S0145.) of the _alternative is
executed.

13
Otherwise (the value is not covered by any discrete_choice_list, perhaps
due to being outside the base range), Constraint_Error is raised.

     NOTES

14
     4  The execution of a case_statement chooses one and only one
     alternative.  Qualification of the expression of a case_statement
     by a static subtype can often be used to limit the number of
     choices that need be given explicitly.

                              _Examples_

15
Examples of case statements:

16
     case Sensor is
        when Elevation   => Record_Elevation(Sensor_Value);
        when Azimuth   => Record_Azimuth  (Sensor_Value);
        when Distance   => Record_Distance (Sensor_Value);
        when others   => null;
     end case;

17
     case Today is
        when Mon   => Compute_Initial_Balance;
        when Fri   => Compute_Closing_Balance;
        when Tue .. Thu   => Generate_Report(Today);
        when Sat .. Sun   => null;
     end case;

18
     case Bin_Number(Count) is
        when 1   => Update_Bin(1);
        when 2   => Update_Bin(2);
        when 3 | 4   =>
           Empty_Bin(1);
           Empty_Bin(2);
        when others   => raise Error;
     end case;


File: arm2012.info,  Node: 5.5,  Next: 5.6,  Prev: 5.4,  Up: 5

5.5 Loop Statements
===================

1
A loop_statement includes a sequence_of_statements that is to be
executed repeatedly, zero or more times.

                               _Syntax_

2
     loop_statement ::=
        [loop_statement_identifier:]
           [iteration_scheme] loop
              sequence_of_statements
            end loop [loop_identifier];

3/3
     iteration_scheme ::= while condition
        | for loop_parameter_specification
        | for iterator_specification

4
     loop_parameter_specification ::=
        defining_identifier in [reverse] discrete_subtype_definition

5
     If a loop_statement has a loop_statement_identifier, then the
     identifier shall be repeated after the end loop; otherwise, there
     shall not be an identifier after the end loop.

                          _Static Semantics_

6
A loop_parameter_specification declares a loop parameter, which is an
object whose subtype is that defined by the discrete_subtype_definition.

                          _Dynamic Semantics_

7
For the execution of a loop_statement, the sequence_of_statements is
executed repeatedly, zero or more times, until the loop_statement is
complete.  The loop_statement is complete when a transfer of control
occurs that transfers control out of the loop, or, in the case of an
iteration_scheme, as specified below.

8
For the execution of a loop_statement with a while iteration_scheme, the
condition is evaluated before each execution of the
sequence_of_statements (*note 5.1: S0145.); if the value of the
condition is True, the sequence_of_statements (*note 5.1: S0145.) is
executed; if False, the execution of the loop_statement (*note 5.5:
S0156.) is complete.

9/4
For the execution of a loop_statement with the iteration_scheme being
for loop_parameter_specification (*note 5.5: S0158.), the
loop_parameter_specification (*note 5.5: S0158.) is first elaborated.
This elaboration creates the loop parameter and elaborates the
discrete_subtype_definition (*note 3.6: S0055.).  If the
discrete_subtype_definition (*note 3.6: S0055.) defines a subtype with a
null range, the execution of the loop_statement is complete.  Otherwise,
the sequence_of_statements (*note 5.1: S0145.) is executed once for each
value of the discrete subtype defined by the discrete_subtype_definition
(*note 3.6: S0055.) that satisfies the predicates of the subtype (or
until the loop is left as a consequence of a transfer of control). Prior
to each such iteration, the corresponding value of the discrete subtype
is assigned to the loop parameter.  These values are assigned in
increasing order unless the reserved word reverse is present, in which
case the values are assigned in decreasing order.

9.1/3
For details about the execution of a loop_statement with the
iteration_scheme being for iterator_specification, see *note 5.5.2::.

     NOTES

10
     5  A loop parameter is a constant; it cannot be updated within the
     sequence_of_statements of the loop (see *note 3.3::).

11
     6  An object_declaration should not be given for a loop parameter,
     since the loop parameter is automatically declared by the
     loop_parameter_specification.  The scope of a loop parameter
     extends from the loop_parameter_specification to the end of the
     loop_statement, and the visibility rules are such that a loop
     parameter is only visible within the sequence_of_statements of the
     loop.

12
     7  The discrete_subtype_definition of a for loop is elaborated just
     once.  Use of the reserved word reverse does not alter the discrete
     subtype defined, so that the following iteration_schemes are not
     equivalent; the first has a null range.

13
          for J in reverse 1 .. 0
          for J in 0 .. 1

                              _Examples_

14
Example of a loop statement without an iteration scheme:

15
     loop
        Get(Current_Character);
        exit when Current_Character = '*';
     end loop;

16
Example of a loop statement with a while iteration scheme:

17
     while Bid(N).Price < Cut_Off.Price loop
        Record_Bid(Bid(N).Price);
        N := N + 1;
     end loop;

18
Example of a loop statement with a for iteration scheme:

19
     for J in Buffer'Range loop     --  works even with a null range
        if Buffer(J) /= Space then
           Put(Buffer(J));
        end if;
     end loop;

20
Example of a loop statement with a name:

21
     Summation:
        while Next /= Head loop       -- see *note 3.10.1::
           Sum  := Sum + Next.Value;
           Next := Next.Succ;
        end loop Summation;

* Menu:

* 5.5.1 ::    User-Defined Iterator Types
* 5.5.2 ::    Generalized Loop Iteration


File: arm2012.info,  Node: 5.5.1,  Next: 5.5.2,  Up: 5.5

5.5.1 User-Defined Iterator Types
---------------------------------

                          _Static Semantics_

1/3
The following language-defined generic library package exists:

2/3
     generic
        type Cursor;
        with function Has_Element (Position : Cursor) return Boolean;
     package Ada.Iterator_Interfaces is
        pragma Pure (Iterator_Interfaces);

3/3
        type Forward_Iterator is limited interface;
        function First (Object : Forward_Iterator) return Cursor is abstract;
        function Next (Object : Forward_Iterator; Position : Cursor)
           return Cursor is abstract;

4/3
        type Reversible_Iterator is limited interface and Forward_Iterator;
        function Last (Object : Reversible_Iterator) return Cursor is abstract;
        function Previous (Object : Reversible_Iterator; Position : Cursor)
           return Cursor is abstract;

5/3
     end Ada.Iterator_Interfaces;

6/3
An iterator type is a type descended from the Forward_Iterator interface
from some instance of Ada.Iterator_Interfaces.  A reversible iterator
type is a type descended from the Reversible_Iterator interface from
some instance of Ada.Iterator_Interfaces.  An iterator object is an
object of an iterator type.  A reversible iterator object is an object
of a reversible iterator type.  The formal subtype Cursor from the
associated instance of Ada.Iterator_Interfaces is the iteration cursor
subtype for the iterator type.

7/3
The following type-related operational aspects may be specified for an
indexable container type T (see *note 4.1.6::):

8/3
Default_Iterator
               This aspect is specified by a name that denotes exactly
               one function declared immediately within the same
               declaration list in which T is declared, whose first
               parameter is of type T or T'Class or an access parameter
               whose designated type is type T or T'Class, whose other
               parameters, if any, have default expressions, and whose
               result type is an iterator type.  This function is the
               default iterator function for T. Its result subtype is
               the default iterator subtype for T. The iteration cursor
               subtype for the default iterator subtype is the default
               cursor subtype for T.

9/3
Iterator_Element
               This aspect is specified by a name that denotes a
               subtype.  This is the default element subtype for T.

10/3
These aspects are inherited by descendants of type T (including
T'Class).

11/3
An iterable container type is an indexable container type with specified
Default_Iterator and Iterator_Element aspects.  A reversible iterable
container type is an iterable container type with the default iterator
type being a reversible iterator type.  An iterable container object is
an object of an iterable container type.  A reversible iterable
container object is an object of a reversible iterable container type.

11.1/4
The Default_Iterator and Iterator_Element aspects are nonoverridable
(see *note 13.1.1::).

                           _Legality Rules_

12/3
The Constant_Indexing aspect (if any) of an iterable container type T
shall denote exactly one function with the following properties:

13/3
   * the result type of the function is covered by the default element
     type of T or is a reference type (see *note 4.1.5::) with an access
     discriminant designating a type covered by the default element type
     of T;

14/3
   * the type of the second parameter of the function covers the default
     cursor type for T;

15/3
   * if there are more than two parameters, the additional parameters
     all have default expressions.

16/3
This function (if any) is the default constant indexing function for T.

17/3
The Variable_Indexing aspect (if any) of an iterable container type T
shall denote exactly one function with the following properties:

18/3
   * the result type of the function is a reference type (see *note
     4.1.5::) with an access discriminant designating a type covered by
     the default element type of T;

19/3
   * the type of the second parameter of the function covers the default
     cursor type for T;

20/3
   * if there are more than two parameters, the additional parameters
     all have default expressions.

21/3
This function (if any) is the default variable indexing function for T.


File: arm2012.info,  Node: 5.5.2,  Prev: 5.5.1,  Up: 5.5

5.5.2 Generalized Loop Iteration
--------------------------------

1/3
Generalized forms of loop iteration are provided by an
iterator_specification.

                               _Syntax_

2/3
     iterator_specification ::=
         defining_identifier in [reverse] iterator_name
       | defining_identifier [: 
     subtype_indication] of [reverse] iterable_name

                        _Name Resolution Rules_

3/3
For the first form of iterator_specification, called a generalized
iterator, the expected type for the iterator_name is any iterator type.
For the second form of iterator_specification, the expected type for the
iterable_name is any array or iterable container type.  If the
iterable_name denotes an array object, the iterator_specification is
called an array component iterator; otherwise it is called a container
element iterator.

                           _Legality Rules_

4/3
If the reserved word reverse appears, the iterator_specification is a
reverse iterator; otherwise it is a forward iterator.  In a reverse
generalized iterator, the iterator_name shall be of a reversible
iterator type.  In a reverse container element iterator, the default
iterator type for the type of the iterable_name shall be a reversible
iterator type.

5/4
The subtype defined by the subtype_indication, if any, of an array
component iterator shall statically match the component subtype of the
type of the iterable_name.  The subtype defined by the
subtype_indication, if any, of a container element iterator shall
statically match the default element subtype for the type of the
iterable_name.

6/3
In a container element iterator whose iterable_name has type T, if the
iterable_name denotes a constant or the Variable_Indexing aspect is not
specified for T, then the Constant_Indexing aspect shall be specified
for T.

6.1/4
The iterator_name or iterable_name of an iterator_specification shall
not denote a subcomponent that depends on discriminants of an object
whose nominal subtype is unconstrained, unless the object is known to be
constrained.

6.2/4
A container element iterator is illegal if the call of the default
iterator function that creates the loop iterator (see below) is illegal.

6.3/4
A generalized iterator is illegal if the iteration cursor subtype of the
iterator_name is a limited type at the point of the generalized
iterator.  A container element iterator is illegal if the default cursor
subtype of the type of the iterable_name is a limited type at the point
of the container element iterator.

                          _Static Semantics_

7/3
An iterator_specification declares a loop parameter.  In a generalized
iterator, the nominal subtype of the loop parameter is the iteration
cursor subtype.  In an array component iterator or a container element
iterator, if a subtype_indication is present, it determines the nominal
subtype of the loop parameter.  In an array component iterator, if a
subtype_indication is not present, the nominal subtype of the loop
parameter is the component subtype of the type of the iterable_name.  In
a container element iterator, if a subtype_indication is not present,
the nominal subtype of the loop parameter is the default element subtype
for the type of the iterable_name.

8/3
In a generalized iterator, the loop parameter is a constant.  In an
array component iterator, the loop parameter is a constant if the
iterable_name denotes a constant; otherwise it denotes a variable.  In a
container element iterator, the loop parameter is a constant if the
iterable_name denotes a constant, or if the Variable_Indexing aspect is
not specified for the type of the iterable_name; otherwise it is a
variable.

                          _Dynamic Semantics_

9/3
For the execution of a loop_statement with an iterator_specification,
the iterator_specification is first elaborated.  This elaboration
elaborates the subtype_indication, if any.

10/3
For a generalized iterator, the loop parameter is created, the
iterator_name is evaluated, and the denoted iterator object becomes the
loop iterator.  In a forward generalized iterator, the operation First
of the iterator type is called on the loop iterator, to produce the
initial value for the loop parameter.  If the result of calling
Has_Element on the initial value is False, then the execution of the
loop_statement is complete.  Otherwise, the sequence_of_statements is
executed and then the Next operation of the iterator type is called with
the loop iterator and the current value of the loop parameter to produce
the next value to be assigned to the loop parameter.  This repeats until
the result of calling Has_Element on the loop parameter is False, or the
loop is left as a consequence of a transfer of control.  For a reverse
generalized iterator, the operations Last and Previous are called rather
than First and Next.

11/3
For an array component iterator, the iterable_name is evaluated and the
denoted array object becomes the array for the loop.  If the array for
the loop is a null array, then the execution of the loop_statement is
complete.  Otherwise, the sequence_of_statements is executed with the
loop parameter denoting each component of the array for the loop, using
a canonical order of components, which is last dimension varying fastest
(unless the array has convention Fortran, in which case it is first
dimension varying fastest).  For a forward array component iterator, the
iteration starts with the component whose index values are each the
first in their index range, and continues in the canonical order.  For a
reverse array component iterator, the iteration starts with the
component whose index values are each the last in their index range, and
continues in the reverse of the canonical order.  The loop iteration
proceeds until the sequence_of_statements has been executed for each
component of the array for the loop, or until the loop is left as a
consequence of a transfer of control.

12/3
For a container element iterator, the iterable_name is evaluated and the
denoted iterable container object becomes the iterable container object
for the loop.  The default iterator function for the type of the
iterable container object for the loop is called on the iterable
container object and the result is the loop iterator.  An object of the
default cursor subtype is created (the loop cursor).

13/3
For a forward container element iterator, the operation First of the
iterator type is called on the loop iterator, to produce the initial
value for the loop cursor.  If the result of calling Has_Element on the
initial value is False, then the execution of the loop_statement is
complete.  Otherwise, the sequence_of_statements is executed with the
loop parameter denoting an indexing (see *note 4.1.6::) into the
iterable container object for the loop, with the only parameter to the
indexing being the current value of the loop cursor; then the Next
operation of the iterator type is called with the loop iterator and the
loop cursor to produce the next value to be assigned to the loop cursor.
This repeats until the result of calling Has_Element on the loop cursor
is False, or until the loop is left as a consequence of a transfer of
control.  For a reverse container element iterator, the operations Last
and Previous are called rather than First and Next.  If the loop
parameter is a constant (see above), then the indexing uses the default
constant indexing function for the type of the iterable container object
for the loop; otherwise it uses the default variable indexing function.

14/4
Any exception propagated by the execution of a generalized iterator or
container element iterator is propagated by the immediately enclosing
loop statement.

                              _Examples_

15/3
     -- Array component iterator example:
     for Element of Board loop  -- See *note 3.6.1::.
        Element := Element * 2.0; -- Double each element of Board, a two-dimensional array.
     end loop;

16/3
For examples of use of generalized iterators, see *note A.18.32:: and
the corresponding container packages in *note A.18.2:: and *note
A.18.3::.


File: arm2012.info,  Node: 5.6,  Next: 5.7,  Prev: 5.5,  Up: 5

5.6 Block Statements
====================

1
A block_statement encloses a handled_sequence_of_statements optionally
preceded by a declarative_part.

                               _Syntax_

2
     block_statement ::=
        [block_statement_identifier:]
            [declare
                 declarative_part]
             begin
                 handled_sequence_of_statements
             end [block_identifier];

3
     If a block_statement has a block_statement_identifier, then the
     identifier shall be repeated after the end; otherwise, there shall
     not be an identifier after the end.

                          _Static Semantics_

4
A block_statement that has no explicit declarative_part has an implicit
empty declarative_part.

                          _Dynamic Semantics_

5
The execution of a block_statement consists of the elaboration of its
declarative_part followed by the execution of its
handled_sequence_of_statements.

                              _Examples_

6
Example of a block statement with a local variable:

7
     Swap:
        declare
           Temp : Integer;
        begin
           Temp := V; V := U; U := Temp;
        end Swap;


File: arm2012.info,  Node: 5.7,  Next: 5.8,  Prev: 5.6,  Up: 5

5.7 Exit Statements
===================

1
An exit_statement is used to complete the execution of an enclosing
loop_statement; the completion is conditional if the exit_statement
includes a condition.

                               _Syntax_

2
     exit_statement ::=
        exit [loop_name] [when condition];

                        _Name Resolution Rules_

3
The loop_name, if any, in an exit_statement shall resolve to denote a
loop_statement.

                           _Legality Rules_

4
Each exit_statement (*note 5.7: S0161.) applies to a loop_statement
(*note 5.5: S0156.); this is the loop_statement (*note 5.5: S0156.)
being exited.  An exit_statement (*note 5.7: S0161.) with a name is only
allowed within the loop_statement (*note 5.5: S0156.) denoted by the
name, and applies to that loop_statement (*note 5.5: S0156.).  An
exit_statement (*note 5.7: S0161.) without a name is only allowed within
a loop_statement (*note 5.5: S0156.), and applies to the innermost
enclosing one.  An exit_statement (*note 5.7: S0161.) that applies to a
given loop_statement (*note 5.5: S0156.) shall not appear within a body
or accept_statement (*note 9.5.2: S0219.), if this construct is itself
enclosed by the given loop_statement.

                          _Dynamic Semantics_

5
For the execution of an exit_statement, the condition, if present, is
first evaluated.  If the value of the condition is True, or if there is
no condition, a transfer of control is done to complete the
loop_statement (*note 5.5: S0156.).  If the value of the condition is
False, no transfer of control takes place.

     NOTES

6
     8  Several nested loops can be exited by an exit_statement that
     names the outer loop.

                              _Examples_

7
Examples of loops with exit statements:

8
     for N in 1 .. Max_Num_Items loop
        Get_New_Item(New_Item);
        Merge_Item(New_Item, Storage_File);
        exit when New_Item = Terminal_Item;
     end loop;

9
     Main_Cycle:
        loop
           --  initial statements
           exit Main_Cycle when Found;
           --  final statements
        end loop Main_Cycle;


File: arm2012.info,  Node: 5.8,  Prev: 5.7,  Up: 5

5.8 Goto Statements
===================

1
A goto_statement specifies an explicit transfer of control from this
statement to a target statement with a given label.

                               _Syntax_

2
     goto_statement ::= goto label_name;

                        _Name Resolution Rules_

3
The label_name shall resolve to denote a label; the statement with that
label is the target statement.

                           _Legality Rules_

4
The innermost sequence_of_statements that encloses the target statement
shall also enclose the goto_statement.  Furthermore, if a goto_statement
is enclosed by an accept_statement or a body, then the target statement
shall not be outside this enclosing construct.

                          _Dynamic Semantics_

5
The execution of a goto_statement transfers control to the target
statement, completing the execution of any compound_statement that
encloses the goto_statement but does not enclose the target.

     NOTES

6
     9  The above rules allow transfer of control to a statement of an
     enclosing sequence_of_statements but not the reverse.  Similarly,
     they prohibit transfers of control such as between alternatives of
     a case_statement, if_statement, or select_statement; between
     exception_handlers; or from an exception_handler of a
     handled_sequence_of_statements back to its sequence_of_statements.

                              _Examples_

7
Example of a loop containing a goto statement:

8
     <<Sort>>
     for I in 1 .. N-1 loop
        if A(I) > A(I+1) then
           Exchange(A(I), A(I+1));
           goto Sort;
        end if;
     end loop;


File: arm2012.info,  Node: 6,  Next: 7,  Prev: 5,  Up: Top

6 Subprograms
*************

1
A subprogram is a program unit or intrinsic operation whose execution is
invoked by a subprogram call.  There are two forms of subprogram:
procedures and functions.  A procedure call is a statement; a function
call is an expression and returns a value.  The definition of a
subprogram can be given in two parts: a subprogram declaration defining
its interface, and a subprogram_body defining its execution.  Operators
and enumeration literals are functions.

2/3
A callable entity is a subprogram or entry (see Section 9). A callable
entity is invoked by a call; that is, a subprogram call or entry call. A
callable construct is a construct that defines the action of a call upon
a callable entity: a subprogram_body, entry_body, or accept_statement.

* Menu:

* 6.1 ::      Subprogram Declarations
* 6.2 ::      Formal Parameter Modes
* 6.3 ::      Subprogram Bodies
* 6.4 ::      Subprogram Calls
* 6.5 ::      Return Statements
* 6.6 ::      Overloading of Operators
* 6.7 ::      Null Procedures
* 6.8 ::      Expression Functions


File: arm2012.info,  Node: 6.1,  Next: 6.2,  Up: 6

6.1 Subprogram Declarations
===========================

1
A subprogram_declaration declares a procedure or function.

                               _Syntax_

2/3
     subprogram_declaration ::=
         [overriding_indicator]
         subprogram_specification
             [aspect_specification];

3/2
     This paragraph was deleted.

4/2
     subprogram_specification ::=
         procedure_specification
       | function_specification

4.1/2
     procedure_specification ::= procedure defining_program_unit_name 
     parameter_profile

4.2/2
     function_specification ::= function defining_designator 
     parameter_and_result_profile

5
     designator ::= [parent_unit_name . ]identifier | operator_symbol

6
     defining_designator ::= defining_program_unit_name | 
     defining_operator_symbol

7
     defining_program_unit_name ::= [parent_unit_name . ]
     defining_identifier

8
     The optional parent_unit_name is only allowed for library units
     (see *note 10.1.1::).

9
     operator_symbol ::= string_literal

10/3
     The sequence of characters in an operator_symbol shall form a
     reserved word, a delimiter, or compound delimiter that corresponds
     to an operator belonging to one of the six categories of operators
     defined in subclause *note 4.5::.

11
     defining_operator_symbol ::= operator_symbol

12
     parameter_profile ::= [formal_part]

13/2
     parameter_and_result_profile ::=
         [formal_part] return [null_exclusion] subtype_mark
       | [formal_part] return access_definition

14
     formal_part ::=
        (parameter_specification {; parameter_specification})

15/3
     parameter_specification ::=
         defining_identifier_list : [aliased] mode [null_exclusion] 
     subtype_mark [:= default_expression]
       | defining_identifier_list : access_definition [:= 
     default_expression]

16
     mode ::= [in] | in out | out

                        _Name Resolution Rules_

17
A formal parameter is an object directly visible within a
subprogram_body that represents the actual parameter passed to the
subprogram in a call; it is declared by a parameter_specification. For a
formal parameter, the expected type for its default_expression, if any,
is that of the formal parameter. 

                           _Legality Rules_

18/3
The parameter mode of a formal parameter conveys the direction of
information transfer with the actual parameter: in, in out, or out.
Mode in is the default, and is the mode of a parameter defined by an
access_definition.

19
A default_expression is only allowed in a parameter_specification for a
formal parameter of mode in.

20/3
A subprogram_declaration or a generic_subprogram_declaration requires a
completion unless the Import aspect (see *note B.1::) is True for the
declaration; the completion shall be a body or a renaming_declaration
(see *note 8.5::).  A completion is not allowed for an
abstract_subprogram_declaration (see *note 3.9.3::), a
null_procedure_declaration (see *note 6.7::), or an
expression_function_declaration (see *note 6.8::).

21
A name that denotes a formal parameter is not allowed within the
formal_part in which it is declared, nor within the formal_part of a
corresponding body or accept_statement.

                          _Static Semantics_

22
The profile of (a view of) a callable entity is either a
parameter_profile or parameter_and_result_profile; it embodies
information about the interface to that entity -- for example, the
profile includes information about parameters passed to the callable
entity.  All callable entities have a profile -- enumeration literals,
other subprograms, and entries.  An access-to-subprogram type has a
designated profile.  Associated with a profile is a calling convention.
A subprogram_declaration declares a procedure or a function, as
indicated by the initial reserved word, with name and profile as given
by its specification.

23/2
The nominal subtype of a formal parameter is the subtype determined by
the optional null_exclusion and the subtype_mark, or defined by the
access_definition, in the parameter_specification.  The nominal subtype
of a function result is the subtype determined by the optional
null_exclusion and the subtype_mark, or defined by the
access_definition, in the parameter_and_result_profile. 

23.1/3
An explicitly aliased parameter is a formal parameter whose
parameter_specification includes the reserved word aliased.

24/2
An access parameter is a formal in parameter specified by an
access_definition. An access result type is a function result type
specified by an access_definition.  An access parameter or result type
is of an anonymous access type (see *note 3.10::).  Access parameters of
an access-to-object type allow dispatching calls to be controlled by
access values.  Access parameters of an access-to-subprogram type permit
calls to subprograms passed as parameters irrespective of their
accessibility level.

25
The subtypes of a profile are:

26
   * For any non-access parameters, the nominal subtype of the
     parameter.

27/2
   * For any access parameters of an access-to-object type, the
     designated subtype of the parameter type.

27.1/3
   * For any access parameters of an access-to-subprogram type, the
     subtypes of the designated profile of the parameter type.

28/2
   * For any non-access result, the nominal subtype of the function
     result.

28.1/2
   * For any access result type of an access-to-object type, the
     designated subtype of the result type.

28.2/3
   * For any access result type of an access-to-subprogram type, the
     subtypes of the designated profile of the result type.

29
The types of a profile are the types of those subtypes.

30/3
A subprogram declared by an abstract_subprogram_declaration is abstract;
a subprogram declared by a subprogram_declaration is not.  See *note
3.9.3::, "*note 3.9.3:: Abstract Types and Subprograms".  Similarly, a
procedure declared by a null_procedure_declaration is a null procedure;
a procedure declared by a subprogram_declaration is not.  See *note
6.7::, "*note 6.7:: Null Procedures".  Finally, a function declared by
an expression_function_declaration is an expression function; a function
declared by a subprogram_declaration is not.  See *note 6.8::, "*note
6.8:: Expression Functions".

30.1/2
An overriding_indicator is used to indicate whether overriding is
intended.  See *note 8.3.1::, "*note 8.3.1:: Overriding Indicators".

                          _Dynamic Semantics_

31/2
The elaboration of a subprogram_declaration has no effect.

     NOTES

32
     1  A parameter_specification with several identifiers is equivalent
     to a sequence of single parameter_specifications, as explained in
     *note 3.3::.

33
     2  Abstract subprograms do not have bodies, and cannot be used in a
     nondispatching call (see *note 3.9.3::, "*note 3.9.3:: Abstract
     Types and Subprograms").

34
     3  The evaluation of default_expressions is caused by certain
     calls, as described in *note 6.4.1::.  They are not evaluated
     during the elaboration of the subprogram declaration.

35
     4  Subprograms can be called recursively and can be called
     concurrently from multiple tasks.

                              _Examples_

36
Examples of subprogram declarations:

37
     procedure Traverse_Tree;
     procedure Increment(X : in out Integer);
     procedure Right_Indent(Margin : out Line_Size);          --  see *note 3.5.4::
     procedure Switch(From, To : in out Link);                --  see *note 3.10.1::

38
     function Random return Probability;                      --  see *note 3.5.7::

39/4
     function Min_Cell(X : Link) return Cell;                 --  see *note 3.10.1::
     function Next_Frame(K : Positive) return Frame;          --  see *note 3.10::
     function Dot_Product(Left, Right : Vector) return Real;  --  see *note 3.6::
     function Find(B : aliased in out Barrel; Key : String) return Real;
                                                              --  see *note 4.1.5::

40
     function "*"(Left, Right : Matrix) return Matrix;        --  see *note 3.6::

41
Examples of in parameters with default expressions:

42
     procedure Print_Header(Pages  : in Natural;
                 Header : in Line    :=  (1 .. Line'Last => ' ');  --  see *note 3.6::
                 Center : in Boolean := True);

* Menu:

* 6.1.1 ::    Preconditions and Postconditions


File: arm2012.info,  Node: 6.1.1,  Up: 6.1

6.1.1 Preconditions and Postconditions
--------------------------------------

1/4
For a noninstance subprogram, a generic subprogram, or an entry, the
following language-defined aspects may be specified with an
aspect_specification (see *note 13.1.1::):

2/3
Pre
               This aspect specifies a specific precondition for a
               callable entity; it shall be specified by an expression,
               called a specific precondition expression.  If not
               specified for an entity, the specific precondition
               expression for the entity is the enumeration literal
               True.

3/3
Pre'Class
               This aspect specifies a class-wide precondition for an
               operation of a tagged type and its descendants; it shall
               be specified by an expression, called a class-wide
               precondition expression.  If not specified for an entity,
               then if no other class-wide precondition applies to the
               entity, the class-wide precondition expression for the
               entity is the enumeration literal True.

4/3
Post
               This aspect specifies a specific postcondition for a
               callable entity; it shall be specified by an expression,
               called a specific postcondition expression.  If not
               specified for an entity, the specific postcondition
               expression for the entity is the enumeration literal
               True.

5/3
Post'Class
               This aspect specifies a class-wide postcondition for an
               operation of a tagged type and its descendants; it shall
               be specified by an expression, called a class-wide
               postcondition expression.  If not specified for an
               entity, the class-wide postcondition expression for the
               entity is the enumeration literal True.

                        _Name Resolution Rules_

6/3
The expected type for a precondition or postcondition expression is any
boolean type.

7/4
Within the expression for a Pre'Class or Post'Class aspect for a
primitive subprogram S of a tagged type T, a name that denotes a formal
parameter (or S'Result) of type T is interpreted as though it had a
(notional) type NT that is a formal derived type whose ancestor type is
T, with directly visible primitive operations.  Similarly, a name that
denotes a formal access parameter (or S'Result) of type access-to-T is
interpreted as having type access-to-NT. The result of this
interpretation is that the only operations that can be applied to such
names are those defined for such a formal derived type.

8/3
For an attribute_reference with attribute_designator Old, if the
attribute reference has an expected type or shall resolve to a given
type, the same applies to the prefix; otherwise, the prefix shall be
resolved independently of context.

                           _Legality Rules_

9/3
The Pre or Post aspect shall not be specified for an abstract subprogram
or a null procedure.  Only the Pre'Class and Post'Class aspects may be
specified for such a subprogram.

10/3
If a type T has an implicitly declared subprogram P inherited from a
parent type T1 and a homograph (see *note 8.3::) of P from a progenitor
type T2, and

11/3
   * the corresponding primitive subprogram P1 of type T1 is neither
     null nor abstract; and

12/3
   * the class-wide precondition expression True does not apply to P1
     (implicitly or explicitly); and

13/3
   * there is a class-wide precondition expression that applies to the
     corresponding primitive subprogram P2 of T2 that does not fully
     conform to any class-wide precondition expression that applies to
     P1,

14/3
then:

15/3
   * If the type T is abstract, the implicitly declared subprogram P is
     abstract.

16/3
   * Otherwise, the subprogram P requires overriding and shall be
     overridden with a nonabstract subprogram.

17/3
If a renaming of a subprogram or entry S1 overrides an inherited
subprogram S2, then the overriding is illegal unless each class-wide
precondition expression that applies to S1 fully conforms to some
class-wide precondition expression that applies to S2 and each
class-wide precondition expression that applies to S2 fully conforms to
some class-wide precondition expression that applies to S1.

17.1/4
Pre'Class shall not be specified for an overriding primitive subprogram
of a tagged type T unless the Pre'Class aspect is specified for the
corresponding primitive subprogram of some ancestor of T.

17.2/4
In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules also apply in the private part of an instance of a
generic unit.

                          _Static Semantics_

18/4
If a Pre'Class or Post'Class aspect is specified for a primitive
subprogram S of a tagged type T, or such an aspect defaults to True,
then a corresponding expression also applies to the corresponding
primitive subprogram S of each descendant of T. The corresponding
expression is constructed from the associated expression as follows: 

18.1/4
   * References to formal parameters of S (or to S itself) are replaced
     with references to the corresponding formal parameters of the
     corresponding inherited or overriding subprogram S (or to the
     corresponding subprogram S itself).

18.2/4
The primitive subprogram S is illegal if it is not abstract and the
corresponding expression for a Pre'Class or Post'Class aspect would be
illegal.

19/3
If performing checks is required by the Pre, Pre'Class, Post, or
Post'Class assertion policies (see *note 11.4.2::) in effect at the
point of a corresponding aspect specification applicable to a given
subprogram or entry, then the respective precondition or postcondition
expressions are considered enabled.

20/3
An expression is potentially unevaluated if it occurs within:

21/3
   * any part of an if_expression other than the first condition;

22/3
   * a dependent_expression of a case_expression;

22.1/4
   * a predicate of a quantified_expression;

23/3
   * the right operand of a short-circuit control form; or

24/3
   * a membership_choice other than the first of a membership operation.

25/3
For a prefix X that denotes an object of a nonlimited type, the
following attribute is defined:

26/4
X'Old
               Each X'Old in a postcondition expression that is enabled
               denotes a constant that is implicitly declared at the
               beginning of the subprogram body, entry body, or accept
               statement.

26.1/4
               The implicitly declared entity denoted by each occurrence
               of X'Old is declared as follows:

26.2/4
                  * If X is of an anonymous access type defined by an
                    access_definition A then

26.3/4
                         X'Old : constant A := X;

26.4/4
                  * If X is of a specific tagged type T then

26.5/4
                         anonymous : constant T'Class := T'Class(X);
                         X'Old : T renames T(anonymous);

26.6/4
                    where the name X'Old denotes the object renaming.

26.7/4
                  * Otherwise

26.8/4
                         X'Old : constant S := X;

26.9/4
                    where S is the nominal subtype of X. This includes
                    the case where the type of S is an anonymous array
                    type or a universal type.

26.10/4
               The nominal subtype of X'Old is as implied by the above
               definitions.  The expected type of the prefix of an Old
               attribute is that of the attribute.  Similarly, if an Old
               attribute shall resolve to be of some type, then the
               prefix of the attribute shall resolve to be of that type.

27/3
               Reference to this attribute is only allowed within a
               postcondition expression.  The prefix of an Old
               attribute_reference shall not contain a Result
               attribute_reference, nor an Old attribute_reference, nor
               a use of an entity declared within the postcondition
               expression but not within prefix itself (for example, the
               loop parameter of an enclosing quantified_expression).
               The prefix of an Old attribute_reference that is
               potentially unevaluated shall statically denote an
               entity.

28/3
For a prefix F that denotes a function declaration, the following
attribute is defined:

29/3
F'Result
               Within a postcondition expression for function F, denotes
               the result object of the function.  The type of this
               attribute is that of the function result except within a
               Post'Class postcondition expression for a function with a
               controlling result or with a controlling access result.
               For a controlling result, the type of the attribute is
               T'Class, where T is the function result type.  For a
               controlling access result, the type of the attribute is
               an anonymous access type whose designated type is
               T'Class, where T is the designated type of the function
               result type.

30/3
               Use of this attribute is allowed only within a
               postcondition expression for F.

                          _Dynamic Semantics_

31/3
Upon a call of the subprogram or entry, after evaluating any actual
parameters, precondition checks are performed as follows:

32/3
   * The specific precondition check begins with the evaluation of the
     specific precondition expression that applies to the subprogram or
     entry, if it is enabled; if the expression evaluates to False,
     Assertions.Assertion_Error is raised; if the expression is not
     enabled, the check succeeds.

33/3
   * The class-wide precondition check begins with the evaluation of any
     enabled class-wide precondition expressions that apply to the
     subprogram or entry.  If and only if all the class-wide
     precondition expressions evaluate to False,
     Assertions.Assertion_Error is raised.

34/3
The precondition checks are performed in an arbitrary order, and if any
of the class-wide precondition expressions evaluate to True, it is not
specified whether the other class-wide precondition expressions are
evaluated.  The precondition checks and any check for elaboration of the
subprogram body are performed in an arbitrary order.  It is not
specified whether in a call on a protected operation, the checks are
performed before or after starting the protected action.  For an entry
call, the checks are performed prior to checking whether the entry is
open.

35/3
Upon successful return from a call of the subprogram or entry, prior to
copying back any by-copy in out or out parameters, the postcondition
check is performed.  This consists of the evaluation of any enabled
specific and class-wide postcondition expressions that apply to the
subprogram or entry.  If any of the postcondition expressions evaluate
to False, then Assertions.Assertion_Error is raised.  The postcondition
expressions are evaluated in an arbitrary order, and if any
postcondition expression evaluates to False, it is not specified whether
any other postcondition expressions are evaluated.  The postcondition
check, and any constraint or predicate checks associated with in out or
out parameters are performed in an arbitrary order.

35.1/4
For a call to a task entry, the postcondition check is performed before
the end of the rendezvous; for a call to a protected operation, the
postcondition check is performed before the end of the protected action
of the call.  The postcondition check for any call is performed before
the finalization of any implicitly-declared constants associated (as
described above) with Old attribute_references but after the
finalization of any other entities whose accessibility level is that of
the execution of the callable construct.

36/3
If a precondition or postcondition check fails, the exception is raised
at the point of the call; the exception cannot be handled inside the
called subprogram or entry.  Similarly, any exception raised by the
evaluation of a precondition or postcondition expression is raised at
the point of call.

37/4
For any call to a subprogram or entry S (including dispatching calls),
the checks that are performed to verify specific precondition
expressions and specific and class-wide postcondition expressions are
determined by those for the subprogram or entry actually invoked.  Note
that the class-wide postcondition expressions verified by the
postcondition check that is part of a call on a primitive subprogram of
type T includes all class-wide postcondition expressions originating in
any progenitor of T, even if the primitive subprogram called is
inherited from a type T1 and some of the postcondition expressions do
not apply to the corresponding primitive subprogram of T1.  Any
operations within a class-wide postcondition expression that were
resolved as primitive operations of the (notional) formal derived type
NT, are in the evaluation of the postcondition bound to the
corresponding operations of the type identified by the controlling tag
of the call on S. This applies to both dispatching and non-dispatching
calls on S.

38/4
The class-wide precondition check for a call to a subprogram or entry S
consists solely of checking the class-wide precondition expressions that
apply to the denoted callable entity (not necessarily to the one that is
invoked).  Any operations within such an expression that were resolved
as primitive operations of the (notional) formal derived type NT are in
the evaluation of the precondition bound to the corresponding operations
of the type identified by the controlling tag of the call on S. This
applies to both dispatching and non-dispatching calls on S.

39/3
For a call via an access-to-subprogram value, all precondition and
postcondition checks performed are determined by the subprogram or entry
denoted by the prefix of the Access attribute reference that produced
the value.

     NOTES

40/3
     5  A precondition is checked just before the call.  If another task
     can change any value that the precondition expression depends on,
     the precondition need not hold within the subprogram or entry body.


File: arm2012.info,  Node: 6.2,  Next: 6.3,  Prev: 6.1,  Up: 6

6.2 Formal Parameter Modes
==========================

1
A parameter_specification declares a formal parameter of mode in, in
out, or out.

                          _Static Semantics_

2
A parameter is passed either by copy or by reference.  When a parameter
is passed by copy, the formal parameter denotes a separate object from
the actual parameter, and any information transfer between the two
occurs only before and after executing the subprogram.  When a parameter
is passed by reference, the formal parameter denotes (a view of) the
object denoted by the actual parameter; reads and updates of the formal
parameter directly reference the actual parameter object.

3/3
A type is a by-copy type if it is an elementary type, or if it is a
descendant of a private type whose full type is a by-copy type.  A
parameter of a by-copy type is passed by copy, unless the formal
parameter is explicitly aliased.

4
A type is a by-reference type if it is a descendant of one of the
following:

5
   * a tagged type;

6
   * a task or protected type;

7/3
   * an explicitly limited record type;

8
   * a composite type with a subcomponent of a by-reference type;

9
   * a private type whose full type is a by-reference type.

10/4
A parameter of a by-reference type is passed by reference, as is an
explicitly aliased parameter of any type. Each value of a by-reference
type has an associated object.  For a parenthesized expression,
qualified_expression, or view conversion, this object is the one
associated with the operand.  For a value conversion, the associated
object is the anonymous result object if such an object is created (see
*note 4.6::); otherwise it is the associated object of the operand.  For
a conditional_expression, this object is the one associated with the
evaluated dependent_expression.

11/3
For other parameters, it is unspecified whether the parameter is passed
by copy or by reference.

                      _Bounded (Run-Time) Errors_

12/3
If one name denotes a part of a formal parameter, and a second name
denotes a part of a distinct formal parameter or an object that is not
part of a formal parameter, then the two names are considered distinct
access paths.  If an object is of a type for which the parameter passing
mechanism is not specified and is not an explicitly aliased parameter,
then it is a bounded error to assign to the object via one access path,
and then read the value of the object via a distinct access path, unless
the first access path denotes a part of a formal parameter that no
longer exists at the point of the second access (due to leaving the
corresponding callable construct). The possible consequences are that
Program_Error is raised, or the newly assigned value is read, or some
old value of the object is read.

     NOTES

13/4
     6  The mode of a formal parameter describes the direction of
     information transfer to or from the subprogram_body (see *note
     6.1::).

14
     7  A formal parameter of mode in is a constant view (see *note
     3.3::); it cannot be updated within the subprogram_body.

15/4
     8  A formal parameter of mode out might be uninitialized at the
     start of the subprogram_body (see *note 6.4.1::).


File: arm2012.info,  Node: 6.3,  Next: 6.4,  Prev: 6.2,  Up: 6

6.3 Subprogram Bodies
=====================

1
A subprogram_body specifies the execution of a subprogram.

                               _Syntax_

2/3
     subprogram_body ::=
         [overriding_indicator]
         subprogram_specification
            [aspect_specification] is
            declarative_part
         begin
             handled_sequence_of_statements
         end [designator];

3
     If a designator appears at the end of a subprogram_body, it shall
     repeat the defining_designator of the subprogram_specification.

                           _Legality Rules_

4
In contrast to other bodies, a subprogram_body need not be the
completion of a previous declaration, in which case the body declares
the subprogram.  If the body is a completion, it shall be the completion
of a subprogram_declaration or generic_subprogram_declaration.  The
profile of a subprogram_body that completes a declaration shall conform
fully to that of the declaration. 

                          _Static Semantics_

5
A subprogram_body is considered a declaration.  It can either complete a
previous declaration, or itself be the initial declaration of the
subprogram.

                          _Dynamic Semantics_

6
The elaboration of a nongeneric subprogram_body has no other effect than
to establish that the subprogram can from then on be called without
failing the Elaboration_Check.

7
The execution of a subprogram_body is invoked by a subprogram call.  For
this execution the declarative_part is elaborated, and the
handled_sequence_of_statements is then executed.

                              _Examples_

8
Example of procedure body:

9
     procedure Push(E : in Element_Type; S : in out Stack) is
     begin
        if S.Index = S.Size then
           raise Stack_Overflow;
        else
           S.Index := S.Index + 1;
           S.Space(S.Index) := E;
        end if;
     end Push;

10
Example of a function body:

11
     function Dot_Product(Left, Right : Vector) return Real is
        Sum : Real := 0.0;
     begin
        Check(Left'First = Right'First and Left'Last = Right'Last);
        for J in Left'Range loop
           Sum := Sum + Left(J)*Right(J);
        end loop;
        return Sum;
     end Dot_Product;

* Menu:

* 6.3.1 ::    Conformance Rules
* 6.3.2 ::    Inline Expansion of Subprograms


File: arm2012.info,  Node: 6.3.1,  Next: 6.3.2,  Up: 6.3

6.3.1 Conformance Rules
-----------------------

1
When subprogram profiles are given in more than one place, they are
required to conform in one of four ways: type conformance, mode
conformance, subtype conformance, or full conformance.

                          _Static Semantics_

2/1
As explained in *note B.1::, "*note B.1:: Interfacing Aspects", a
convention can be specified for an entity.  Unless this International
Standard states otherwise, the default convention of an entity is Ada.
For a callable entity or access-to-subprogram type, the convention is
called the calling convention.  The following conventions are defined by
the language:

3/3
   * The default calling convention for any subprogram not listed below
     is Ada.  The Convention aspect may be specified to override the
     default calling convention (see *note B.1::).

4
   * The Intrinsic calling convention represents subprograms that are
     "built in" to the compiler.  The default calling convention is
     Intrinsic for the following:

5
             * an enumeration literal;

6
             * a "/=" operator declared implicitly due to the
               declaration of "=" (see *note 6.6::);

7
             * any other implicitly declared subprogram unless it is a
               dispatching operation of a tagged type;

8
             * an inherited subprogram of a generic formal tagged type
               with unknown discriminants;

9
             * an attribute that is a subprogram;

10/2
             * a subprogram declared immediately within a
               protected_body;

10.1/4
             * any prefixed view of a subprogram (see *note 4.1.3::)
               without synchronization kind (see *note 9.5::) By_Entry
               or By_Protected_Procedure.

11
     The Access attribute is not allowed for Intrinsic subprograms.

12/4
   * The default calling convention is protected for a protected
     subprogram, for a prefixed view of a subprogram with a
     synchronization kind of By_Protected_Procedure, and for an
     access-to-subprogram type with the reserved word protected in its
     definition.

13/4
   * The default calling convention is entry for an entry and for a
     prefixed view of a subprogram with a synchronization kind of
     By_Entry.

13.1/3
   * The calling convention for an anonymous access-to-subprogram
     parameter or anonymous access-to-subprogram result is protected if
     the reserved word protected appears in its definition; otherwise,
     it is the convention of the subprogram that contains the parameter.

13.2/1
   * If not specified above as Intrinsic, the calling convention for any
     inherited or overriding dispatching operation of a tagged type is
     that of the corresponding subprogram of the parent type.  The
     default calling convention for a new dispatching operation of a
     tagged type is the convention of the type.

14/3
Of these four conventions, only Ada and Intrinsic are allowed as a
convention_identifier in the specification of a Convention aspect.

15/2
Two profiles are type conformant if they have the same number of
parameters, and both have a result if either does, and corresponding
parameter and result types are the same, or, for access parameters or
access results, corresponding designated types are the same, or
corresponding designated profiles are type conformant. 

16/3
Two profiles are mode conformant if:

16.1/3
   * they are type conformant; and

16.2/3
   * corresponding parameters have identical modes and both or neither
     are explicitly aliased parameters; and

16.3/3
   * for corresponding access parameters and any access result type, the
     designated subtypes statically match and either both or neither are
     access-to-constant, or the designated profiles are subtype
     conformant. 

17/3
Two profiles are subtype conformant if they are mode conformant,
corresponding subtypes of the profile statically match, and the
associated calling conventions are the same.  The profile of a generic
formal subprogram is not subtype conformant with any other profile. 

18/3
Two profiles are fully conformant if they are subtype conformant, if
they have access-to-subprogram results whose designated profiles are
fully conformant, and for corresponding parameters:

18.1/3
   * they have the same names; and

18.2/3
   * both or neither have null_exclusions; and

18.3/3
   * neither have default_expressions, or they both have
     default_expressions that are fully conformant with one another; and

18.4/3
   * for access-to-subprogram parameters, the designated profiles are
     fully conformant.

19
Two expressions are fully conformant if, after replacing each use of an
operator with the equivalent function_call:

20
   * each constituent construct of one corresponds to an instance of the
     same syntactic category in the other, except that an expanded name
     may correspond to a direct_name (or character_literal) or to a
     different expanded name in the other; and

20.1/4
   * corresponding defining_identifiers occurring within the two
     expressions are the same; and

21/4
   * each direct_name, character_literal, and selector_name that is not
     part of the prefix of an expanded name in one denotes the same
     declaration as the corresponding direct_name, character_literal, or
     selector_name in the other, or they denote corresponding
     declarations occurring within the two expressions; and

21.1/3
   * each attribute_designator in one is the same as the corresponding
     attribute_designator in the other; and

22
   * each primary that is a literal in one has the same value as the
     corresponding literal in the other.

23
Two known_discriminant_parts are fully conformant if they have the same
number of discriminants, and discriminants in the same positions have
the same names, statically matching subtypes, and default_expressions
that are fully conformant with one another. 

24
Two discrete_subtype_definitions are fully conformant if they are both
subtype_indications or are both ranges, the subtype_marks (if any)
denote the same subtype, and the corresponding simple_expressions of the
ranges (if any) fully conform.

24.1/2
The prefixed view profile of a subprogram is the profile obtained by
omitting the first parameter of that subprogram.  There is no prefixed
view profile for a parameterless subprogram.  For the purposes of
defining subtype and mode conformance, the convention of a prefixed view
profile is considered to match that of either an entry or a protected
operation.

                     _Implementation Permissions_

25
An implementation may declare an operator declared in a language-defined
library unit to be intrinsic.


File: arm2012.info,  Node: 6.3.2,  Prev: 6.3.1,  Up: 6.3

6.3.2 Inline Expansion of Subprograms
-------------------------------------

1
Subprograms may be expanded in line at the call site.

Paragraphs 2 through 4 were moved to *note Annex J::, "*note Annex J::
Obsolescent Features".

                          _Static Semantics_

5/3
For a callable entity or a generic subprogram, the following
language-defined representation aspect may be specified:

5.1/3
Inline
               The type of aspect Inline is Boolean.  When aspect Inline
               is True for a callable entity, inline expansion is
               desired for all calls to that entity.  When aspect Inline
               is True for a generic subprogram, inline expansion is
               desired for all calls to all instances of that generic
               subprogram.

5.2/3
               If directly specified, the aspect_definition shall be a
               static expression.  This aspect is never inherited; if
               not directly specified, the aspect is False.

                     _Implementation Permissions_

6/3
For each call, an implementation is free to follow or to ignore the
recommendation determined by the Inline aspect.


File: arm2012.info,  Node: 6.4,  Next: 6.5,  Prev: 6.3,  Up: 6

6.4 Subprogram Calls
====================

1
A subprogram call is either a procedure_call_statement or a
function_call; it invokes the execution of the subprogram_body.  The
call specifies the association of the actual parameters, if any, with
formal parameters of the subprogram.

                               _Syntax_

2
     procedure_call_statement ::=
         procedure_name;
       | procedure_prefix actual_parameter_part;

3
     function_call ::=
         function_name
       | function_prefix actual_parameter_part

4
     actual_parameter_part ::=
         (parameter_association {, parameter_association})

5
     parameter_association ::=
        [formal_parameter_selector_name =>] explicit_actual_parameter

6
     explicit_actual_parameter ::= expression | variable_name

7
     A parameter_association is named or positional according to whether
     or not the formal_parameter_selector_name (*note 4.1.3: S0099.) is
     specified.  Any positional associations shall precede any named
     associations.  Named associations are not allowed if the prefix in
     a subprogram call is an attribute_reference (*note 4.1.4: S0100.).

                        _Name Resolution Rules_

8/2
The name or prefix given in a procedure_call_statement shall resolve to
denote a callable entity that is a procedure, or an entry renamed as
(viewed as) a procedure.  The name or prefix given in a function_call
shall resolve to denote a callable entity that is a function.  The name
or prefix shall not resolve to denote an abstract subprogram unless it
is also a dispatching subprogram.  When there is an
actual_parameter_part (*note 6.4: S0180.), the prefix can be an
implicit_dereference (*note 4.1: S0095.) of an access-to-subprogram
value.

9
A subprogram call shall contain at most one association for each formal
parameter.  Each formal parameter without an association shall have a
default_expression (in the profile of the view denoted by the name or
prefix).  This rule is an overloading rule (see *note 8.6::).

                          _Dynamic Semantics_

10/2
For the execution of a subprogram call, the name or prefix of the call
is evaluated, and each parameter_association (*note 6.4: S0181.) is
evaluated (see *note 6.4.1::).  If a default_expression (*note 3.7:
S0063.) is used, an implicit parameter_association (*note 6.4: S0181.)
is assumed for this rule.  These evaluations are done in an arbitrary
order.  The subprogram_body (*note 6.3: S0177.) is then executed, or a
call on an entry or protected subprogram is performed (see *note
3.9.2::).  Finally, if the subprogram completes normally, then after it
is left, any necessary assigning back of formal to actual parameters
occurs (see *note 6.4.1::).

10.1/2
If the name or prefix of a subprogram call denotes a prefixed view (see
*note 4.1.3::), the subprogram call is equivalent to a call on the
underlying subprogram, with the first actual parameter being provided by
the prefix of the prefixed view (or the Access attribute of this prefix
if the first formal parameter is an access parameter), and the remaining
actual parameters given by the actual_parameter_part, if any.

11/2
The exception Program_Error is raised at the point of a function_call if
the function completes normally without executing a return statement.

12/2
A function_call denotes a constant, as defined in *note 6.5::; the
nominal subtype of the constant is given by the nominal subtype of the
function result. 

                              _Examples_

13
Examples of procedure calls:

14
     Traverse_Tree;                                               --  see *note 6.1::
     Print_Header(128, Title, True);                              --  see *note 6.1::

15
     Switch(From => X, To => Next);                               --  see *note 6.1::
     Print_Header(128, Header => Title, Center => True);          --  see *note 6.1::
     Print_Header(Header => Title, Center => True, Pages => 128); --  see *note 6.1::

16
Examples of function calls:

17
     Dot_Product(U, V)   --  see *note 6.1:: and *note 6.3::
     Clock               --  see *note 9.6::
     F.all               --  presuming F is of an access-to-subprogram type -- see *note 3.10::

18
Examples of procedures with default expressions:

19
     procedure Activate(Process : in Process_Name;
                        After   : in Process_Name := No_Process;
                        Wait    : in Duration := 0.0;
                        Prior   : in Boolean := False);

20/3
     procedure Pair(Left, Right : in Person_Name := new Person(M));   --  see *note 3.10.1::

21
Examples of their calls:

22
     Activate(X);
     Activate(X, After => Y);
     Activate(X, Wait => 60.0, Prior => True);
     Activate(X, Y, 10.0, False);

23/3
     Pair;
     Pair(Left => new Person(F), Right => new Person(M));

     NOTES

24
     9  If a default_expression is used for two or more parameters in a
     multiple parameter_specification (*note 6.1: S0175.), the
     default_expression (*note 3.7: S0063.) is evaluated once for each
     omitted parameter.  Hence in the above examples, the two calls of
     Pair are equivalent.

                              _Examples_

25
Examples of overloaded subprograms:

26
     procedure Put(X : in Integer);
     procedure Put(X : in String);

27
     procedure Set(Tint   : in Color);
     procedure Set(Signal : in Light);

28
Examples of their calls:

29
     Put(28);
     Put("no possible ambiguity here");

30
     Set(Tint   => Red);
     Set(Signal => Red);
     Set(Color'(Red));

31
     --  Set(Red) would be ambiguous since Red may
     --  denote a value either of type Color or of type Light

* Menu:

* 6.4.1 ::    Parameter Associations


File: arm2012.info,  Node: 6.4.1,  Up: 6.4

6.4.1 Parameter Associations
----------------------------

1
A parameter association defines the association between an actual
parameter and a formal parameter.

                        _Name Resolution Rules_

2/3
The formal_parameter_selector_name of a named parameter_association
(*note 6.4: S0181.) shall resolve to denote a parameter_specification
(*note 6.1: S0175.) of the view being called; this is the formal
parameter of the association.  The formal parameter for a positional
parameter_association (*note 6.4: S0181.) is the parameter with the
corresponding position in the formal part of the view being called.

3
The actual parameter is either the explicit_actual_parameter given in a
parameter_association for a given formal parameter, or the corresponding
default_expression if no parameter_association is given for the formal
parameter. The expected type for an actual parameter is the type of the
corresponding formal parameter.

4
If the mode is in, the actual is interpreted as an expression;
otherwise, the actual is interpreted only as a name, if possible.

                           _Legality Rules_

5
If the mode is in out or out, the actual shall be a name that denotes a
variable.

5.1/4
If the mode is out, the actual parameter is a view conversion, and the
type of the formal parameter is an access type or a scalar type that has
the Default_Value aspect specified, then

5.2/4
   * there shall exist a type (other than a root numeric type) that is
     an ancestor of both the target type and the operand type; and

5.3/4
   * in the case of a scalar type, the type of the operand of the
     conversion shall have the Default_Value aspect specified.

5.4/4
In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules also apply in the private part of an instance of a
generic unit.

6/3
If the formal parameter is an explicitly aliased parameter, the type of
the actual parameter shall be tagged or the actual parameter shall be an
aliased view of an object.  Further, if the formal parameter subtype F
is untagged:

6.1/3
   * the subtype F shall statically match the nominal subtype of the
     actual object; or

6.2/3
   * the subtype F shall be unconstrained, discriminated in its full
     view, and unconstrained in any partial view.

6.3/4
In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules also apply in the private part of an instance of a
generic unit.

6.4/3
In a function call, the accessibility level of the actual object for
each explicitly aliased parameter shall not be statically deeper than
the accessibility level of the master of the call (see *note 3.10.2::).

6.5/3
Two names are known to denote the same object if:

6.6/3
   * both names statically denote the same stand-alone object or
     parameter; or

6.7/3
   * both names are selected_components, their prefixes are known to
     denote the same object, and their selector_names denote the same
     component; or

6.8/3
   * both names are dereferences (implicit or explicit) and the
     dereferenced names are known to denote the same object; or

6.9/3
   * both names are indexed_components, their prefixes are known to
     denote the same object, and each of the pairs of corresponding
     index values are either both static expressions with the same
     static value or both names that are known to denote the same
     object; or

6.10/3
   * both names are slices, their prefixes are known to denote the same
     object, and the two slices have statically matching index
     constraints; or

6.11/3
   * one of the two names statically denotes a renaming declaration
     whose renamed object_name is known to denote the same object as the
     other, the prefix of any dereference within the renamed object_name
     is not a variable, and any expression within the renamed
     object_name contains no references to variables nor calls on
     nonstatic functions.

6.12/3
Two names are known to refer to the same object if 

6.13/3
   * The two names are known to denote the same object; or

6.14/3
   * One of the names is a selected_component, indexed_component, or
     slice and its prefix is known to refer to the same object as the
     other name; or

6.15/3
   * One of the two names statically denotes a renaming declaration
     whose renamed object_name is known to refer to the same object as
     the other name.

6.16/3
If a call C has two or more parameters of mode in out or out that are of
an elementary type, then the call is legal only if:

6.17/3
   * For each name N that is passed as a parameter of mode in out or out
     to the call C, there is no other name among the other parameters of
     mode in out or out to C that is known to denote the same object.

6.18/3
If a construct C has two or more direct constituents that are names or
expressions whose evaluation may occur in an arbitrary order, at least
one of which contains a function call with an in out or out parameter,
then the construct is legal only if:

6.19/3
   * For each name N that is passed as a parameter of mode in out or out
     to some inner function call C2 (not including the construct C
     itself), there is no other name anywhere within a direct
     constituent of the construct C other than the one containing C2,
     that is known to refer to the same object.

6.20/3
For the purposes of checking this rule:

6.21/3
   * For an array aggregate, an expression associated with a
     discrete_choice_list that has two or more discrete choices, or that
     has a nonstatic range, is considered as two or more separate
     occurrences of the expression;

6.22/3
   * For a record aggregate:

6.23/3
             * The expression of a record_component_association is
               considered to occur once for each associated component;
               and

6.24/3
             * The default_expression for each
               record_component_association with <> for which the
               associated component has a default_expression is
               considered part of the aggregate;

6.25/3
   * For a call, any default_expression evaluated as part of the call is
     considered part of the call.

                          _Dynamic Semantics_

7
For the evaluation of a parameter_association:

8
   * The actual parameter is first evaluated.

9
   * For an access parameter, the access_definition is elaborated, which
     creates the anonymous access type.

10
   * For a parameter (of any mode) that is passed by reference (see
     *note 6.2::), a view conversion of the actual parameter to the
     nominal subtype of the formal parameter is evaluated, and the
     formal parameter denotes that conversion. 

11
   * For an in or in out parameter that is passed by copy (see *note
     6.2::), the formal parameter object is created, and the value of
     the actual parameter is converted to the nominal subtype of the
     formal parameter and assigned to the formal. 

12
   * For an out parameter that is passed by copy, the formal parameter
     object is created, and:

13/3
        * For an access type, the formal parameter is initialized from
          the value of the actual, without checking that the value
          satisfies any constraint, any predicate, or any exclusion of
          the null value;

13.1/4
        * For a scalar type that has the Default_Value aspect specified,
          the formal parameter is initialized from the value of the
          actual, without checking that the value satisfies any
          constraint or any predicate.  Furthermore, if the actual
          parameter is a view conversion and either

13.2/4
             * there exists no type (other than a root numeric type)
               that is an ancestor of both the target type and the type
               of the operand of the conversion; or

13.3/4
             * the Default_Value aspect is unspecified for the type of
               the operand of the conversion

13.4/4
          then Program_Error is raised;

14
        * For a composite type with discriminants or that has implicit
          initial values for any subcomponents (see *note 3.3.1::), the
          behavior is as for an in out parameter passed by copy.

15
        * For any other type, the formal parameter is uninitialized.  If
          composite, a view conversion of the actual parameter to the
          nominal subtype of the formal is evaluated (which might raise
          Constraint_Error), and the actual subtype of the formal is
          that of the view conversion.  If elementary, the actual
          subtype of the formal is given by its nominal subtype.

15.1/3
   * In a function call, for each explicitly aliased parameter, a check
     is made that the accessibility level of the master of the actual
     object is not deeper than that of the master of the call (see *note
     3.10.2::).

16
A formal parameter of mode in out or out with discriminants is
constrained if either its nominal subtype or the actual parameter is
constrained.

17
After normal completion and leaving of a subprogram, for each in out or
out parameter that is passed by copy, the value of the formal parameter
is converted to the subtype of the variable given as the actual
parameter and assigned to it. These conversions and assignments occur in
an arbitrary order.

                         _Erroneous Execution_

18/3
If the nominal subtype of a formal parameter with discriminants is
constrained or indefinite, and the parameter is passed by reference,
then the execution of the call is erroneous if the value of any
discriminant of the actual is changed while the formal parameter exists
(that is, before leaving the corresponding callable construct).


File: arm2012.info,  Node: 6.5,  Next: 6.6,  Prev: 6.4,  Up: 6

6.5 Return Statements
=====================

1/2
A simple_return_statement (*note 6.5: S0183.) or
extended_return_statement (*note 6.5: S0186.) (collectively called a
return statement)  is used to complete the execution of the innermost
enclosing subprogram_body (*note 6.3: S0177.), entry_body (*note 9.5.2:
S0221.), or accept_statement (*note 9.5.2: S0219.).

                               _Syntax_

2/2
     simple_return_statement ::= return [expression];

2.1/3
     extended_return_object_declaration ::=
         defining_identifier : [aliased][constant] 
     return_subtype_indication [:= expression]

2.2/3
     extended_return_statement ::=
         return extended_return_object_declaration [do
             handled_sequence_of_statements
         end return];

2.3/2
     return_subtype_indication ::= subtype_indication | 
     access_definition

                        _Name Resolution Rules_

3/2
The result subtype of a function is the subtype denoted by the
subtype_mark, or defined by the access_definition, after the reserved
word return in the profile of the function.  The expected type for the
expression, if any, of a simple_return_statement (*note 6.5: S0183.) is
the result type of the corresponding function. The expected type for the
expression of an extended_return_statement is that of the
return_subtype_indication (*note 6.5: S0187.).

                           _Legality Rules_

4/2
A return statement shall be within a callable construct, and it applies
to the innermost callable construct or extended_return_statement that
contains it.  A return statement shall not be within a body that is
within the construct to which the return statement applies.

5/3
A function body shall contain at least one return statement that applies
to the function body, unless the function contains code_statements.  A
simple_return_statement (*note 6.5: S0183.) shall include an expression
if and only if it applies to a function body.  An
extended_return_statement shall apply to a function body.  An
extended_return_statement with the reserved word constant shall include
an expression.

5.1/2
For an extended_return_statement (*note 6.5: S0186.) that applies to a
function body:

5.2/3
   * If the result subtype of the function is defined by a subtype_mark,
     the return_subtype_indication (*note 6.5: S0187.) shall be a
     subtype_indication.  The type of the subtype_indication shall be
     covered by the result type of the function.  The subtype defined by
     the subtype_indication shall be statically compatible with the
     result subtype of the function; if the result type of the function
     is elementary, the two subtypes shall statically match.  If the
     result subtype of the function is indefinite, then the subtype
     defined by the subtype_indication shall be a definite subtype, or
     there shall be an expression.

5.3/2
   * If the result subtype of the function is defined by an
     access_definition, the return_subtype_indication (*note 6.5:
     S0187.) shall be an access_definition.  The subtype defined by the
     access_definition shall statically match the result subtype of the
     function.  The accessibility level of this anonymous access subtype
     is that of the result subtype.

5.4/3
   * If the result subtype of the function is class-wide, the
     accessibility level of the type of the subtype defined by the
     return_subtype_indication shall not be statically deeper than that
     of the master that elaborated the function body.

5.5/3
For any return statement that applies to a function body:

5.6/3
   * If the result subtype of the function is limited, then the
     expression of the return statement (if any) shall meet the
     restrictions described in *note 7.5::.

5.7/3
   * If the result subtype of the function is class-wide, the
     accessibility level of the type of the expression (if any) of the
     return statement shall not be statically deeper than that of the
     master that elaborated the function body.

5.8/3
   * If the subtype determined by the expression of the
     simple_return_statement or by the return_subtype_indication has one
     or more access discriminants, the accessibility level of the
     anonymous access type of each access discriminant shall not be
     statically deeper than that of the master that elaborated the
     function body.

5.9/3
If the keyword aliased is present in an
extended_return_object_declaration, the type of the extended return
object shall be immutably limited.

                          _Static Semantics_

5.10/3
Within an extended_return_statement, the return object is declared with
the given defining_identifier, with the nominal subtype defined by the
return_subtype_indication (*note 6.5: S0187.).  An
extended_return_statement with the reserved word constant is a full
constant declaration that declares the return object to be a constant
object.

                          _Dynamic Semantics_

5.11/3
For the execution of an extended_return_statement, the
subtype_indication or access_definition is elaborated.  This creates the
nominal subtype of the return object.  If there is an expression, it is
evaluated and converted to the nominal subtype (which might raise
Constraint_Error -- see *note 4.6::); the return object is created and
the converted value is assigned to the return object.  Otherwise, the
return object is created and initialized by default as for a stand-alone
object of its nominal subtype (see *note 3.3.1::).  If the nominal
subtype is indefinite, the return object is constrained by its initial
value.  A check is made that the value of the return object belongs to
the function result subtype.  Constraint_Error is raised if this check
fails. 

6/2
For the execution of a simple_return_statement (*note 6.5: S0183.), the
expression (if any) is first evaluated, converted to the result subtype,
and then is assigned to the anonymous return object. 

7/2
If the return object has any parts that are tasks, the activation of
those tasks does not occur until after the function returns (see *note
9.2::).

8/4
If the result type of a function is a specific tagged type, the tag of
the return object is that of the result type.  If the result type is
class-wide, the tag of the return object is that of the value of the
expression, unless the return object is defined by an
extended_return_object_declaration with a subtype_indication that is
specific, in which case it is that of the type of the
subtype_indication.  A check is made that the master of the type
identified by the tag of the result includes the elaboration of the
master that elaborated the function body.  If this check fails,
Program_Error is raised. 

8.1/3
If the result subtype of the function is defined by an access_definition
designating a specific tagged type T, a check is made that the result
value is null or the tag of the object designated by the result value
identifies T. Constraint_Error is raised if this check fails.

Paragraphs 9 through 20 were deleted.

21/3
If any part of the specific type of the return object of a function (or
coextension thereof) has one or more access discriminants whose value is
not constrained by the result subtype of the function, a check is made
that the accessibility level of the anonymous access type of each access
discriminant, as determined by the expression or the
return_subtype_indication (*note 6.5: S0187.) of the return statement,
is not deeper than the level of the master of the call (see *note
3.10.2::).  If this check fails, Program_Error is raised. 

22/3
For the execution of an extended_return_statement (*note 6.5: S0186.),
the handled_sequence_of_statements (*note 11.2: S0265.) is executed.
Within this handled_sequence_of_statements (*note 11.2: S0265.), the
execution of a simple_return_statement (*note 6.5: S0183.) that applies
to the extended_return_statement (*note 6.5: S0186.) causes a transfer
of control that completes the extended_return_statement (*note 6.5:
S0186.).  Upon completion of a return statement that applies to a
callable construct by the normal completion of a simple_return_statement
(*note 6.5: S0183.) or by reaching the end return of an
extended_return_statement (*note 6.5: S0186.), a transfer of control is
performed which completes the execution of the callable construct, and
returns to the caller.

23/2
In the case of a function, the function_call denotes a constant view of
the return object.

                     _Implementation Permissions_

24/3
For a function call used to initialize a composite object with a
constrained nominal subtype or used to initialize a return object that
is built in place into such an object:

24.1/3
   * If the result subtype of the function is constrained, and
     conversion of an object of this subtype to the subtype of the
     object being initialized would raise Constraint_Error, then
     Constraint_Error may be raised before calling the function.

24.2/3
   * If the result subtype of the function is unconstrained, and a
     return statement is executed such that the return object is known
     to be constrained, and conversion of the return object to the
     subtype of the object being initialized would raise
     Constraint_Error, then Constraint_Error may be raised at the point
     of the call (after abandoning the execution of the function body).

                              _Examples_

25
Examples of return statements:

26/2
     return;                         -- in a procedure body, entry_body,
                                     -- accept_statement, or extended_return_statement

27
     return Key_Value(Last_Index);   -- in a function body

28/2
     return Node : Cell do           -- in a function body, see *note 3.10.1:: for Cell
        Node.Value := Result;
        Node.Succ := Next_Node;
     end return;

* Menu:

* 6.5.1 ::    Nonreturning Procedures


File: arm2012.info,  Node: 6.5.1,  Up: 6.5

6.5.1 Nonreturning Procedures
-----------------------------

1/3
Specifying aspect No_Return to have the value True indicates that a
procedure cannot return normally; it may propagate an exception or loop
forever.

Paragraphs 2 and 3 were moved to *note Annex J::, "*note Annex J::
Obsolescent Features".

                          _Static Semantics_

3.1/3
For a procedure or generic procedure, the following language-defined
representation aspect may be specified:

3.2/3
No_Return
               The type of aspect No_Return is Boolean.  When aspect
               No_Return is True for an entity, the entity is said to be
               nonreturning.

3.3/3
               If directly specified, the aspect_definition shall be a
               static expression.  This aspect is never inherited; if
               not directly specified, the aspect is False.

3.4/3
If a generic procedure is nonreturning, then so are its instances.  If a
procedure declared within a generic unit is nonreturning, then so are
the corresponding copies of that procedure in instances.

                           _Legality Rules_

4/3
Aspect No_Return shall not be specified for a null procedure nor an
instance of a generic unit.

5/2
A return statement shall not apply to a nonreturning procedure or
generic procedure.

6/2
A procedure shall be nonreturning if it overrides a dispatching
nonreturning procedure. In addition to the places where Legality Rules
normally apply (see *note 12.3::), this rule applies also in the private
part of an instance of a generic unit.

7/2
If a renaming-as-body completes a nonreturning procedure declaration,
then the renamed procedure shall be nonreturning.

Paragraph 8 was deleted.

                          _Dynamic Semantics_

9/2
If the body of a nonreturning procedure completes normally,
Program_Error is raised at the point of the call. 

                              _Examples_

10/3
     procedure Fail(Msg : String)  -- raises Fatal_Error exception
        with No_Return;
        -- Inform compiler and reader that procedure never returns normally


File: arm2012.info,  Node: 6.6,  Next: 6.7,  Prev: 6.5,  Up: 6

6.6 Overloading of Operators
============================

1
An operator is a function whose designator is an operator_symbol.
Operators, like other functions, may be overloaded.

                        _Name Resolution Rules_

2
Each use of a unary or binary operator is equivalent to a function_call
with function_prefix being the corresponding operator_symbol, and with
(respectively) one or two positional actual parameters being the
operand(s) of the operator (in order).

                           _Legality Rules_

3/3
The subprogram_specification of a unary or binary operator shall have
one or two parameters, respectively.  The parameters shall be of mode
in.  A generic function instantiation whose designator is an
operator_symbol is only allowed if the specification of the generic
function has the corresponding number of parameters, and they are all of
mode in.

4
Default_expressions are not allowed for the parameters of an operator
(whether the operator is declared with an explicit
subprogram_specification or by a generic_instantiation).

5
An explicit declaration of "/=" shall not have a result type of the
predefined type Boolean.

                          _Static Semantics_

6/3
An explicit declaration of "=" whose result type is Boolean implicitly
declares an operator "/=" that gives the complementary result.

     NOTES

7
     10  The operators "+" and "-" are both unary and binary operators,
     and hence may be overloaded with both one- and two-parameter
     functions.

                              _Examples_

8
Examples of user-defined operators:

9
     function "+" (Left, Right : Matrix) return Matrix;
     function "+" (Left, Right : Vector) return Vector;

     --  assuming that A, B, and C are of the type Vector
     --  the following two statements are equivalent:

     A := B + C;
     A := "+"(B, C);


File: arm2012.info,  Node: 6.7,  Next: 6.8,  Prev: 6.6,  Up: 6

6.7 Null Procedures
===================

1/2
A null_procedure_declaration provides a shorthand to declare a procedure
with an empty body.

                               _Syntax_

2/3
     null_procedure_declaration ::=
        [overriding_indicator]
        procedure_specification is null
            [aspect_specification];

                           _Legality Rules_

2.1/3
If a null_procedure_declaration is a completion, it shall be the
completion of a subprogram_declaration or
generic_subprogram_declaration.  The profile of a
null_procedure_declaration that completes a declaration shall conform
fully to that of the declaration.

                          _Static Semantics_

3/3
A null_procedure_declaration declares a null procedure.  A completion is
not allowed for a null_procedure_declaration; however, a
null_procedure_declaration can complete a previous declaration.

                          _Dynamic Semantics_

4/2
The execution of a null procedure is invoked by a subprogram call.  For
the execution of a subprogram call on a null procedure, the execution of
the subprogram_body has no effect.

5/3
The elaboration of a null_procedure_declaration has no other effect than
to establish that the null procedure can be called without failing the
Elaboration_Check.

                              _Examples_

6/2
     procedure Simplify(Expr : in out Expression) is null; -- see *note 3.9::
     -- By default, Simplify does nothing, but it may be overridden in extensions of Expression


File: arm2012.info,  Node: 6.8,  Prev: 6.7,  Up: 6

6.8 Expression Functions
========================

1/3
An expression_function_declaration provides a shorthand to declare a
function whose body consists of a single return statement.

                               _Syntax_

2/4
     expression_function_declaration ::=
        [overriding_indicator]
        function_specification is
            (expression)
            [aspect_specification];
      | [overriding_indicator]
        function_specification is
            aggregate
            [aspect_specification];

                        _Name Resolution Rules_

3/4
The expected type for the expression or aggregate of an
expression_function_declaration (*note 6.8: S0189.) is the result type
(see *note 6.5::) of the function.

                           _Legality Rules_

4/3
If an expression_function_declaration (*note 6.8: S0189.) is a
completion, it shall be the completion of a subprogram_declaration or
generic_subprogram_declaration.  The profile of an
expression_function_declaration (*note 6.8: S0189.) that completes a
declaration shall conform fully to that of the declaration.

5/4
If the result subtype has one or more unconstrained access
discriminants, the accessibility level of the anonymous access type of
each access discriminant, as determined by the expression or aggregate
of the expression_function_declaration (*note 6.8: S0189.), shall not be
statically deeper than that of the master that elaborated the
expression_function_declaration (*note 6.8: S0189.).

                          _Static Semantics_

6/4
An expression_function_declaration (*note 6.8: S0189.) declares an
expression function.  The return expression of an expression function is
the expression or aggregate of the expression_function_declaration.  A
completion is not allowed for an expression_function_declaration (*note
6.8: S0189.); however, an expression_function_declaration (*note 6.8:
S0189.) can complete a previous declaration.

                          _Dynamic Semantics_

7/4
The execution of an expression function is invoked by a subprogram call.
For the execution of a subprogram call on an expression function, the
execution of the subprogram_body executes an implicit function body
containing only a simple_return_statement whose expression is the return
expression of the expression function.

8/3
The elaboration of an expression_function_declaration (*note 6.8:
S0189.) has no other effect than to establish that the expression
function can be called without failing the Elaboration_Check.

                              _Examples_

9/3
     function Is_Origin (P : in Point) return Boolean is -- see *note 3.9::
        (P.X = 0.0 and P.Y = 0.0);


File: arm2012.info,  Node: 7,  Next: 8,  Prev: 6,  Up: Top

7 Packages
**********

1
Packages are program units that allow the specification of groups of
logically related entities.  Typically, a package contains the
declaration of a type (often a private type or private extension) along
with the declarations of primitive subprograms of the type, which can be
called from outside the package, while their inner workings remain
hidden from outside users. 

* Menu:

* 7.1 ::      Package Specifications and Declarations
* 7.2 ::      Package Bodies
* 7.3 ::      Private Types and Private Extensions
* 7.4 ::      Deferred Constants
* 7.5 ::      Limited Types
* 7.6 ::      Assignment and Finalization


File: arm2012.info,  Node: 7.1,  Next: 7.2,  Up: 7

7.1 Package Specifications and Declarations
===========================================

1
A package is generally provided in two parts: a package_specification
and a package_body.  Every package has a package_specification, but not
all packages have a package_body.

                               _Syntax_

2
     package_declaration ::= package_specification;

3/3
     package_specification ::=
         package defining_program_unit_name
             [aspect_specification] is
           {basic_declarative_item}
        [private
           {basic_declarative_item}]
         end [[parent_unit_name.]identifier]

4
     If an identifier or parent_unit_name.identifier appears at the end
     of a package_specification, then this sequence of lexical elements
     shall repeat the defining_program_unit_name.

                           _Legality Rules_

5/2
A package_declaration or generic_package_declaration requires a
completion (a body) if it contains any basic_declarative_item that
requires a completion, but whose completion is not in its
package_specification.

                          _Static Semantics_

6/2
The first list of basic_declarative_items of a package_specification of
a package other than a generic formal package is called the visible part
of the package. The optional list of basic_declarative_items after the
reserved word private (of any package_specification) is called the
private part of the package.  If the reserved word private does not
appear, the package has an implicit empty private part.  Each list of
basic_declarative_items of a package_specification forms a declaration
list of the package.

7
An entity declared in the private part of a package is visible only
within the declarative region of the package itself (including any child
units -- see *note 10.1.1::).  In contrast, expanded names denoting
entities declared in the visible part can be used even outside the
package; furthermore, direct visibility of such entities can be achieved
by means of use_clauses (see *note 4.1.3:: and *note 8.4::).

                          _Dynamic Semantics_

8
The elaboration of a package_declaration consists of the elaboration of
its basic_declarative_items in the given order.

     NOTES

9
     1  The visible part of a package contains all the information that
     another program unit is able to know about the package.

10
     2  If a declaration occurs immediately within the specification of
     a package, and the declaration has a corresponding completion that
     is a body, then that body has to occur immediately within the body
     of the package.

                              _Examples_

11
Example of a package declaration:

12
     package Rational_Numbers is

13
        type Rational is
           record
              Numerator   : Integer;
              Denominator : Positive;
           end record;

14
        function "="(X,Y : Rational) return Boolean;

15
        function "/"  (X,Y : Integer)  return Rational;  --  to construct a rational number

16
        function "+"  (X,Y : Rational) return Rational;
        function "-"  (X,Y : Rational) return Rational;
        function "*"  (X,Y : Rational) return Rational;
        function "/"  (X,Y : Rational) return Rational;
     end Rational_Numbers;

17
There are also many examples of package declarations in the predefined
language environment (see *note Annex A::).


File: arm2012.info,  Node: 7.2,  Next: 7.3,  Prev: 7.1,  Up: 7

7.2 Package Bodies
==================

1
In contrast to the entities declared in the visible part of a package,
the entities declared in the package_body are visible only within the
package_body itself.  As a consequence, a package with a package_body
can be used for the construction of a group of related subprograms in
which the logical operations available to clients are clearly isolated
from the internal entities.

                               _Syntax_

2/3
     package_body ::=
         package body defining_program_unit_name
             [aspect_specification] is
            declarative_part
        [begin
             handled_sequence_of_statements]
         end [[parent_unit_name.]identifier];

3
     If an identifier or parent_unit_name.identifier appears at the end
     of a package_body, then this sequence of lexical elements shall
     repeat the defining_program_unit_name.

                           _Legality Rules_

4
A package_body shall be the completion of a previous package_declaration
(*note 7.1: S0190.) or generic_package_declaration (*note 12.1: S0273.).
A library package_declaration (*note 7.1: S0190.) or library
generic_package_declaration (*note 12.1: S0273.) shall not have a body
unless it requires a body; pragma Elaborate_Body can be used to require
a library_unit_declaration (*note 10.1.1: S0249.) to have a body (see
*note 10.2.1::) if it would not otherwise require one.

                          _Static Semantics_

5/3
In any package_body without statements there is an implicit
null_statement (*note 5.1: S0149.).  For any package_declaration (*note
7.1: S0190.) without an explicit completion, there is an implicit
package_body (*note 7.2: S0192.) containing a single null_statement.
For a noninstance, nonlibrary package, this body occurs at the end of
the declarative_part (*note 3.11: S0086.) of the innermost enclosing
program unit or block_statement (*note 5.6: S0160.); if there are
several such packages, the order of the implicit package_bodies is
unspecified. (For an instance, the implicit package_body (*note 7.2:
S0192.) occurs at the place of the instantiation (see *note 12.3::).
For a library package, the place is partially determined by the
elaboration dependences (see Clause *note 10::).)

                          _Dynamic Semantics_

6
For the elaboration of a nongeneric package_body, its declarative_part
(*note 3.11: S0086.) is first elaborated, and its
handled_sequence_of_statements (*note 11.2: S0265.) is then executed.

     NOTES

7
     3  A variable declared in the body of a package is only visible
     within this body and, consequently, its value can only be changed
     within the package_body.  In the absence of local tasks, the value
     of such a variable remains unchanged between calls issued from
     outside the package to subprograms declared in the visible part.
     The properties of such a variable are similar to those of a
     "static" variable of C.

8
     4  The elaboration of the body of a subprogram explicitly declared
     in the visible part of a package is caused by the elaboration of
     the body of the package.  Hence a call of such a subprogram by an
     outside program unit raises the exception Program_Error if the call
     takes place before the elaboration of the package_body (see *note
     3.11::).

                              _Examples_

9
Example of a package body (see *note 7.1::):

10
     package body Rational_Numbers is

11
        procedure Same_Denominator (X,Y : in out Rational) is
        begin
           --  reduces X and Y to the same denominator:
           ...
        end Same_Denominator;

12
        function "="(X,Y : Rational) return Boolean is
           U : Rational := X;
           V : Rational := Y;
        begin
           Same_Denominator (U,V);
           return U.Numerator = V.Numerator;
        end "=";

13
        function "/" (X,Y : Integer) return Rational is
        begin
           if Y > 0 then
              return (Numerator => X,  Denominator => Y);
           else
              return (Numerator => -X, Denominator => -Y);
           end if;
        end "/";

14
        function "+" (X,Y : Rational) return Rational is ... end "+";
        function "-" (X,Y : Rational) return Rational is ... end "-";
        function "*" (X,Y : Rational) return Rational is ... end "*";
        function "/" (X,Y : Rational) return Rational is ... end "/";

15
     end Rational_Numbers;


File: arm2012.info,  Node: 7.3,  Next: 7.4,  Prev: 7.2,  Up: 7

7.3 Private Types and Private Extensions
========================================

1
The declaration (in the visible part of a package) of a type as a
private type or private extension serves to separate the characteristics
that can be used directly by outside program units (that is, the logical
properties) from other characteristics whose direct use is confined to
the package (the details of the definition of the type itself).  See
*note 3.9.1:: for an overview of type extensions. 

                               _Syntax_

2/3
     private_type_declaration ::=
        type defining_identifier [
     discriminant_part] is [[abstract] tagged] [limited] private
           [aspect_specification];

3/3
     private_extension_declaration ::=
        type defining_identifier [discriminant_part] is
          [abstract] [limited | synchronized] new ancestor_
     subtype_indication
          [and interface_list] with private
            [aspect_specification];

                           _Legality Rules_

4
A private_type_declaration or private_extension_declaration declares a
partial view of the type; such a declaration is allowed only as a
declarative_item of the visible part of a package, and it requires a
completion, which shall be a full_type_declaration that occurs as a
declarative_item of the private part of the package.  The view of the
type declared by the full_type_declaration is called the full view.  A
generic formal private type or a generic formal private extension is
also a partial view.

5
A type shall be completely defined before it is frozen (see *note
3.11.1:: and *note 13.14::).  Thus, neither the declaration of a
variable of a partial view of a type, nor the creation by an allocator
of an object of the partial view are allowed before the full declaration
of the type.  Similarly, before the full declaration, the name of the
partial view cannot be used in a generic_instantiation or in a
representation item.

6/2
A private type is limited if its declaration includes the reserved word
limited; a private extension is limited if its ancestor type is a
limited type that is not an interface type, or if the reserved word
limited or synchronized appears in its definition.  If the partial view
is nonlimited, then the full view shall be nonlimited.  If a tagged
partial view is limited, then the full view shall be limited.  On the
other hand, if an untagged partial view is limited, the full view may be
limited or nonlimited.

7
If the partial view is tagged, then the full view shall be tagged.  On
the other hand, if the partial view is untagged, then the full view may
be tagged or untagged.  In the case where the partial view is untagged
and the full view is tagged, no derivatives of the partial view are
allowed within the immediate scope of the partial view; derivatives of
the full view are allowed.

7.1/2
If a full type has a partial view that is tagged, then:

7.2/2
   * the partial view shall be a synchronized tagged type (see *note
     3.9.4::) if and only if the full type is a synchronized tagged
     type;

7.3/2
   * the partial view shall be a descendant of an interface type (see
     3.9.4) if and only if the full type is a descendant of the
     interface type.

8
The ancestor subtype of a private_extension_declaration is the subtype
defined by the ancestor_subtype_indication (*note 3.2.2: S0027.); the
ancestor type shall be a specific tagged type.  The full view of a
private extension shall be derived (directly or indirectly) from the
ancestor type.  In addition to the places where Legality Rules normally
apply (see *note 12.3::), the requirement that the ancestor be specific
applies also in the private part of an instance of a generic unit.

8.1/2
If the reserved word limited appears in a private_extension_declaration,
the ancestor type shall be a limited type.  If the reserved word
synchronized appears in a private_extension_declaration, the ancestor
type shall be a limited interface.

9
If the declaration of a partial view includes a known_discriminant_part,
then the full_type_declaration shall have a fully conforming (explicit)
known_discriminant_part (see *note 6.3.1::, "*note 6.3.1:: Conformance
Rules"). The ancestor subtype may be unconstrained; the parent subtype
of the full view is required to be constrained (see *note 3.7::).

10
If a private extension inherits known discriminants from the ancestor
subtype, then the full view shall also inherit its discriminants from
the ancestor subtype, and the parent subtype of the full view shall be
constrained if and only if the ancestor subtype is constrained.

10.1/3
If the full_type_declaration for a private extension includes a
derived_type_definition, then the reserved word limited shall appear in
the full_type_declaration if and only if it also appears in the
private_extension_declaration.

11
If a partial view has unknown discriminants, then the
full_type_declaration may define a definite or an indefinite subtype,
with or without discriminants.

12
If a partial view has neither known nor unknown discriminants, then the
full_type_declaration shall define a definite subtype.

13
If the ancestor subtype of a private extension has constrained
discriminants, then the parent subtype of the full view shall impose a
statically matching constraint on those discriminants. 

                          _Static Semantics_

14
A private_type_declaration declares a private type and its first
subtype. Similarly, a private_extension_declaration (*note 7.3: S0194.)
declares a private extension and its first subtype.

15/3
A declaration of a partial view and the corresponding
full_type_declaration define two views of a single type.  The
declaration of a partial view together with the visible part define the
operations that are available to outside program units; the declaration
of the full view together with the private part define other operations
whose direct use is possible only within the declarative region of the
package itself.  Moreover, within the scope of the declaration of the
full view, the characteristics (see *note 3.4::) of the type are
determined by the full view; in particular, within its scope, the full
view determines the classes that include the type, which components,
entries, and protected subprograms are visible, what attributes and
other predefined operations are allowed, and whether the first subtype
is static.  See *note 7.3.1::.

16/3
For a private extension, the characteristics (including components, but
excluding discriminants if there is a new discriminant_part specified),
predefined operators, and inherited user-defined primitive subprograms
are determined by its ancestor type and its progenitor types (if any),
in the same way that those of a record extension are determined by those
of its parent type and its progenitor types (see *note 3.4:: and *note
7.3.1::).

                          _Dynamic Semantics_

17
The elaboration of a private_type_declaration creates a partial view of
a type. The elaboration of a private_extension_declaration elaborates
the ancestor_subtype_indication, and creates a partial view of a type.

     NOTES

18
     5  The partial view of a type as declared by a
     private_type_declaration is defined to be a composite view (in
     *note 3.2::).  The full view of the type might or might not be
     composite.  A private extension is also composite, as is its full
     view.

19/2
     6  Declaring a private type with an unknown_discriminant_part is a
     way of preventing clients from creating uninitialized objects of
     the type; they are then forced to initialize each object by calling
     some operation declared in the visible part of the package.

20/2
     7  The ancestor type specified in a private_extension_declaration
     and the parent type specified in the corresponding declaration of a
     record extension given in the private part need not be the same.
     If the ancestor type is not an interface type, the parent type of
     the full view can be any descendant of the ancestor type.  In this
     case, for a primitive subprogram that is inherited from the
     ancestor type and not overridden, the formal parameter names and
     default expressions (if any) come from the corresponding primitive
     subprogram of the specified ancestor type, while the body comes
     from the corresponding primitive subprogram of the parent type of
     the full view.  See *note 3.9.2::.

20.1/2
     8  If the ancestor type specified in a
     private_extension_declaration is an interface type, the parent type
     can be any type so long as the full view is a descendant of the
     ancestor type.  The progenitor types specified in a
     private_extension_declaration and the progenitor types specified in
     the corresponding declaration of a record extension given in the
     private part need not be the same -- the only requirement is that
     the private extension and the record extension be descended from
     the same set of interfaces.

                              _Examples_

21
Examples of private type declarations:

22
     type Key is private;
     type File_Name is limited private;

23
Example of a private extension declaration:

24
     type List is new Ada.Finalization.Controlled with private;

* Menu:

* 7.3.1 ::    Private Operations
* 7.3.2 ::    Type Invariants


File: arm2012.info,  Node: 7.3.1,  Next: 7.3.2,  Up: 7.3

7.3.1 Private Operations
------------------------

1
For a type declared in the visible part of a package or generic package,
certain operations on the type do not become visible until later in the
package -- either in the private part or the body. Such private
operations are available only inside the declarative region of the
package or generic package.

                          _Static Semantics_

2
The predefined operators that exist for a given type are determined by
the classes to which the type belongs.  For example, an integer type has
a predefined "+" operator.  In most cases, the predefined operators of a
type are declared immediately after the definition of the type; the
exceptions are explained below.  Inherited subprograms are also
implicitly declared immediately after the definition of the type, except
as stated below.

3/3
For a composite type, the characteristics (see *note 7.3::) of the type
are determined in part by the characteristics of its component types.
At the place where the composite type is declared, the only
characteristics of component types used are those characteristics
visible at that place.  If later immediately within the declarative
region in which the composite type is declared additional
characteristics become visible for a component type, then any
corresponding characteristics become visible for the composite type.
Any additional predefined operators are implicitly declared at that
place.  If there is no such place, then additional predefined operators
are not declared at all, but they still exist.

4/1
The corresponding rule applies to a type defined by a
derived_type_definition, if there is a place immediately within the
declarative region in which the type is declared where additional
characteristics of its parent type become visible.

5/1
For example, an array type whose component type is limited private
becomes nonlimited if the full view of the component type is nonlimited
and visible at some later place immediately within the declarative
region in which the array type is declared.  In such a case, the
predefined "=" operator is implicitly declared at that place, and
assignment is allowed after that place.

5.1/3
A type is a descendant of the full view of some ancestor of its parent
type only if the current view it has of its parent is a descendant of
the full view of that ancestor.  More generally, at any given place, a
type is descended from the same view of an ancestor as that from which
the current view of its parent is descended.  This view determines what
characteristics are inherited from the ancestor, and, for example,
whether the type is considered to be a descendant of a record type, or a
descendant only through record extensions of a more distant ancestor.

5.2/4
Furthermore, it is possible for there to be places where a derived type
is known to be derived indirectly from an ancestor type, but is not a
descendant of even a partial view of the ancestor type, because the
parent of the derived type is not visibly a descendant of the ancestor.
In this case, the derived type inherits no characteristics from that
ancestor, but nevertheless is within the derivation class of the
ancestor for the purposes of type conversion, the "covers" relationship,
and matching against a formal derived type.  In this case the derived
type is effectively a descendant of an incomplete view of the ancestor.

6/3
Inherited primitive subprograms follow a different rule.  For a
derived_type_definition, each inherited primitive subprogram is
implicitly declared at the earliest place, if any, immediately within
the declarative region in which the type_declaration occurs, but after
the type_declaration, where the corresponding declaration from the
parent is visible.  If there is no such place, then the inherited
subprogram is not declared at all, but it still exists.  For a tagged
type, it is possible to dispatch to an inherited subprogram that is not
declared at all.

7
For a private_extension_declaration, each inherited subprogram is
declared immediately after the private_extension_declaration if the
corresponding declaration from the ancestor is visible at that place.
Otherwise, the inherited subprogram is not declared for the private
extension, though it might be for the full type.

8
The Class attribute is defined for tagged subtypes in *note 3.9::.  In
addition, for every subtype S of an untagged private type whose full
view is tagged, the following attribute is defined:

9
S'Class
               Denotes the class-wide subtype corresponding to the full
               view of S. This attribute is allowed only from the
               beginning of the private part in which the full view is
               declared, until the declaration of the full view.  After
               the full view, the Class attribute of the full view can
               be used.

     NOTES

10
     9  Because a partial view and a full view are two different views
     of one and the same type, outside of the defining package the
     characteristics of the type are those defined by the visible part.
     Within these outside program units the type is just a private type
     or private extension, and any language rule that applies only to
     another class of types does not apply.  The fact that the full
     declaration might implement a private type with a type of a
     particular class (for example, as an array type) is relevant only
     within the declarative region of the package itself including any
     child units.

11
     The consequences of this actual implementation are, however, valid
     everywhere.  For example: any default initialization of components
     takes place; the attribute Size provides the size of the full view;
     finalization is still done for controlled components of the full
     view; task dependence rules still apply to components that are task
     objects.

12/2
     10  Partial views provide initialization, membership tests,
     selected components for the selection of discriminants and
     inherited components, qualification, and explicit conversion.
     Nonlimited partial views also allow use of assignment_statements.

13
     11  For a subtype S of a partial view, S'Size is defined (see *note
     13.3::).  For an object A of a partial view, the attributes A'Size
     and A'Address are defined (see *note 13.3::).  The Position,
     First_Bit, and Last_Bit attributes are also defined for
     discriminants and inherited components.

                              _Examples_

14
Example of a type with private operations:

15
     package Key_Manager is
        type Key is private;
        Null_Key : constant Key; -- a deferred constant declaration (see *note 7.4::)
        procedure Get_Key(K : out Key);
        function "<" (X, Y : Key) return Boolean;
     private
        type Key is new Natural;
        Null_Key : constant Key := Key'First;
     end Key_Manager;

16
     package body Key_Manager is
        Last_Key : Key := Null_Key;
        procedure Get_Key(K : out Key) is
        begin
           Last_Key := Last_Key + 1;
           K := Last_Key;
        end Get_Key;

17
        function "<" (X, Y : Key) return Boolean is
        begin
           return Natural(X) < Natural(Y);
        end "<";
     end Key_Manager;

     NOTES

18
     12  Notes on the example: Outside of the package Key_Manager, the
     operations available for objects of type Key include assignment,
     the comparison for equality or inequality, the procedure Get_Key
     and the operator "<"; they do not include other relational
     operators such as ">=", or arithmetic operators.

19
     The explicitly declared operator "<" hides the predefined operator
     "<" implicitly declared by the full_type_declaration.  Within the
     body of the function, an explicit conversion of X and Y to the
     subtype Natural is necessary to invoke the "<" operator of the
     parent type.  Alternatively, the result of the function could be
     written as not (X >= Y), since the operator ">=" is not redefined.

20
     The value of the variable Last_Key, declared in the package body,
     remains unchanged between calls of the procedure Get_Key.  (See
     also the NOTES of *note 7.2::.)


File: arm2012.info,  Node: 7.3.2,  Prev: 7.3.1,  Up: 7.3

7.3.2 Type Invariants
---------------------

1/4
For a private type, private extension, or interface, the following
language-defined aspects may be specified with an aspect_specification
(see *note 13.1.1::):

2/3
Type_Invariant
               This aspect shall be specified by an expression, called
               an invariant expression.  Type_Invariant may be specified
               on a private_type_declaration (*note 7.3: S0193.), on a
               private_extension_declaration (*note 7.3: S0194.), or on
               a full_type_declaration (*note 3.2.1: S0024.) that
               declares the completion of a private type or private
               extension.

3/4
Type_Invariant'Class
               This aspect shall be specified by an expression, called
               an invariant expression.  Type_Invariant'Class may be
               specified on a private_type_declaration (*note 7.3:
               S0193.), a private_extension_declaration (*note 7.3:
               S0194.), or a full_type_declaration (*note 3.2.1: S0024.)
               for an interface type.  Type_Invariant'Class determines a
               class-wide type invariant for a tagged type.

                        _Name Resolution Rules_

4/3
The expected type for an invariant expression is any boolean type.

5/4
Within an invariant expression, the identifier of the first subtype of
the associated type denotes the current instance of the type.  Within an
invariant expression for the Type_Invariant aspect of a type T, the type
of this current instance is T. Within an invariant expression for the
Type_Invariant'Class aspect of a type T, the type of this current
instance is interpreted as though it had a (notional) type NT that is a
visible formal derived type whose ancestor type is T. The effect of this
interpretation is that the only operations that can be applied to this
current instance are those defined for such a formal derived type.

                           _Legality Rules_

6/3
The Type_Invariant'Class aspect shall not be specified for an untagged
type.  The Type_Invariant aspect shall not be specified for an abstract
type.

6.1/4
If a type extension occurs at a point where a private operation of some
ancestor is visible and inherited, and a Type_Invariant'Class expression
applies to that ancestor, then the inherited operation shall be abstract
or shall be overridden.

                          _Static Semantics_

7/3
If the Type_Invariant aspect is specified for a type T, then the
invariant expression applies to T.

8/3
If the Type_Invariant'Class aspect is specified for a tagged type T,
then the invariant expression applies to all descendants of T.

                          _Dynamic Semantics_

9/4
If one or more invariant expressions apply to a nonabstract type T, then
an invariant check is performed at the following places, on the
specified object(s):

10/4
   * After successful initialization of an object of type T by default
     (see *note 3.3.1::), the check is performed on the new object
     unless the partial view of T has unknown discriminants;

10.1/4
   * After successful explicit initialization of the completion of a
     deferred constant with a part of type T, if the completion is
     inside the immediate scope of the full view of T, and the deferred
     constant is visible outside the immediate scope of T, the check is
     performed on the part(s) of type T;

11/3
   * After successful conversion to type T, the check is performed on
     the result of the conversion;

12/3
   * For a view conversion, outside the immediate scope of T, that
     converts from a descendant of T (including T itself) to an ancestor
     of type T (other than T itself), a check is performed on the part
     of the object that is of type T:

13/3
             * after assigning to the view conversion; and

14/3
             * after successful return from a call that passes the view
               conversion as an in out or out parameter.

15/4
   * After a successful call on the Read or Input stream-oriented
     attribute of the type T, the check is performed on the object
     initialized by the attribute;

16/3
   * An invariant is checked upon successful return from a call on any
     subprogram or entry that:

17/4
        * is declared within the immediate scope of type T (or by an
          instance of a generic unit, and the generic is declared within
          the immediate scope of type T),

18/4
        * This paragraph was deleted.

19/4
        * and either:

19.1/4
             * has a result with a part of type T, or

19.2/4
             * has one or more out or in out parameters with a part of
               type T, or

19.3/4
             * has an access-to-object parameter or result whose
               designated type has a part of type T, or

19.4/4
             * is a procedure or entry that has an in parameter with a
               part of type T,

19.5/4
        * and either:

19.6/4
             * T is a private type or a private extension and the
               subprogram or entry is visible outside the immediate
               scope of type T or overrides an inherited operation that
               is visible outside the immediate scope of T, or

19.7/4
             * T is a record extension, and the subprogram or entry is a
               primitive operation visible outside the immediate scope
               of type T or overrides an inherited operation that is
               visible outside the immediate scope of T.

20/3
     The check is performed on each such part of type T.

20.1/4
   * For a view conversion to a class-wide type occurring within the
     immediate scope of T, from a specific type that is a descendant of
     T (including T itself), a check is performed on the part of the
     object that is of type T.

21/4
If performing checks is required by the Type_Invariant or
Type_Invariant'Class assertion policies (see *note 11.4.2::) in effect
at the point of the corresponding aspect specification applicable to a
given type, then the respective invariant expression is considered
enabled.

22/3
The invariant check consists of the evaluation of each enabled invariant
expression that applies to T, on each of the objects specified above.
If any of these evaluate to False, Assertions.Assertion_Error is raised
at the point of the object initialization, conversion, or call.  If a
given call requires more than one evaluation of an invariant expression,
either for multiple objects of a single type or for multiple types with
invariants, the evaluations are performed in an arbitrary order, and if
one of them evaluates to False, it is not specified whether the others
are evaluated.  Any invariant check is performed prior to copying back
any by-copy in out or out parameters.  Invariant checks, any
postcondition check, and any constraint or predicate checks associated
with in out or out parameters are performed in an arbitrary order.

22.1/4
For an invariant check on a value of type T1 based on a class-wide
invariant expression inherited from an ancestor type T, any operations
within the invariant expression that were resolved as primitive
operations of the (notional) formal derived type NT are bound to the
corresponding operations of type T1 in the evaluation of the invariant
expression for the check on T1.

23/3
The invariant checks performed on a call are determined by the
subprogram or entry actually invoked, whether directly, as part of a
dispatching call, or as part of a call through an access-to-subprogram
value.

     NOTES

24/3
     13  For a call of a primitive subprogram of type NT that is
     inherited from type T, the specified checks of the specific
     invariants of both the types NT and T are performed.  For a call of
     a primitive subprogram of type NT that is overridden for type NT,
     the specified checks of the specific invariants of only type NT are
     performed.


File: arm2012.info,  Node: 7.4,  Next: 7.5,  Prev: 7.3,  Up: 7

7.4 Deferred Constants
======================

1
Deferred constant declarations may be used to declare constants in the
visible part of a package, but with the value of the constant given in
the private part.  They may also be used to declare constants imported
from other languages (see *note Annex B::).

                           _Legality Rules_

2/3
A deferred constant declaration is an object_declaration with the
reserved word constant but no initialization expression. The constant
declared by a deferred constant declaration is called a deferred
constant. Unless the Import aspect (see *note B.1::) is True for a
deferred constant declaration, the deferred constant declaration
requires a completion, which shall be a full constant declaration
(called the full declaration of the deferred constant). 

3
A deferred constant declaration that is completed by a full constant
declaration shall occur immediately within the visible part of a
package_specification.  For this case, the following additional rules
apply to the corresponding full declaration:

4
   * The full declaration shall occur immediately within the private
     part of the same package;

5/2
   * The deferred and full constants shall have the same type, or shall
     have statically matching anonymous access subtypes;

6/3
   * If the deferred constant declaration includes a subtype_indication
     S that defines a constrained subtype, then the constraint defined
     by the subtype_indication in the full declaration shall match the
     constraint defined by S statically.  On the other hand, if the
     subtype of the deferred constant is unconstrained, then the full
     declaration is still allowed to impose a constraint.  The constant
     itself will be constrained, like all constants;

7/2
   * If the deferred constant declaration includes the reserved word
     aliased, then the full declaration shall also;

7.1/2
   * If the subtype of the deferred constant declaration excludes null,
     the subtype of the full declaration shall also exclude null.

8/3
A deferred constant declaration for which the Import aspect is True need
not appear in the visible part of a package_specification, and has no
full constant declaration.

9/2
The completion of a deferred constant declaration shall occur before the
constant is frozen (see *note 13.14::).

                          _Dynamic Semantics_

10/3
The elaboration of a deferred constant declaration elaborates the
subtype_indication, access_definition, or (only allowed in the case of
an imported constant) the array_type_definition.

     NOTES

11
     14  The full constant declaration for a deferred constant that is
     of a given private type or private extension is not allowed before
     the corresponding full_type_declaration.  This is a consequence of
     the freezing rules for types (see *note 13.14::).

                              _Examples_

12
Examples of deferred constant declarations:

13
     Null_Key : constant Key;      -- see *note 7.3.1::

14/3
     CPU_Identifier : constant String(1..8)
        with Import => True, Convention => Assembler, Link_Name => "CPU_ID";
                                   -- see *note B.1::


File: arm2012.info,  Node: 7.5,  Next: 7.6,  Prev: 7.4,  Up: 7

7.5 Limited Types
=================

1/2
A limited type is (a view of) a type for which copying (such as for an
assignment_statement) is not allowed.  A nonlimited type is a (view of
a) type for which copying is allowed.

                           _Legality Rules_

2/2
If a tagged record type has any limited components, then the reserved
word limited shall appear in its record_type_definition.  If the
reserved word limited appears in the definition of a
derived_type_definition, its parent type and any progenitor interfaces
shall be limited.

2.1/3
In the following contexts, an expression of a limited type is not
permitted unless it is an aggregate, a function_call, a parenthesized
expression or qualified_expression whose operand is permitted by this
rule, or a conditional_expression all of whose dependent_expressions are
permitted by this rule:

2.2/2
   * the initialization expression of an object_declaration (see *note
     3.3.1::)

2.3/2
   * the default_expression of a component_declaration (see *note 3.8::)

2.4/2
   * the expression of a record_component_association (see *note
     4.3.1::)

2.5/2
   * the expression for an ancestor_part of an extension_aggregate (see
     *note 4.3.2::)

2.6/2
   * an expression of a positional_array_aggregate or the expression of
     an array_component_association (see *note 4.3.3::)

2.7/2
   * the qualified_expression of an initialized allocator (see *note
     4.8::)

2.8/2
   * the expression of a return statement (see *note 6.5::)

2.9/4
   * the return expression of an expression function (see *note 6.8::)

2.10/3
   * the default_expression or actual parameter for a formal object of
     mode in (see *note 12.4::)

                          _Static Semantics_

3/3
A view of a type is limited if it is one of the following:

4/2
   * a type with the reserved word limited, synchronized, task, or
     protected in its definition;

5/3
   * a class-wide type whose specific type is limited;

6/2
   * a composite type with a limited component;

6.1/3
   * an incomplete view;

6.2/2
   * a derived type whose parent is limited and is not an interface.

7
Otherwise, the type is nonlimited.

8
There are no predefined equality operators for a limited type.

8.1/3
A type is immutably limited if it is one of the following:

8.2/3
   * An explicitly limited record type;

8.3/3
   * A record extension with the reserved word limited;

8.4/3
   * A nonformal limited private type that is tagged or has at least one
     access discriminant with a default_expression;

8.5/3
   * A task type, a protected type, or a synchronized interface;

8.6/3
   * A type derived from an immutably limited type.

8.7/3
A descendant of a generic formal limited private type is presumed to be
immutably limited except within the body of a generic unit or a body
declared within the declarative region of a generic unit, if the formal
type is declared within the formal part of the generic unit.

     NOTES

9/3
     15  While it is allowed to write initializations of limited
     objects, such initializations never copy a limited object.  The
     source of such an assignment operation must be an aggregate or
     function_call, and such aggregates and function_calls must be built
     directly in the target object (see *note 7.6::).

     Paragraphs 10 through 15 were deleted.

16
     16  As illustrated in *note 7.3.1::, an untagged limited type can
     become nonlimited under certain circumstances.

                              _Examples_

17
Example of a package with a limited type:

18
     package IO_Package is
        type File_Name is limited private;

19
        procedure Open (F : in out File_Name);
        procedure Close(F : in out File_Name);
        procedure Read (F : in File_Name; Item : out Integer);
        procedure Write(F : in File_Name; Item : in  Integer);
     private
        type File_Name is
           limited record
              Internal_Name : Integer := 0;
           end record;
     end IO_Package;

20
     package body IO_Package is
        Limit : constant := 200;
        type File_Descriptor is record  ...  end record;
        Directory : array (1 .. Limit) of File_Descriptor;
        ...
        procedure Open (F : in out File_Name) is  ...  end;
        procedure Close(F : in out File_Name) is  ...  end;
        procedure Read (F : in File_Name; Item : out Integer) is ... end;
        procedure Write(F : in File_Name; Item : in  Integer) is ... end;
     begin
        ...
     end IO_Package;

     NOTES

21
     17  Notes on the example: In the example above, an outside
     subprogram making use of IO_Package may obtain a file name by
     calling Open and later use it in calls to Read and Write.  Thus,
     outside the package, a file name obtained from Open acts as a kind
     of password; its internal properties (such as containing a numeric
     value) are not known and no other operations (such as addition or
     comparison of internal names) can be performed on a file name.
     Most importantly, clients of the package cannot make copies of
     objects of type File_Name.

22
     This example is characteristic of any case where complete control
     over the operations of a type is desired.  Such packages serve a
     dual purpose.  They prevent a user from making use of the internal
     structure of the type.  They also implement the notion of an
     encapsulated data type where the only operations on the type are
     those given in the package specification.

23/2
     The fact that the full view of File_Name is explicitly declared
     limited means that parameter passing will always be by reference
     and function results will always be built directly in the result
     object (see *note 6.2:: and *note 6.5::).


File: arm2012.info,  Node: 7.6,  Prev: 7.5,  Up: 7

7.6 Assignment and Finalization
===============================

1
Three kinds of actions are fundamental to the manipulation of objects:
initialization, finalization, and assignment.  Every object is
initialized, either explicitly or by default, after being created (for
example, by an object_declaration or allocator).  Every object is
finalized before being destroyed (for example, by leaving a
subprogram_body containing an object_declaration, or by a call to an
instance of Unchecked_Deallocation).  An assignment operation is used as
part of assignment_statements, explicit initialization, parameter
passing, and other operations. 

2
Default definitions for these three fundamental operations are provided
by the language, but a controlled type gives the user additional control
over parts of these operations. In particular, the user can define, for
a controlled type, an Initialize procedure which is invoked immediately
after the normal default initialization of a controlled object, a
Finalize procedure which is invoked immediately before finalization of
any of the components of a controlled object, and an Adjust procedure
which is invoked as the last step of an assignment to a (nonlimited)
controlled object.

                          _Static Semantics_

3
The following language-defined library package exists:

4/3
     package Ada.Finalization is
         pragma Pure(Finalization);

5/2
         type Controlled is abstract tagged private;
         pragma Preelaborable_Initialization(Controlled);

6/2
         procedure Initialize (Object : in out Controlled) is null;
         procedure Adjust     (Object : in out Controlled) is null;
         procedure Finalize   (Object : in out Controlled) is null;

7/2
         type Limited_Controlled is abstract tagged limited private;
         pragma Preelaborable_Initialization(Limited_Controlled);

8/2
         procedure Initialize (Object : in out Limited_Controlled) is null;
         procedure Finalize   (Object : in out Limited_Controlled) is null;
     private
         ... -- not specified by the language
     end Ada.Finalization;

9/2
A controlled type is a descendant of Controlled or Limited_Controlled.
The predefined "=" operator of type Controlled always returns True,
since this operator is incorporated into the implementation of the
predefined equality operator of types derived from Controlled, as
explained in *note 4.5.2::.  The type Limited_Controlled is like
Controlled, except that it is limited and it lacks the primitive
subprogram Adjust.

9.1/2
A type is said to need finalization if:

9.2/2
   * it is a controlled type, a task type or a protected type; or

9.3/3
   * it has a component whose type needs finalization; or

9.4/3
   * it is a class-wide type; or

9.5/3
   * it is a partial view whose full view needs finalization; or

9.6/2
   * it is one of a number of language-defined types that are explicitly
     defined to need finalization.

                          _Dynamic Semantics_

10/2
During the elaboration or evaluation of a construct that causes an
object to be initialized by default, for every controlled subcomponent
of the object that is not assigned an initial value (as defined in *note
3.3.1::), Initialize is called on that subcomponent.  Similarly, if the
object that is initialized by default as a whole is controlled,
Initialize is called on the object.

11/2
For an extension_aggregate whose ancestor_part is a subtype_mark
denoting a controlled subtype, the Initialize procedure of the ancestor
type is called, unless that Initialize procedure is abstract.

12
Initialize and other initialization operations are done in an arbitrary
order, except as follows.  Initialize is applied to an object after
initialization of its subcomponents, if any (including both implicit
initialization and Initialize calls).  If an object has a component with
an access discriminant constrained by a per-object expression,
Initialize is applied to this component after any components that do not
have such discriminants.  For an object with several components with
such a discriminant, Initialize is applied to them in order of their
component_declarations.  For an allocator, any task activations follow
all calls on Initialize.

13
When a target object with any controlled parts is assigned a value,
either when created or in a subsequent assignment_statement, the
assignment operation proceeds as follows:

14
   * The value of the target becomes the assigned value.

15
   * The value of the target is adjusted.

16/3
To adjust the value of a composite object, the values of the components
of the object are first adjusted in an arbitrary order, and then, if the
object is nonlimited controlled, Adjust is called.  Adjusting the value
of an elementary object has no effect, nor does adjusting the value of a
composite object with no controlled parts.

17
For an assignment_statement, after the name and expression have been
evaluated, and any conversion (including constraint checking) has been
done, an anonymous object is created, and the value is assigned into it;
that is, the assignment operation is applied.  (Assignment includes
value adjustment.)  The target of the assignment_statement is then
finalized.  The value of the anonymous object is then assigned into the
target of the assignment_statement.  Finally, the anonymous object is
finalized.  As explained below, the implementation may eliminate the
intermediate anonymous object, so this description subsumes the one
given in *note 5.2::, "*note 5.2:: Assignment Statements".

17.1/3
When a function call or aggregate is used to initialize an object, the
result of the function call or aggregate is an anonymous object, which
is assigned into the newly-created object.  For such an assignment, the
anonymous object might be built in place, in which case the assignment
does not involve any copying.  Under certain circumstances, the
anonymous object is required to be built in place.  In particular:

17.2/3
   * If the full type of any part of the object is immutably limited,
     the anonymous object is built in place.

17.3/3
   * In the case of an aggregate, if the full type of any part of the
     newly-created object is controlled, the anonymous object is built
     in place.

17.4/3
   * In other cases, it is unspecified whether the anonymous object is
     built in place.

17.5/3
Notwithstanding what this International Standard says elsewhere, if an
object is built in place:

17.6/3
   * Upon successful completion of the return statement or aggregate,
     the anonymous object mutates into the newly-created object; that
     is, the anonymous object ceases to exist, and the newly-created
     object appears in its place.

17.7/3
   * Finalization is not performed on the anonymous object.

17.8/3
   * Adjustment is not performed on the newly-created object.

17.9/3
   * All access values that designate parts of the anonymous object now
     designate the corresponding parts of the newly-created object.

17.10/3
   * All renamings of parts of the anonymous object now denote views of
     the corresponding parts of the newly-created object.

17.11/3
   * Coextensions of the anonymous object become coextensions of the
     newly-created object.

                     _Implementation Permissions_

18/3
An implementation is allowed to relax the above rules for
assignment_statements in the following ways:

19/3
   * If an object is assigned the value of that same object, the
     implementation need not do anything.

20/3
   * For assignment of a noncontrolled type, the implementation may
     finalize and assign each component of the variable separately
     (rather than finalizing the entire variable and assigning the
     entire new value) unless a discriminant of the variable is changed
     by the assignment.

21/3
   * The implementation need not create an anonymous object if the value
     being assigned is the result of evaluating a name denoting an
     object (the source object) whose storage cannot overlap with the
     target.  If the source object might overlap with the target object,
     then the implementation can avoid the need for an intermediary
     anonymous object by exercising one of the above permissions and
     perform the assignment one component at a time (for an overlapping
     array assignment), or not at all (for an assignment where the
     target and the source of the assignment are the same object).

22/2
Furthermore, an implementation is permitted to omit implicit Initialize,
Adjust, and Finalize calls and associated assignment operations on an
object of a nonlimited controlled type provided that:

23/2
   * any omitted Initialize call is not a call on a user-defined
     Initialize procedure, and

24/2
   * any usage of the value of the object after the implicit Initialize
     or Adjust call and before any subsequent Finalize call on the
     object does not change the external effect of the program, and

25/2
   * after the omission of such calls and operations, any execution of
     the program that executes an Initialize or Adjust call on an object
     or initializes an object by an aggregate will also later execute a
     Finalize call on the object and will always do so prior to
     assigning a new value to the object, and

26/2
   * the assignment operations associated with omitted Adjust calls are
     also omitted.

27/2
This permission applies to Adjust and Finalize calls even if the
implicit calls have additional external effects.

* Menu:

* 7.6.1 ::    Completion and Finalization


File: arm2012.info,  Node: 7.6.1,  Up: 7.6

7.6.1 Completion and Finalization
---------------------------------

1
This subclause defines completion and leaving of the execution of
constructs and entities.  A master is the execution of a construct that
includes finalization of local objects after it is complete (and after
waiting for any local tasks -- see *note 9.3::), but before leaving.
Other constructs and entities are left immediately upon completion. 

                          _Dynamic Semantics_

2/2
The execution of a construct or entity is complete when the end of that
execution has been reached, or when a transfer of control (see *note
5.1::) causes it to be abandoned. Completion due to reaching the end of
execution, or due to the transfer of control of an exit_statement,
return statement, goto_statement, or requeue_statement or of the
selection of a terminate_alternative is normal completion.  Completion
is abnormal otherwise -- when control is transferred out of a construct
due to abort or the raising of an exception.

3/2
After execution of a construct or entity is complete, it is left,
meaning that execution continues with the next action, as defined for
the execution that is taking place. Leaving an execution happens
immediately after its completion, except in the case of a master: the
execution of a body other than a package_body; the execution of a
statement; or the evaluation of an expression, function_call, or range
that is not part of an enclosing expression, function_call, range, or
simple_statement (*note 5.1: S0147.) other than a
simple_return_statement (*note 6.5: S0183.).  A master is finalized
after it is complete, and before it is left.

4
For the finalization of a master, dependent tasks are first awaited, as
explained in *note 9.3::.  Then each object whose accessibility level is
the same as that of the master is finalized if the object was
successfully initialized and still exists.  These actions are performed
whether the master is left by reaching the last statement or via a
transfer of control.  When a transfer of control causes completion of an
execution, each included master is finalized in order, from innermost
outward.

5
For the finalization of an object:

6/3
   * If the full type of the object is an elementary type, finalization
     has no effect;

7/3
   * If the full type of the object is a tagged type, and the tag of the
     object identifies a controlled type, the Finalize procedure of that
     controlled type is called;

8/3
   * If the full type of the object is a protected type, or if the full
     type of the object is a tagged type and the tag of the object
     identifies a protected type, the actions defined in *note 9.4:: are
     performed;

9/3
   * If the full type of the object is a composite type, then after
     performing the above actions, if any, every component of the object
     is finalized in an arbitrary order, except as follows: if the
     object has a component with an access discriminant constrained by a
     per-object expression, this component is finalized before any
     components that do not have such discriminants; for an object with
     several components with such a discriminant, they are finalized in
     the reverse of the order of their component_declarations;

9.1/2
   * If the object has coextensions (see *note 3.10.2::), each
     coextension is finalized after the object whose access discriminant
     designates it.

10
Immediately before an instance of Unchecked_Deallocation reclaims the
storage of an object, the object is finalized.  If an instance of
Unchecked_Deallocation is never applied to an object created by an
allocator, the object will still exist when the corresponding master
completes, and it will be finalized then.

11/3
The finalization of a master performs finalization of objects created by
declarations in the master in the reverse order of their creation.
After the finalization of a master is complete, the objects finalized as
part of its finalization cease to exist, as do any types and subtypes
defined and created within the master. 

11.1/3
Each nonderived access type T has an associated collection, which is the
set of objects created by allocators of T, or of types derived from T.
Unchecked_Deallocation removes an object from its collection.
Finalization of a collection consists of finalization of each object in
the collection, in an arbitrary order.  The collection of an access type
is an object implicitly declared at the following place:

11.2/3
   * For a named access type, the first freezing point (see *note
     13.14::) of the type.

11.3/3
   * For the type of an access parameter, the call that contains the
     allocator.

11.4/3
   * For the type of an access result, within the master of the call
     (see *note 3.10.2::).

11.5/3
   * For any other anonymous access type, the first freezing point of
     the innermost enclosing declaration.

12/2
The target of an assignment_statement is finalized before copying in the
new value, as explained in *note 7.6::.

13/3
The master of an object is the master enclosing its creation whose
accessibility level (see *note 3.10.2::) is equal to that of the object,
except in the case of an anonymous object representing the result of an
aggregate or function call.  If such an anonymous object is part of the
result of evaluating the actual parameter expression for an explicitly
aliased parameter of a function call, the master of the object is the
innermost master enclosing the evaluation of the aggregate or function
call, excluding the aggregate or function call itself.  Otherwise, the
master of such an anonymous object is the innermost master enclosing the
evaluation of the aggregate or function call, which may be the aggregate
or function call itself.

13.1/3
In the case of an expression that is a master, finalization of any
(anonymous) objects occurs after completing evaluation of the expression
and all use of the objects, prior to starting the execution of any
subsequent construct.

                      _Bounded (Run-Time) Errors_

14/1
It is a bounded error for a call on Finalize or Adjust that occurs as
part of object finalization or assignment to propagate an exception.
The possible consequences depend on what action invoked the Finalize or
Adjust operation:

15
   * For a Finalize invoked as part of an assignment_statement,
     Program_Error is raised at that point.

16/2
   * For an Adjust invoked as part of assignment operations other than
     those invoked as part of an assignment_statement, other adjustments
     due to be performed might or might not be performed, and then
     Program_Error is raised.  During its propagation, finalization
     might or might not be applied to objects whose Adjust failed. For
     an Adjust invoked as part of an assignment_statement, any other
     adjustments due to be performed are performed, and then
     Program_Error is raised.

17
   * For a Finalize invoked as part of a call on an instance of
     Unchecked_Deallocation, any other finalizations due to be performed
     are performed, and then Program_Error is raised.

17.1/3
   * This paragraph was deleted.

17.2/1
   * For a Finalize invoked due to reaching the end of the execution of
     a master, any other finalizations associated with the master are
     performed, and Program_Error is raised immediately after leaving
     the master.

18/2
   * For a Finalize invoked by the transfer of control of an
     exit_statement, return statement, goto_statement, or
     requeue_statement (*note 9.5.4: S0226.), Program_Error is raised no
     earlier than after the finalization of the master being finalized
     when the exception occurred, and no later than the point where
     normal execution would have continued.  Any other finalizations due
     to be performed up to that point are performed before raising
     Program_Error.

19
   * For a Finalize invoked by a transfer of control that is due to
     raising an exception, any other finalizations due to be performed
     for the same master are performed; Program_Error is raised
     immediately after leaving the master.

20
   * For a Finalize invoked by a transfer of control due to an abort or
     selection of a terminate alternative, the exception is ignored; any
     other finalizations due to be performed are performed.

                     _Implementation Permissions_

20.1/3
If the execution of an allocator propagates an exception, any parts of
the allocated object that were successfully initialized may be finalized
as part of the finalization of the innermost master enclosing the
allocator.

20.2/3
The implementation may finalize objects created by allocators for an
access type whose storage pool supports subpools (see *note 13.11.4::)
as if the objects were created (in an arbitrary order) at the point
where the storage pool was elaborated instead of at the first freezing
point of the access type.

     NOTES

21/3
     18  The rules of Clause 10 imply that immediately prior to
     partition termination, Finalize operations are applied to
     library-level controlled objects (including those created by
     allocators of library-level access types, except those already
     finalized).  This occurs after waiting for library-level tasks to
     terminate.

22
     19  A constant is only constant between its initialization and
     finalization.  Both initialization and finalization are allowed to
     change the value of a constant.

23
     20  Abort is deferred during certain operations related to
     controlled types, as explained in *note 9.8::.  Those rules prevent
     an abort from causing a controlled object to be left in an
     ill-defined state.

24
     21  The Finalize procedure is called upon finalization of a
     controlled object, even if Finalize was called earlier, either
     explicitly or as part of an assignment; hence, if a controlled type
     is visibly controlled (implying that its Finalize primitive is
     directly callable), or is nonlimited (implying that assignment is
     allowed), its Finalize procedure should be designed to have no ill
     effect if it is applied a second time to the same object.


File: arm2012.info,  Node: 8,  Next: 9,  Prev: 7,  Up: Top

8 Visibility Rules
******************

1/3
The rules defining the scope of declarations and the rules defining
which identifiers, character_literals, and operator_symbols are visible
at (or from) various places in the text of the program are described in
this clause.  The formulation of these rules uses the notion of a
declarative region.

2/3
As explained in Clause *note 3::, a declaration declares a view of an
entity and associates a defining name with that view.  The view
comprises an identification of the viewed entity, and possibly
additional properties.  A usage name denotes a declaration.  It also
denotes the view declared by that declaration, and denotes the entity of
that view.  Thus, two different usage names might denote two different
views of the same entity; in this case they denote the same entity.

* Menu:

* 8.1 ::      Declarative Region
* 8.2 ::      Scope of Declarations
* 8.3 ::      Visibility
* 8.4 ::      Use Clauses
* 8.5 ::      Renaming Declarations
* 8.6 ::      The Context of Overload Resolution


File: arm2012.info,  Node: 8.1,  Next: 8.2,  Up: 8

8.1 Declarative Region
======================

                          _Static Semantics_

1
For each of the following constructs, there is a portion of the program
text called its declarative region, within which nested declarations can
occur:

2
   * any declaration, other than that of an enumeration type, that is
     not a completion of a previous declaration;

2.1/4
   * an access_definition;

3
   * a block_statement;

4
   * a loop_statement;

4.1/3
   * a quantified_expression;

4.2/3
   * an extended_return_statement;

5
   * an accept_statement;

6
   * an exception_handler.

7
The declarative region includes the text of the construct together with
additional text determined (recursively), as follows:

8
   * If a declaration is included, so is its completion, if any.

9
   * If the declaration of a library unit (including Standard -- see
     *note 10.1.1::) is included, so are the declarations of any child
     units (and their completions, by the previous rule).  The child
     declarations occur after the declaration.

10
   * If a body_stub is included, so is the corresponding subunit.

11
   * If a type_declaration is included, then so is a corresponding
     record_representation_clause, if any.

12
The declarative region of a declaration is also called the declarative
region of any view or entity declared by the declaration.

13
A declaration occurs immediately within a declarative region if this
region is the innermost declarative region that encloses the declaration
(the immediately enclosing declarative region), not counting the
declarative region (if any) associated with the declaration itself.

14
A declaration is local to a declarative region if the declaration occurs
immediately within the declarative region.  An entity is local to a
declarative region if the entity is declared by a declaration that is
local to the declarative region.

15
A declaration is global to a declarative region if the declaration
occurs immediately within another declarative region that encloses the
declarative region.  An entity is global to a declarative region if the
entity is declared by a declaration that is global to the declarative
region.

     NOTES

16
     1  The children of a parent library unit are inside the parent's
     declarative region, even though they do not occur inside the
     parent's declaration or body.  This implies that one can use (for
     example) "P.Q" to refer to a child of P whose defining name is Q,
     and that after "use P;" Q can refer (directly) to that child.

17
     2  As explained above and in *note 10.1.1::, "*note 10.1.1::
     Compilation Units - Library Units", all library units are
     descendants of Standard, and so are contained in the declarative
     region of Standard.  They are not inside the declaration or body of
     Standard, but they are inside its declarative region.

18
     3  For a declarative region that comes in multiple parts, the text
     of the declarative region does not contain any text that might
     appear between the parts.  Thus, when a portion of a declarative
     region is said to extend from one place to another in the
     declarative region, the portion does not contain any text that
     might appear between the parts of the declarative region.


File: arm2012.info,  Node: 8.2,  Next: 8.3,  Prev: 8.1,  Up: 8

8.2 Scope of Declarations
=========================

1
For each declaration, the language rules define a certain portion of the
program text called the scope of the declaration.  The scope of a
declaration is also called the scope of any view or entity declared by
the declaration.  Within the scope of an entity, and only there, there
are places where it is legal to refer to the declared entity.  These
places are defined by the rules of visibility and overloading.

                          _Static Semantics_

2
The immediate scope of a declaration is a portion of the declarative
region immediately enclosing the declaration.  The immediate scope
starts at the beginning of the declaration, except in the case of an
overloadable declaration, in which case the immediate scope starts just
after the place where the profile of the callable entity is determined
(which is at the end of the _specification for the callable entity, or
at the end of the generic_instantiation if an instance).  The immediate
scope extends to the end of the declarative region, with the following
exceptions:

3
   * The immediate scope of a library_item includes only its semantic
     dependents.

4
   * The immediate scope of a declaration in the private part of a
     library unit does not include the visible part of any public
     descendant of that library unit. 

5
The visible part of (a view of) an entity is a portion of the text of
its declaration containing declarations that are visible from outside.
The private part of (a view of) an entity that has a visible part
contains all declarations within the declaration of (the view of) the
entity, except those in the visible part; these are not visible from
outside.  Visible and private parts are defined only for these kinds of
entities: callable entities, other program units, and composite types.

6
   * The visible part of a view of a callable entity is its profile.

7
   * The visible part of a composite type other than a task or protected
     type consists of the declarations of all components declared
     (explicitly or implicitly) within the type_declaration.

8
   * The visible part of a generic unit includes the
     generic_formal_part.  For a generic package, it also includes the
     first list of basic_declarative_items of the package_specification.
     For a generic subprogram, it also includes the profile.

9
   * The visible part of a package, task unit, or protected unit
     consists of declarations in the program unit's declaration other
     than those following the reserved word private, if any; see *note
     7.1:: and *note 12.7:: for packages, *note 9.1:: for task units,
     and *note 9.4:: for protected units.

10
The scope of a declaration always contains the immediate scope of the
declaration.  In addition, for a given declaration that occurs
immediately within the visible part of an outer declaration, or is a
public child of an outer declaration, the scope of the given declaration
extends to the end of the scope of the outer declaration, except that
the scope of a library_item includes only its semantic dependents.

10.1/3
The scope of an attribute_definition_clause is identical to the scope of
a declaration that would occur at the point of the
attribute_definition_clause.  The scope of an aspect_specification is
identical to the scope of the associated declaration.

11
The immediate scope of a declaration is also the immediate scope of the
entity or view declared by the declaration. Similarly, the scope of a
declaration is also the scope of the entity or view declared by the
declaration.

12/4
The immediate scope of a pragma that is not used as a configuration
pragma is defined to be the region extending from immediately after the
pragma to the end of the declarative region immediately enclosing the
pragma.

     NOTES

13/3
     4  There are notations for denoting visible declarations that are
     not directly visible.  For example, parameter_specification (*note
     6.1: S0175.)s are in the visible part of a subprogram_declaration
     (*note 6.1: S0163.) so that they can be used in named-notation
     calls appearing outside the called subprogram.  For another
     example, declarations of the visible part of a package can be
     denoted by expanded names appearing outside the package, and can be
     made directly visible by a use_clause.


File: arm2012.info,  Node: 8.3,  Next: 8.4,  Prev: 8.2,  Up: 8

8.3 Visibility
==============

1
The visibility rules, given below, determine which declarations are
visible and directly visible at each place within a program.  The
visibility rules apply to both explicit and implicit declarations.

                          _Static Semantics_

2
A declaration is defined to be directly visible at places where a name
consisting of only an identifier or operator_symbol is sufficient to
denote the declaration; that is, no selected_component notation or
special context (such as preceding => in a named association) is
necessary to denote the declaration. A declaration is defined to be
visible wherever it is directly visible, as well as at other places
where some name (such as a selected_component) can denote the
declaration.

3
The syntactic category direct_name is used to indicate contexts where
direct visibility is required.  The syntactic category selector_name is
used to indicate contexts where visibility, but not direct visibility,
is required.

4
There are two kinds of direct visibility: immediate visibility and
use-visibility. A declaration is immediately visible at a place if it is
directly visible because the place is within its immediate scope. A
declaration is use-visible if it is directly visible because of a
use_clause (see *note 8.4::).  Both conditions can apply.

5
A declaration can be hidden, either from direct visibility, or from all
visibility, within certain parts of its scope. Where hidden from all
visibility, it is not visible at all (neither using a direct_name nor a
selector_name). Where hidden from direct visibility, only direct
visibility is lost; visibility using a selector_name is still possible.

6
Two or more declarations are overloaded if they all have the same
defining name and there is a place where they are all directly visible.

7
The declarations of callable entities (including enumeration literals)
are overloadable, meaning that overloading is allowed for them.

8
Two declarations are homographs if they have the same defining name,
and, if both are overloadable, their profiles are type conformant. An
inner declaration hides any outer homograph from direct visibility.

9/1
Two homographs are not generally allowed immediately within the same
declarative region unless one overrides the other (see Legality Rules
below). The only declarations that are overridable are the implicit
declarations for predefined operators and inherited primitive
subprograms.  A declaration overrides another homograph that occurs
immediately within the same declarative region in the following cases:

10/1
   * A declaration that is not overridable overrides one that is
     overridable, regardless of which declaration occurs first;

11
   * The implicit declaration of an inherited operator overrides that of
     a predefined operator;

12
   * An implicit declaration of an inherited subprogram overrides a
     previous implicit declaration of an inherited subprogram.

12.1/2
   * If two or more homographs are implicitly declared at the same
     place:

12.2/2
             * If at least one is a subprogram that is neither a null
               procedure nor an abstract subprogram, and does not
               require overriding (see *note 3.9.3::), then they
               override those that are null procedures, abstract
               subprograms, or require overriding.  If more than one
               such homograph remains that is not thus overridden, then
               they are all hidden from all visibility.

12.3/2
             * Otherwise (all are null procedures, abstract subprograms,
               or require overriding), then any null procedure overrides
               all abstract subprograms and all subprograms that require
               overriding; if more than one such homograph remains that
               is not thus overridden, then if they are all fully
               conformant with one another, one is chosen arbitrarily;
               if not, they are all hidden from all visibility. 

13
   * For an implicit declaration of a primitive subprogram in a generic
     unit, there is a copy of this declaration in an instance.  However,
     a whole new set of primitive subprograms is implicitly declared for
     each type declared within the visible part of the instance.  These
     new declarations occur immediately after the type declaration, and
     override the copied ones.  The copied ones can be called only from
     within the instance; the new ones can be called only from outside
     the instance, although for tagged types, the body of a new one can
     be executed by a call to an old one.

14
A declaration is visible within its scope, except where hidden from all
visibility, as follows:

15
   * An overridden declaration is hidden from all visibility within the
     scope of the overriding declaration.

16
   * A declaration is hidden from all visibility until the end of the
     declaration, except:

17
             * For a record type or record extension, the declaration is
               hidden from all visibility only until the reserved word
               record;

18/3
             * For a package_declaration, generic_package_declaration
               (*note 12.1: S0273.), subprogram_body (*note 6.3:
               S0177.), or expression_function_declaration (*note 6.8:
               S0189.), the declaration is hidden from all visibility
               only until the reserved word is of the declaration;

18.1/2
             * For a task declaration or protected declaration, the
               declaration is hidden from all visibility only until the
               reserved word with of the declaration if there is one, or
               the reserved word is of the declaration if there is no
               with.

19
   * If the completion of a declaration is a declaration, then within
     the scope of the completion, the first declaration is hidden from
     all visibility.  Similarly, a discriminant_specification (*note
     3.7: S0062.) or parameter_specification (*note 6.1: S0175.) is
     hidden within the scope of a corresponding
     discriminant_specification (*note 3.7: S0062.) or
     parameter_specification (*note 6.1: S0175.) of a corresponding
     completion, or of a corresponding accept_statement (*note 9.5.2:
     S0219.).

20/2
   * The declaration of a library unit (including a
     library_unit_renaming_declaration) is hidden from all visibility at
     places outside its declarative region that are not within the scope
     of a nonlimited_with_clause that mentions it.  The limited view of
     a library package is hidden from all visibility at places that are
     not within the scope of a limited_with_clause that mentions it; in
     addition, the limited view is hidden from all visibility within the
     declarative region of the package, as well as within the scope of
     any nonlimited_with_clause that mentions the package.  Where the
     declaration of the limited view of a package is visible, any name
     that denotes the package denotes the limited view, including those
     provided by a package renaming.

20.1/2
   * For each declaration or renaming of a generic unit as a child of
     some parent generic package, there is a corresponding declaration
     nested immediately within each instance of the parent.  Such a
     nested declaration is hidden from all visibility except at places
     that are within the scope of a with_clause that mentions the child.

21
A declaration with a defining_identifier or defining_operator_symbol is
immediately visible (and hence directly visible) within its immediate
scope  except where hidden from direct visibility, as follows:

22
   * A declaration is hidden from direct visibility within the immediate
     scope of a homograph of the declaration, if the homograph occurs
     within an inner declarative region;

23
   * A declaration is also hidden from direct visibility where hidden
     from all visibility.

23.1/3
An attribute_definition_clause or an aspect_specification is visible
everywhere within its scope.

                        _Name Resolution Rules_

24
A direct_name shall resolve to denote a directly visible declaration
whose defining name is the same as the direct_name. A selector_name
shall resolve to denote a visible declaration whose defining name is the
same as the selector_name.

25
These rules on visibility and direct visibility do not apply in a
context_clause, a parent_unit_name, or a pragma that appears at the
place of a compilation_unit.  For those contexts, see the rules in *note
10.1.6::, "*note 10.1.6:: Environment-Level Visibility Rules".

                           _Legality Rules_

26/2
A nonoverridable declaration is illegal if there is a homograph
occurring immediately within the same declarative region that is visible
at the place of the declaration, and is not hidden from all visibility
by the nonoverridable declaration.  In addition, a type extension is
illegal if somewhere within its immediate scope it has two visible
components with the same name.  Similarly, the context_clause for a
compilation unit is illegal if it mentions (in a with_clause) some
library unit, and there is a homograph of the library unit that is
visible at the place of the compilation unit, and the homograph and the
mentioned library unit are both declared immediately within the same
declarative region.  These rules also apply to dispatching operations
declared in the visible part of an instance of a generic unit.  However,
they do not apply to other overloadable declarations in an instance;
such declarations may have type conformant profiles in the instance, so
long as the corresponding declarations in the generic were not type
conformant. 

     NOTES

27
     5  Visibility for compilation units follows from the definition of
     the environment in *note 10.1.4::, except that it is necessary to
     apply a with_clause to obtain visibility to a
     library_unit_declaration or library_unit_renaming_declaration.

28
     6  In addition to the visibility rules given above, the meaning of
     the occurrence of a direct_name or selector_name at a given place
     in the text can depend on the overloading rules (see *note 8.6::).

29
     7  Not all contexts where an identifier, character_literal, or
     operator_symbol are allowed require visibility of a corresponding
     declaration.  Contexts where visibility is not required are
     identified by using one of these three syntactic categories
     directly in a syntax rule, rather than using direct_name or
     selector_name.

* Menu:

* 8.3.1 ::    Overriding Indicators


File: arm2012.info,  Node: 8.3.1,  Up: 8.3

8.3.1 Overriding Indicators
---------------------------

1/2
An overriding_indicator is used to declare that an operation is intended
to override (or not override) an inherited operation.

                               _Syntax_

2/2
     overriding_indicator ::= [not] overriding

                           _Legality Rules_

3/3
If an abstract_subprogram_declaration (*note 3.9.3: S0076.),
null_procedure_declaration (*note 6.7: S0188.),
expression_function_declaration (*note 6.8: S0189.), subprogram_body,
subprogram_body_stub (*note 10.1.3: S0259.),
subprogram_renaming_declaration (*note 8.5.4: S0203.),
generic_instantiation (*note 12.3: S0276.) of a subprogram, or
subprogram_declaration (*note 6.1: S0163.) other than a protected
subprogram has an overriding_indicator (*note 8.3.1: S0195.), then:

4/2
   * the operation shall be a primitive operation for some type;

5/2
   * if the overriding_indicator is overriding, then the operation shall
     override a homograph at the place of the declaration or body;

6/2
   * if the overriding_indicator is not overriding, then the operation
     shall not override any homograph (at any place).

7/2
In addition to the places where Legality Rules normally apply, these
rules also apply in the private part of an instance of a generic unit.

     NOTES

8/2
     8  Rules for overriding_indicators of task and protected entries
     and of protected subprograms are found in *note 9.5.2:: and *note
     9.4::, respectively.

                              _Examples_

9/2
The use of overriding_indicators allows the detection of errors at
compile-time that otherwise might not be detected at all.  For instance,
we might declare a security queue derived from the Queue interface of
3.9.4 as:

10/2
     type Security_Queue is new Queue with record ...;

11/2
     overriding
     procedure Append(Q : in out Security_Queue; Person : in Person_Name);

12/2
     overriding
     procedure Remove_First(Q : in out Security_Queue; Person : in Person_Name);

13/2
     overriding
     function Cur_Count(Q : in Security_Queue) return Natural;

14/2
     overriding
     function Max_Count(Q : in Security_Queue) return Natural;

15/2
     not overriding
     procedure Arrest(Q : in out Security_Queue; Person : in Person_Name);

16/2
The first four subprogram declarations guarantee that these subprograms
will override the four subprograms inherited from the Queue interface.
A misspelling in one of these subprograms will be detected by the
implementation.  Conversely, the declaration of Arrest guarantees that
this is a new operation.


File: arm2012.info,  Node: 8.4,  Next: 8.5,  Prev: 8.3,  Up: 8

8.4 Use Clauses
===============

1
A use_package_clause achieves direct visibility of declarations that
appear in the visible part of a package; a use_type_clause achieves
direct visibility of the primitive operators of a type.

                               _Syntax_

2
     use_clause ::= use_package_clause | use_type_clause

3
     use_package_clause ::= use package_name {, package_name};

4/3
     use_type_clause ::= use [all] type subtype_mark {, subtype_mark};

                           _Legality Rules_

5/2
A package_name of a use_package_clause shall denote a nonlimited view of
a package.

                          _Static Semantics_

6
For each use_clause, there is a certain region of text called the scope
of the use_clause.  For a use_clause within a context_clause of a
library_unit_declaration or library_unit_renaming_declaration, the scope
is the entire declarative region of the declaration.  For a use_clause
within a context_clause of a body, the scope is the entire body and any
subunits (including multiply nested subunits).  The scope does not
include context_clauses themselves.

7
For a use_clause immediately within a declarative region, the scope is
the portion of the declarative region starting just after the use_clause
and extending to the end of the declarative region.  However, the scope
of a use_clause in the private part of a library unit does not include
the visible part of any public descendant of that library unit.

7.1/2
A package is named in a use_package_clause if it is denoted by a
package_name of that clause.  A type is named in a use_type_clause if it
is determined by a subtype_mark of that clause.

8/3
For each package named in a use_package_clause whose scope encloses a
place, each declaration that occurs immediately within the declarative
region of the package is potentially use-visible at this place if the
declaration is visible at this place.  For each type T or T'Class named
in a use_type_clause whose scope encloses a place, the declaration of
each primitive operator of type T is potentially use-visible at this
place if its declaration is visible at this place.  If a use_type_clause
whose scope encloses a place includes the reserved word all, then the
following entities are also potentially use-visible at this place if the
declaration of the entity is visible at this place:

8.1/3
   * Each primitive subprogram of T including each enumeration literal
     (if any);

8.2/3
   * Each subprogram that is declared immediately within the declarative
     region in which an ancestor type of T is declared and that operates
     on a class-wide type that covers T.

8.3/3
Certain implicit declarations may become potentially use-visible in
certain contexts as described in *note 12.6::.

9
A declaration is use-visible if it is potentially use-visible, except in
these naming-conflict cases:

10
   * A potentially use-visible declaration is not use-visible if the
     place considered is within the immediate scope of a homograph of
     the declaration.

11
   * Potentially use-visible declarations that have the same identifier
     are not use-visible unless each of them is an overloadable
     declaration.

                          _Dynamic Semantics_

12
The elaboration of a use_clause has no effect.

                              _Examples_

13
Example of a use clause in a context clause:

14
     with Ada.Calendar; use Ada;

15
Example of a use type clause:

16
     use type Rational_Numbers.Rational; -- see *note 7.1::
     Two_Thirds: Rational_Numbers.Rational := 2/3;


File: arm2012.info,  Node: 8.5,  Next: 8.6,  Prev: 8.4,  Up: 8

8.5 Renaming Declarations
=========================

1
A renaming_declaration declares another name for an entity, such as an
object, exception, package, subprogram, entry, or generic unit.
Alternatively, a subprogram_renaming_declaration can be the completion
of a previous subprogram_declaration.

                               _Syntax_

2
     renaming_declaration ::=
           object_renaming_declaration
         | exception_renaming_declaration
         | package_renaming_declaration
         | subprogram_renaming_declaration
         | generic_renaming_declaration

                          _Dynamic Semantics_

3
The elaboration of a renaming_declaration evaluates the name that
follows the reserved word renames and thereby determines the view and
entity denoted by this name (the renamed view and renamed entity).  A
name that denotes the renaming_declaration denotes (a new view of) the
renamed entity.

     NOTES

4
     9  Renaming may be used to resolve name conflicts and to act as a
     shorthand.  Renaming with a different identifier or operator_symbol
     does not hide the old name; the new name and the old name need not
     be visible at the same places.

5
     10  A task or protected object that is declared by an explicit
     object_declaration can be renamed as an object.  However, a single
     task or protected object cannot be renamed since the corresponding
     type is anonymous (meaning it has no nameable subtypes).  For
     similar reasons, an object of an anonymous array or access type
     cannot be renamed.

6
     11  A subtype defined without any additional constraint can be used
     to achieve the effect of renaming another subtype (including a task
     or protected subtype) as in

7
             subtype Mode is Ada.Text_IO.File_Mode;

* Menu:

* 8.5.1 ::    Object Renaming Declarations
* 8.5.2 ::    Exception Renaming Declarations
* 8.5.3 ::    Package Renaming Declarations
* 8.5.4 ::    Subprogram Renaming Declarations
* 8.5.5 ::    Generic Renaming Declarations


File: arm2012.info,  Node: 8.5.1,  Next: 8.5.2,  Up: 8.5

8.5.1 Object Renaming Declarations
----------------------------------

1
An object_renaming_declaration is used to rename an object.

                               _Syntax_

2/3
     object_renaming_declaration ::=
         defining_identifier : [null_exclusion] 
     subtype_mark renames object_name
             [aspect_specification];
       | defining_identifier : access_definition renames object_name
             [aspect_specification];

                        _Name Resolution Rules_

3/2
The type of the object_name shall resolve to the type determined by the
subtype_mark, or in the case where the type is defined by an
access_definition, to an anonymous access type.  If the anonymous access
type is an access-to-object type, the type of the object_name shall have
the same designated type as that of the access_definition.  If the
anonymous access type is an access-to-subprogram type, the type of the
object_name shall have a designated profile that is type conformant with
that of the access_definition.

                           _Legality Rules_

4
The renamed entity shall be an object.

4.1/2
In the case where the type is defined by an access_definition, the type
of the renamed object and the type defined by the access_definition:

4.2/2
   * shall both be access-to-object types with statically matching
     designated subtypes and with both or neither being
     access-to-constant types; or 

4.3/2
   * shall both be access-to-subprogram types with subtype conformant
     designated profiles. 

4.4/2
For an object_renaming_declaration with a null_exclusion or an
access_definition that has a null_exclusion:

4.5/2
   * if the object_name denotes a generic formal object of a generic
     unit G, and the object_renaming_declaration occurs within the body
     of G or within the body of a generic unit declared within the
     declarative region of G, then the declaration of the formal object
     of G shall have a null_exclusion;

4.6/2
   * otherwise, the subtype of the object_name shall exclude null. In
     addition to the places where Legality Rules normally apply (see
     *note 12.3::), this rule applies also in the private part of an
     instance of a generic unit.

5/3
The renamed entity shall not be a subcomponent that depends on
discriminants of an object whose nominal subtype is unconstrained unless
the object is known to be constrained.  A slice of an array shall not be
renamed if this restriction disallows renaming of the array. In addition
to the places where Legality Rules normally apply, these rules apply
also in the private part of an instance of a generic unit.

                          _Static Semantics_

6/2
An object_renaming_declaration declares a new view of the renamed object
whose properties are identical to those of the renamed view.  Thus, the
properties of the renamed object are not affected by the
renaming_declaration.  In particular, its value and whether or not it is
a constant are unaffected; similarly, the null exclusion or constraints
that apply to an object are not affected by renaming (any constraint
implied by the subtype_mark or access_definition of the
object_renaming_declaration is ignored).

                              _Examples_

7
Example of renaming an object:

8
     declare
        L : Person renames Leftmost_Person; -- see *note 3.10.1::
     begin
        L.Age := L.Age + 1;
     end;


File: arm2012.info,  Node: 8.5.2,  Next: 8.5.3,  Prev: 8.5.1,  Up: 8.5

8.5.2 Exception Renaming Declarations
-------------------------------------

1
An exception_renaming_declaration is used to rename an exception.

                               _Syntax_

2/3
     exception_renaming_declaration ::=
     defining_identifier : exception renames exception_name
        [aspect_specification];

                           _Legality Rules_

3
The renamed entity shall be an exception.

                          _Static Semantics_

4
An exception_renaming_declaration declares a new view of the renamed
exception.

                              _Examples_

5
Example of renaming an exception:

6
     EOF : exception renames Ada.IO_Exceptions.End_Error; -- see *note A.13::


File: arm2012.info,  Node: 8.5.3,  Next: 8.5.4,  Prev: 8.5.2,  Up: 8.5

8.5.3 Package Renaming Declarations
-----------------------------------

1
A package_renaming_declaration is used to rename a package.

                               _Syntax_

2/3
     package_renaming_declaration ::= package 
     defining_program_unit_name renames package_name
        [aspect_specification];

                           _Legality Rules_

3
The renamed entity shall be a package.

3.1/2
If the package_name of a package_renaming_declaration denotes a limited
view of a package P, then a name that denotes the
package_renaming_declaration shall occur only within the immediate scope
of the renaming or the scope of a with_clause that mentions the package
P or, if P is a nested package, the innermost library package enclosing
P.

                          _Static Semantics_

4
A package_renaming_declaration declares a new view of the renamed
package.

4.1/2
At places where the declaration of the limited view of the renamed
package is visible, a name that denotes the package_renaming_declaration
denotes a limited view of the package (see *note 10.1.1::).

                              _Examples_

5
Example of renaming a package:

6
     package TM renames Table_Manager;


File: arm2012.info,  Node: 8.5.4,  Next: 8.5.5,  Prev: 8.5.3,  Up: 8.5

8.5.4 Subprogram Renaming Declarations
--------------------------------------

1/3
A subprogram_renaming_declaration can serve as the completion of a
subprogram_declaration; such a renaming_declaration is called a
renaming-as-body. A subprogram_renaming_declaration that is not a
completion is called a renaming-as-declaration, and is used to rename a
subprogram (possibly an enumeration literal) or an entry.

                               _Syntax_

2/3
     subprogram_renaming_declaration ::=
         [overriding_indicator]
         subprogram_specification renames callable_entity_name
             [aspect_specification];

                        _Name Resolution Rules_

3
The expected profile for the callable_entity_name is the profile given
in the subprogram_specification.

                           _Legality Rules_

4/3
The profile of a renaming-as-declaration shall be mode conformant, with
that of the renamed callable entity. 

4.1/2
For a parameter or result subtype of the subprogram_specification that
has an explicit null_exclusion:

4.2/2
   * if the callable_entity_name denotes a generic formal subprogram of
     a generic unit G, and the subprogram_renaming_declaration occurs
     within the body of a generic unit G or within the body of a generic
     unit declared within the declarative region of the generic unit G,
     then the corresponding parameter or result subtype of the formal
     subprogram of G shall have a null_exclusion;

4.3/2
   * otherwise, the subtype of the corresponding parameter or result
     type of the renamed callable entity shall exclude null. In addition
     to the places where Legality Rules normally apply (see *note
     12.3::), this rule applies also in the private part of an instance
     of a generic unit.

5/3
The profile of a renaming-as-body shall conform fully to that of the
declaration it completes. If the renaming-as-body completes that
declaration before the subprogram it declares is frozen, the profile
shall be mode conformant with that of the renamed callable entity and
the subprogram it declares takes its convention from the renamed
subprogram; otherwise, the profile shall be subtype conformant with that
of the renamed callable entity and the convention of the renamed
subprogram shall not be Intrinsic. A renaming-as-body is illegal if the
declaration occurs before the subprogram whose declaration it completes
is frozen, and the renaming renames the subprogram itself, through one
or more subprogram renaming declarations, none of whose subprograms has
been frozen.

5.1/2
The callable_entity_name of a renaming shall not denote a subprogram
that requires overriding (see *note 3.9.3::).

5.2/2
The callable_entity_name of a renaming-as-body shall not denote an
abstract subprogram.

6
A name that denotes a formal parameter of the subprogram_specification
is not allowed within the callable_entity_name.

                          _Static Semantics_

7
A renaming-as-declaration declares a new view of the renamed entity.
The profile of this new view takes its subtypes, parameter modes, and
calling convention from the original profile of the callable entity,
while taking the formal parameter names and default_expressions from the
profile given in the subprogram_renaming_declaration.  The new view is a
function or procedure, never an entry.

                          _Dynamic Semantics_

7.1/1
For a call to a subprogram whose body is given as a renaming-as-body,
the execution of the renaming-as-body is equivalent to the execution of
a subprogram_body that simply calls the renamed subprogram with its
formal parameters as the actual parameters and, if it is a function,
returns the value of the call.

8/3
For a call on a renaming of a dispatching subprogram that is overridden,
if the overriding occurred before the renaming, then the body executed
is that of the overriding declaration, even if the overriding
declaration is not visible at the place of the renaming; otherwise, the
inherited or predefined subprogram is called.  A corresponding rule
applies to a call on a renaming of a predefined equality operator for an
untagged record type.

                      _Bounded (Run-Time) Errors_

8.1/1
If a subprogram directly or indirectly renames itself, then it is a
bounded error to call that subprogram.  Possible consequences are that
Program_Error or Storage_Error is raised, or that the call results in
infinite recursion.

     NOTES

9
     12  A procedure can only be renamed as a procedure.  A function
     whose defining_designator is either an identifier or an
     operator_symbol can be renamed with either an identifier or an
     operator_symbol; for renaming as an operator, the subprogram
     specification given in the renaming_declaration is subject to the
     rules given in *note 6.6:: for operator declarations.  Enumeration
     literals can be renamed as functions; similarly,
     attribute_references that denote functions (such as references to
     Succ and Pred) can be renamed as functions.  An entry can only be
     renamed as a procedure; the new name is only allowed to appear in
     contexts that allow a procedure name.  An entry of a family can be
     renamed, but an entry family cannot be renamed as a whole.

10
     13  The operators of the root numeric types cannot be renamed
     because the types in the profile are anonymous, so the
     corresponding specifications cannot be written; the same holds for
     certain attributes, such as Pos.

11
     14  Calls with the new name of a renamed entry are
     procedure_call_statements and are not allowed at places where the
     syntax requires an entry_call_statement in conditional_ and
     timed_entry_calls, nor in an asynchronous_select; similarly, the
     Count attribute is not available for the new name.

12
     15  The primitiveness of a renaming-as-declaration is determined by
     its profile, and by where it occurs, as for any declaration of (a
     view of) a subprogram; primitiveness is not determined by the
     renamed view.  In order to perform a dispatching call, the
     subprogram name has to denote a primitive subprogram, not a
     nonprimitive renaming of a primitive subprogram.

                              _Examples_

13
Examples of subprogram renaming declarations:

14
     procedure My_Write(C : in Character) renames Pool(K).Write; --  see *note 4.1.3::

15
     function Real_Plus(Left, Right : Real   ) return Real    renames "+";
     function Int_Plus (Left, Right : Integer) return Integer renames "+";

16
     function Rouge return Color renames Red;  --  see *note 3.5.1::
     function Rot   return Color renames Red;
     function Rosso return Color renames Rouge;

17
     function Next(X : Color) return Color renames Color'Succ; -- see *note 3.5.1::

18
Example of a subprogram renaming declaration with new parameter names:

19
     function "*" (X,Y : Vector) return Real renames Dot_Product; -- see *note 6.1::

20
Example of a subprogram renaming declaration with a new default
expression:

21
     function Minimum(L : Link := Head) return Cell renames Min_Cell; -- see *note 6.1::


File: arm2012.info,  Node: 8.5.5,  Prev: 8.5.4,  Up: 8.5

8.5.5 Generic Renaming Declarations
-----------------------------------

1
A generic_renaming_declaration is used to rename a generic unit.

                               _Syntax_

2/3
     generic_renaming_declaration ::=
         generic package   
     defining_program_unit_name renames generic_package_name
             [aspect_specification];
       | generic procedure   
     defining_program_unit_name renames generic_procedure_name
             [aspect_specification];
       | generic function   
     defining_program_unit_name renames generic_function_name
             [aspect_specification];

                           _Legality Rules_

3
The renamed entity shall be a generic unit of the corresponding kind.

                          _Static Semantics_

4
A generic_renaming_declaration declares a new view of the renamed
generic unit.

     NOTES

5
     16  Although the properties of the new view are the same as those
     of the renamed view, the place where the
     generic_renaming_declaration occurs may affect the legality of
     subsequent renamings and instantiations that denote the
     generic_renaming_declaration, in particular if the renamed generic
     unit is a library unit (see *note 10.1.1::).

                              _Examples_

6
Example of renaming a generic unit:

7
     generic package Enum_IO renames Ada.Text_IO.Enumeration_IO;  -- see *note A.10.10::


File: arm2012.info,  Node: 8.6,  Prev: 8.5,  Up: 8

8.6 The Context of Overload Resolution
======================================

1/3
Because declarations can be overloaded, it is possible for an occurrence
of a usage name to have more than one possible interpretation; in most
cases, ambiguity is disallowed.  This subclause describes how the
possible interpretations resolve to the actual interpretation.

2
Certain rules of the language (the Name Resolution Rules) are considered
"overloading rules".  If a possible interpretation violates an
overloading rule, it is assumed not to be the intended interpretation;
some other possible interpretation is assumed to be the actual
interpretation.  On the other hand, violations of nonoverloading rules
do not affect which interpretation is chosen; instead, they cause the
construct to be illegal.  To be legal, there usually has to be exactly
one acceptable interpretation of a construct that is a "complete
context", not counting any nested complete contexts.

3
The syntax rules of the language and the visibility rules given in *note
8.3:: determine the possible interpretations.  Most type checking rules
(rules that require a particular type, or a particular class of types,
for example) are overloading rules.  Various rules for the matching of
formal and actual parameters are overloading rules.

                        _Name Resolution Rules_

4
Overload resolution is applied separately to each complete context, not
counting inner complete contexts.  Each of the following constructs is a
complete context:

5
   * A context_item.

6
   * A declarative_item or declaration.

7
   * A statement.

8
   * A pragma_argument_association.

9/4
   * The selecting_expression of a case_statement or case_expression.

10
An (overall) interpretation of a complete context embodies its meaning,
and includes the following information about the constituents of the
complete context, not including constituents of inner complete contexts:

11
   * for each constituent of the complete context, to which syntactic
     categories it belongs, and by which syntax rules; and

12
   * for each usage name, which declaration it denotes (and, therefore,
     which view and which entity it denotes); and

13
   * for a complete context that is a declarative_item, whether or not
     it is a completion of a declaration, and (if so) which declaration
     it completes.

14
A possible interpretation is one that obeys the syntax rules and the
visibility rules. An acceptable interpretation is a possible
interpretation that obeys the overloading rules, that is, those rules
that specify an expected type or expected profile, or specify how a
construct shall resolve or be interpreted.

15
The interpretation of a constituent of a complete context is determined
from the overall interpretation of the complete context as a whole.
Thus, for example, "interpreted as a function_call," means that the
construct's interpretation says that it belongs to the syntactic
category function_call.

16
Each occurrence of a usage name denotes the declaration determined by
its interpretation.  It also denotes the view declared by its denoted
declaration, except in the following cases:

17/3
   * If a usage name appears within the declarative region of a
     type_declaration and denotes that same type_declaration, then it
     denotes the current instance of the type (rather than the type
     itself); the current instance of a type is the object or value of
     the type that is associated with the execution that evaluates the
     usage name.  Similarly, if a usage name appears within the
     declarative region of a subtype_declaration and denotes that same
     subtype_declaration, then it denotes the current instance of the
     subtype.  These rules do not apply if the usage name appears within
     the subtype_mark of an access_definition for an access-to-object
     type, or within the subtype of a parameter or result of an
     access-to-subprogram type.

17.1/4
     Within an aspect_specification for a type or subtype, the current
     instance represents a value of the type; it is not an object.  The
     nominal subtype of this value is given by the subtype itself (the
     first subtype in the case of a type_declaration), prior to applying
     any predicate specified directly on the type or subtype.  If the
     type or subtype is by-reference, the associated object with the
     value is the object associated (see *note 6.2::) with the execution
     of the usage name.

18
   * If a usage name appears within the declarative region of a
     generic_declaration (but not within its generic_formal_part) and it
     denotes that same generic_declaration, then it denotes the current
     instance of the generic unit (rather than the generic unit itself).
     See also *note 12.3::.

19
A usage name that denotes a view also denotes the entity of that view.

20/2
The expected type for a given expression, name, or other construct
determines, according to the type resolution rules given below, the
types considered for the construct during overload resolution. The type
resolution rules provide support for class-wide programming, universal
literals, dispatching operations, and anonymous access types:

21
   * If a construct is expected to be of any type in a class of types,
     or of the universal or class-wide type for a class, then the type
     of the construct shall resolve to a type in that class or to a
     universal type that covers the class.

22
   * If the expected type for a construct is a specific type T, then the
     type of the construct shall resolve either to T, or:

23
             * to T'Class; or

24
             * to a universal type that covers T; or

25/2
             * when T is a specific anonymous access-to-object type (see
               *note 3.10::) with designated type D, to an
               access-to-object type whose designated type is D'Class or
               is covered by D; or

25.1/3
             * when T is a named general access-to-object type (see
               *note 3.10::) with designated type D, to an anonymous
               access-to-object type whose designated type covers or is
               covered by D; or

25.2/3
             * when T is an anonymous access-to-subprogram type (see
               *note 3.10::), to an access-to-subprogram type whose
               designated profile is type conformant with that of T.

26
In certain contexts, such as in a subprogram_renaming_declaration, the
Name Resolution Rules define an expected profile for a given name; in
such cases, the name shall resolve to the name of a callable entity
whose profile is type conformant with the expected profile. 

                           _Legality Rules_

27/2
When a construct is one that requires that its expected type be a single
type in a given class, the type of the construct shall be determinable
solely from the context in which the construct appears, excluding the
construct itself, but using the requirement that it be in the given
class.  Furthermore, the context shall not be one that expects any type
in some class that contains types of the given class; in particular, the
construct shall not be the operand of a type_conversion.

27.1/4
Other than for the tested_simple_expression of a membership test, if the
expected type for a name or expression is not the same as the actual
type of the name or expression, the actual type shall be convertible to
the expected type (see *note 4.6::); further, if the expected type is a
named access-to-object type with designated type D1 and the actual type
is an anonymous access-to-object type with designated type D2, then D1
shall cover D2, and the name or expression shall denote a view with an
accessibility level for which the statically deeper relationship
applies; in particular it shall not denote an access parameter nor a
stand-alone access object.

28
A complete context shall have at least one acceptable interpretation; if
there is exactly one, then that one is chosen.

29
There is a preference for the primitive operators (and ranges) of the
root numeric types root_integer and root_real.  In particular, if two
acceptable interpretations of a constituent of a complete context differ
only in that one is for a primitive operator (or range) of the type
root_integer or root_real, and the other is not, the interpretation
using the primitive operator (or range) of the root numeric type is
preferred.

29.1/3
Similarly, there is a preference for the equality operators of the
universal_access type (see *note 4.5.2::).  If two acceptable
interpretations of a constituent of a complete context differ only in
that one is for an equality operator of the universal_access type, and
the other is not, the interpretation using the equality operator of the
universal_access type is preferred.

30
For a complete context, if there is exactly one overall acceptable
interpretation where each constituent's interpretation is the same as or
preferred (in the above sense) over those in all other overall
acceptable interpretations, then that one overall acceptable
interpretation is chosen. Otherwise, the complete context is ambiguous.

31
A complete context other than a pragma_argument_association shall not be
ambiguous.

32
A complete context that is a pragma_argument_association is allowed to
be ambiguous (unless otherwise specified for the particular pragma), but
only if every acceptable interpretation of the pragma argument is as a
name that statically denotes a callable entity. Such a name denotes all
of the declarations determined by its interpretations, and all of the
views declared by these declarations.

     NOTES

33
     17  If a usage name has only one acceptable interpretation, then it
     denotes the corresponding entity.  However, this does not mean that
     the usage name is necessarily legal since other requirements exist
     which are not considered for overload resolution; for example, the
     fact that an expression is static, whether an object is constant,
     mode and subtype conformance rules, freezing rules, order of
     elaboration, and so on.

34
     Similarly, subtypes are not considered for overload resolution (the
     violation of a constraint does not make a program illegal but
     raises an exception during program execution).


File: arm2012.info,  Node: 9,  Next: 10,  Prev: 8,  Up: Top

9 Tasks and Synchronization
***************************

1/3
The execution of an Ada program consists of the execution of one or more
tasks. Each task represents a separate thread of control that proceeds
independently and concurrently between the points where it interacts
with other tasks.  The various forms of task interaction are described
in this clause, and include: 

2
   * the activation and termination of a task;

3
   * a call on a protected subprogram of a protected object, providing
     exclusive read-write access, or concurrent read-only access to
     shared data;

4
   * a call on an entry, either of another task, allowing for
     synchronous communication with that task, or of a protected object,
     allowing for asynchronous communication with one or more other
     tasks using that same protected object;

5
   * a timed operation, including a simple delay statement, a timed
     entry call or accept, or a timed asynchronous select statement (see
     next item);

6
   * an asynchronous transfer of control as part of an asynchronous
     select statement, where a task stops what it is doing and begins
     execution at a different point in response to the completion of an
     entry call or the expiration of a delay;

7
   * an abort statement, allowing one task to cause the termination of
     another task.

8
In addition, tasks can communicate indirectly by reading and updating
(unprotected) shared variables, presuming the access is properly
synchronized through some other kind of task interaction.

                          _Static Semantics_

9
The properties of a task are defined by a corresponding task declaration
and task_body, which together define a program unit called a task unit.

                          _Dynamic Semantics_

10
Over time, tasks proceed through various states. A task is initially
inactive; upon activation, and prior to its termination it is either
blocked (as part of some task interaction) or ready to run. While ready,
a task competes for the available execution resources that it requires
to run.

     NOTES

11
     1  Concurrent task execution may be implemented on multicomputers,
     multiprocessors, or with interleaved execution on a single physical
     processor.  On the other hand, whenever an implementation can
     determine that the required semantic effects can be achieved when
     parts of the execution of a given task are performed by different
     physical processors acting in parallel, it may choose to perform
     them in this way.

* Menu:

* 9.1 ::      Task Units and Task Objects
* 9.2 ::      Task Execution - Task Activation
* 9.3 ::      Task Dependence - Termination of Tasks
* 9.4 ::      Protected Units and Protected Objects
* 9.5 ::      Intertask Communication
* 9.6 ::      Delay Statements, Duration, and Time
* 9.7 ::      Select Statements
* 9.8 ::      Abort of a Task - Abort of a Sequence of Statements
* 9.9 ::      Task and Entry Attributes
* 9.10 ::     Shared Variables
* 9.11 ::     Example of Tasking and Synchronization


File: arm2012.info,  Node: 9.1,  Next: 9.2,  Up: 9

9.1 Task Units and Task Objects
===============================

1
A task unit is declared by a task declaration, which has a corresponding
task_body.  A task declaration may be a task_type_declaration, in which
case it declares a named task type; alternatively, it may be a
single_task_declaration, in which case it defines an anonymous task
type, as well as declaring a named task object of that type.

                               _Syntax_

2/3
     task_type_declaration ::=
        task type defining_identifier [known_discriminant_part]
             [aspect_specification] [is
          [new interface_list with]
          task_definition];

3/3
     single_task_declaration ::=
        task defining_identifier 
             [aspect_specification][is
          [new interface_list with]
          task_definition];

4
     task_definition ::=
          {task_item}
       [ private
          {task_item}]
       end [task_identifier]

5/1
     task_item ::= entry_declaration | aspect_clause

6/3
     task_body ::=
        task body defining_identifier
             [aspect_specification] is
          declarative_part
        begin
          handled_sequence_of_statements
        end [task_identifier];

7
     If a task_identifier appears at the end of a task_definition or
     task_body, it shall repeat the defining_identifier.

Paragraph 8 was deleted.

                          _Static Semantics_

9
A task_definition defines a task type and its first subtype. The first
list of task_items of a task_definition (*note 9.1: S0207.), together
with the known_discriminant_part (*note 3.7: S0061.), if any, is called
the visible part of the task unit. The optional list of task_items after
the reserved word private is called the private part of the task unit.

9.1/1
For a task declaration without a task_definition, a task_definition
without task_items is assumed.

9.2/3
For a task declaration with an interface_list, the task type inherits
user-defined primitive subprograms from each progenitor type (see *note
3.9.4::), in the same way that a derived type inherits user-defined
primitive subprograms from its progenitor types (see *note 3.4::).  If
the first parameter of a primitive inherited subprogram is of the task
type or an access parameter designating the task type, and there is an
entry_declaration for a single entry with the same identifier within the
task declaration, whose profile is type conformant with the prefixed
view profile of the inherited subprogram, the inherited subprogram is
said to be implemented by the conforming task entry using an implicitly
declared nonabstract subprogram which has the same profile as the
inherited subprogram and which overrides it.

                           _Legality Rules_

9.3/2
A task declaration requires a completion, which shall be a task_body,
and every task_body shall be the completion of some task declaration.

9.4/2
Each interface_subtype_mark of an interface_list appearing within a task
declaration shall denote a limited interface type that is not a
protected interface.

9.5/3
The prefixed view profile of an explicitly declared primitive subprogram
of a tagged task type shall not be type conformant with any entry of the
task type, if the subprogram has the same defining name as the entry and
the first parameter of the subprogram is of the task type or is an
access parameter designating the task type.

9.6/2
For each primitive subprogram inherited by the type declared by a task
declaration, at most one of the following shall apply:

9.7/2
   * the inherited subprogram is overridden with a primitive subprogram
     of the task type, in which case the overriding subprogram shall be
     subtype conformant with the inherited subprogram and not abstract;
     or

9.8/2
   * the inherited subprogram is implemented by a single entry of the
     task type; in which case its prefixed view profile shall be subtype
     conformant with that of the task entry. 

9.9/2
If neither applies, the inherited subprogram shall be a null procedure.
In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules also apply in the private part of an instance of a
generic unit.

                          _Dynamic Semantics_

10
The elaboration of a task declaration elaborates the task_definition.
The elaboration of a single_task_declaration (*note 9.1: S0206.) also
creates an object of an (anonymous) task type.

11
The elaboration of a task_definition creates the task type and its first
subtype; it also includes the elaboration of the entry_declarations in
the given order.

12/1
As part of the initialization of a task object, any aspect_clauses and
any per-object constraints associated with entry_declaration (*note
9.5.2: S0218.)s of the corresponding task_definition (*note 9.1: S0207.)
are elaborated in the given order.

13
The elaboration of a task_body has no effect other than to establish
that tasks of the type can from then on be activated without failing the
Elaboration_Check.

14
The execution of a task_body is invoked by the activation of a task of
the corresponding type (see *note 9.2::).

15
The content of a task object of a given task type includes:

16
   * The values of the discriminants of the task object, if any;

17
   * An entry queue for each entry of the task object;

18
   * A representation of the state of the associated task.

     NOTES

19/2
     2  Other than in an access_definition, the name of a task unit
     within the declaration or body of the task unit denotes the current
     instance of the unit (see *note 8.6::), rather than the first
     subtype of the corresponding task type (and thus the name cannot be
     used as a subtype_mark).

20
     3  The notation of a selected_component can be used to denote a
     discriminant of a task (see *note 4.1.3::).  Within a task unit,
     the name of a discriminant of the task type denotes the
     corresponding discriminant of the current instance of the unit.

21/2
     4  A task type is a limited type (see *note 7.5::), and hence
     precludes use of assignment_statements and predefined equality
     operators.  If an application needs to store and exchange task
     identities, it can do so by defining an access type designating the
     corresponding task objects and by using access values for
     identification purposes.  Assignment is available for such an
     access type as for any access type.  Alternatively, if the
     implementation supports the Systems Programming Annex, the Identity
     attribute can be used for task identification (see *note C.7.1::).

                              _Examples_

22
Examples of declarations of task types:

23
     task type Server is
        entry Next_Work_Item(WI : in Work_Item);
        entry Shut_Down;
     end Server;

24/2
     task type Keyboard_Driver(ID : Keyboard_ID := New_ID) is
           new Serial_Device with  -- see *note 3.9.4::
        entry Read (C : out Character);
        entry Write(C : in  Character);
     end Keyboard_Driver;

25
Examples of declarations of single tasks:

26
     task Controller is
        entry Request(Level)(D : Item);  --  a family of entries
     end Controller;

27
     task Parser is
        entry Next_Lexeme(L : in  Lexical_Element);
        entry Next_Action(A : out Parser_Action);
     end;

28
     task User;  --  has no entries

29
Examples of task objects:

30
     Agent    : Server;
     Teletype : Keyboard_Driver(TTY_ID);
     Pool     : array(1 .. 10) of Keyboard_Driver;

31
Example of access type designating task objects:

32
     type Keyboard is access Keyboard_Driver;
     Terminal : Keyboard := new Keyboard_Driver(Term_ID);


File: arm2012.info,  Node: 9.2,  Next: 9.3,  Prev: 9.1,  Up: 9

9.2 Task Execution - Task Activation
====================================

                          _Dynamic Semantics_

1
The execution of a task of a given task type consists of the execution
of the corresponding task_body. The initial part of this execution is
called the activation of the task; it consists of the elaboration of the
declarative_part of the task_body. Should an exception be propagated by
the elaboration of its declarative_part, the activation of the task is
defined to have failed, and it becomes a completed task.

2/2
A task object (which represents one task) can be a part of a stand-alone
object, of an object created by an allocator, or of an anonymous object
of a limited type, or a coextension of one of these.  All tasks that are
part or coextensions of any of the stand-alone objects created by the
elaboration of object_declaration (*note 3.3.1: S0032.)s (or
generic_associations of formal objects of mode in) of a single
declarative region are activated together.  All tasks that are part or
coextensions of a single object that is not a stand-alone object are
activated together.

3/2
For the tasks of a given declarative region, the activations are
initiated within the context of the handled_sequence_of_statements
(*note 11.2: S0265.) (and its associated exception_handler (*note 11.2:
S0266.)s if any -- see *note 11.2::), just prior to executing the
statements of the handled_sequence_of_statements.  For a package without
an explicit body or an explicit handled_sequence_of_statements (*note
11.2: S0265.), an implicit body or an implicit null_statement (*note
5.1: S0149.) is assumed, as defined in *note 7.2::.

4/2
For tasks that are part or coextensions of a single object that is not a
stand-alone object, activations are initiated after completing any
initialization of the outermost object enclosing these tasks, prior to
performing any other operation on the outermost object.  In particular,
for tasks that are part or coextensions of the object created by the
evaluation of an allocator, the activations are initiated as the last
step of evaluating the allocator, prior to returning the new access
value.  For tasks that are part or coextensions of an object that is the
result of a function call, the activations are not initiated until after
the function returns.

5
The task that created the new tasks and initiated their activations (the
activator) is blocked until all of these activations complete
(successfully or not). Once all of these activations are complete, if
the activation of any of the tasks has failed (due to the propagation of
an exception), Tasking_Error is raised in the activator, at the place at
which it initiated the activations.  Otherwise, the activator proceeds
with its execution normally.  Any tasks that are aborted prior to
completing their activation are ignored when determining whether to
raise Tasking_Error.

6/3
If the master that directly encloses the point where the activation of a
task T would be initiated, completes before the activation of T is
initiated, T becomes terminated and is never activated.  Furthermore, if
a return statement is left such that the return object is not returned
to the caller, any task that was created as a part of the return object
or one of its coextensions immediately becomes terminated and is never
activated.

     NOTES

7
     5  An entry of a task can be called before the task has been
     activated.

8
     6  If several tasks are activated together, the execution of any of
     these tasks need not await the end of the activation of the other
     tasks.

9
     7  A task can become completed during its activation either because
     of an exception or because it is aborted (see *note 9.8::).

                              _Examples_

10
Example of task activation:

11
     procedure P is
        A, B : Server;    --  elaborate the task objects A, B
        C    : Server;    --  elaborate the task object C
     begin
        --  the tasks A, B, C are activated together before the first statement
        ...
     end;


File: arm2012.info,  Node: 9.3,  Next: 9.4,  Prev: 9.2,  Up: 9

9.3 Task Dependence - Termination of Tasks
==========================================

                          _Dynamic Semantics_

1
Each task (other than an environment task -- see *note 10.2::) depends
on one or more masters (see *note 7.6.1::), as follows:

2/4
   * If the task is created by the evaluation of an allocator for a
     given named access type, it depends on each master that includes
     the elaboration of the declaration of the ultimate ancestor of the
     given access type.

3
   * If the task is created by the elaboration of an object_declaration,
     it depends on each master that includes this elaboration.

3.1/2
   * Otherwise, the task depends on the master of the outermost object
     of which it is a part (as determined by the accessibility level of
     that object -- see *note 3.10.2:: and *note 7.6.1::), as well as on
     any master whose execution includes that of the master of the
     outermost object.

4
Furthermore, if a task depends on a given master, it is defined to
depend on the task that executes the master, and (recursively) on any
master of that task.

5
A task is said to be completed when the execution of its corresponding
task_body is completed.  A task is said to be terminated when any
finalization of the task_body has been performed (see *note 7.6.1::).
The first step of finalizing a master (including a task_body) is to wait
for the termination of any tasks dependent on the master. The task
executing the master is blocked until all the dependents have
terminated.  Any remaining finalization is then performed and the master
is left.

6/1
Completion of a task (and the corresponding task_body) can occur when
the task is blocked at a select_statement (*note 9.7: S0230.) with an
open terminate_alternative (see *note 9.7.1::); the open
terminate_alternative is selected if and only if the following
conditions are satisfied:

7/2
   * The task depends on some completed master; and

8
   * Each task that depends on the master considered is either already
     terminated or similarly blocked at a select_statement with an open
     terminate_alternative.

9
When both conditions are satisfied, the task considered becomes
completed, together with all tasks that depend on the master considered
that are not yet completed.

     NOTES

10
     8  The full view of a limited private type can be a task type, or
     can have subcomponents of a task type.  Creation of an object of
     such a type creates dependences according to the full type.

11
     9  An object_renaming_declaration defines a new view of an existing
     entity and hence creates no further dependence.

12
     10  The rules given for the collective completion of a group of
     tasks all blocked on select_statements with open
     terminate_alternatives ensure that the collective completion can
     occur only when there are no remaining active tasks that could call
     one of the tasks being collectively completed.

13
     11  If two or more tasks are blocked on select_statements with open
     terminate_alternatives, and become completed collectively, their
     finalization actions proceed concurrently.

14
     12  The completion of a task can occur due to any of the following:

15
        * the raising of an exception during the elaboration of the
          declarative_part of the corresponding task_body;

16
        * the completion of the handled_sequence_of_statements of the
          corresponding task_body;

17
        * the selection of an open terminate_alternative of a
          select_statement in the corresponding task_body;

18
        * the abort of the task.

                              _Examples_

19
Example of task dependence:

20
     declare
        type Global is access Server;        --  see *note 9.1::
        A, B : Server;
        G    : Global;
     begin
        --  activation of A and B
        declare
           type Local is access Server;
           X : Global := new Server;  --  activation of X.all
           L : Local  := new Server;  --  activation of L.all
           C : Server;
        begin
           --  activation of C
           G := X;  --  both G and X designate the same task object
           ...
        end;  --  await termination of C and L.all (but not X.all)
        ...
     end;  --  await termination of A, B, and G.all


File: arm2012.info,  Node: 9.4,  Next: 9.5,  Prev: 9.3,  Up: 9

9.4 Protected Units and Protected Objects
=========================================

1
A protected object provides coordinated access to shared data, through
calls on its visible protected operations, which can be protected
subprograms or protected entries. A protected unit is declared by a
protected declaration, which has a corresponding protected_body.  A
protected declaration may be a protected_type_declaration, in which case
it declares a named protected type; alternatively, it may be a
single_protected_declaration, in which case it defines an anonymous
protected type, as well as declaring a named protected object of that
type. 

                               _Syntax_

2/3
     protected_type_declaration ::=
       protected type defining_identifier [known_discriminant_part]
             [aspect_specification] is
          [new interface_list with]
          protected_definition;

3/3
     single_protected_declaration ::=
       protected defining_identifier
             [aspect_specification] is
          [new interface_list with]
          protected_definition;

4
     protected_definition ::=
         { protected_operation_declaration }
     [ private
         { protected_element_declaration } ]
       end [protected_identifier]

5/1
     protected_operation_declaration ::= subprogram_declaration
          | entry_declaration
          | aspect_clause

6
     protected_element_declaration ::= protected_operation_declaration
          | component_declaration

7/3
     protected_body ::=
       protected body defining_identifier
             [aspect_specification] is
        { protected_operation_item }
       end [protected_identifier];

8/4
     protected_operation_item ::= subprogram_declaration
          | subprogram_body
          | null_procedure_declaration
          | expression_function_declaration
          | entry_body
          | aspect_clause

9
     If a protected_identifier appears at the end of a
     protected_definition or protected_body, it shall repeat the
     defining_identifier.

Paragraph 10 was deleted.

                          _Static Semantics_

11/2
A protected_definition defines a protected type and its first subtype.
The list of protected_operation_declaration (*note 9.4: S0213.)s of a
protected_definition (*note 9.4: S0212.), together with the
known_discriminant_part (*note 3.7: S0061.), if any, is called the
visible part of the protected unit. The optional list of
protected_element_declaration (*note 9.4: S0214.)s after the reserved
word private is called the private part of the protected unit.

11.1/3
For a protected declaration with an interface_list, the protected type
inherits user-defined primitive subprograms from each progenitor type
(see *note 3.9.4::), in the same way that a derived type inherits
user-defined primitive subprograms from its progenitor types (see *note
3.4::).  If the first parameter of a primitive inherited subprogram is
of the protected type or an access parameter designating the protected
type, and there is a protected_operation_declaration for a protected
subprogram or single entry with the same identifier within the protected
declaration, whose profile is type conformant with the prefixed view
profile of the inherited subprogram, the inherited subprogram is said to
be implemented by the conforming protected subprogram or entry using an
implicitly declared nonabstract subprogram which has the same profile as
the inherited subprogram and which overrides it. 

                           _Legality Rules_

11.2/2
A protected declaration requires a completion, which shall be a
protected_body (*note 9.4: S0215.), and every protected_body (*note 9.4:
S0215.) shall be the completion of some protected declaration.

11.3/2
Each interface_subtype_mark of an interface_list appearing within a
protected declaration shall denote a limited interface type that is not
a task interface.

11.4/3
The prefixed view profile of an explicitly declared primitive subprogram
of a tagged protected type shall not be type conformant with any
protected operation of the protected type, if the subprogram has the
same defining name as the protected operation and the first parameter of
the subprogram is of the protected type or is an access parameter
designating the protected type.

11.5/2
For each primitive subprogram inherited by the type declared by a
protected declaration, at most one of the following shall apply:

11.6/2
   * the inherited subprogram is overridden with a primitive subprogram
     of the protected type, in which case the overriding subprogram
     shall be subtype conformant with the inherited subprogram and not
     abstract; or

11.7/2
   * the inherited subprogram is implemented by a protected subprogram
     or single entry of the protected type, in which case its prefixed
     view profile shall be subtype conformant with that of the protected
     subprogram or entry. 

11.8/2
If neither applies, the inherited subprogram shall be a null procedure.
In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules also apply in the private part of an instance of a
generic unit.

11.9/3
If an inherited subprogram is implemented by a protected procedure or an
entry, then the first parameter of the inherited subprogram shall be of
mode out or in out, or an access-to-variable parameter.  If an inherited
subprogram is implemented by a protected function, then the first
parameter of the inherited subprogram shall be of mode in, but not an
access-to-variable parameter.

11.10/2
If a protected subprogram declaration has an overriding_indicator, then
at the point of the declaration:

11.11/2
   * if the overriding_indicator is overriding, then the subprogram
     shall implement an inherited subprogram;

11.12/2
   * if the overriding_indicator is not overriding, then the subprogram
     shall not implement any inherited subprogram.

11.13/2
In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules also apply in the private part of an instance of a
generic unit.

                          _Dynamic Semantics_

12
The elaboration of a protected declaration elaborates the
protected_definition. The elaboration of a single_protected_declaration
(*note 9.4: S0211.) also creates an object of an (anonymous) protected
type.

13
The elaboration of a protected_definition creates the protected type and
its first subtype; it also includes the elaboration of the
component_declarations and protected_operation_declarations in the given
order.

14
As part of the initialization of a protected object, any per-object
constraints (see *note 3.8::) are elaborated.

15
The elaboration of a protected_body has no other effect than to
establish that protected operations of the type can from then on be
called without failing the Elaboration_Check.

16
The content of an object of a given protected type includes:

17
   * The values of the components of the protected object, including
     (implicitly) an entry queue for each entry declared for the
     protected object;

18
   * A representation of the state of the execution resource associated
     with the protected object (one such resource is associated with
     each protected object).

19
The execution resource associated with a protected object has to be
acquired to read or update any components of the protected object; it
can be acquired (as part of a protected action -- see *note 9.5.1::)
either for concurrent read-only access, or for exclusive read-write
access.

20
As the first step of the finalization of a protected object, each call
remaining on any entry queue of the object is removed from its queue and
Program_Error is raised at the place of the corresponding
entry_call_statement (*note 9.5.3: S0225.).

                      _Bounded (Run-Time) Errors_

20.1/2
It is a bounded error to call an entry or subprogram of a protected
object after that object is finalized.  If the error is detected,
Program_Error is raised.  Otherwise, the call proceeds normally, which
may leave a task queued forever.

     NOTES

21/2
     13  Within the declaration or body of a protected unit other than
     in an access_definition, the name of the protected unit denotes the
     current instance of the unit (see *note 8.6::), rather than the
     first subtype of the corresponding protected type (and thus the
     name cannot be used as a subtype_mark).

22
     14  A selected_component can be used to denote a discriminant of a
     protected object (see *note 4.1.3::).  Within a protected unit, the
     name of a discriminant of the protected type denotes the
     corresponding discriminant of the current instance of the unit.

23/2
     15  A protected type is a limited type (see *note 7.5::), and hence
     precludes use of assignment_statements and predefined equality
     operators.

24
     16  The bodies of the protected operations given in the
     protected_body define the actions that take place upon calls to the
     protected operations.

25
     17  The declarations in the private part are only visible within
     the private part and the body of the protected unit.

                              _Examples_

26
Example of declaration of protected type and corresponding body:

27
     protected type Resource is
        entry Seize;
        procedure Release;
     private
        Busy : Boolean := False;
     end Resource;

28
     protected body Resource is
        entry Seize when not Busy is
        begin
           Busy := True;
        end Seize;

29
        procedure Release is
        begin
           Busy := False;
        end Release;
     end Resource;

30
Example of a single protected declaration and corresponding body:

31
     protected Shared_Array is
        --  Index, Item, and Item_Array are global types
        function  Component    (N : in Index) return Item;
        procedure Set_Component(N : in Index; E : in  Item);
     private
        Table : Item_Array(Index) := (others => Null_Item);
     end Shared_Array;

32
     protected body Shared_Array is
        function Component(N : in Index) return Item is
        begin
           return Table(N);
        end Component;

33
        procedure Set_Component(N : in Index; E : in Item) is
        begin
           Table(N) := E;
        end Set_Component;
     end Shared_Array;

34
Examples of protected objects:

35
     Control  : Resource;
     Flags    : array(1 .. 100) of Resource;


File: arm2012.info,  Node: 9.5,  Next: 9.6,  Prev: 9.4,  Up: 9

9.5 Intertask Communication
===========================

1
The primary means for intertask communication is provided by calls on
entries and protected subprograms.  Calls on protected subprograms allow
coordinated access to shared data objects.  Entry calls allow for
blocking the caller until a given condition is satisfied (namely, that
the corresponding entry is open -- see *note 9.5.3::), and then
communicating data or control information directly with another task or
indirectly via a shared protected object.

                          _Static Semantics_

2/3
When a name or prefix denotes an entry, protected subprogram, or a
prefixed view of a primitive subprogram of a limited interface whose
first parameter is a controlling parameter, the name or prefix
determines a target object, as follows:

3/3
   * If it is a direct_name or expanded name that denotes the
     declaration (or body) of the operation, then the target object is
     implicitly specified to be the current instance of the task or
     protected unit immediately enclosing the operation; a call using
     such a name is defined to be an internal call;

4/3
   * If it is a selected_component that is not an expanded name, then
     the target object is explicitly specified to be the object denoted
     by the prefix of the name; a call using such a name is defined to
     be an external call;

5/3
   * If the name or prefix is a dereference (implicit or explicit) of an
     access-to-protected-subprogram value, then the target object is
     determined by the prefix of the Access attribute_reference that
     produced the access value originally; a call using such a name is
     defined to be an external call;

6
   * If the name or prefix denotes a subprogram_renaming_declaration,
     then the target object is as determined by the name of the renamed
     entity.

6.1/3
A call on an entry or a protected subprogram either uses a name or
prefix that determines a target object implicitly, as above, or is a
call on (a non-prefixed view of) a primitive subprogram of a limited
interface whose first parameter is a controlling parameter, in which
case the target object is identified explicitly by the first parameter.
This latter case is an external call.

7
A corresponding definition of target object applies to a
requeue_statement (see *note 9.5.4::), with a corresponding distinction
between an internal requeue and an external requeue.

                           _Legality Rules_

7.1/3
If a name or prefix determines a target object, and the name denotes a
protected entry or procedure, then the target object shall be a
variable, unless the prefix is for an attribute_reference to the Count
attribute (see *note 9.9::).

                          _Dynamic Semantics_

8
Within the body of a protected operation, the current instance (see
*note 8.6::) of the immediately enclosing protected unit is determined
by the target object specified (implicitly or explicitly) in the call
(or requeue) on the protected operation.

9
Any call on a protected procedure or entry of a target protected object
is defined to be an update to the object, as is a requeue on such an
entry.

                               _Syntax_

10/3
     synchronization_kind ::=
     By_Entry | By_Protected_Procedure | Optional

                          _Static Semantics_

11/3
For the declaration of a primitive procedure of a synchronized tagged
type the following language-defined representation aspect may be
specified with an aspect_specification (see *note 13.1.1::):

12/3
Synchronization
               If specified, the aspect definition shall be a
               synchronization_kind.

13/3
Inherited subprograms inherit the Synchronization aspect, if any, from
the corresponding subprogram of the parent or progenitor type.  If an
overriding operation does not have a directly specified Synchronization
aspect then the Synchronization aspect of the inherited operation is
inherited by the overriding operation.

                           _Legality Rules_

14/3
The synchronization_kind By_Protected_Procedure shall not be applied to
a primitive procedure of a task interface.

15/3
A procedure for which the specified synchronization_kind is By_Entry
shall be implemented by an entry.  A procedure for which the specified
synchronization_kind is By_Protected_Procedure shall be implemented by a
protected procedure.  A procedure for which the specified
synchronization_kind is Optional may be implemented by an entry or by a
procedure (including a protected procedure).

16/3
If a primitive procedure overrides an inherited operation for which the
Synchronization aspect has been specified to be By_Entry or
By_Protected_Procedure, then any specification of the aspect
Synchronization applied to the overriding operation shall have the same
synchronization_kind.

17/3
In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules also apply in the private part of an instance of a
generic unit.

     NOTES

18/3
     18  The synchronization_kind By_Protected_Procedure implies that
     the operation will not block.

* Menu:

* 9.5.1 ::    Protected Subprograms and Protected Actions
* 9.5.2 ::    Entries and Accept Statements
* 9.5.3 ::    Entry Calls
* 9.5.4 ::    Requeue Statements


File: arm2012.info,  Node: 9.5.1,  Next: 9.5.2,  Up: 9.5

9.5.1 Protected Subprograms and Protected Actions
-------------------------------------------------

1
A protected subprogram is a subprogram declared immediately within a
protected_definition.  Protected procedures provide exclusive read-write
access to the data of a protected object; protected functions provide
concurrent read-only access to the data.

                          _Static Semantics_

2
Within the body of a protected function (or a function declared
immediately within a protected_body), the current instance of the
enclosing protected unit is defined to be a constant (that is, its
subcomponents may be read but not updated).  Within the body of a
protected procedure (or a procedure declared immediately within a
protected_body), and within an entry_body, the current instance is
defined to be a variable (updating is permitted).

2.1/4
For a type declared by a protected_type_declaration or for the anonymous
type of an object declared by a single_protected_declaration, the
following language-defined type-related representation aspect may be
specified:

2.2/4
Exclusive_Functions
               The type of aspect Exclusive_Functions is Boolean.  If
               not specified (including by inheritance), the aspect is
               False.

2.3/4

               A value of True for this aspect indicates that protected
               functions behave in the same way as protected procedures
               with respect to mutual exclusion and queue servicing (see
               below).

2.4/4
A protected procedure or entry is an exclusive protected operation.  A
protected function of a protected type P is an exclusive protected
operation if the Exclusive_Functions aspect of P is True.

                          _Dynamic Semantics_

3
For the execution of a call on a protected subprogram, the evaluation of
the name or prefix and of the parameter associations, and any assigning
back of in out or out parameters, proceeds as for a normal subprogram
call (see *note 6.4::).  If the call is an internal call (see *note
9.5::), the body of the subprogram is executed as for a normal
subprogram call.  If the call is an external call, then the body of the
subprogram is executed as part of a new protected action on the target
protected object; the protected action completes after the body of the
subprogram is executed.  A protected action can also be started by an
entry call (see *note 9.5.3::).

4/4
A new protected action is not started on a protected object while
another protected action on the same protected object is underway,
unless both actions are the result of a call on a nonexclusive protected
function.  This rule is expressible in terms of the execution resource
associated with the protected object:

5/4
   * Starting a protected action on a protected object corresponds to
     acquiring the execution resource associated with the protected
     object, either for exclusive read-write access if the protected
     action is for a call on an exclusive protected operation, or for
     concurrent read-only access otherwise;

6
   * Completing the protected action corresponds to releasing the
     associated execution resource.

7/4
After performing an exclusive protected operation on a protected object,
but prior to completing the associated protected action, the entry
queues (if any) of the protected object are serviced (see *note
9.5.3::).

                      _Bounded (Run-Time) Errors_

8
During a protected action, it is a bounded error to invoke an operation
that is potentially blocking. The following are defined to be
potentially blocking operations:

9
   * a select_statement;

10
   * an accept_statement;

11
   * an entry_call_statement;

12
   * a delay_statement;

13
   * an abort_statement;

14
   * task creation or activation;

15
   * an external call on a protected subprogram (or an external requeue)
     with the same target object as that of the protected action;

16
   * a call on a subprogram whose body contains a potentially blocking
     operation.

17
If the bounded error is detected, Program_Error is raised.  If not
detected, the bounded error might result in deadlock or a (nested)
protected action on the same target object.

18
Certain language-defined subprograms are potentially blocking.  In
particular, the subprograms of the language-defined input-output
packages that manipulate files (implicitly or explicitly) are
potentially blocking.  Other potentially blocking subprograms are
identified where they are defined.  When not specified as potentially
blocking, a language-defined subprogram is nonblocking.

     NOTES

19
     19  If two tasks both try to start a protected action on a
     protected object, and at most one is calling a protected function,
     then only one of the tasks can proceed.  Although the other task
     cannot proceed, it is not considered blocked, and it might be
     consuming processing resources while it awaits its turn.  There is
     no language-defined ordering or queuing presumed for tasks
     competing to start a protected action -- on a multiprocessor such
     tasks might use busy-waiting; for monoprocessor considerations, see
     *note D.3::, "*note D.3:: Priority Ceiling Locking".

20
     20  The body of a protected unit may contain declarations and
     bodies for local subprograms.  These are not visible outside the
     protected unit.

21
     21  The body of a protected function can contain internal calls on
     other protected functions, but not protected procedures, because
     the current instance is a constant.  On the other hand, the body of
     a protected procedure can contain internal calls on both protected
     functions and procedures.

22
     22  From within a protected action, an internal call on a protected
     subprogram, or an external call on a protected subprogram with a
     different target object is not considered a potentially blocking
     operation.

22.1/2
     23  The pragma Detect_Blocking may be used to ensure that all
     executions of potentially blocking operations during a protected
     action raise Program_Error.  See *note H.5::.

                              _Examples_

23
Examples of protected subprogram calls (see *note 9.4::):

24
     Shared_Array.Set_Component(N, E);
     E := Shared_Array.Component(M);
     Control.Release;


File: arm2012.info,  Node: 9.5.2,  Next: 9.5.3,  Prev: 9.5.1,  Up: 9.5

9.5.2 Entries and Accept Statements
-----------------------------------

1
Entry_declarations, with the corresponding entry_bodies or
accept_statements, are used to define potentially queued operations on
tasks and protected objects.

                               _Syntax_

2/3
     entry_declaration ::=
        [overriding_indicator]
        entry defining_identifier [(discrete_subtype_definition)] 
     parameter_profile
           [aspect_specification];

3
     accept_statement ::=
        accept entry_direct_name [(entry_index)] parameter_profile [do
          handled_sequence_of_statements
        end [entry_identifier]];

4
     entry_index ::= expression

5
     entry_body ::=
       entry defining_identifier  entry_body_formal_part  
     entry_barrier is
         declarative_part
       begin
         handled_sequence_of_statements
       end [entry_identifier];

6
     entry_body_formal_part ::= [(entry_index_specification)] 
     parameter_profile

7
     entry_barrier ::= when condition

8
     entry_index_specification ::= for defining_identifier in 
     discrete_subtype_definition

9
     If an entry_identifier appears at the end of an accept_statement,
     it shall repeat the entry_direct_name (*note 4.1: S0092.).  If an
     entry_identifier appears at the end of an entry_body (*note 9.5.2:
     S0221.), it shall repeat the defining_identifier (*note 3.1:
     S0022.).

10
     An entry_declaration is allowed only in a protected or task
     declaration.

10.1/2
     An overriding_indicator is not allowed in an entry_declaration that
     includes a discrete_subtype_definition.

                        _Name Resolution Rules_

11
In an accept_statement, the expected profile for the entry_direct_name
is that of the entry_declaration (*note 9.5.2: S0218.); the expected
type for an entry_index is that of the subtype defined by the
discrete_subtype_definition (*note 3.6: S0055.) of the corresponding
entry_declaration (*note 9.5.2: S0218.).

12
Within the handled_sequence_of_statements of an accept_statement, if a
selected_component (*note 4.1.3: S0098.) has a prefix that denotes the
corresponding entry_declaration (*note 9.5.2: S0218.), then the entity
denoted by the prefix is the accept_statement (*note 9.5.2: S0219.), and
the selected_component (*note 4.1.3: S0098.) is interpreted as an
expanded name (see *note 4.1.3::); the selector_name of the
selected_component (*note 4.1.3: S0098.) has to be the identifier for
some formal parameter of the accept_statement (*note 9.5.2: S0219.).

                           _Legality Rules_

13
An entry_declaration in a task declaration shall not contain a
specification for an access parameter (see *note 3.10::).

13.1/2
If an entry_declaration has an overriding_indicator, then at the point
of the declaration:

13.2/2
   * if the overriding_indicator is overriding, then the entry shall
     implement an inherited subprogram;

13.3/2
   * if the overriding_indicator is not overriding, then the entry shall
     not implement any inherited subprogram.

13.4/2
In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules also apply in the private part of an instance of a
generic unit.

14
For an accept_statement, the innermost enclosing body shall be a
task_body, and the entry_direct_name (*note 4.1: S0092.) shall denote an
entry_declaration (*note 9.5.2: S0218.) in the corresponding task
declaration; the profile of the accept_statement (*note 9.5.2: S0219.)
shall conform fully to that of the corresponding entry_declaration
(*note 9.5.2: S0218.). An accept_statement (*note 9.5.2: S0219.) shall
have a parenthesized entry_index (*note 9.5.2: S0220.) if and only if
the corresponding entry_declaration (*note 9.5.2: S0218.) has a
discrete_subtype_definition (*note 3.6: S0055.).

15
An accept_statement shall not be within another accept_statement that
corresponds to the same entry_declaration (*note 9.5.2: S0218.), nor
within an asynchronous_select (*note 9.7.4: S0241.) inner to the
enclosing task_body.

16
An entry_declaration of a protected unit requires a completion, which
shall be an entry_body, and every entry_body (*note 9.5.2: S0221.) shall
be the completion of an entry_declaration (*note 9.5.2: S0218.) of a
protected unit. The profile of the entry_body (*note 9.5.2: S0221.)
shall conform fully to that of the corresponding declaration. 

17
An entry_body_formal_part shall have an entry_index_specification (*note
9.5.2: S0224.) if and only if the corresponding entry_declaration (*note
9.5.2: S0218.) has a discrete_subtype_definition (*note 3.6: S0055.).
In this case, the discrete_subtype_definition (*note 3.6: S0055.)s of
the entry_declaration (*note 9.5.2: S0218.) and the
entry_index_specification (*note 9.5.2: S0224.) shall fully conform to
one another (see *note 6.3.1::). 

18
A name that denotes a formal parameter of an entry_body is not allowed
within the entry_barrier of the entry_body.

                          _Static Semantics_

19
The parameter modes defined for parameters in the parameter_profile of
an entry_declaration are the same as for a subprogram_declaration and
have the same meaning (see *note 6.2::).

20
An entry_declaration with a discrete_subtype_definition (see *note
3.6::) declares a family of distinct entries having the same profile,
with one such entry for each value of the entry index subtype defined by
the discrete_subtype_definition (*note 3.6: S0055.).  A name for an
entry of a family takes the form of an indexed_component, where the
prefix denotes the entry_declaration for the family, and the index value
identifies the entry within the family. The term single entry is used to
refer to any entry other than an entry of an entry family.

21
In the entry_body for an entry family, the entry_index_specification
declares a named constant whose subtype is the entry index subtype
defined by the corresponding entry_declaration; the value of the named
entry index identifies which entry of the family was called.

                          _Dynamic Semantics_

22/1
The elaboration of an entry_declaration for an entry family consists of
the elaboration of the discrete_subtype_definition (*note 3.6: S0055.),
as described in *note 3.8::.  The elaboration of an entry_declaration
(*note 9.5.2: S0218.) for a single entry has no effect.

23
The actions to be performed when an entry is called are specified by the
corresponding accept_statement (*note 9.5.2: S0219.)s (if any) for an
entry of a task unit, and by the corresponding entry_body (*note 9.5.2:
S0221.) for an entry of a protected unit.

24
For the execution of an accept_statement, the entry_index, if any, is
first evaluated and converted to the entry index subtype; this index
value identifies which entry of the family is to be accepted. Further
execution of the accept_statement is then blocked until a caller of the
corresponding entry is selected (see *note 9.5.3::), whereupon the
handled_sequence_of_statements, if any, of the accept_statement is
executed, with the formal parameters associated with the corresponding
actual parameters of the selected entry call.  Upon completion of the
handled_sequence_of_statements, the accept_statement completes and is
left.  When an exception is propagated from the
handled_sequence_of_statements of an accept_statement, the same
exception is also raised by the execution of the corresponding
entry_call_statement.

25
The above interaction between a calling task and an accepting task is
called a rendezvous.  After a rendezvous, the two tasks continue their
execution independently.

26
An entry_body is executed when the condition of the entry_barrier
evaluates to True and a caller of the corresponding single entry, or
entry of the corresponding entry family, has been selected (see *note
9.5.3::). For the execution of the entry_body (*note 9.5.2: S0221.), the
declarative_part (*note 3.11: S0086.) of the entry_body (*note 9.5.2:
S0221.) is elaborated, and the handled_sequence_of_statements (*note
11.2: S0265.) of the body is executed, as for the execution of a
subprogram_body.  The value of the named entry index, if any, is
determined by the value of the entry index specified in the entry_name
of the selected entry call (or intermediate requeue_statement (*note
9.5.4: S0226.) -- see *note 9.5.4::).

     NOTES

27
     24  A task entry has corresponding accept_statements (zero or
     more), whereas a protected entry has a corresponding entry_body
     (exactly one).

28
     25  A consequence of the rule regarding the allowed placements of
     accept_statements is that a task can execute accept_statements only
     for its own entries.

29/2
     26  A return statement (see *note 6.5::) or a requeue_statement
     (see *note 9.5.4::) may be used to complete the execution of an
     accept_statement or an entry_body.

30
     27  The condition in the entry_barrier may reference anything
     visible except the formal parameters of the entry.  This includes
     the entry index (if any), the components (including discriminants)
     of the protected object, the Count attribute of an entry of that
     protected object, and data global to the protected unit.

31
     The restriction against referencing the formal parameters within an
     entry_barrier ensures that all calls of the same entry see the same
     barrier value.  If it is necessary to look at the parameters of an
     entry call before deciding whether to handle it, the entry_barrier
     can be "when True" and the caller can be requeued (on some private
     entry) when its parameters indicate that it cannot be handled
     immediately.

                              _Examples_

32
Examples of entry declarations:

33
     entry Read(V : out Item);
     entry Seize;
     entry Request(Level)(D : Item);  --  a family of entries

34
Examples of accept statements:

35
     accept Shut_Down;

36
     accept Read(V : out Item) do
        V := Local_Item;
     end Read;

37
     accept Request(Low)(D : Item) do
        ...
     end Request;


File: arm2012.info,  Node: 9.5.3,  Next: 9.5.4,  Prev: 9.5.2,  Up: 9.5

9.5.3 Entry Calls
-----------------

1
An entry_call_statement (an entry call) can appear in various contexts. 
A simple entry call is a stand-alone statement that represents an
unconditional call on an entry of a target task or a protected object.
Entry calls can also appear as part of select_statements (see *note
9.7::).

                               _Syntax_

2
     entry_call_statement ::= entry_name [actual_parameter_part];

                        _Name Resolution Rules_

3
The entry_name given in an entry_call_statement shall resolve to denote
an entry.  The rules for parameter associations are the same as for
subprogram calls (see *note 6.4:: and *note 6.4.1::).

                          _Static Semantics_

4
The entry_name of an entry_call_statement specifies (explicitly or
implicitly) the target object of the call, the entry or entry family,
and the entry index, if any (see *note 9.5::).

                          _Dynamic Semantics_

5
Under certain circumstances (detailed below), an entry of a task or
protected object is checked to see whether it is open or closed:

6/3
   * An entry of a task is open if the task is blocked on an
     accept_statement that corresponds to the entry (see *note 9.5.2::),
     or on a selective_accept (see *note 9.7.1::) with an open
     accept_alternative that corresponds to the entry; otherwise, it is
     closed.

7/3
   * An entry of a protected object is open if the condition of the
     entry_barrier of the corresponding entry_body evaluates to True;
     otherwise, it is closed. If the evaluation of the condition
     propagates an exception, the exception Program_Error is propagated
     to all current callers of all entries of the protected object.

8
For the execution of an entry_call_statement, evaluation of the name and
of the parameter associations is as for a subprogram call (see *note
6.4::). The entry call is then issued: For a call on an entry of a
protected object, a new protected action is started on the object (see
*note 9.5.1::).  The named entry is checked to see if it is open; if
open, the entry call is said to be selected immediately, and the
execution of the call proceeds as follows:

9
   * For a call on an open entry of a task, the accepting task becomes
     ready and continues the execution of the corresponding
     accept_statement (see *note 9.5.2::).

10
   * For a call on an open entry of a protected object, the
     corresponding entry_body is executed (see *note 9.5.2::) as part of
     the protected action.

11
If the accept_statement or entry_body completes other than by a requeue
(see *note 9.5.4::), return is made to the caller (after servicing the
entry queues -- see below); any necessary assigning back of formal to
actual parameters occurs, as for a subprogram call (see *note 6.4.1::);
such assignments take place outside of any protected action.

12
If the named entry is closed, the entry call is added to an entry queue
(as part of the protected action, for a call on a protected entry), and
the call remains queued until it is selected or cancelled; there is a
separate (logical) entry queue for each entry of a given task or
protected object (including each entry of an entry family).

13
When a queued call is selected, it is removed from its entry queue.
Selecting a queued call from a particular entry queue is called
servicing the entry queue.  An entry with queued calls can be serviced
under the following circumstances:

14
   * When the associated task reaches a corresponding accept_statement,
     or a selective_accept with a corresponding open accept_alternative;

15/4
   * If after performing, as part of a protected action on the
     associated protected object, an exclusive protected operation on
     the object, the entry is checked and found to be open.

16
If there is at least one call on a queue corresponding to an open entry,
then one such call is selected according to the entry queuing policy in
effect (see below), and the corresponding accept_statement or entry_body
is executed as above for an entry call that is selected immediately.

17
The entry queuing policy controls selection among queued calls both for
task and protected entry queues. The default entry queuing policy is to
select calls on a given entry queue in order of arrival.  If calls from
two or more queues are simultaneously eligible for selection, the
default entry queuing policy does not specify which queue is serviced
first.  Other entry queuing policies can be specified by pragmas (see
*note D.4::).

18
For a protected object, the above servicing of entry queues continues
until there are no open entries with queued calls, at which point the
protected action completes.

19
For an entry call that is added to a queue, and that is not the
triggering_statement of an asynchronous_select (*note 9.7.4: S0241.)
(see *note 9.7.4::), the calling task is blocked until the call is
cancelled, or the call is selected and a corresponding accept_statement
or entry_body completes without requeuing.  In addition, the calling
task is blocked during a rendezvous.

20
An attempt can be made to cancel an entry call upon an abort (see *note
9.8::) and as part of certain forms of select_statement (see *note
9.7.2::, *note 9.7.3::, and *note 9.7.4::).  The cancellation does not
take place until a point (if any) when the call is on some entry queue,
and not protected from cancellation as part of a requeue (see *note
9.5.4::); at such a point, the call is removed from the entry queue and
the call completes due to the cancellation.  The cancellation of a call
on an entry of a protected object is a protected action, and as such
cannot take place while any other protected action is occurring on the
protected object.  Like any protected action, it includes servicing of
the entry queues (in case some entry barrier depends on a Count
attribute).

21
A call on an entry of a task that has already completed its execution
raises the exception Tasking_Error at the point of the call; similarly,
this exception is raised at the point of the call if the called task
completes its execution or becomes abnormal before accepting the call or
completing the rendezvous (see *note 9.8::).  This applies equally to a
simple entry call and to an entry call as part of a select_statement.

                     _Implementation Permissions_

22
An implementation may perform the sequence of steps of a protected
action using any thread of control; it need not be that of the task that
started the protected action.  If an entry_body completes without
requeuing, then the corresponding calling task may be made ready without
waiting for the entire protected action to complete.

23/4
When the entry of a protected object is checked to see whether it is
open, the implementation need not reevaluate the condition of the
corresponding entry_barrier if no variable or attribute referenced by
the condition (directly or indirectly) has been altered by the execution
(or cancellation) of a call to an exclusive protected operation of the
object since the condition was last evaluated.

24
An implementation may evaluate the conditions of all entry_barriers of a
given protected object any time any entry of the object is checked to
see if it is open.

25
When an attempt is made to cancel an entry call, the implementation need
not make the attempt using the thread of control of the task (or
interrupt) that initiated the cancellation; in particular, it may use
the thread of control of the caller itself to attempt the cancellation,
even if this might allow the entry call to be selected in the interim.

     NOTES

26
     28  If an exception is raised during the execution of an
     entry_body, it is propagated to the corresponding caller (see *note
     11.4::).

27
     29  For a call on a protected entry, the entry is checked to see if
     it is open prior to queuing the call, and again thereafter if its
     Count attribute (see *note 9.9::) is referenced in some entry
     barrier.

28
     30  In addition to simple entry calls, the language permits timed,
     conditional, and asynchronous entry calls (see *note 9.7.2::, *note
     9.7.3::, and see *note 9.7.4::).

29
     31  The condition of an entry_barrier is allowed to be evaluated by
     an implementation more often than strictly necessary, even if the
     evaluation might have side effects.  On the other hand, an
     implementation need not reevaluate the condition if nothing it
     references was updated by an intervening protected action on the
     protected object, even if the condition references some global
     variable that might have been updated by an action performed from
     outside of a protected action.

                              _Examples_

30
Examples of entry calls:

31
     Agent.Shut_Down;                      --  see *note 9.1::
     Parser.Next_Lexeme(E);                --  see *note 9.1::
     Pool(5).Read(Next_Char);              --  see *note 9.1::
     Controller.Request(Low)(Some_Item);   --  see *note 9.1::
     Flags(3).Seize;                       --  see *note 9.4::


File: arm2012.info,  Node: 9.5.4,  Prev: 9.5.3,  Up: 9.5

9.5.4 Requeue Statements
------------------------

1
A requeue_statement can be used to complete an accept_statement or
entry_body, while redirecting the corresponding entry call to a new (or
the same) entry queue. Such a requeue can be performed with or without
allowing an intermediate cancellation of the call, due to an abort or
the expiration of a delay. 

                               _Syntax_

2/3
     requeue_statement ::= requeue procedure_or_entry_name [with abort];

                        _Name Resolution Rules_

3/3
The procedure_or_entry_name of a requeue_statement shall resolve to
denote a procedure or an entry (the requeue target).  The profile of the
entry, or the profile or prefixed profile of the procedure, shall either
have no parameters, or be type conformant (see *note 6.3.1::) with the
profile of the innermost enclosing entry_body (*note 9.5.2: S0221.) or
accept_statement (*note 9.5.2: S0219.). 

                           _Legality Rules_

4
A requeue_statement shall be within a callable construct that is either
an entry_body or an accept_statement, and this construct shall be the
innermost enclosing body or callable construct.

5/3
If the requeue target has parameters, then its (prefixed) profile shall
be subtype conformant with the profile of the innermost enclosing
callable construct. 

5.1/4
Given a requeue_statement where the innermost enclosing callable
construct is for an entry E1, for every specific or class-wide
postcondition expression P1 that applies to E1, there shall exist a
postcondition expression P2 that applies to the requeue target E2 such
that

5.2/4
   * P1 is fully conformant with the expression produced by replacing
     each reference in P2 to a formal parameter of E2 with a reference
     to the corresponding formal paramter of E1; and

5.3/4
   * if P1 is enabled, then P2 is also enabled.

5.4/4
The requeue target shall not have an applicable specific or class-wide
postcondition which includes an Old attribute_reference.

5.5/4
If the requeue target is declared immediately within the task_definition
of a named task type or the protected_definition of a named protected
type, and if the requeue statement occurs within the body of that type,
and if the requeue is an external requeue, then the requeue target shall
not have a specific or class-wide postcondition which includes a name
denoting either the current instance of that type or any entity declared
within the declaration of that type.

5.6/4
If the target is a procedure, the name shall denote a renaming of an
entry, or shall denote a view or a prefixed view of a primitive
subprogram of a synchronized interface, where the first parameter of the
unprefixed view of the primitive subprogram shall be a controlling
parameter, and the Synchronization aspect shall be specified with
synchronization_kind By_Entry for the primitive subprogram.

6/3
In a requeue_statement of an accept_statement of some task unit, either
the target object shall be a part of a formal parameter of the
accept_statement, or the accessibility level of the target object shall
not be equal to or statically deeper than any enclosing accept_statement
of the task unit.  In a requeue_statement (*note 9.5.4: S0226.) of an
entry_body (*note 9.5.2: S0221.) of some protected unit, either the
target object shall be a part of a formal parameter of the entry_body
(*note 9.5.2: S0221.), or the accessibility level of the target object
shall not be statically deeper than that of the entry_declaration for
the entry_body.

                          _Dynamic Semantics_

7/4
The execution of a requeue_statement proceeds by first evaluating the
procedure_or_entry_name, including the prefix identifying the target
task or protected object and the expression identifying the entry within
an entry family, if any.  Precondition checks are then performed as for
a call to the requeue target entry or subprogram.  The entry_body or
accept_statement enclosing the requeue_statement is then completed,
finalized, and left (see *note 7.6.1::).

8
For the execution of a requeue on an entry of a target task, after
leaving the enclosing callable construct, the named entry is checked to
see if it is open and the requeued call is either selected immediately
or queued, as for a normal entry call (see *note 9.5.3::).

9
For the execution of a requeue on an entry of a target protected object,
after leaving the enclosing callable construct:

10
   * if the requeue is an internal requeue (that is, the requeue is back
     on an entry of the same protected object -- see *note 9.5::), the
     call is added to the queue of the named entry and the ongoing
     protected action continues (see *note 9.5.1::);

11
   * if the requeue is an external requeue (that is, the target
     protected object is not implicitly the same as the current object
     -- see *note 9.5::), a protected action is started on the target
     object and proceeds as for a normal entry call (see *note 9.5.3::).

12/4
If the requeue target named in the requeue_statement has formal
parameters, then during the execution of the accept_statement or
entry_body corresponding to the new entry and during the checking of any
preconditions of the new entry, the formal parameters denote the same
objects as did the corresponding formal parameters of the callable
construct completed by the requeue.  In any case, no parameters are
specified in a requeue_statement; any parameter passing is implicit.

13
If the requeue_statement includes the reserved words with abort (it is a
requeue-with-abort), then:

14
   * if the original entry call has been aborted (see *note 9.8::), then
     the requeue acts as an abort completion point for the call, and the
     call is cancelled and no requeue is performed;

15
   * if the original entry call was timed (or conditional), then the
     original expiration time is the expiration time for the requeued
     call.

16
If the reserved words with abort do not appear, then the call remains
protected against cancellation while queued as the result of the
requeue_statement.

     NOTES

17
     32  A requeue is permitted from a single entry to an entry of an
     entry family, or vice-versa.  The entry index, if any, plays no
     part in the subtype conformance check between the profiles of the
     two entries; an entry index is part of the entry_name for an entry
     of a family. 

                              _Examples_

18
Examples of requeue statements:

19
     requeue Request(Medium) with abort;
                         -- requeue on a member of an entry family of the current task, see *note 9.1::

20
     requeue Flags(I).Seize;
                         -- requeue on an entry of an array component, see *note 9.4::


File: arm2012.info,  Node: 9.6,  Next: 9.7,  Prev: 9.5,  Up: 9

9.6 Delay Statements, Duration, and Time
========================================

1
A delay_statement is used to block further execution until a specified
expiration time is reached.  The expiration time can be specified either
as a particular point in time (in a delay_until_statement (*note 9.6:
S0228.)), or in seconds from the current time (in a
delay_relative_statement (*note 9.6: S0229.)).  The language-defined
package Calendar provides definitions for a type Time and associated
operations, including a function Clock that returns the current time. 

                               _Syntax_

2
     delay_statement ::= delay_until_statement | 
     delay_relative_statement

3
     delay_until_statement ::= delay until delay_expression;

4
     delay_relative_statement ::= delay delay_expression;

                        _Name Resolution Rules_

5
The expected type for the delay_expression in a delay_relative_statement
is the predefined type Duration. The delay_expression in a
delay_until_statement is expected to be of any nonlimited type.

                           _Legality Rules_

6/3
There can be multiple time bases, each with a corresponding clock, and a
corresponding time type.  The type of the delay_expression in a
delay_until_statement shall be a time type -- either the type Time
defined in the language-defined package Calendar (see below), the type
Time in the package Real_Time (see *note D.8::), or some other
implementation-defined time type.

                          _Static Semantics_

7
There is a predefined fixed point type named Duration, declared in the
visible part of package Standard; a value of type Duration is used to
represent the length of an interval of time, expressed in seconds.  The
type Duration is not specific to a particular time base, but can be used
with any time base.

8/3
A value of the type Time in package Calendar, or of some other time
type, represents a time as reported by a corresponding clock.

9
The following language-defined library package exists:

10

     package Ada.Calendar is
       type Time is private;

11/2
       subtype Year_Number  is Integer range 1901 .. 2399;
       subtype Month_Number is Integer range 1 .. 12;
       subtype Day_Number   is Integer range 1 .. 31;
       subtype Day_Duration is Duration range 0.0 .. 86_400.0;

12
       function Clock return Time;

13
       function Year   (Date : Time) return Year_Number;
       function Month  (Date : Time) return Month_Number;
       function Day    (Date : Time) return Day_Number;
       function Seconds(Date : Time) return Day_Duration;

14
       procedure Split (Date  : in Time;
                        Year    : out Year_Number;
                        Month   : out Month_Number;
                        Day     : out Day_Number;
                        Seconds : out Day_Duration);

15
       function Time_Of(Year  : Year_Number;
                        Month   : Month_Number;
                        Day     : Day_Number;
                        Seconds : Day_Duration := 0.0)
        return Time;

16
       function "+" (Left : Time;   Right : Duration) return Time;
       function "+" (Left : Duration; Right : Time) return Time;
       function "-" (Left : Time;   Right : Duration) return Time;
       function "-" (Left : Time;   Right : Time) return Duration;

17
       function "<" (Left, Right : Time) return Boolean;
       function "<="(Left, Right : Time) return Boolean;
       function ">" (Left, Right : Time) return Boolean;
       function ">="(Left, Right : Time) return Boolean;

18
       Time_Error : exception;

19
     private
        ... -- not specified by the language
     end Ada.Calendar;

                          _Dynamic Semantics_

20
For the execution of a delay_statement, the delay_expression is first
evaluated. For a delay_until_statement, the expiration time for the
delay is the value of the delay_expression, in the time base associated
with the type of the expression. For a delay_relative_statement, the
expiration time is defined as the current time, in the time base
associated with relative delays, plus the value of the delay_expression
converted to the type Duration, and then rounded up to the next clock
tick. The time base associated with relative delays is as defined in
*note D.9::, "*note D.9:: Delay Accuracy" or is implementation defined.

21
The task executing a delay_statement is blocked until the expiration
time is reached, at which point it becomes ready again.  If the
expiration time has already passed, the task is not blocked.

22/3
If an attempt is made to cancel the delay_statement (as part of an
asynchronous_select (*note 9.7.4: S0241.) or abort -- see *note 9.7.4::
and *note 9.8::), the statement is cancelled if the expiration time has
not yet passed, thereby completing the delay_statement.

23
The time base associated with the type Time of package Calendar is
implementation defined.  The function Clock of package Calendar returns
a value representing the current time for this time base.  The
implementation-defined value of the named number System.Tick (see *note
13.7::) is an approximation of the length of the real-time interval
during which the value of Calendar.Clock remains constant.

24/2
The functions Year, Month, Day, and Seconds return the corresponding
values for a given value of the type Time, as appropriate to an
implementation-defined time zone; the procedure Split returns all four
corresponding values.  Conversely, the function Time_Of combines a year
number, a month number, a day number, and a duration, into a value of
type Time.  The operators "+" and "-" for addition and subtraction of
times and durations, and the relational operators for times, have the
conventional meaning.

25
If Time_Of is called with a seconds value of 86_400.0, the value
returned is equal to the value of Time_Of for the next day with a
seconds value of 0.0.  The value returned by the function Seconds or
through the Seconds parameter of the procedure Split is always less than
86_400.0.

26/1
The exception Time_Error is raised by the function Time_Of if the actual
parameters do not form a proper date.  This exception is also raised by
the operators "+" and "-" if the result is not representable in the type
Time or Duration, as appropriate.  This exception is also raised by the
functions Year, Month, Day, and Seconds and the procedure Split if the
year number of the given date is outside of the range of the subtype
Year_Number.

                     _Implementation Requirements_

27
The implementation of the type Duration shall allow representation of
time intervals (both positive and negative) up to at least 86400 seconds
(one day); Duration'Small shall not be greater than twenty milliseconds.
The implementation of the type Time shall allow representation of all
dates with year numbers in the range of Year_Number; it may allow
representation of other dates as well (both earlier and later).

                     _Implementation Permissions_

28/3
An implementation may define additional time types.

29
An implementation may raise Time_Error if the value of a
delay_expression in a delay_until_statement of a select_statement
represents a time more than 90 days past the current time.  The actual
limit, if any, is implementation-defined.

                        _Implementation Advice_

30
Whenever possible in an implementation, the value of Duration'Small
should be no greater than 100 microseconds.

31
The time base for delay_relative_statements should be monotonic; it need
not be the same time base as used for Calendar.Clock.

     NOTES

32
     33  A delay_relative_statement with a negative value of the
     delay_expression is equivalent to one with a zero value.

33
     34  A delay_statement may be executed by the environment task;
     consequently delay_statements may be executed as part of the
     elaboration of a library_item or the execution of the main
     subprogram.  Such statements delay the environment task (see *note
     10.2::).

34
     35  A delay_statement is an abort completion point and a
     potentially blocking operation, even if the task is not actually
     blocked.

35
     36  There is no necessary relationship between System.Tick (the
     resolution of the clock of package Calendar) and Duration'Small
     (the small of type Duration).

36
     37  Additional requirements associated with delay_statements are
     given in *note D.9::, "*note D.9:: Delay Accuracy".

                              _Examples_

37
Example of a relative delay statement:

38
     delay 3.0;  -- delay 3.0 seconds

39
Example of a periodic task:

40
     declare
        use Ada.Calendar;
        Next_Time : Time := Clock + Period;
                           -- Period is a global constant of type Duration
     begin
        loop               -- repeated every Period seconds
           delay until Next_Time;
           ... -- perform some actions
           Next_Time := Next_Time + Period;
        end loop;
     end;

* Menu:

* 9.6.1 ::    Formatting, Time Zones, and other operations for Time


File: arm2012.info,  Node: 9.6.1,  Up: 9.6

9.6.1 Formatting, Time Zones, and other operations for Time
-----------------------------------------------------------

                          _Static Semantics_

1/2
The following language-defined library packages exist:

2/2
     package Ada.Calendar.Time_Zones is

3/2
        -- Time zone manipulation:

4/2
        type Time_Offset is range -28*60 .. 28*60;

5/2
        Unknown_Zone_Error : exception;

6/2
        function UTC_Time_Offset (Date : Time := Clock) return Time_Offset;

7/2
     end Ada.Calendar.Time_Zones;

8/2

     package Ada.Calendar.Arithmetic is

9/2
        -- Arithmetic on days:

10/2
        type Day_Count is range
          -366*(1+Year_Number'Last - Year_Number'First)
          ..
          366*(1+Year_Number'Last - Year_Number'First);

11/2
        subtype Leap_Seconds_Count is Integer range -2047 .. 2047;

12/2
        procedure Difference (Left, Right : in Time;
                              Days : out Day_Count;
                              Seconds : out Duration;
                              Leap_Seconds : out Leap_Seconds_Count);

13/2
        function "+" (Left : Time; Right : Day_Count) return Time;
        function "+" (Left : Day_Count; Right : Time) return Time;
        function "-" (Left : Time; Right : Day_Count) return Time;
        function "-" (Left, Right : Time) return Day_Count;

14/2
     end Ada.Calendar.Arithmetic;

15/2

     with Ada.Calendar.Time_Zones;
     package Ada.Calendar.Formatting is

16/2
        -- Day of the week:

17/2
        type Day_Name is (Monday, Tuesday, Wednesday, Thursday,
            Friday, Saturday, Sunday);

18/2
        function Day_of_Week (Date : Time) return Day_Name;

19/2
        -- Hours:Minutes:Seconds access:

20/2
        subtype Hour_Number         is Natural range 0 .. 23;
        subtype Minute_Number       is Natural range 0 .. 59;
        subtype Second_Number       is Natural range 0 .. 59;
        subtype Second_Duration     is Day_Duration range 0.0 .. 1.0;

21/2
        function Year       (Date : Time;
                             Time_Zone  : Time_Zones.Time_Offset := 0)
                                return Year_Number;

22/2
        function Month      (Date : Time;
                             Time_Zone  : Time_Zones.Time_Offset := 0)
                                return Month_Number;

23/2
        function Day        (Date : Time;
                             Time_Zone  : Time_Zones.Time_Offset := 0)
                                return Day_Number;

24/2
        function Hour       (Date : Time;
                             Time_Zone  : Time_Zones.Time_Offset := 0)
                                return Hour_Number;

25/2
        function Minute     (Date : Time;
                             Time_Zone  : Time_Zones.Time_Offset := 0)
                                return Minute_Number;

26/2
        function Second     (Date : Time)
                                return Second_Number;

27/2
        function Sub_Second (Date : Time)
                                return Second_Duration;

28/2
        function Seconds_Of (Hour   :  Hour_Number;
                             Minute : Minute_Number;
                             Second : Second_Number := 0;
                             Sub_Second : Second_Duration := 0.0)
            return Day_Duration;

29/2
        procedure Split (Seconds    : in Day_Duration;
                         Hour       : out Hour_Number;
                         Minute     : out Minute_Number;
                         Second     : out Second_Number;
                         Sub_Second : out Second_Duration);

30/2
        function Time_Of (Year       : Year_Number;
                          Month      : Month_Number;
                          Day        : Day_Number;
                          Hour       : Hour_Number;
                          Minute     : Minute_Number;
                          Second     : Second_Number;
                          Sub_Second : Second_Duration := 0.0;
                          Leap_Second: Boolean := False;
                          Time_Zone  : Time_Zones.Time_Offset := 0)
                                  return Time;

31/2
        function Time_Of (Year       : Year_Number;
                          Month      : Month_Number;
                          Day        : Day_Number;
                          Seconds    : Day_Duration := 0.0;
                          Leap_Second: Boolean := False;
                          Time_Zone  : Time_Zones.Time_Offset := 0)
                                  return Time;

32/2
        procedure Split (Date       : in Time;
                         Year       : out Year_Number;
                         Month      : out Month_Number;
                         Day        : out Day_Number;
                         Hour       : out Hour_Number;
                         Minute     : out Minute_Number;
                         Second     : out Second_Number;
                         Sub_Second : out Second_Duration;
                         Time_Zone  : in Time_Zones.Time_Offset := 0);

33/2
        procedure Split (Date       : in Time;
                         Year       : out Year_Number;
                         Month      : out Month_Number;
                         Day        : out Day_Number;
                         Hour       : out Hour_Number;
                         Minute     : out Minute_Number;
                         Second     : out Second_Number;
                         Sub_Second : out Second_Duration;
                         Leap_Second: out Boolean;
                         Time_Zone  : in Time_Zones.Time_Offset := 0);

34/2
        procedure Split (Date       : in Time;
                         Year       : out Year_Number;
                         Month      : out Month_Number;
                         Day        : out Day_Number;
                         Seconds    : out Day_Duration;
                         Leap_Second: out Boolean;
                         Time_Zone  : in Time_Zones.Time_Offset := 0);

35/2
        -- Simple image and value:
        function Image (Date : Time;
                        Include_Time_Fraction : Boolean := False;
                        Time_Zone  : Time_Zones.Time_Offset := 0) return String;

36/2
        function Value (Date : String;
                        Time_Zone  : Time_Zones.Time_Offset := 0) return Time;

37/2
        function Image (Elapsed_Time : Duration;
                        Include_Time_Fraction : Boolean := False) return String;

38/2
        function Value (Elapsed_Time : String) return Duration;

39/2
     end Ada.Calendar.Formatting;

40/2
Type Time_Offset represents the number of minutes difference between the
implementation-defined time zone used by Calendar and another time zone.

41/2
     function UTC_Time_Offset (Date : Time := Clock) return Time_Offset;

42/3
          Returns, as a number of minutes, the result of subtracting the
          implementation-defined time zone of Calendar from UTC time, at
          the time Date.  If the time zone of the Calendar
          implementation is unknown, then Unknown_Zone_Error is raised.

43/2
     procedure Difference (Left, Right : in Time;
                           Days : out Day_Count;
                           Seconds : out Duration;
                           Leap_Seconds : out Leap_Seconds_Count);

44/2
          Returns the difference between Left and Right.  Days is the
          number of days of difference, Seconds is the remainder seconds
          of difference excluding leap seconds, and Leap_Seconds is the
          number of leap seconds.  If Left < Right, then Seconds <= 0.0,
          Days <= 0, and Leap_Seconds <= 0.  Otherwise, all values are
          nonnegative.  The absolute value of Seconds is always less
          than 86_400.0.  For the returned values, if Days = 0, then
          Seconds + Duration(Leap_Seconds) = Calendar."-" (Left, Right).

45/2
     function "+" (Left : Time; Right : Day_Count) return Time;
     function "+" (Left : Day_Count; Right : Time) return Time;

46/2
          Adds a number of days to a time value.  Time_Error is raised
          if the result is not representable as a value of type Time.

47/2
     function "-" (Left : Time; Right : Day_Count) return Time;

48/2
          Subtracts a number of days from a time value.  Time_Error is
          raised if the result is not representable as a value of type
          Time.

49/2
     function "-" (Left, Right : Time) return Day_Count;

50/2
          Subtracts two time values, and returns the number of days
          between them.  This is the same value that Difference would
          return in Days.

51/2
     function Day_of_Week (Date : Time) return Day_Name;

52/2
          Returns the day of the week for Time.  This is based on the
          Year, Month, and Day values of Time.

53/2
     function Year       (Date : Time;
                          Time_Zone  : Time_Zones.Time_Offset := 0)
                             return Year_Number;

54/2
          Returns the year for Date, as appropriate for the specified
          time zone offset.

55/2
     function Month      (Date : Time;
                          Time_Zone  : Time_Zones.Time_Offset := 0)
                             return Month_Number;

56/2
          Returns the month for Date, as appropriate for the specified
          time zone offset.

57/2
     function Day        (Date : Time;
                          Time_Zone  : Time_Zones.Time_Offset := 0)
                             return Day_Number;

58/2
          Returns the day number for Date, as appropriate for the
          specified time zone offset.

59/2
     function Hour       (Date : Time;
                          Time_Zone  : Time_Zones.Time_Offset := 0)
                             return Hour_Number;

60/2
          Returns the hour for Date, as appropriate for the specified
          time zone offset.

61/2
     function Minute     (Date : Time;
                          Time_Zone  : Time_Zones.Time_Offset := 0)
                             return Minute_Number;

62/2
          Returns the minute within the hour for Date, as appropriate
          for the specified time zone offset.

63/2
     function Second     (Date : Time)
                             return Second_Number;

64/2
          Returns the second within the hour and minute for Date.

65/2
     function Sub_Second (Date : Time)
                             return Second_Duration;

66/2
          Returns the fraction of second for Date (this has the same
          accuracy as Day_Duration).  The value returned is always less
          than 1.0.

67/2
     function Seconds_Of (Hour   : Hour_Number;
                          Minute : Minute_Number;
                          Second : Second_Number := 0;
                          Sub_Second : Second_Duration := 0.0)
         return Day_Duration;

68/2
          Returns a Day_Duration value for the combination of the given
          Hour, Minute, Second, and Sub_Second.  This value can be used
          in Calendar.Time_Of as well as the argument to Calendar."+"
          and Calendar."-".  If Seconds_Of is called with a Sub_Second
          value of 1.0, the value returned is equal to the value of
          Seconds_Of for the next second with a Sub_Second value of 0.0.

69/2
     procedure Split (Seconds    : in Day_Duration;
                      Hour       : out Hour_Number;
                      Minute     : out Minute_Number;
                      Second     : out Second_Number;
                      Sub_Second : out Second_Duration);

70/3
          Splits Seconds into Hour, Minute, Second and Sub_Second in
          such a way that the resulting values all belong to their
          respective subtypes.  The value returned in the Sub_Second
          parameter is always less than 1.0.  If Seconds = 86400.0,
          Split propagates Time_Error.

71/2
     function Time_Of (Year       : Year_Number;
                       Month      : Month_Number;
                       Day        : Day_Number;
                       Hour       : Hour_Number;
                       Minute     : Minute_Number;
                       Second     : Second_Number;
                       Sub_Second : Second_Duration := 0.0;
                       Leap_Second: Boolean := False;
                       Time_Zone  : Time_Zones.Time_Offset := 0)
                               return Time;

72/2
          If Leap_Second is False, returns a Time built from the date
          and time values, relative to the specified time zone offset.
          If Leap_Second is True, returns the Time that represents the
          time within the leap second that is one second later than the
          time specified by the other parameters.  Time_Error is raised
          if the parameters do not form a proper date or time.  If
          Time_Of is called with a Sub_Second value of 1.0, the value
          returned is equal to the value of Time_Of for the next second
          with a Sub_Second value of 0.0.

73/2
     function Time_Of (Year       : Year_Number;
                       Month      : Month_Number;
                       Day        : Day_Number;
                       Seconds    : Day_Duration := 0.0;
                       Leap_Second: Boolean := False;
                       Time_Zone  : Time_Zones.Time_Offset := 0)
                               return Time;

74/2
          If Leap_Second is False, returns a Time built from the date
          and time values, relative to the specified time zone offset.
          If Leap_Second is True, returns the Time that represents the
          time within the leap second that is one second later than the
          time specified by the other parameters.  Time_Error is raised
          if the parameters do not form a proper date or time.  If
          Time_Of is called with a Seconds value of 86_400.0, the value
          returned is equal to the value of Time_Of for the next day
          with a Seconds value of 0.0.

75/2
     procedure Split (Date       : in Time;
                      Year       : out Year_Number;
                      Month      : out Month_Number;
                      Day        : out Day_Number;
                      Hour       : out Hour_Number;
                      Minute     : out Minute_Number;
                      Second     : out Second_Number;
                      Sub_Second : out Second_Duration;
                      Leap_Second: out Boolean;
                      Time_Zone  : in Time_Zones.Time_Offset := 0);

76/2
          If Date does not represent a time within a leap second, splits
          Date into its constituent parts (Year, Month, Day, Hour,
          Minute, Second, Sub_Second), relative to the specified time
          zone offset, and sets Leap_Second to False.  If Date
          represents a time within a leap second, set the constituent
          parts to values corresponding to a time one second earlier
          than that given by Date, relative to the specified time zone
          offset, and sets Leap_Seconds to True.  The value returned in
          the Sub_Second parameter is always less than 1.0.

77/2
     procedure Split (Date       : in Time;
                      Year       : out Year_Number;
                      Month      : out Month_Number;
                      Day        : out Day_Number;
                      Hour       : out Hour_Number;
                      Minute     : out Minute_Number;
                      Second     : out Second_Number;
                      Sub_Second : out Second_Duration;
                      Time_Zone  : in Time_Zones.Time_Offset := 0);

78/2
          Splits Date into its constituent parts (Year, Month, Day,
          Hour, Minute, Second, Sub_Second), relative to the specified
          time zone offset.  The value returned in the Sub_Second
          parameter is always less than 1.0.

79/2
     procedure Split (Date       : in Time;
                      Year       : out Year_Number;
                      Month      : out Month_Number;
                      Day        : out Day_Number;
                      Seconds    : out Day_Duration;
                      Leap_Second: out Boolean;
                      Time_Zone  : in Time_Zones.Time_Offset := 0);

80/2
          If Date does not represent a time within a leap second, splits
          Date into its constituent parts (Year, Month, Day, Seconds),
          relative to the specified time zone offset, and sets
          Leap_Second to False.  If Date represents a time within a leap
          second, set the constituent parts to values corresponding to a
          time one second earlier than that given by Date, relative to
          the specified time zone offset, and sets Leap_Seconds to True.
          The value returned in the Seconds parameter is always less
          than 86_400.0.

81/2
     function Image (Date : Time;
                     Include_Time_Fraction : Boolean := False;
                     Time_Zone  : Time_Zones.Time_Offset := 0) return String;

82/2
          Returns a string form of the Date relative to the given
          Time_Zone.  The format is "Year-Month-Day Hour:Minute:Second",
          where the Year is a 4-digit value, and all others are 2-digit
          values, of the functions defined in Calendar and
          Calendar.Formatting, including a leading zero, if needed.  The
          separators between the values are a minus, another minus, a
          colon, and a single space between the Day and Hour.  If
          Include_Time_Fraction is True, the integer part of
          Sub_Seconds*100 is suffixed to the string as a point followed
          by a 2-digit value.

83/2
     function Value (Date : String;
                     Time_Zone  : Time_Zones.Time_Offset := 0) return Time;

84/2
          Returns a Time value for the image given as Date, relative to
          the given time zone.  Constraint_Error is raised if the string
          is not formatted as described for Image, or the function
          cannot interpret the given string as a Time value.

85/2
     function Image (Elapsed_Time : Duration;
                     Include_Time_Fraction : Boolean := False) return String;

86/2
          Returns a string form of the Elapsed_Time.  The format is
          "Hour:Minute:Second", where all values are 2-digit values,
          including a leading zero, if needed.  The separators between
          the values are colons.  If Include_Time_Fraction is True, the
          integer part of Sub_Seconds*100 is suffixed to the string as a
          point followed by a 2-digit value.  If Elapsed_Time < 0.0, the
          result is Image (abs Elapsed_Time, Include_Time_Fraction)
          prefixed with a minus sign.  If abs Elapsed_Time represents
          100 hours or more, the result is implementation-defined.

87/2
     function Value (Elapsed_Time : String) return Duration;

88/2
          Returns a Duration value for the image given as Elapsed_Time.
          Constraint_Error is raised if the string is not formatted as
          described for Image, or the function cannot interpret the
          given string as a Duration value.

                        _Implementation Advice_

89/2
An implementation should support leap seconds if the target system
supports them.  If leap seconds are not supported, Difference should
return zero for Leap_Seconds, Split should return False for Leap_Second,
and Time_Of should raise Time_Error if Leap_Second is True.

     NOTES

90/2
     38  The implementation-defined time zone of package Calendar may,
     but need not, be the local time zone.  UTC_Time_Offset always
     returns the difference relative to the implementation-defined time
     zone of package Calendar.  If UTC_Time_Offset does not raise
     Unknown_Zone_Error, UTC time can be safely calculated (within the
     accuracy of the underlying time-base).

91/2
     39  Calling Split on the results of subtracting
     Duration(UTC_Time_Offset*60) from Clock provides the components
     (hours, minutes, and so on) of the UTC time.  In the United States,
     for example, UTC_Time_Offset will generally be negative.


File: arm2012.info,  Node: 9.7,  Next: 9.8,  Prev: 9.6,  Up: 9

9.7 Select Statements
=====================

1
There are four forms of the select_statement.  One form provides a
selective wait for one or more select_alternatives.  Two provide timed
and conditional entry calls.  The fourth provides asynchronous transfer
of control.

                               _Syntax_

2
     select_statement ::=
        selective_accept
       | timed_entry_call
       | conditional_entry_call
       | asynchronous_select

                              _Examples_

3
Example of a select statement:

4
     select
        accept Driver_Awake_Signal;
     or
        delay 30.0*Seconds;
        Stop_The_Train;
     end select;

* Menu:

* 9.7.1 ::    Selective Accept
* 9.7.2 ::    Timed Entry Calls
* 9.7.3 ::    Conditional Entry Calls
* 9.7.4 ::    Asynchronous Transfer of Control


File: arm2012.info,  Node: 9.7.1,  Next: 9.7.2,  Up: 9.7

9.7.1 Selective Accept
----------------------

1
This form of the select_statement allows a combination of waiting for,
and selecting from, one or more alternatives.  The selection may depend
on conditions associated with each alternative of the selective_accept. 

                               _Syntax_

2
     selective_accept ::=
       select
        [guard]
          select_alternative
     { or
        [guard]
          select_alternative }
     [ else
        sequence_of_statements ]
       end select;

3
     guard ::= when condition =>

4
     select_alternative ::=
        accept_alternative
       | delay_alternative
       | terminate_alternative

5
     accept_alternative ::=
       accept_statement [sequence_of_statements]

6
     delay_alternative ::=
       delay_statement [sequence_of_statements]

7
     terminate_alternative ::= terminate;

8
     A selective_accept shall contain at least one accept_alternative.
     In addition, it can contain:

9
        * a terminate_alternative (only one); or

10
        * one or more delay_alternatives; or

11
        * an else part (the reserved word else followed by a
          sequence_of_statements).

12
     These three possibilities are mutually exclusive.

                           _Legality Rules_

13
If a selective_accept contains more than one delay_alternative, then all
shall be delay_relative_statement (*note 9.6: S0229.)s, or all shall be
delay_until_statement (*note 9.6: S0228.)s for the same time type.

                          _Dynamic Semantics_

14
A select_alternative is said to be open if it is not immediately
preceded by a guard, or if the condition of its guard evaluates to True.
It is said to be closed otherwise.

15
For the execution of a selective_accept, any guard conditions are
evaluated; open alternatives are thus determined.  For an open
delay_alternative, the delay_expression is also evaluated.  Similarly,
for an open accept_alternative for an entry of a family, the entry_index
is also evaluated.  These evaluations are performed in an arbitrary
order, except that a delay_expression or entry_index is not evaluated
until after evaluating the corresponding condition, if any.  Selection
and execution of one open alternative, or of the else part, then
completes the execution of the selective_accept; the rules for this
selection are described below.

16
Open accept_alternatives are first considered.  Selection of one such
alternative takes place immediately if the corresponding entry already
has queued calls.  If several alternatives can thus be selected, one of
them is selected according to the entry queuing policy in effect (see
*note 9.5.3:: and *note D.4::).  When such an alternative is selected,
the selected call is removed from its entry queue and the
handled_sequence_of_statements (*note 11.2: S0265.) (if any) of the
corresponding accept_statement is executed; after the rendezvous
completes any subsequent sequence_of_statements (*note 5.1: S0145.) of
the alternative is executed. If no selection is immediately possible (in
the above sense) and there is no else part, the task blocks until an
open alternative can be selected.

17
Selection of the other forms of alternative or of an else part is
performed as follows:

18
   * An open delay_alternative is selected when its expiration time is
     reached if no accept_alternative (*note 9.7.1: S0234.) or other
     delay_alternative (*note 9.7.1: S0235.) can be selected prior to
     the expiration time.  If several delay_alternative (*note 9.7.1:
     S0235.)s have this same expiration time, one of them is selected
     according to the queuing policy in effect (see *note D.4::); the
     default queuing policy chooses arbitrarily among the
     delay_alternative (*note 9.7.1: S0235.)s whose expiration time has
     passed.

19
   * The else part is selected and its sequence_of_statements (*note
     5.1: S0145.) is executed if no accept_alternative can immediately
     be selected; in particular, if all alternatives are closed.

20/3
   * An open terminate_alternative is selected if the conditions stated
     at the end of subclause *note 9.3:: are satisfied.

21
The exception Program_Error is raised if all alternatives are closed and
there is no else part.

     NOTES

22
     40  A selective_accept is allowed to have several open
     delay_alternatives.  A selective_accept is allowed to have several
     open accept_alternatives for the same entry.

                              _Examples_

23
Example of a task body with a selective accept:

24
     task body Server is
        Current_Work_Item : Work_Item;
     begin
        loop
           select
              accept Next_Work_Item(WI : in Work_Item) do
                 Current_Work_Item := WI;
              end;
              Process_Work_Item(Current_Work_Item);
           or
              accept Shut_Down;
              exit;       -- Premature shut down requested
           or
              terminate;  -- Normal shutdown at end of scope
           end select;
        end loop;
     end Server;


File: arm2012.info,  Node: 9.7.2,  Next: 9.7.3,  Prev: 9.7.1,  Up: 9.7

9.7.2 Timed Entry Calls
-----------------------

1/2
A timed_entry_call issues an entry call that is cancelled if the call
(or a requeue-with-abort of the call) is not selected before the
expiration time is reached.  A procedure call may appear rather than an
entry call for cases where the procedure might be implemented by an
entry. 

                               _Syntax_

2
     timed_entry_call ::=
       select
        entry_call_alternative
       or
        delay_alternative
       end select;

3/2
     entry_call_alternative ::=
       procedure_or_entry_call [sequence_of_statements]

3.1/2
     procedure_or_entry_call ::=
       procedure_call_statement | entry_call_statement

                           _Legality Rules_

3.2/2
If a procedure_call_statement is used for a procedure_or_entry_call, the
procedure_name or procedure_prefix of the procedure_call_statement shall
statically denote an entry renamed as a procedure or (a view of) a
primitive subprogram of a limited interface whose first parameter is a
controlling parameter (see *note 3.9.2::).

                          _Dynamic Semantics_

4/2
For the execution of a timed_entry_call, the entry_name, procedure_name,
or procedure_prefix, and any actual parameters are evaluated, as for a
simple entry call (see *note 9.5.3::) or procedure call (see *note
6.4::).  The expiration time (see *note 9.6::) for the call is
determined by evaluating the delay_expression of the delay_alternative.
If the call is an entry call or a call on a procedure implemented by an
entry, the entry call is then issued.  Otherwise, the call proceeds as
described in *note 6.4:: for a procedure call, followed by the
sequence_of_statements (*note 5.1: S0145.) of the entry_call_alternative
(*note 9.7.2: S0238.); the sequence_of_statements (*note 5.1: S0145.) of
the delay_alternative (*note 9.7.1: S0235.) is ignored.

5
If the call is queued (including due to a requeue-with-abort), and not
selected before the expiration time is reached, an attempt to cancel the
call is made.  If the call completes due to the cancellation, the
optional sequence_of_statements (*note 5.1: S0145.) of the
delay_alternative (*note 9.7.1: S0235.) is executed; if the entry call
completes normally, the optional sequence_of_statements (*note 5.1:
S0145.) of the entry_call_alternative (*note 9.7.2: S0238.) is executed.

                              _Examples_

6
Example of a timed entry call:

7
     select
        Controller.Request(Medium)(Some_Item);
     or
        delay 45.0;
        --  controller too busy, try something else
     end select;


File: arm2012.info,  Node: 9.7.3,  Next: 9.7.4,  Prev: 9.7.2,  Up: 9.7

9.7.3 Conditional Entry Calls
-----------------------------

1/2
A conditional_entry_call issues an entry call that is then cancelled if
it is not selected immediately (or if a requeue-with-abort of the call
is not selected immediately).  A procedure call may appear rather than
an entry call for cases where the procedure might be implemented by an
entry.

                               _Syntax_

2
     conditional_entry_call ::=
       select
        entry_call_alternative
       else
        sequence_of_statements
       end select;

                          _Dynamic Semantics_

3
The execution of a conditional_entry_call is defined to be equivalent to
the execution of a timed_entry_call (*note 9.7.2: S0237.) with a
delay_alternative (*note 9.7.1: S0235.) specifying an immediate
expiration time and the same sequence_of_statements (*note 5.1: S0145.)
as given after the reserved word else.

     NOTES

4
     41  A conditional_entry_call may briefly increase the Count
     attribute of the entry, even if the conditional call is not
     selected.

                              _Examples_

5
Example of a conditional entry call:

6
     procedure Spin(R : in Resource) is
     begin
        loop
           select
              R.Seize;
              return;
           else
              null;  --  busy waiting
           end select;
        end loop;
     end;


File: arm2012.info,  Node: 9.7.4,  Prev: 9.7.3,  Up: 9.7

9.7.4 Asynchronous Transfer of Control
--------------------------------------

1
An asynchronous select_statement provides asynchronous transfer of
control upon completion of an entry call or the expiration of a delay.

                               _Syntax_

2
     asynchronous_select ::=
       select
        triggering_alternative
       then abort
        abortable_part
       end select;

3
     triggering_alternative ::= triggering_statement [
     sequence_of_statements]

4/2
     triggering_statement ::= procedure_or_entry_call | delay_statement

5
     abortable_part ::= sequence_of_statements

                          _Dynamic Semantics_

6/2
For the execution of an asynchronous_select whose triggering_statement
(*note 9.7.4: S0243.) is a procedure_or_entry_call, the entry_name,
procedure_name, or procedure_prefix, and actual parameters are evaluated
as for a simple entry call (see *note 9.5.3::) or procedure call (see
*note 6.4::).  If the call is an entry call or a call on a procedure
implemented by an entry, the entry call is issued.  If the entry call is
queued (or requeued-with-abort), then the abortable_part is executed.
If the entry call is selected immediately, and never
requeued-with-abort, then the abortable_part is never started.  If the
call is on a procedure that is not implemented by an entry, the call
proceeds as described in *note 6.4::, followed by the
sequence_of_statements (*note 5.1: S0145.) of the triggering_alternative
(*note 9.7.4: S0242.); the abortable_part is never started.

7
For the execution of an asynchronous_select whose triggering_statement
(*note 9.7.4: S0243.) is a delay_statement, the delay_expression is
evaluated and the expiration time is determined, as for a normal
delay_statement.  If the expiration time has not already passed, the
abortable_part is executed.

8
If the abortable_part completes and is left prior to completion of the
triggering_statement (*note 9.7.4: S0243.), an attempt to cancel the
triggering_statement (*note 9.7.4: S0243.) is made.  If the attempt to
cancel succeeds (see *note 9.5.3:: and *note 9.6::), the
asynchronous_select is complete.

9
If the triggering_statement (*note 9.7.4: S0243.) completes other than
due to cancellation, the abortable_part is aborted (if started but not
yet completed -- see *note 9.8::).  If the triggering_statement (*note
9.7.4: S0243.) completes normally, the optional sequence_of_statements
(*note 5.1: S0145.) of the triggering_alternative (*note 9.7.4: S0242.)
is executed after the abortable_part is left.

                              _Examples_

10
Example of a main command loop for a command interpreter:

11
     loop
        select
           Terminal.Wait_For_Interrupt;
           Put_Line("Interrupted");
        then abort
           -- This will be abandoned upon terminal interrupt
           Put_Line("-> ");
           Get_Line(Command, Last);
           Process_Command(Command(1..Last));
        end select;
     end loop;

12
Example of a time-limited calculation: 

13
     select
        delay 5.0;
        Put_Line("Calculation does not converge");
     then abort
        -- This calculation should finish in 5.0 seconds;
        --  if not, it is assumed to diverge.
        Horribly_Complicated_Recursive_Function(X, Y);
     end select;

14/4
Note that these examples presume that there are abort completion points
within the execution of the abortable_part.


File: arm2012.info,  Node: 9.8,  Next: 9.9,  Prev: 9.7,  Up: 9

9.8 Abort of a Task - Abort of a Sequence of Statements
=======================================================

1
An abort_statement causes one or more tasks to become abnormal, thus
preventing any further interaction with such tasks.  The completion of
the triggering_statement (*note 9.7.4: S0243.) of an asynchronous_select
causes a sequence_of_statements (*note 5.1: S0145.) to be aborted.

                               _Syntax_

2
     abort_statement ::= abort task_name {, task_name};

                        _Name Resolution Rules_

3
Each task_name is expected to be of any task type; they need not all be
of the same task type.

                          _Dynamic Semantics_

4
For the execution of an abort_statement, the given task_names are
evaluated in an arbitrary order. Each named task is then aborted, which
consists of making the task abnormal and aborting the execution of the
corresponding task_body, unless it is already completed.

5
When the execution of a construct is aborted (including that of a
task_body (*note 9.1: S0209.) or of a sequence_of_statements (*note 5.1:
S0145.)), the execution of every construct included within the aborted
execution is also aborted, except for executions included within the
execution of an abort-deferred operation; the execution of an
abort-deferred operation continues to completion without being affected
by the abort; the following are the abort-deferred operations:

6
   * a protected action;

7
   * waiting for an entry call to complete (after having initiated the
     attempt to cancel it -- see below);

8
   * waiting for the termination of dependent tasks;

9
   * the execution of an Initialize procedure as the last step of the
     default initialization of a controlled object;

10
   * the execution of a Finalize procedure as part of the finalization
     of a controlled object;

11
   * an assignment operation to an object with a controlled part.

12
The last three of these are discussed further in *note 7.6::.

13
When a master is aborted, all tasks that depend on that master are
aborted.

14
The order in which tasks become abnormal as the result of an
abort_statement or the abort of a sequence_of_statements (*note 5.1:
S0145.) is not specified by the language.

15
If the execution of an entry call is aborted, an immediate attempt is
made to cancel the entry call (see *note 9.5.3::).  If the execution of
a construct is aborted at a time when the execution is blocked, other
than for an entry call, at a point that is outside the execution of an
abort-deferred operation, then the execution of the construct completes
immediately.  For an abort due to an abort_statement, these immediate
effects occur before the execution of the abort_statement completes.
Other than for these immediate cases, the execution of a construct that
is aborted does not necessarily complete before the abort_statement
completes.  However, the execution of the aborted construct completes no
later than its next abort completion point (if any) that occurs outside
of an abort-deferred operation; the following are abort completion
points for an execution:

16
   * the point where the execution initiates the activation of another
     task;

17
   * the end of the activation of a task;

18
   * the start or end of the execution of an entry call,
     accept_statement, delay_statement, or abort_statement;

19
   * the start of the execution of a select_statement, or of the
     sequence_of_statements (*note 5.1: S0145.) of an exception_handler.

                      _Bounded (Run-Time) Errors_

20/3
An attempt to execute an asynchronous_select as part of the execution of
an abort-deferred operation is a bounded error.  Similarly, an attempt
to create a task that depends on a master that is included entirely
within the execution of an abort-deferred operation is a bounded error.
In both cases, Program_Error is raised if the error is detected by the
implementation; otherwise, the operations proceed as they would outside
an abort-deferred operation, except that an abort of the abortable_part
or the created task might or might not have an effect.

                         _Erroneous Execution_

21
If an assignment operation completes prematurely due to an abort, the
assignment is said to be disrupted; the target of the assignment or its
parts can become abnormal, and certain subsequent uses of the object can
be erroneous, as explained in *note 13.9.1::.

     NOTES

22
     42  An abort_statement should be used only in situations requiring
     unconditional termination.

23
     43  A task is allowed to abort any task it can name, including
     itself.

24
     44  Additional requirements associated with abort are given in
     *note D.6::, "*note D.6:: Preemptive Abort".


File: arm2012.info,  Node: 9.9,  Next: 9.10,  Prev: 9.8,  Up: 9

9.9 Task and Entry Attributes
=============================

                          _Dynamic Semantics_

1
For a prefix T that is of a task type (after any implicit dereference),
the following attributes are defined:

2
T'Callable
               Yields the value True when the task denoted by T is
               callable, and False otherwise; a task is callable unless
               it is completed or abnormal.  The value of this attribute
               is of the predefined type Boolean.

3
T'Terminated
               Yields the value True if the task denoted by T is
               terminated, and False otherwise.  The value of this
               attribute is of the predefined type Boolean.

4
For a prefix E that denotes an entry of a task or protected unit, the
following attribute is defined.  This attribute is only allowed within
the body of the task or protected unit, but excluding, in the case of an
entry of a task unit, within any program unit that is, itself, inner to
the body of the task unit.

5
E'Count
               Yields the number of calls presently queued on the entry
               E of the current instance of the unit.  The value of this
               attribute is of the type universal_integer.

     NOTES

6
     45  For the Count attribute, the entry can be either a single entry
     or an entry of a family.  The name of the entry or entry family can
     be either a direct_name or an expanded name.

7
     46  Within task units, algorithms interrogating the attribute
     E'Count should take precautions to allow for the increase of the
     value of this attribute for incoming entry calls, and its decrease,
     for example with timed_entry_calls.  Also, a conditional_entry_call
     may briefly increase this value, even if the conditional call is
     not accepted.

8
     47  Within protected units, algorithms interrogating the attribute
     E'Count in the entry_barrier for the entry E should take
     precautions to allow for the evaluation of the condition of the
     barrier both before and after queuing a given caller.


File: arm2012.info,  Node: 9.10,  Next: 9.11,  Prev: 9.9,  Up: 9

9.10 Shared Variables
=====================

                          _Static Semantics_

1/3
If two different objects, including nonoverlapping parts of the same
object, are independently addressable, they can be manipulated
concurrently by two different tasks without synchronization.  Any two
nonoverlapping objects are independently addressable if either object is
specified as independently addressable (see *note C.6::).  Otherwise,
two nonoverlapping objects are independently addressable except when
they are both parts of a composite object for which a nonconfirming
value is specified for any of the following representation aspects:
(record) Layout, Component_Size, Pack, Atomic, or Convention; in this
case it is unspecified whether the parts are independently addressable.

                          _Dynamic Semantics_

2
Separate tasks normally proceed independently and concurrently with one
another.  However, task interactions can be used to synchronize the
actions of two or more tasks to allow, for example, meaningful
communication by the direct updating and reading of variables shared
between the tasks.  The actions of two different tasks are synchronized
in this sense when an action of one task signals an action of the other
task; an action A1 is defined to signal an action A2 under the following
circumstances:

3
   * If A1 and A2 are part of the execution of the same task, and the
     language rules require A1 to be performed before A2;

4
   * If A1 is the action of an activator that initiates the activation
     of a task, and A2 is part of the execution of the task that is
     activated;

5
   * If A1 is part of the activation of a task, and A2 is the action of
     waiting for completion of the activation;

6
   * If A1 is part of the execution of a task, and A2 is the action of
     waiting for the termination of the task;

6.1/3
   * If A1 is the termination of a task T, and A2 is either an
     evaluation of the expression T'Terminated that results in True, or
     a call to Ada.Task_Identification.Is_Terminated with an actual
     parameter that identifies T and a result of True (see *note
     C.7.1::);

7/3
   * If A1 is the action of issuing an entry call, and A2 is part of the
     corresponding execution of the appropriate entry_body or
     accept_statement;

8
   * If A1 is part of the execution of an accept_statement or
     entry_body, and A2 is the action of returning from the
     corresponding entry call;

9
   * If A1 is part of the execution of a protected procedure body or
     entry_body for a given protected object, and A2 is part of a later
     execution of an entry_body for the same protected object;

10
   * If A1 signals some action that in turn signals A2.

                         _Erroneous Execution_

11
Given an action of assigning to an object, and an action of reading or
updating a part of the same object (or of a neighboring object if the
two are not independently addressable), then the execution of the
actions is erroneous unless the actions are sequential. Two actions are
sequential if one of the following is true:

12
   * One action signals the other;

13
   * Both actions occur as part of the execution of the same task;

14
   * Both actions occur as part of protected actions on the same
     protected object, and at most one of the actions is part of a call
     on a protected function of the protected object.

15/3
Aspect Atomic or aspect Atomic_Components may also be specified to
ensure that certain reads and updates are sequential -- see *note C.6::.


File: arm2012.info,  Node: 9.11,  Prev: 9.10,  Up: 9

9.11 Example of Tasking and Synchronization
===========================================

                              _Examples_

1
The following example defines a buffer protected object to smooth
variations between the speed of output of a producing task and the speed
of input of some consuming task.  For instance, the producing task might
have the following structure:

2
     task Producer;

3/2
     task body Producer is
        Person : Person_Name; -- see *note 3.10.1::
     begin
        loop
           ... --  simulate arrival of the next customer
           Buffer.Append_Wait(Person);
           exit when Person = null;
        end loop;
     end Producer;

4
and the consuming task might have the following structure:

5
     task Consumer;

6/2
     task body Consumer is
        Person : Person_Name;
     begin
        loop
           Buffer.Remove_First_Wait(Person);
           exit when Person = null;
           ... --  simulate serving a customer
        end loop;
     end Consumer;

7/2
The buffer object contains an internal array of person names managed in
a round-robin fashion.  The array has two indices, an In_Index denoting
the index for the next input person name and an Out_Index denoting the
index for the next output person name.

7.1/2
The Buffer is defined as an extension of the Synchronized_Queue
interface (see *note 3.9.4::), and as such promises to implement the
abstraction defined by that interface.  By doing so, the Buffer can be
passed to the Transfer class-wide operation defined for objects of a
type covered by Queue'Class.

8/2
     protected Buffer is new Synchronized_Queue with  -- see *note 3.9.4::
        entry Append_Wait(Person : in Person_Name);
        entry Remove_First_Wait(Person : out Person_Name);
        function Cur_Count return Natural;
        function Max_Count return Natural;
        procedure Append(Person : in Person_Name);
        procedure Remove_First(Person : out Person_Name);
     private
        Pool      : Person_Name_Array(1 .. 100);
        Count     : Natural := 0;
        In_Index, Out_Index : Positive := 1;
     end Buffer;

9/2
     protected body Buffer is
        entry Append_Wait(Person : in Person_Name)
           when Count < Pool'Length is
        begin
           Append(Person);
        end Append_Wait;

9.1/2
        procedure Append(Person : in Person_Name) is
        begin
           if Count = Pool'Length then
              raise Queue_Error with "Buffer Full";  -- see *note 11.3::
           end if;
           Pool(In_Index) := Person;
           In_Index       := (In_Index mod Pool'Length) + 1;
           Count          := Count + 1;
        end Append;

10/2
        entry Remove_First_Wait(Person : out Person_Name)
           when Count > 0 is
        begin
           Remove_First(Person);
        end Remove_First_Wait;

11/2
        procedure Remove_First(Person : out Person_Name) is
        begin
           if Count = 0 then
              raise Queue_Error with "Buffer Empty"; -- see *note 11.3::
           end if;
           Person    := Pool(Out_Index);
           Out_Index := (Out_Index mod Pool'Length) + 1;
           Count     := Count - 1;
        end Remove_First;

12/2
        function Cur_Count return Natural is
        begin
            return Buffer.Count;
        end Cur_Count;

13/2
        function Max_Count return Natural is
        begin
            return Pool'Length;
        end Max_Count;
     end Buffer;


File: arm2012.info,  Node: 10,  Next: 11,  Prev: 9,  Up: Top

10 Program Structure and Compilation Issues
*******************************************

1/3
The overall structure of programs and the facilities for separate
compilation are described in this clause.  A program is a set of
partitions, each of which may execute in a separate address space,
possibly on a separate computer.

2
As explained below, a partition is constructed from library units.
Syntactically, the declaration of a library unit is a library_item, as
is the body of a library unit.  An implementation may support a concept
of a program library (or simply, a "library"), which contains
library_items and their subunits. Library units may be organized into a
hierarchy of children, grandchildren, and so on.

3/3
This clause has two subclauses: *note 10.1::, "*note 10.1:: Separate
Compilation" discusses compile-time issues related to separate
compilation.  *note 10.2::, "*note 10.2:: Program Execution" discusses
issues related to what is traditionally known as "link time" and "run
time" -- building and executing partitions.

* Menu:

* 10.1 ::     Separate Compilation
* 10.2 ::     Program Execution


File: arm2012.info,  Node: 10.1,  Next: 10.2,  Up: 10

10.1 Separate Compilation
=========================

1
A program unit is either a package, a task unit, a protected unit, a
protected entry, a generic unit, or an explicitly declared subprogram
other than an enumeration literal.  Certain kinds of program units can
be separately compiled.  Alternatively, they can appear physically
nested within other program units.

2
The text of a program can be submitted to the compiler in one or more
compilations.  Each compilation is a succession of compilation_units.  A
compilation_unit contains either the declaration, the body, or a
renaming of a program unit.  The representation for a compilation is
implementation-defined.

3
A library unit is a separately compiled program unit, and is always a
package, subprogram, or generic unit.  Library units may have other
(logically nested) library units as children, and may have other program
units physically nested within them. A root library unit, together with
its children and grandchildren and so on, form a subsystem.

                     _Implementation Permissions_

4
An implementation may impose implementation-defined restrictions on
compilations that contain multiple compilation_units.

* Menu:

* 10.1.1 ::   Compilation Units - Library Units
* 10.1.2 ::   Context Clauses - With Clauses
* 10.1.3 ::   Subunits of Compilation Units
* 10.1.4 ::   The Compilation Process
* 10.1.5 ::   Pragmas and Program Units
* 10.1.6 ::   Environment-Level Visibility Rules


File: arm2012.info,  Node: 10.1.1,  Next: 10.1.2,  Up: 10.1

10.1.1 Compilation Units - Library Units
----------------------------------------

1
A library_item is a compilation unit that is the declaration, body, or
renaming of a library unit.  Each library unit (except Standard) has a
parent unit, which is a library package or generic library package. A
library unit is a child of its parent unit.  The root library units are
the children of the predefined library package Standard.

                               _Syntax_

2
     compilation ::= {compilation_unit}

3
     compilation_unit ::=
         context_clause library_item
       | context_clause subunit

4
     library_item ::= [private] library_unit_declaration
       | library_unit_body
       | [private] library_unit_renaming_declaration

5
     library_unit_declaration ::=
          subprogram_declaration   | package_declaration
        | generic_declaration   | generic_instantiation

6
     library_unit_renaming_declaration ::=
        package_renaming_declaration
      | generic_renaming_declaration
      | subprogram_renaming_declaration

7
     library_unit_body ::= subprogram_body | package_body

8
     parent_unit_name ::= name

8.1/2
     An overriding_indicator is not allowed in a subprogram_declaration,
     generic_instantiation, or subprogram_renaming_declaration that
     declares a library unit.

9
A library unit is a program unit that is declared by a library_item.
When a program unit is a library unit, the prefix "library" is used to
refer to it (or "generic library" if generic), as well as to its
declaration and body, as in "library procedure", "library package_body",
or "generic library package". The term compilation unit is used to refer
to a compilation_unit.  When the meaning is clear from context, the term
is also used to refer to the library_item of a compilation_unit or to
the proper_body of a subunit (that is, the compilation_unit without the
context_clause and the separate (parent_unit_name)).

10
The parent declaration of a library_item (and of the library unit) is
the declaration denoted by the parent_unit_name (*note 10.1.1: S0252.),
if any, of the defining_program_unit_name (*note 6.1: S0169.) of the
library_item. If there is no parent_unit_name (*note 10.1.1: S0252.),
the parent declaration is the declaration of Standard, the library_item
is a root library_item, and the library unit (renaming) is a root
library unit (renaming).  The declaration and body of Standard itself
have no parent declaration. The parent unit of a library_item or library
unit is the library unit declared by its parent declaration.

11
The children of a library unit occur immediately within the declarative
region of the declaration of the library unit. The ancestors of a
library unit are itself, its parent, its parent's parent, and so on.
(Standard is an ancestor of every library unit.) The descendant relation
is the inverse of the ancestor relation.

12
A library_unit_declaration or a library_unit_renaming_declaration (*note
10.1.1: S0250.) is private if the declaration is immediately preceded by
the reserved word private; it is otherwise public.  A library unit is
private or public according to its declaration. The public descendants
of a library unit are the library unit itself, and the public
descendants of its public children. Its other descendants are private
descendants.

12.1/2
For each library package_declaration in the environment, there is an
implicit declaration of a limited view of that library package.  The
limited view of a package contains:

12.2/3
   * For each package_declaration occurring immediately within the
     visible part, a declaration of the limited view of that package,
     with the same defining_program_unit_name.

12.3/3
   * For each type_declaration occurring immediately within the visible
     part that is not an incomplete_type_declaration, an incomplete view
     of the type with no discriminant_part; if the type_declaration is
     tagged, then the view is a tagged incomplete view.

12.4/2
The limited view of a library package_declaration is private if that
library package_declaration is immediately preceded by the reserved word
private.

12.5/2
There is no syntax for declaring limited views of packages, because they
are always implicit.  The implicit declaration of a limited view of a
library package is not the declaration of a library unit (the library
package_declaration is); nonetheless, it is a library_item.  The
implicit declaration of the limited view of a library package forms an
(implicit) compilation unit whose context_clause is empty.

12.6/2
A library package_declaration is the completion of the declaration of
its limited view.

                           _Legality Rules_

13
The parent unit of a library_item shall be a library package or generic
library package.

14
If a defining_program_unit_name of a given declaration or body has a
parent_unit_name, then the given declaration or body shall be a
library_item.  The body of a program unit shall be a library_item if and
only if the declaration of the program unit is a library_item.  In a
library_unit_renaming_declaration (*note 10.1.1: S0250.), the (old) name
shall denote a library_item.

15/2
A parent_unit_name (which can be used within a
defining_program_unit_name of a library_item and in the separate clause
of a subunit), and each of its prefixes, shall not denote a
renaming_declaration.  On the other hand, a name that denotes a
library_unit_renaming_declaration (*note 10.1.1: S0250.) is allowed in a
nonlimited_with_clause and other places where the name of a library unit
is allowed.

16
If a library package is an instance of a generic package, then every
child of the library package shall either be itself an instance or be a
renaming of a library unit.

17/3
A child of a generic library package shall either be itself a generic
unit or be a renaming of some other child of the same generic unit.

18
A child of a parent generic package shall be instantiated or renamed
only within the declarative region of the parent generic.

19/2
For each child C of some parent generic package P, there is a
corresponding declaration C nested immediately within each instance of
P. For the purposes of this rule, if a child C itself has a child D,
each corresponding declaration for C has a corresponding child D. The
corresponding declaration for a child within an instance is visible only
within the scope of a with_clause that mentions the (original) child
generic unit.

20
A library subprogram shall not override a primitive subprogram.

21
The defining name of a function that is a compilation unit shall not be
an operator_symbol.

                          _Static Semantics_

22
A subprogram_renaming_declaration that is a
library_unit_renaming_declaration (*note 10.1.1: S0250.) is a
renaming-as-declaration, not a renaming-as-body.

23
There are two kinds of dependences among compilation units:

24
   * The semantic dependences (see below) are the ones needed to check
     the compile-time rules across compilation unit boundaries; a
     compilation unit depends semantically on the other compilation
     units needed to determine its legality.  The visibility rules are
     based on the semantic dependences.

25
   * The elaboration dependences (see *note 10.2::) determine the order
     of elaboration of library_items.

26/2
A library_item depends semantically upon its parent declaration.  A
subunit depends semantically upon its parent body.  A library_unit_body
depends semantically upon the corresponding library_unit_declaration, if
any.  The declaration of the limited view of a library package depends
semantically upon the declaration of the limited view of its parent.
The declaration of a library package depends semantically upon the
declaration of its limited view.  A compilation unit depends
semantically upon each library_item mentioned in a with_clause of the
compilation unit.  In addition, if a given compilation unit contains an
attribute_reference of a type defined in another compilation unit, then
the given compilation unit depends semantically upon the other
compilation unit.  The semantic dependence relationship is transitive.

                          _Dynamic Semantics_

26.1/2
The elaboration of the declaration of the limited view of a package has
no effect.

     NOTES

27
     1  A simple program may consist of a single compilation unit.  A
     compilation need not have any compilation units; for example, its
     text can consist of pragmas.

28
     2  The designator of a library function cannot be an
     operator_symbol, but a nonlibrary renaming_declaration is allowed
     to rename a library function as an operator.  Within a partition,
     two library subprograms are required to have distinct names and
     hence cannot overload each other.  However, renaming_declarations
     are allowed to define overloaded names for such subprograms, and a
     locally declared subprogram is allowed to overload a library
     subprogram.  The expanded name Standard.L can be used to denote a
     root library unit L (unless the declaration of Standard is hidden)
     since root library unit declarations occur immediately within the
     declarative region of package Standard.

                              _Examples_

29
Examples of library units:

30
     package Rational_Numbers.IO is  -- public child of Rational_Numbers, see *note 7.1::
        procedure Put(R : in  Rational);
        procedure Get(R : out Rational);
     end Rational_Numbers.IO;

31
     private procedure Rational_Numbers.Reduce(R : in out Rational);
                                     -- private child of Rational_Numbers

32
     with Rational_Numbers.Reduce;   -- refer to a private child
     package body Rational_Numbers is
        ...
     end Rational_Numbers;

33
     with Rational_Numbers.IO; use Rational_Numbers;
     with Ada.Text_io;               -- see *note A.10::
     procedure Main is               -- a root library procedure
        R : Rational;
     begin
        R := 5/3;                    -- construct a rational number, see *note 7.1::
        Ada.Text_IO.Put("The answer is: ");
        IO.Put(R);
        Ada.Text_IO.New_Line;
     end Main;

34
     with Rational_Numbers.IO;
     package Rational_IO renames Rational_Numbers.IO;
                                     -- a library unit renaming declaration

35
Each of the above library_items can be submitted to the compiler
separately.


File: arm2012.info,  Node: 10.1.2,  Next: 10.1.3,  Prev: 10.1.1,  Up: 10.1

10.1.2 Context Clauses - With Clauses
-------------------------------------

1
A context_clause is used to specify the library_items whose names are
needed within a compilation unit.

                               _Syntax_

2
     context_clause ::= {context_item}

3
     context_item ::= with_clause | use_clause

4/2
     with_clause ::= limited_with_clause | nonlimited_with_clause

4.1/2
     limited_with_clause ::= limited [private] with library_unit_
     name {, library_unit_name};

4.2/2
     nonlimited_with_clause ::= [private] with library_unit_
     name {, library_unit_name};

                        _Name Resolution Rules_

5
The scope of a with_clause that appears on a library_unit_declaration
(*note 10.1.1: S0249.) or library_unit_renaming_declaration (*note
10.1.1: S0250.) consists of the entire declarative region of the
declaration, which includes all children and subunits.  The scope of a
with_clause that appears on a body consists of the body, which includes
all subunits.

6/2
A library_item (and the corresponding library unit) is named in a
with_clause if it is denoted by a library_unit_name in the with_clause.
A library_item (and the corresponding library unit) is mentioned in a
with_clause if it is named in the with_clause or if it is denoted by a
prefix in the with_clause.

7
Outside its own declarative region, the declaration or renaming of a
library unit can be visible only within the scope of a with_clause that
mentions it.  The visibility of the declaration or renaming of a library
unit otherwise follows from its placement in the environment.

                           _Legality Rules_

8/2
If a with_clause of a given compilation_unit mentions a private child of
some library unit, then the given compilation_unit shall be one of:

9/2
   * the declaration, body, or subunit of a private descendant of that
     library unit;

10/2
   * the body or subunit of a public descendant of that library unit,
     but not a subprogram body acting as a subprogram declaration (see
     *note 10.1.4::); or

11/2
   * the declaration of a public descendant of that library unit, in
     which case the with_clause shall include the reserved word private.

12/3
A name denoting a library_item (or the corresponding declaration for a
child of a generic within an instance -- see *note 10.1.1::), if it is
visible only due to being mentioned in one or more with_clauses that
include the reserved word private, shall appear only within:

13/2
   * a private part;

14/2
   * a body, but not within the subprogram_specification of a library
     subprogram body;

15/2
   * a private descendant of the unit on which one of these with_clauses
     appear; or

16/2
   * a pragma within a context clause.

17/2
A library_item mentioned in a limited_with_clause shall be the implicit
declaration of the limited view of a library package, not the
declaration of a subprogram, generic unit, generic instance, or a
renaming.

18/2
A limited_with_clause shall not appear on a library_unit_body, subunit,
or library_unit_renaming_declaration (*note 10.1.1: S0250.).

19/2
A limited_with_clause that names a library package shall not appear:

20/3
   * in the context_clause for the explicit declaration of the named
     library package or any of its descendants;

21/3
   * within a context_clause for a library_item that is within the scope
     of a nonlimited_with_clause that mentions the same library package;
     or

22/3
   * within a context_clause for a library_item that is within the scope
     of a use_clause that names an entity declared within the
     declarative region of the library package.

     NOTES

23/2
     3  A library_item mentioned in a nonlimited_with_clause of a
     compilation unit is visible within the compilation unit and hence
     acts just like an ordinary declaration.  Thus, within a compilation
     unit that mentions its declaration, the name of a library package
     can be given in use_clauses and can be used to form expanded names,
     a library subprogram can be called, and instances of a generic
     library unit can be declared.  If a child of a parent generic
     package is mentioned in a nonlimited_with_clause, then the
     corresponding declaration nested within each visible instance is
     visible within the compilation unit.  Similarly, a library_item
     mentioned in a limited_with_clause of a compilation unit is visible
     within the compilation unit and thus can be used to form expanded
     names.

                              _Examples_

24/2
     package Office is
     end Office;

25/2
     with Ada.Strings.Unbounded;
     package Office.Locations is
        type Location is new Ada.Strings.Unbounded.Unbounded_String;
     end Office.Locations;

26/2
     limited with Office.Departments;  -- types are incomplete
     private with Office.Locations;    -- only visible in private part
     package Office.Employees is
        type Employee is private;

27/2
        function Dept_Of(Emp : Employee) return access Departments.Department;
        procedure Assign_Dept(Emp  : in out Employee;
                              Dept : access Departments.Department);

28/2
        ...
     private
        type Employee is
           record
              Dept : access Departments.Department;
              Loc : Locations.Location;
              ...
           end record;
     end Office.Employees;

29/2
     limited with Office.Employees;
     package Office.Departments is
        type Department is private;

30/2
        function Manager_Of(Dept : Department) return access Employees.Employee;
        procedure Assign_Manager(Dept : in out Department;
                                 Mgr  : access Employees.Employee);
        ...
     end Office.Departments;

31/2
The limited_with_clause may be used to support mutually dependent
abstractions that are split across multiple packages.  In this case, an
employee is assigned to a department, and a department has a manager who
is an employee.  If a with_clause with the reserved word private appears
on one library unit and mentions a second library unit, it provides
visibility to the second library unit, but restricts that visibility to
the private part and body of the first unit.  The compiler checks that
no use is made of the second unit in the visible part of the first unit.


File: arm2012.info,  Node: 10.1.3,  Next: 10.1.4,  Prev: 10.1.2,  Up: 10.1

10.1.3 Subunits of Compilation Units
------------------------------------

1
Subunits are like child units, with these (important) differences:
subunits support the separate compilation of bodies only (not
declarations); the parent contains a body_stub to indicate the existence
and place of each of its subunits; declarations appearing in the
parent's body can be visible within the subunits.

                               _Syntax_

2
     body_stub ::= subprogram_body_stub | package_body_stub | 
     task_body_stub | protected_body_stub

3/3
     subprogram_body_stub ::=
        [overriding_indicator]
        subprogram_specification is separate
           [aspect_specification];

4/3
     package_body_stub ::=
        package body defining_identifier is separate
           [aspect_specification];

5/3
     task_body_stub ::=
        task body defining_identifier is separate
           [aspect_specification];

6/3
     protected_body_stub ::=
        protected body defining_identifier is separate
           [aspect_specification];

7
     subunit ::= separate (parent_unit_name) proper_body

                           _Legality Rules_

8/2
The parent body of a subunit is the body of the program unit denoted by
its parent_unit_name.   The term subunit is used to refer to a subunit
and also to the proper_body of a subunit.  The subunits of a program
unit include any subunit that names that program unit as its parent, as
well as any subunit that names such a subunit as its parent
(recursively).

9
The parent body of a subunit shall be present in the current
environment, and shall contain a corresponding body_stub with the same
defining_identifier as the subunit.

10/3
A package_body_stub shall be the completion of a package_declaration
(*note 7.1: S0190.) or generic_package_declaration (*note 12.1: S0273.);
a task_body_stub (*note 10.1.3: S0261.) shall be the completion of a
task declaration; a protected_body_stub (*note 10.1.3: S0262.) shall be
the completion of a protected declaration.

11
In contrast, a subprogram_body_stub need not be the completion of a
previous declaration, in which case the _stub declares the subprogram.
If the _stub is a completion, it shall be the completion of a
subprogram_declaration or generic_subprogram_declaration.  The profile
of a subprogram_body_stub that completes a declaration shall conform
fully to that of the declaration. 

12
A subunit that corresponds to a body_stub shall be of the same kind
(package_, subprogram_, task_, or protected_) as the body_stub.  The
profile of a subprogram_body subunit shall be fully conformant to that
of the corresponding body_stub. 

13
A body_stub shall appear immediately within the declarative_part of a
compilation unit body.  This rule does not apply within an instance of a
generic unit.

14
The defining_identifiers of all body_stubs that appear immediately
within a particular declarative_part shall be distinct.

                       _Post-Compilation Rules_

15
For each body_stub, there shall be a subunit containing the
corresponding proper_body.

     NOTES

16
     4  The rules in *note 10.1.4::, "*note 10.1.4:: The Compilation
     Process" say that a body_stub is equivalent to the corresponding
     proper_body.  This implies:

17
        * Visibility within a subunit is the visibility that would be
          obtained at the place of the corresponding body_stub (within
          the parent body) if the context_clause of the subunit were
          appended to that of the parent body.

18
        * The effect of the elaboration of a body_stub is to elaborate
          the subunit.

                              _Examples_

19
The package Parent is first written without subunits:

20
     package Parent is
         procedure Inner;
     end Parent;

21
     with Ada.Text_IO;
     package body Parent is
         Variable : String := "Hello, there.";
         procedure Inner is
         begin
             Ada.Text_IO.Put_Line(Variable);
         end Inner;
     end Parent;

22
The body of procedure Inner may be turned into a subunit by rewriting
the package body as follows (with the declaration of Parent remaining
the same):

23
     package body Parent is
         Variable : String := "Hello, there.";
         procedure Inner is separate;
     end Parent;

24
     with Ada.Text_IO;
     separate(Parent)
     procedure Inner is
     begin
         Ada.Text_IO.Put_Line(Variable);
     end Inner;


File: arm2012.info,  Node: 10.1.4,  Next: 10.1.5,  Prev: 10.1.3,  Up: 10.1

10.1.4 The Compilation Process
------------------------------

1
Each compilation unit submitted to the compiler is compiled in the
context of an environment declarative_part (or simply, an environment),
which is a conceptual declarative_part that forms the outermost
declarative region of the context of any compilation.  At run time, an
environment forms the declarative_part of the body of the environment
task of a partition (see *note 10.2::, "*note 10.2:: Program
Execution").

2
The declarative_items of the environment are library_items appearing in
an order such that there are no forward semantic dependences.  Each
included subunit occurs in place of the corresponding stub.  The
visibility rules apply as if the environment were the outermost
declarative region, except that with_clause (*note 10.1.2: S0255.)s are
needed to make declarations of library units visible (see *note
10.1.2::).

3/2
The mechanisms for creating an environment and for adding and replacing
compilation units within an environment are implementation defined.  The
mechanisms for adding a compilation unit mentioned in a
limited_with_clause to an environment are implementation defined.

                        _Name Resolution Rules_

4/3
If a library_unit_body that is a subprogram_body is submitted to the
compiler, it is interpreted only as a completion if a
library_unit_declaration with the same defining_program_unit_name
already exists in the environment for a subprogram other than an
instance of a generic subprogram or for a generic subprogram (even if
the profile of the body is not type conformant with that of the
declaration); otherwise, the subprogram_body is interpreted as both the
declaration and body of a library subprogram. 

                           _Legality Rules_

5
When a compilation unit is compiled, all compilation units upon which it
depends semantically shall already exist in the environment; the set of
these compilation units shall be consistent in the sense that the new
compilation unit shall not semantically depend (directly or indirectly)
on two different versions of the same compilation unit, nor on an
earlier version of itself.

                     _Implementation Permissions_

6/2
The implementation may require that a compilation unit be legal before
it can be mentioned in a limited_with_clause or it can be inserted into
the environment.

7/3
When a compilation unit that declares or renames a library unit is added
to the environment, the implementation may remove from the environment
any preexisting library_item or subunit with the same full expanded
name.  When a compilation unit that is a subunit or the body of a
library unit is added to the environment, the implementation may remove
from the environment any preexisting version of the same compilation
unit.  When a compilation unit that contains a body_stub is added to the
environment, the implementation may remove any preexisting library_item
or subunit with the same full expanded name as the body_stub.  When a
given compilation unit is removed from the environment, the
implementation may also remove any compilation unit that depends
semantically upon the given one.  If the given compilation unit contains
the body of a subprogram for which aspect Inline is True, the
implementation may also remove any compilation unit containing a call to
that subprogram.

     NOTES

8
     5  The rules of the language are enforced across compilation and
     compilation unit boundaries, just as they are enforced within a
     single compilation unit.

9
     6  An implementation may support a concept of a library, which
     contains library_items.  If multiple libraries are supported, the
     implementation has to define how a single environment is
     constructed when a compilation unit is submitted to the compiler.
     Naming conflicts between different libraries might be resolved by
     treating each library as the root of a hierarchy of child library
     units. 

10
     7  A compilation unit containing an instantiation of a separately
     compiled generic unit does not semantically depend on the body of
     the generic unit.  Therefore, replacing the generic body in the
     environment does not result in the removal of the compilation unit
     containing the instantiation.


File: arm2012.info,  Node: 10.1.5,  Next: 10.1.6,  Prev: 10.1.4,  Up: 10.1

10.1.5 Pragmas and Program Units
--------------------------------

1
This subclause discusses pragmas related to program units, library
units, and compilations.

                        _Name Resolution Rules_

2
Certain pragmas are defined to be program unit pragmas. A name given as
the argument of a program unit pragma shall resolve to denote the
declarations or renamings of one or more program units that occur
immediately within the declarative region or compilation in which the
pragma immediately occurs, or it shall resolve to denote the declaration
of the immediately enclosing program unit (if any); the pragma applies
to the denoted program unit(s).  If there are no names given as
arguments, the pragma applies to the immediately enclosing program unit.

                           _Legality Rules_

3
A program unit pragma shall appear in one of these places:

4
   * At the place of a compilation_unit, in which case the pragma shall
     immediately follow in the same compilation (except for other
     pragmas) a library_unit_declaration (*note 10.1.1: S0249.) that is
     a subprogram_declaration (*note 6.1: S0163.),
     generic_subprogram_declaration (*note 12.1: S0272.), or
     generic_instantiation (*note 12.3: S0276.), and the pragma shall
     have an argument that is a name denoting that declaration.

5/1
   * Immediately within the visible part of a program unit and before
     any nested declaration (but not within a generic formal part), in
     which case the argument, if any, shall be a direct_name that
     denotes the immediately enclosing program unit declaration.

6
   * At the place of a declaration other than the first, of a
     declarative_part or program unit declaration, in which case the
     pragma shall have an argument, which shall be a direct_name that
     denotes one or more of the following (and nothing else): a
     subprogram_declaration (*note 6.1: S0163.), a
     generic_subprogram_declaration (*note 12.1: S0272.), or a
     generic_instantiation (*note 12.3: S0276.), of the same
     declarative_part (*note 3.11: S0086.) or program unit declaration.

7/3
Certain program unit pragmas are defined to be library unit pragmas.  If
a library unit pragma applies to a program unit, the program unit shall
be a library unit.

                          _Static Semantics_

7.1/1
A library unit pragma that applies to a generic unit does not apply to
its instances, unless a specific rule for the pragma specifies the
contrary.

                       _Post-Compilation Rules_

8
Certain pragmas are defined to be configuration pragmas; they shall
appear before the first compilation_unit of a compilation.  They are
generally used to select a partition-wide or system-wide option.  The
pragma applies to all compilation_units appearing in the compilation,
unless there are none, in which case it applies to all future
compilation_units compiled into the same environment.

                     _Implementation Permissions_

9/2
An implementation may require that configuration pragmas that select
partition-wide or system-wide options be compiled when the environment
contains no library_items other than those of the predefined
environment.  In this case, the implementation shall still accept
configuration pragmas in individual compilations that confirm the
initially selected partition-wide or system-wide options.

                        _Implementation Advice_

10/1
When applied to a generic unit, a program unit pragma that is not a
library unit pragma should apply to each instance of the generic unit
for which there is not an overriding pragma applied directly to the
instance.


File: arm2012.info,  Node: 10.1.6,  Prev: 10.1.5,  Up: 10.1

10.1.6 Environment-Level Visibility Rules
-----------------------------------------

1
The normal visibility rules do not apply within a parent_unit_name or a
context_clause, nor within a pragma that appears at the place of a
compilation unit.  The special visibility rules for those contexts are
given here.

                          _Static Semantics_

2/2
Within the parent_unit_name at the beginning of an explicit
library_item, and within a nonlimited_with_clause, the only declarations
that are visible are those that are explicit library_items of the
environment, and the only declarations that are directly visible are
those that are explicit root library_items of the environment.  Within a
limited_with_clause, the only declarations that are visible are those
that are the implicit declaration of the limited view of a library
package of the environment, and the only declarations that are directly
visible are those that are the implicit declaration of the limited view
of a root library package.

3
Within a use_clause or pragma that is within a context_clause, each
library_item mentioned in a previous with_clause of the same
context_clause is visible, and each root library_item so mentioned is
directly visible.  In addition, within such a use_clause, if a given
declaration is visible or directly visible, each declaration that occurs
immediately within the given declaration's visible part is also visible.
No other declarations are visible or directly visible.

4
Within the parent_unit_name of a subunit, library_items are visible as
they are in the parent_unit_name of a library_item; in addition, the
declaration corresponding to each body_stub in the environment is also
visible.

5
Within a pragma that appears at the place of a compilation unit, the
immediately preceding library_item and each of its ancestors is visible.
The ancestor root library_item is directly visible.

6/2
Notwithstanding the rules of *note 4.1.3::, an expanded name in a
with_clause, a pragma in a context_clause, or a pragma that appears at
the place of a compilation unit may consist of a prefix that denotes a
generic package and a selector_name that denotes a child of that generic
package.  (The child is necessarily a generic unit; see *note 10.1.1::.)


File: arm2012.info,  Node: 10.2,  Prev: 10.1,  Up: 10

10.2 Program Execution
======================

1
An Ada program consists of a set of partitions, which can execute in
parallel with one another, possibly in a separate address space, and
possibly on a separate computer.

                       _Post-Compilation Rules_

2
A partition is a program or part of a program that can be invoked from
outside the Ada implementation.  For example, on many systems, a
partition might be an executable file generated by the system linker.
The user can explicitly assign library units to a partition.  The
assignment is done in an implementation-defined manner.  The compilation
units included in a partition are those of the explicitly assigned
library units, as well as other compilation units needed by those
library units.  The compilation units needed by a given compilation unit
are determined as follows (unless specified otherwise via an
implementation-defined pragma, or by some other implementation-defined
means): 

3
   * A compilation unit needs itself;

4
   * If a compilation unit is needed, then so are any compilation units
     upon which it depends semantically;

5
   * If a library_unit_declaration is needed, then so is any
     corresponding library_unit_body;

6/2
   * If a compilation unit with stubs is needed, then so are any
     corresponding subunits;

6.1/2
   * If the (implicit) declaration of the limited view of a library
     package is needed, then so is the explicit declaration of the
     library package.

7
The user can optionally designate (in an implementation-defined manner)
one subprogram as the main subprogram for the partition.  A main
subprogram, if specified, shall be a subprogram.

8
Each partition has an anonymous environment task, which is an implicit
outermost task whose execution elaborates the library_items of the
environment declarative_part, and then calls the main subprogram, if
there is one.  A partition's execution is that of its tasks.

9
The order of elaboration of library units is determined primarily by the
elaboration dependences. There is an elaboration dependence of a given
library_item upon another if the given library_item or any of its
subunits depends semantically on the other library_item.  In addition,
if a given library_item or any of its subunits has a pragma Elaborate or
Elaborate_All that names another library unit, then there is an
elaboration dependence of the given library_item upon the body of the
other library unit, and, for Elaborate_All only, upon each library_item
needed by the declaration of the other library unit.

10
The environment task for a partition has the following structure:

11
     task Environment_Task;

12
     task body Environment_Task is
         ... (1) -- The environment declarative_part
                 -- (that is, the sequence of library_items) goes here.
     begin
         ... (2) -- Call the main subprogram, if there is one.
     end Environment_Task;

13
The environment declarative_part at (1) is a sequence of
declarative_items consisting of copies of the library_items included in
the partition.  The order of elaboration of library_items is the order
in which they appear in the environment declarative_part:

14
   * The order of all included library_items is such that there are no
     forward elaboration dependences.

15/3
   * Any included library_unit_declaration for which aspect
     Elaborate_Body is True (including when a pragma Elaborate_Body
     applies) is immediately followed by its library_unit_body, if
     included.

16
   * All library_items declared pure occur before any that are not
     declared pure.

17
   * All preelaborated library_items occur before any that are not
     preelaborated.

18
There shall be a total order of the library_items that obeys the above
rules.  The order is otherwise implementation defined.

19
The full expanded names of the library units and subunits included in a
given partition shall be distinct.

20
The sequence_of_statements of the environment task (see (2) above)
consists of either:

21
   * A call to the main subprogram, if the partition has one.  If the
     main subprogram has parameters, they are passed; where the actuals
     come from is implementation defined.  What happens to the result of
     a main function is also implementation defined.

22
or:

23
   * A null_statement, if there is no main subprogram.

24
The mechanisms for building and running partitions are implementation
defined.  These might be combined into one operation, as, for example,
in dynamic linking, or "load-and-go" systems.

                          _Dynamic Semantics_

25
The execution of a program consists of the execution of a set of
partitions.  Further details are implementation defined. The execution
of a partition starts with the execution of its environment task, ends
when the environment task terminates, and includes the executions of all
tasks of the partition.  The execution of the (implicit) task_body of
the environment task acts as a master for all other tasks created as
part of the execution of the partition.  When the environment task
completes (normally or abnormally), it waits for the termination of all
such tasks, and then finalizes any remaining objects of the partition.

                      _Bounded (Run-Time) Errors_

26
Once the environment task has awaited the termination of all other tasks
of the partition, any further attempt to create a task (during
finalization) is a bounded error, and may result in the raising of
Program_Error either upon creation or activation of the task. If such a
task is activated, it is not specified whether the task is awaited prior
to termination of the environment task.

                     _Implementation Requirements_

27
The implementation shall ensure that all compilation units included in a
partition are consistent with one another, and are legal according to
the rules of the language.

                     _Implementation Permissions_

28/3
The kind of partition described in this subclause is known as an active
partition.  An implementation is allowed to support other kinds of
partitions, with implementation-defined semantics.

29
An implementation may restrict the kinds of subprograms it supports as
main subprograms.  However, an implementation is required to support all
main subprograms that are public parameterless library procedures.

30
If the environment task completes abnormally, the implementation may
abort any dependent tasks.

     NOTES

31
     8  An implementation may provide inter-partition communication
     mechanism(s) via special packages and pragmas.  Standard pragmas
     for distribution and methods for specifying inter-partition
     communication are defined in *note Annex E::, "*note Annex E::
     Distributed Systems".  If no such mechanisms are provided, then
     each partition is isolated from all others, and behaves as a
     program in and of itself.

32
     9  Partitions are not required to run in separate address spaces.
     For example, an implementation might support dynamic linking via
     the partition concept.

33
     10  An order of elaboration of library_items that is consistent
     with the partial ordering defined above does not always ensure that
     each library_unit_body is elaborated before any other compilation
     unit whose elaboration necessitates that the library_unit_body be
     already elaborated.  (In particular, there is no requirement that
     the body of a library unit be elaborated as soon as possible after
     the library_unit_declaration is elaborated, unless the pragmas in
     subclause *note 10.2.1:: are used.)

34
     11  A partition (active or otherwise) need not have a main
     subprogram.  In such a case, all the work done by the partition
     would be done by elaboration of various library_items, and by tasks
     created by that elaboration.  Passive partitions, which cannot have
     main subprograms, are defined in *note Annex E::, "*note Annex E::
     Distributed Systems".

* Menu:

* 10.2.1 ::   Elaboration Control


File: arm2012.info,  Node: 10.2.1,  Up: 10.2

10.2.1 Elaboration Control
--------------------------

1
This subclause defines pragmas that help control the elaboration order
of library_items.

                               _Syntax_

2
     The form of a pragma Preelaborate is as follows:

3
       pragma Preelaborate[(library_unit_name)];

4
     A pragma Preelaborate is a library unit pragma.

4.1/2
     The form of a pragma Preelaborable_Initialization is as follows:

4.2/2
       pragma Preelaborable_Initialization(direct_name);

                           _Legality Rules_

5
An elaborable construct is preelaborable unless its elaboration performs
any of the following actions:

6
   * The execution of a statement other than a null_statement.

7
   * A call to a subprogram other than a static function.

8
   * The evaluation of a primary that is a name of an object, unless the
     name is a static expression, or statically denotes a discriminant
     of an enclosing type.

9/3
   * The creation of an object (including a component) that is
     initialized by default, if its type does not have preelaborable
     initialization.  Similarly, the evaluation of an
     extension_aggregate (*note 4.3.2: S0111.) with an ancestor
     subtype_mark (*note 3.2.2: S0028.) denoting a subtype of such a
     type.

10/2
A generic body is preelaborable only if elaboration of a corresponding
instance body would not perform any such actions, presuming that: 

10.1/3
   * the actual for each discriminated formal derived type, formal
     private type, or formal private extension declared within the
     formal part of the generic unit is a type that does not have
     preelaborable initialization, unless pragma
     Preelaborable_Initialization has been applied to the formal type;

10.2/2
   * the actual for each formal type is nonstatic;

10.3/2
   * the actual for each formal object is nonstatic; and

10.4/2
   * the actual for each formal subprogram is a user-defined subprogram.

11/3
A pragma Preelaborate (or pragma Pure -- see below) is used to specify
that a library unit is preelaborated, namely that the Preelaborate
aspect of the library unit is True; all compilation units of the library
unit are preelaborated.  The declaration and body of a preelaborated
library unit, and all subunits that are elaborated as part of
elaborating the library unit, shall be preelaborable.  All compilation
units of a preelaborated library unit shall depend semantically only on
declared pure or preelaborated library_items. In addition to the places
where Legality Rules normally apply (see *note 12.3::), these rules also
apply in the private part of an instance of a generic unit. If a library
unit is preelaborated, then its declaration, if any, and body, if any,
are elaborated prior to all nonpreelaborated library_items of the
partition.

11.1/2
The following rules specify which entities have preelaborable
initialization:

11.2/3
   * The partial view of a private type or private extension, a
     protected type without entry_declarations, a generic formal private
     type, or a generic formal derived type, has preelaborable
     initialization if and only if the pragma
     Preelaborable_Initialization has been applied to them.  A protected
     type with entry_declarations or a task type never has preelaborable
     initialization.

11.3/2
   * A component (including a discriminant) of a record or protected
     type has preelaborable initialization if its declaration includes a
     default_expression whose execution does not perform any actions
     prohibited in preelaborable constructs as described above, or if
     its declaration does not include a default expression and its type
     has preelaborable initialization.

11.4/3
   * A derived type has preelaborable initialization if its parent type
     has preelaborable initialization and if the noninherited components
     all have preelaborable initialization.  However, a controlled type
     with an Initialize procedure that is not a null procedure does not
     have preelaborable initialization.

11.5/2
   * A view of a type has preelaborable initialization if it is an
     elementary type, an array type whose component type has
     preelaborable initialization, a record type whose components all
     have preelaborable initialization, or an interface type.

11.6/2
A pragma Preelaborable_Initialization specifies that a type has
preelaborable initialization.  This pragma shall appear in the visible
part of a package or generic package.

11.7/3
If the pragma appears in the first list of basic_declarative_items of a
package_specification, then the direct_name shall denote the first
subtype of a composite type, and the type shall be declared immediately
within the same package as the pragma.  If the pragma is applied to a
private type or a private extension, the full view of the type shall
have preelaborable initialization.  If the pragma is applied to a
protected type, the protected type shall not have entries, and each
component of the protected type shall have preelaborable initialization.
For any other composite type, the type shall have preelaborable
initialization. In addition to the places where Legality Rules normally
apply (see *note 12.3::), these rules apply also in the private part of
an instance of a generic unit.

11.8/2
If the pragma appears in a generic_formal_part, then the direct_name
shall denote a generic formal private type or a generic formal derived
type declared in the same generic_formal_part as the pragma.  In a
generic_instantiation the corresponding actual type shall have
preelaborable initialization.

                        _Implementation Advice_

12
In an implementation, a type declared in a preelaborated package should
have the same representation in every elaboration of a given version of
the package, whether the elaborations occur in distinct executions of
the same program, or in executions of distinct programs or partitions
that include the given version.

                               _Syntax_

13
     The form of a pragma Pure is as follows:

14
       pragma Pure[(library_unit_name)];

15
     A pragma Pure is a library unit pragma.

                          _Static Semantics_

15.1/3
A pure compilation unit is a preelaborable compilation unit whose
elaboration does not perform any of the following actions:

15.2/2
   * the elaboration of a variable declaration;

15.3/2
   * the evaluation of an allocator of an access-to-variable type; for
     the purposes of this rule, the partial view of a type is presumed
     to have nonvisible components whose default initialization
     evaluates such an allocator;

15.4/3
   * the elaboration of the declaration of a nonderived named
     access-to-variable type unless the Storage_Size of the type has
     been specified by a static expression with value zero or is defined
     by the language to be zero;

15.5/3
   * the elaboration of the declaration of a nonderived named
     access-to-constant type for which the Storage_Size has been
     specified by an expression other than a static expression with
     value zero.

15.6/3
A generic body is pure only if elaboration of a corresponding instance
body would not perform any such actions presuming any composite formal
types have nonvisible components whose default initialization evaluates
an allocator of an access-to-variable type.

15.7/2
The Storage_Size for an anonymous access-to-variable type declared at
library level in a library unit that is declared pure is defined to be
zero.

                           _Legality Rules_

16/2
This paragraph was deleted.

17/3
A pragma Pure is used to specify that a library unit is declared pure,
namely that the Pure aspect of the library unit is True; all compilation
units of the library unit are declared pure.  In addition, the limited
view of any library package is declared pure.  The declaration and body
of a declared pure library unit, and all subunits that are elaborated as
part of elaborating the library unit, shall be pure.  All compilation
units of a declared pure library unit shall depend semantically only on
declared pure library_items. In addition to the places where Legality
Rules normally apply (see *note 12.3::), these rules also apply in the
private part of an instance of a generic unit.  Furthermore, the full
view of any partial view declared in the visible part of a declared pure
library unit that has any available stream attributes shall support
external streaming (see *note 13.13.2::).

                         _Erroneous Execution_

17.1/4
Execution is erroneous if some operation (other than the initialization
or finalization of the object) modifies the value of a constant object
declared at library-level in a pure package.

                     _Implementation Permissions_

18/3
If a library unit is declared pure, then the implementation is permitted
to omit a call on a library-level subprogram of the library unit if the
results are not needed after the call.  In addition, the implementation
may omit a call on such a subprogram and simply reuse the results
produced by an earlier call on the same subprogram, provided that none
of the parameters nor any object accessible via access values from the
parameters have any part that is of a type whose full type is an
immutably limited type, and the addresses and values of all by-reference
actual parameters, the values of all by-copy-in actual parameters, and
the values of all objects accessible via access values from the
parameters, are the same as they were at the earlier call.  This
permission applies even if the subprogram produces other side effects
when called.

                               _Syntax_

19
     The form of a pragma Elaborate, Elaborate_All, or Elaborate_Body is
     as follows:

20
       pragma Elaborate(library_unit_name{, library_unit_name});

21
       pragma Elaborate_All(library_unit_name{, library_unit_name});

22
       pragma Elaborate_Body[(library_unit_name)];

23
     A pragma Elaborate or Elaborate_All is only allowed within a
     context_clause.

24
     A pragma Elaborate_Body is a library unit pragma.

                           _Legality Rules_

25/3
If the aspect Elaborate_Body is True for a declaration (including when
pragma Elaborate_Body applies), then the declaration requires a
completion (a body).

25.1/2
The library_unit_name of a pragma Elaborate or Elaborate_All shall
denote a nonlimited view of a library unit.

                          _Static Semantics_

26/3
A pragma Elaborate specifies that the body of the named library unit is
elaborated before the current library_item.  A pragma Elaborate_All
specifies that each library_item that is needed by the named library
unit declaration is elaborated before the current library_item.

26.1/3
A pragma Elaborate_Body sets the Elaborate_Body representation aspect of
the library unit to which it applies to the value True.  If the
Elaborate_Body aspect of a library unit is True, the body of the library
unit is elaborated immediately after its declaration.

     NOTES

27
     12  A preelaborated library unit is allowed to have
     nonpreelaborable children.

28
     13  A library unit that is declared pure is allowed to have impure
     children.


File: arm2012.info,  Node: 11,  Next: 12,  Prev: 10,  Up: Top

11 Exceptions
*************

1/3
This clause defines the facilities for dealing with errors or other
exceptional situations that arise during program execution. An exception
represents a kind of exceptional situation; an occurrence of such a
situation (at run time) is called an exception occurrence. To raise an
exception is to abandon normal program execution so as to draw attention
to the fact that the corresponding situation has arisen. Performing some
actions in response to the arising of an exception is called handling
the exception.

2/3
An exception_declaration declares a name for an exception.  An exception
can be raised explicitly (for example, by a raise_statement) or
implicitly (for example, by the failure of a language-defined check).
When an exception arises, control can be transferred to a user-provided
exception_handler at the end of a handled_sequence_of_statements (*note
11.2: S0265.), or it can be propagated to a dynamically enclosing
execution.

* Menu:

* 11.1 ::     Exception Declarations
* 11.2 ::     Exception Handlers
* 11.3 ::     Raise Statements and Raise Expressions
* 11.4 ::     Exception Handling
* 11.5 ::     Suppressing Checks
* 11.6 ::     Exceptions and Optimization


File: arm2012.info,  Node: 11.1,  Next: 11.2,  Up: 11

11.1 Exception Declarations
===========================

1
An exception_declaration declares a name for an exception.

                               _Syntax_

2/3
     exception_declaration ::= defining_identifier_list : exception
        [aspect_specification];

                          _Static Semantics_

3
Each single exception_declaration declares a name for a different
exception.  If a generic unit includes an exception_declaration, the
exception_declarations implicitly generated by different instantiations
of the generic unit refer to distinct exceptions (but all have the same
defining_identifier).  The particular exception denoted by an exception
name is determined at compilation time and is the same regardless of how
many times the exception_declaration is elaborated.

4
The predefined exceptions are the ones declared in the declaration of
package Standard: Constraint_Error, Program_Error, Storage_Error, and
Tasking_Error; one of them is raised when a language-defined check
fails.

                          _Dynamic Semantics_

5
The elaboration of an exception_declaration has no effect.

6
The execution of any construct raises Storage_Error if there is
insufficient storage for that execution. The amount of storage needed
for the execution of constructs is unspecified.

                              _Examples_

7
Examples of user-defined exception declarations:

8
     Singular : exception;
     Error    : exception;
     Overflow, Underflow : exception;


File: arm2012.info,  Node: 11.2,  Next: 11.3,  Prev: 11.1,  Up: 11

11.2 Exception Handlers
=======================

1
The response to one or more exceptions is specified by an
exception_handler.

                               _Syntax_

2
     handled_sequence_of_statements ::=
          sequence_of_statements
       [exception
          exception_handler
         {exception_handler}]

3
     exception_handler ::=
       when [choice_parameter_specification:] exception_choice {| 
     exception_choice} =>
          sequence_of_statements

4
     choice_parameter_specification ::= defining_identifier

5
     exception_choice ::= exception_name | others

                           _Legality Rules_

5.1/4
An exception_name of an exception_choice shall denote an exception.

6
A choice with an exception_name covers the named exception.  A choice
with others covers all exceptions not named by previous choices of the
same handled_sequence_of_statements (*note 11.2: S0265.).  Two choices
in different exception_handlers of the same
handled_sequence_of_statements (*note 11.2: S0265.) shall not cover the
same exception.

7
A choice with others is allowed only for the last handler of a
handled_sequence_of_statements and as the only choice of that handler.

8
An exception_name of a choice shall not denote an exception declared in
a generic formal package.

                          _Static Semantics_

9
A choice_parameter_specification declares a choice parameter, which is a
constant object of type Exception_Occurrence (see *note 11.4.1::).
During the handling of an exception occurrence, the choice parameter, if
any, of the handler represents the exception occurrence that is being
handled.

                          _Dynamic Semantics_

10
The execution of a handled_sequence_of_statements consists of the
execution of the sequence_of_statements (*note 5.1: S0145.).  The
optional handlers are used to handle any exceptions that are propagated
by the sequence_of_statements (*note 5.1: S0145.).

                              _Examples_

11
Example of an exception handler:

12
     begin
        Open(File, In_File, "input.txt");   -- see *note A.8.2::
     exception
        when E : Name_Error =>
           Put("Cannot open input file : ");
           Put_Line(Exception_Message(E));  -- see *note 11.4.1::
           raise;
     end;


File: arm2012.info,  Node: 11.3,  Next: 11.4,  Prev: 11.2,  Up: 11

11.3 Raise Statements and Raise Expressions
===========================================

1
A raise_statement raises an exception.

                               _Syntax_

2/2
     raise_statement ::= raise;
           | raise exception_name [with string_expression];

2.1/4
     raise_expression ::= raise exception_name [with string_
     simple_expression]

2.2/4
     If a raise_expression appears within the expression of one of the
     following contexts, the raise_expression shall appear within a pair
     of parentheses within the expression:

2.3/4
        * object_declaration;

2.4/4
        * modular_type_definition;

2.5/4
        * floating_point_definition;

2.6/4
        * ordinary_fixed_point_definition;

2.7/4
        * decimal_fixed_point_definition;

2.8/4
        * default_expression;

2.9/4
        * ancestor_part.

                           _Legality Rules_

3/4
The exception_name, if any, of a raise_statement or raise_expression
shall denote an exception. A raise_statement with no exception_name
(that is, a re-raise statement) shall be within a handler, but not
within a body enclosed by that handler.

                        _Name Resolution Rules_

3.1/4
The string_expression or string_simple_expression, if any, of a
raise_statement or raise_expression is expected to be of type String.

3.2/4
The expected type for a raise_expression shall be any single type.

                          _Dynamic Semantics_

4/4
To raise an exception is to raise a new occurrence of that exception, as
explained in *note 11.4::. For the execution of a raise_statement with
an exception_name, the named exception is raised.  Similarly, for the
evaluation of a raise_expression, the named exception is raised.  In
both of these cases, if a string_expression or string_simple_expression
is present, the expression is evaluated and its value is associated with
the exception occurrence. For the execution of a re-raise statement, the
exception occurrence that caused transfer of control to the innermost
enclosing handler is raised again.

     NOTES

4.1/4
     1  If the evaluation of a string_expression or
     string_simple_expression raises an exception, that exception is
     propagated instead of the one denoted by the exception_name of the
     raise_statement or raise_expression.

                              _Examples_

5
Examples of raise statements:

6/2
     raise Ada.IO_Exceptions.Name_Error;   -- see *note A.13::
     raise Queue_Error with "Buffer Full"; -- see *note 9.11::

7
     raise;                                -- re-raise the current exception


File: arm2012.info,  Node: 11.4,  Next: 11.5,  Prev: 11.3,  Up: 11

11.4 Exception Handling
=======================

1
When an exception occurrence is raised, normal program execution is
abandoned and control is transferred to an applicable exception_handler,
if any. To handle an exception occurrence is to respond to the
exceptional event. To propagate an exception occurrence is to raise it
again in another context; that is, to fail to respond to the exceptional
event in the present context.

                          _Dynamic Semantics_

2
Within a given task, if the execution of construct a is defined by this
International Standard to consist (in part) of the execution of
construct b, then while b is executing, the execution of a is said to
dynamically enclose the execution of b. The innermost dynamically
enclosing execution of a given execution is the dynamically enclosing
execution that started most recently.

3
When an exception occurrence is raised by the execution of a given
construct, the rest of the execution of that construct is abandoned;
that is, any portions of the execution that have not yet taken place are
not performed.  The construct is first completed, and then left, as
explained in *note 7.6.1::.  Then:

4
   * If the construct is a task_body, the exception does not propagate
     further;

5
   * If the construct is the sequence_of_statements of a
     handled_sequence_of_statements that has a handler with a choice
     covering the exception, the occurrence is handled by that handler;

6
   * Otherwise, the occurrence is propagated to the innermost
     dynamically enclosing execution, which means that the occurrence is
     raised again in that context.

7
When an occurrence is handled by a given handler, the
choice_parameter_specification, if any, is first elaborated, which
creates the choice parameter and initializes it to the occurrence.
Then, the sequence_of_statements of the handler is executed; this
execution replaces the abandoned portion of the execution of the
sequence_of_statements.

     NOTES

8
     2  Note that exceptions raised in a declarative_part of a body are
     not handled by the handlers of the handled_sequence_of_statements
     (*note 11.2: S0265.) of that body.

* Menu:

* 11.4.1 ::   The Package Exceptions
* 11.4.2 ::   Pragmas Assert and Assertion_Policy
* 11.4.3 ::   Example of Exception Handling


File: arm2012.info,  Node: 11.4.1,  Next: 11.4.2,  Up: 11.4

11.4.1 The Package Exceptions
-----------------------------

                          _Static Semantics_

1
The following language-defined library package exists:

2/2
     with Ada.Streams;
     package Ada.Exceptions is
         pragma Preelaborate(Exceptions);
         type Exception_Id is private;
         pragma Preelaborable_Initialization(Exception_Id);
         Null_Id : constant Exception_Id;
         function Exception_Name(Id : Exception_Id) return String;
         function Wide_Exception_Name(Id : Exception_Id) return Wide_String;
         function Wide_Wide_Exception_Name(Id : Exception_Id)
             return Wide_Wide_String;

3/2
         type Exception_Occurrence is limited private;
         pragma Preelaborable_Initialization(Exception_Occurrence);
         type Exception_Occurrence_Access is access all Exception_Occurrence;
         Null_Occurrence : constant Exception_Occurrence;

4/3
         procedure Raise_Exception(E : in Exception_Id;
                                   Message : in String := "")
             with No_Return;
         function Exception_Message(X : Exception_Occurrence) return String;
         procedure Reraise_Occurrence(X : in Exception_Occurrence);

5/2
         function Exception_Identity(X : Exception_Occurrence)
                                     return Exception_Id;
         function Exception_Name(X : Exception_Occurrence) return String;
             -- Same as Exception_Name(Exception_Identity(X)).
         function Wide_Exception_Name(X : Exception_Occurrence)
             return Wide_String;
             -- Same as Wide_Exception_Name(Exception_Identity(X)).
         function Wide_Wide_Exception_Name(X : Exception_Occurrence)
             return Wide_Wide_String;
             -- Same as Wide_Wide_Exception_Name(Exception_Identity(X)).
         function Exception_Information(X : Exception_Occurrence) return String;

6/2
         procedure Save_Occurrence(Target : out Exception_Occurrence;
                                   Source : in Exception_Occurrence);
         function Save_Occurrence(Source : Exception_Occurrence)
                                  return Exception_Occurrence_Access;

6.1/2
         procedure Read_Exception_Occurrence
            (Stream : not null access Ada.Streams.Root_Stream_Type'Class;
             Item   : out Exception_Occurrence);
         procedure Write_Exception_Occurrence
            (Stream : not null access Ada.Streams.Root_Stream_Type'Class;
             Item   : in Exception_Occurrence);

6.2/2
         for Exception_Occurrence'Read use Read_Exception_Occurrence;
         for Exception_Occurrence'Write use Write_Exception_Occurrence;

6.3/2
     private
        ... -- not specified by the language
     end Ada.Exceptions;

7
Each distinct exception is represented by a distinct value of type
Exception_Id.  Null_Id does not represent any exception, and is the
default initial value of type Exception_Id.  Each occurrence of an
exception is represented by a value of type Exception_Occurrence.
Null_Occurrence does not represent any exception occurrence, and is the
default initial value of type Exception_Occurrence.

8/1
For a prefix E that denotes an exception, the following attribute is
defined:

9
E'Identity
               E'Identity returns the unique identity of the exception.
               The type of this attribute is Exception_Id.

10/2
Raise_Exception raises a new occurrence of the identified exception.

10.1/4
Exception_Message returns the message associated with the given
Exception_Occurrence.  For an occurrence raised by a call to
Raise_Exception, the message is the Message parameter passed to
Raise_Exception.  For the occurrence raised by a raise_statement or
raise_expression with an exception_name and a string_expression or
string_simple_expression, the message is the string_expression or
string_simple_expression.  For the occurrence raised by a
raise_statement or raise_expression with an exception_name but without a
string_expression or string_simple_expression, the message is a string
giving implementation-defined information about the exception
occurrence.  For an occurrence originally raised in some other manner
(including by the failure of a language-defined check), the message is
an unspecified string.  In all cases, Exception_Message returns a string
with lower bound 1.

10.2/2
Reraise_Occurrence reraises the specified exception occurrence.

11
Exception_Identity returns the identity of the exception of the
occurrence.

12/2
The Wide_Wide_Exception_Name functions return the full expanded name of
the exception, in upper case, starting with a root library unit.  For an
exception declared immediately within package Standard, the
defining_identifier (*note 3.1: S0022.) is returned.  The result is
implementation defined if the exception is declared within an unnamed
block_statement.

12.1/2
The Exception_Name functions (respectively, Wide_Exception_Name) return
the same sequence of graphic characters as that defined for
Wide_Wide_Exception_Name, if all the graphic characters are defined in
Character (respectively, Wide_Character); otherwise, the sequence of
characters is implementation defined, but no shorter than that returned
by Wide_Wide_Exception_Name for the same value of the argument.

12.2/2
The string returned by the Exception_Name, Wide_Exception_Name, and
Wide_Wide_Exception_Name functions has lower bound 1.

13/2
Exception_Information returns implementation-defined information about
the exception occurrence.  The returned string has lower bound 1.

14/2
Reraise_Occurrence has no effect in the case of Null_Occurrence.
Raise_Exception and Exception_Name raise Constraint_Error for a Null_Id.
Exception_Message, Exception_Name, and Exception_Information raise
Constraint_Error for a Null_Occurrence.  Exception_Identity applied to
Null_Occurrence returns Null_Id.

15
The Save_Occurrence procedure copies the Source to the Target.  The
Save_Occurrence function uses an allocator of type
Exception_Occurrence_Access to create a new object, copies the Source to
this new object, and returns an access value designating this new
object; the result may be deallocated using an instance of
Unchecked_Deallocation.

15.1/2
Write_Exception_Occurrence writes a representation of an exception
occurrence to a stream; Read_Exception_Occurrence reconstructs an
exception occurrence from a stream (including one written in a different
partition).

Paragraph 16 was deleted.

                     _Implementation Permissions_

17
An implementation of Exception_Name in a space-constrained environment
may return the defining_identifier (*note 3.1: S0022.) instead of the
full expanded name.

18
The string returned by Exception_Message may be truncated (to no less
than 200 characters) by the Save_Occurrence procedure (not the
function), the Reraise_Occurrence procedure, and the re-raise statement.

                        _Implementation Advice_

19
Exception_Message (by default) and Exception_Information should produce
information useful for debugging.  Exception_Message should be short
(about one line), whereas Exception_Information can be long.
Exception_Message should not include the Exception_Name.
Exception_Information should include both the Exception_Name and the
Exception_Message.


File: arm2012.info,  Node: 11.4.2,  Next: 11.4.3,  Prev: 11.4.1,  Up: 11.4

11.4.2 Pragmas Assert and Assertion_Policy
------------------------------------------

1/3
Pragma Assert is used to assert the truth of a boolean expression at a
point within a sequence of declarations or statements.

1.1/3
Assert pragmas, subtype predicates (see *note 3.2.4::), preconditions
and postconditions (see *note 6.1.1::), and type invariants (see *note
7.3.2::) are collectively referred to as assertions; their boolean
expressions are referred to as assertion expressions.

1.2/3
Pragma Assertion_Policy is used to control whether assertions are to be
ignored by the implementation, checked at run time, or handled in some
implementation-defined manner.

                               _Syntax_

2/2
     The form of a pragma Assert is as follows:

3/2
       pragma Assert([Check =>] boolean_expression[, [Message =>]
     string_expression]);

4/2
     A pragma Assert is allowed at the place where a declarative_item or
     a statement is allowed.

5/2
     The form of a pragma Assertion_Policy is as follows:

6/2
       pragma Assertion_Policy(policy_identifier);

6.1/3
       pragma Assertion_Policy(
              assertion_aspect_mark => policy_identifier
          {, assertion_aspect_mark => policy_identifier});

7/3
     A pragma Assertion_Policy is allowed only immediately within a
     declarative_part, immediately within a package_specification, or as
     a configuration pragma.

                        _Name Resolution Rules_

8/2
The expected type for the boolean_expression of a pragma Assert is any
boolean type.  The expected type for the string_expression of a pragma
Assert is type String.

                           _Legality Rules_

9/3
The assertion_aspect_mark of a pragma Assertion_Policy shall be one of
Assert, Static_Predicate, Dynamic_Predicate, Pre, Pre'Class, Post,
Post'Class, Type_Invariant, Type_Invariant'Class, or some implementation
defined aspect_mark.  The policy_identifier shall be either Check,
Ignore, or some implementation-defined identifier.

                          _Static Semantics_

10/3
A pragma Assertion_Policy determines for each assertion aspect named in
the pragma_argument_associations whether assertions of the given aspect
are to be enforced by a run-time check.  The policy_identifier Check
requires that assertion expressions of the given aspect be checked that
they evaluate to True at the points specified for the given aspect; the
policy_identifier Ignore requires that the assertion expression not be
evaluated at these points, and the run-time checks not be performed.
Note that for subtype predicate aspects (see *note 3.2.4::), even when
the applicable Assertion_Policy is Ignore, the predicate will still be
evaluated as part of membership tests and Valid attribute_references,
and if static, will still have an effect on loop iteration over the
subtype, and the selection of case_statement_alternatives and variants.

10.1/3
If no assertion_aspect_marks are specified in the pragma, the specified
policy applies to all assertion aspects.

10.2/3
A pragma Assertion_Policy applies to the named assertion aspects in a
specific region, and applies to all assertion expressions specified in
that region.  A pragma Assertion_Policy given in a declarative_part or
immediately within a package_specification applies from the place of the
pragma to the end of the innermost enclosing declarative region.  The
region for a pragma Assertion_Policy given as a configuration pragma is
the declarative region for the entire compilation unit (or units) to
which it applies.

10.3/3
If a pragma Assertion_Policy applies to a generic_instantiation, then
the pragma Assertion_Policy applies to the entire instance.

10.4/3
If multiple Assertion_Policy pragmas apply to a given construct for a
given assertion aspect, the assertion policy is determined by the one in
the innermost enclosing region of a pragma Assertion_Policy specifying a
policy for the assertion aspect.  If no such Assertion_Policy pragma
exists, the policy is implementation defined.

11/2
The following language-defined library package exists:

12/2
     package Ada.Assertions is
        pragma Pure(Assertions);

13/2
        Assertion_Error : exception;

14/2
        procedure Assert(Check : in Boolean);
        procedure Assert(Check : in Boolean; Message : in String);

15/2
     end Ada.Assertions;

16/3
A compilation unit containing a check for an assertion (including a
pragma Assert) has a semantic dependence on the Assertions library unit.

17/3
This paragraph was deleted.

                          _Dynamic Semantics_

18/3
If performing checks is required by the Assert assertion policy in
effect at the place of a pragma Assert, the elaboration of the pragma
consists of evaluating the boolean expression, and if the result is
False, evaluating the Message argument, if any, and raising the
exception Assertions.Assertion_Error, with a message if the Message
argument is provided.

19/2
Calling the procedure Assertions.Assert without a Message parameter is
equivalent to:

20/2
     if Check = False then
        raise Ada.Assertions.Assertion_Error;
     end if;

21/2
Calling the procedure Assertions.Assert with a Message parameter is
equivalent to:

22/2
     if Check = False then
        raise Ada.Assertions.Assertion_Error with Message;
     end if;

23/2
The procedures Assertions.Assert have these effects independently of the
assertion policy in effect.

                      _Bounded (Run-Time) Errors_

23.1/3
It is a bounded error to invoke a potentially blocking operation (see
*note 9.5.1::) during the evaluation of an assertion expression
associated with a call on, or return from, a protected operation.  If
the bounded error is detected, Program_Error is raised.  If not
detected, execution proceeds normally, but if it is invoked within a
protected action, it might result in deadlock or a (nested) protected
action.

                     _Implementation Permissions_

24/2
Assertion_Error may be declared by renaming an implementation-defined
exception from another package.

25/2
Implementations may define their own assertion policies.

26/3
If the result of a function call in an assertion is not needed to
determine the value of the assertion expression, an implementation is
permitted to omit the function call.  This permission applies even if
the function has side effects.

27/3
An implementation need not allow the specification of an assertion
expression if the evaluation of the expression has a side effect such
that an immediate reevaluation of the expression could produce a
different value.  Similarly, an implementation need not allow the
specification of an assertion expression that is checked as part of a
call on or return from a callable entity C, if the evaluation of the
expression has a side effect such that the evaluation of some other
assertion expression associated with the same call of (or return from) C
could produce a different value than it would if the first expression
had not been evaluated.

     NOTES

28/2
     3  Normally, the boolean expression in a pragma Assert should not
     call functions that have significant side effects when the result
     of the expression is True, so that the particular assertion policy
     in effect will not affect normal operation of the program.


File: arm2012.info,  Node: 11.4.3,  Prev: 11.4.2,  Up: 11.4

11.4.3 Example of Exception Handling
------------------------------------

                              _Examples_

1
Exception handling may be used to separate the detection of an error
from the response to that error:

2/2
     package File_System is
         type File_Handle is limited private;

3
         File_Not_Found : exception;
         procedure Open(F : in out File_Handle; Name : String);
             -- raises File_Not_Found if named file does not exist

4
         End_Of_File : exception;
         procedure Read(F : in out File_Handle; Data : out Data_Type);
             -- raises End_Of_File if the file is not open

5
         ...
     end File_System;

6/2
     package body File_System is
         procedure Open(F : in out File_Handle; Name : String) is
         begin
             if File_Exists(Name) then
                 ...
             else
                 raise File_Not_Found with "File not found: " & Name & ".";
             end if;
         end Open;

7
         procedure Read(F : in out File_Handle; Data : out Data_Type) is
         begin
             if F.Current_Position <= F.Last_Position then
                 ...
             else
                 raise End_Of_File;
             end if;
         end Read;

8
         ...

9
     end File_System;

10
     with Ada.Text_IO;
     with Ada.Exceptions;
     with File_System; use File_System;
     use Ada;
     procedure Main is
     begin
         ... -- call operations in File_System
     exception
         when End_Of_File =>
             Close(Some_File);
         when Not_Found_Error : File_Not_Found =>
             Text_IO.Put_Line(Exceptions.Exception_Message(Not_Found_Error));
         when The_Error : others =>
             Text_IO.Put_Line("Unknown error:");
             if Verbosity_Desired then
                 Text_IO.Put_Line(Exceptions.Exception_Information(The_Error));
             else
                 Text_IO.Put_Line(Exceptions.Exception_Name(The_Error));
                 Text_IO.Put_Line(Exceptions.Exception_Message(The_Error));
             end if;
             raise;
     end Main;

11
In the above example, the File_System package contains information about
detecting certain exceptional situations, but it does not specify how to
handle those situations.  Procedure Main specifies how to handle them;
other clients of File_System might have different handlers, even though
the exceptional situations arise from the same basic causes.


File: arm2012.info,  Node: 11.5,  Next: 11.6,  Prev: 11.4,  Up: 11

11.5 Suppressing Checks
=======================

1/2
Checking pragmas give instructions to an implementation on handling
language-defined checks.  A pragma Suppress gives permission to an
implementation to omit certain language-defined checks, while a pragma
Unsuppress revokes the permission to omit checks..

2/3
A language-defined check (or simply, a "check") is one of the situations
defined by this International Standard that requires a check to be made
at run time to determine whether some condition is true. A check fails
when the condition being checked is False, causing an exception to be
raised.

                               _Syntax_

3/2
     The forms of checking pragmas are as follows:

4/2
       pragma Suppress(identifier);

4.1/2
       pragma Unsuppress(identifier);

5/2
     A checking pragma is allowed only immediately within a
     declarative_part, immediately within a package_specification (*note
     7.1: S0191.), or as a configuration pragma.

                           _Legality Rules_

6/2
The identifier shall be the name of a check.

7/2
This paragraph was deleted.

                          _Static Semantics_

7.1/2
A checking pragma applies to the named check in a specific region, and
applies to all entities in that region.  A checking pragma given in a
declarative_part or immediately within a package_specification applies
from the place of the pragma to the end of the innermost enclosing
declarative region.  The region for a checking pragma given as a
configuration pragma is the declarative region for the entire
compilation unit (or units) to which it applies.

7.2/3
If a checking pragma applies to a generic_instantiation, then the
checking pragma also applies to the entire instance.

8/2
A pragma Suppress gives permission to an implementation to omit the
named check (or every check in the case of All_Checks) for any entities
to which it applies. If permission has been given to suppress a given
check, the check is said to be suppressed.

8.1/2
A pragma Unsuppress revokes the permission to omit the named check (or
every check in the case of All_Checks) given by any pragma Suppress that
applies at the point of the pragma Unsuppress.  The permission is
revoked for the region to which the pragma Unsuppress applies.  If there
is no such permission at the point of a pragma Unsuppress, then the
pragma has no effect.  A later pragma Suppress can renew the permission.

9
The following are the language-defined checks:

10
   * The following checks correspond to situations in which the
     exception Constraint_Error is raised upon failure.

11/2
Access_Check
               When evaluating a dereference (explicit or implicit),
               check that the value of the name is not null.  When
               converting to a subtype that excludes null, check that
               the converted value is not null.

12
Discriminant_Check
               Check that the discriminants of a composite value have
               the values imposed by a discriminant constraint.  Also,
               when accessing a record component, check that it exists
               for the current discriminant values.

13/2
Division_Check
               Check that the second operand is not zero for the
               operations /, rem and mod.

14
Index_Check
               Check that the bounds of an array value are equal to the
               corresponding bounds of an index constraint.  Also, when
               accessing a component of an array object, check for each
               dimension that the given index value belongs to the range
               defined by the bounds of the array object.  Also, when
               accessing a slice of an array object, check that the
               given discrete range is compatible with the range defined
               by the bounds of the array object.

15
Length_Check
               Check that two arrays have matching components, in the
               case of array subtype conversions, and logical operators
               for arrays of boolean components.

16
Overflow_Check
               Check that a scalar value is within the base range of its
               type, in cases where the implementation chooses to raise
               an exception instead of returning the correct
               mathematical result.

17
Range_Check
               Check that a scalar value satisfies a range constraint.
               Also, for the elaboration of a subtype_indication, check
               that the constraint (if present) is compatible with the
               subtype denoted by the subtype_mark.  Also, for an
               aggregate, check that an index or discriminant value
               belongs to the corresponding subtype.  Also, check that
               when the result of an operation yields an array, the
               value of each component belongs to the component subtype.

18
Tag_Check
               Check that operand tags in a dispatching call are all
               equal.  Check for the correct tag on tagged type
               conversions, for an assignment_statement, and when
               returning a tagged limited object from a function.

19
   * The following checks correspond to situations in which the
     exception Program_Error is raised upon failure.

19.1/2
Accessibility_Check
               Check the accessibility level of an entity or view.

19.2/2
Allocation_Check
               For an allocator, check that the master of any tasks to
               be created by the allocator is not yet completed or some
               dependents have not yet terminated, and that the
               finalization of the collection has not started.

20
Elaboration_Check
               When a subprogram or protected entry is called, a task
               activation is accomplished, or a generic instantiation is
               elaborated, check that the body of the corresponding unit
               has already been elaborated.

21/2

               This paragraph was deleted.

22
   * The following check corresponds to situations in which the
     exception Storage_Error is raised upon failure.

23
Storage_Check
               Check that evaluation of an allocator does not require
               more space than is available for a storage pool.  Check
               that the space available for a task or subprogram has not
               been exceeded.

24
   * The following check corresponds to all situations in which any
     predefined exception is raised.

25/3
All_Checks
               Represents the union of all checks; suppressing
               All_Checks suppresses all checks other than those
               associated with assertions.  In addition, an
               implementation is allowed (but not required) to behave as
               if a pragma Assertion_Policy(Ignore) applies to any
               region to which pragma Suppress(All_Checks) applies.

                         _Erroneous Execution_

26
If a given check has been suppressed, and the corresponding error
situation occurs, the execution of the program is erroneous.

                     _Implementation Permissions_

27/2
An implementation is allowed to place restrictions on checking pragmas,
subject only to the requirement that pragma Unsuppress shall allow any
check names supported by pragma Suppress.  An implementation is allowed
to add additional check names, with implementation-defined semantics.
When Overflow_Check has been suppressed, an implementation may also
suppress an unspecified subset of the Range_Checks.

27.1/2
An implementation may support an additional parameter on pragma
Unsuppress similar to the one allowed for pragma Suppress (see *note
J.10::).  The meaning of such a parameter is implementation-defined.

                        _Implementation Advice_

28
The implementation should minimize the code executed for checks that
have been suppressed.

     NOTES

29
     4  There is no guarantee that a suppressed check is actually
     removed; hence a pragma Suppress should be used only for efficiency
     reasons.

29.1/2
     5  It is possible to give both a pragma Suppress and Unsuppress for
     the same check immediately within the same declarative_part.  In
     that case, the last pragma given determines whether or not the
     check is suppressed.  Similarly, it is possible to resuppress a
     check which has been unsuppressed by giving a pragma Suppress in an
     inner declarative region.

                              _Examples_

30/2
Examples of suppressing and unsuppressing checks:

31/2
     pragma Suppress(Index_Check);
     pragma Unsuppress(Overflow_Check);


File: arm2012.info,  Node: 11.6,  Prev: 11.5,  Up: 11

11.6 Exceptions and Optimization
================================

1/3
This subclause gives permission to the implementation to perform certain
"optimizations" that do not necessarily preserve the canonical
semantics.

                          _Dynamic Semantics_

2/3
The rest of this International Standard (outside this subclause) defines
the canonical semantics of the language.  The canonical semantics of a
given (legal) program determines a set of possible external effects that
can result from the execution of the program with given inputs.

3/3
As explained in *note 1.1.3::, "*note 1.1.3:: Conformity of an
Implementation with the Standard", the external effect of a program is
defined in terms of its interactions with its external environment.
Hence, the implementation can perform any internal actions whatsoever,
in any order or in parallel, so long as the external effect of the
execution of the program is one that is allowed by the canonical
semantics, or by the rules of this subclause.

                     _Implementation Permissions_

4
The following additional permissions are granted to the implementation:

5
   * An implementation need not always raise an exception when a
     language-defined check fails.  Instead, the operation that failed
     the check can simply yield an undefined result.  The exception need
     be raised by the implementation only if, in the absence of raising
     it, the value of this undefined result would have some effect on
     the external interactions of the program.  In determining this, the
     implementation shall not presume that an undefined result has a
     value that belongs to its subtype, nor even to the base range of
     its type, if scalar.  Having removed the raise of the exception,
     the canonical semantics will in general allow the implementation to
     omit the code for the check, and some or all of the operation
     itself.

6/3
   * If an exception is raised due to the failure of a language-defined
     check, then upon reaching the corresponding exception_handler (or
     the termination of the task, if none), the external interactions
     that have occurred need reflect only that the exception was raised
     somewhere within the execution of the sequence_of_statements with
     the handler (or the task_body), possibly earlier (or later if the
     interactions are independent of the result of the checked
     operation) than that defined by the canonical semantics, but not
     within the execution of some abort-deferred operation or
     independent subprogram that does not dynamically enclose the
     execution of the construct whose check failed. An independent
     subprogram is one that is defined outside the library unit
     containing the construct whose check failed, and for which the
     Inline aspect is False. Any assignment that occurred outside of
     such abort-deferred operations or independent subprograms can be
     disrupted by the raising of the exception, causing the object or
     its parts to become abnormal, and certain subsequent uses of the
     object to be erroneous, as explained in *note 13.9.1::.

     NOTES

7/3
     6  The permissions granted by this subclause can have an effect on
     the semantics of a program only if the program fails a
     language-defined check.


File: arm2012.info,  Node: 12,  Next: 13,  Prev: 11,  Up: Top

12 Generic Units
****************

1
A generic unit is a program unit that is either a generic subprogram or
a generic package. A generic unit is a template, which can be
parameterized, and from which corresponding (nongeneric) subprograms or
packages can be obtained.  The resulting program units are said to be
instances of the original generic unit. 

2
A generic unit is declared by a generic_declaration.  This form of
declaration has a generic_formal_part (*note 12.1: S0274.) declaring any
generic formal parameters.  An instance of a generic unit is obtained as
the result of a generic_instantiation with appropriate generic actual
parameters for the generic formal parameters.  An instance of a generic
subprogram is a subprogram.  An instance of a generic package is a
package.

3
Generic units are templates.  As templates they do not have the
properties that are specific to their nongeneric counterparts.  For
example, a generic subprogram can be instantiated but it cannot be
called.  In contrast, an instance of a generic subprogram is a
(nongeneric) subprogram; hence, this instance can be called but it
cannot be used to produce further instances.

* Menu:

* 12.1 ::     Generic Declarations
* 12.2 ::     Generic Bodies
* 12.3 ::     Generic Instantiation
* 12.4 ::     Formal Objects
* 12.5 ::     Formal Types
* 12.6 ::     Formal Subprograms
* 12.7 ::     Formal Packages
* 12.8 ::     Example of a Generic Package


File: arm2012.info,  Node: 12.1,  Next: 12.2,  Up: 12

12.1 Generic Declarations
=========================

1
A generic_declaration declares a generic unit, which is either a generic
subprogram or a generic package.  A generic_declaration includes a
generic_formal_part declaring any generic formal parameters.  A generic
formal parameter can be an object; alternatively (unlike a parameter of
a subprogram), it can be a type, a subprogram, or a package.

                               _Syntax_

2
     generic_declaration ::= generic_subprogram_declaration | 
     generic_package_declaration

3/3
     generic_subprogram_declaration ::=
          generic_formal_part  subprogram_specification
             [aspect_specification];

4
     generic_package_declaration ::=
          generic_formal_part  package_specification;

5
     generic_formal_part ::= generic {
     generic_formal_parameter_declaration | use_clause}

6
     generic_formal_parameter_declaration ::=
           formal_object_declaration
         | formal_type_declaration
         | formal_subprogram_declaration
         | formal_package_declaration

7
     The only form of subtype_indication allowed within a
     generic_formal_part is a subtype_mark (that is, the
     subtype_indication shall not include an explicit constraint).  The
     defining name of a generic subprogram shall be an identifier (not
     an operator_symbol).

                          _Static Semantics_

8/2
A generic_declaration declares a generic unit -- a generic package,
generic procedure, or generic function, as appropriate.

9
An entity is a generic formal entity if it is declared by a
generic_formal_parameter_declaration.  "Generic formal," or simply
"formal," is used as a prefix in referring to objects, subtypes (and
types), functions, procedures and packages, that are generic formal
entities, as well as to their respective declarations.  Examples:
"generic formal procedure" or a "formal integer type declaration."

                          _Dynamic Semantics_

10
The elaboration of a generic_declaration has no effect.

     NOTES

11
     1  Outside a generic unit a name that denotes the
     generic_declaration denotes the generic unit.  In contrast, within
     the declarative region of the generic unit, a name that denotes the
     generic_declaration denotes the current instance.

12
     2  Within a generic subprogram_body, the name of this program unit
     acts as the name of a subprogram.  Hence this name can be
     overloaded, and it can appear in a recursive call of the current
     instance.  For the same reason, this name cannot appear after the
     reserved word new in a (recursive) generic_instantiation.

13
     3  A default_expression or default_name appearing in a
     generic_formal_part is not evaluated during elaboration of the
     generic_formal_part; instead, it is evaluated when used.  (The
     usual visibility rules apply to any name used in a default: the
     denoted declaration therefore has to be visible at the place of the
     expression.)

                              _Examples_

14
Examples of generic formal parts:

15
     generic     --  parameterless 

16
     generic
        Size : Natural;  --  formal object 

17
     generic
        Length : Integer := 200;          -- formal object with a default expression

18
        Area   : Integer := Length*Length; -- formal object with a default expression

19
     generic
        type Item  is private;                       -- formal type
        type Index is (<>);                          -- formal type
        type Row   is array(Index range <>) of Item; -- formal type
        with function "<"(X, Y : Item) return Boolean;    -- formal subprogram 

20
Examples of generic declarations declaring generic subprograms Exchange
and Squaring:

21
     generic
        type Elem is private;
     procedure Exchange(U, V : in out Elem);

22
     generic
        type Item is private;
        with function "*"(U, V : Item) return Item is <>;
     function Squaring(X : Item) return Item;

23
Example of a generic declaration declaring a generic package:

24
     generic
        type Item   is private;
        type Vector is array (Positive range <>) of Item;
        with function Sum(X, Y : Item) return Item;
     package On_Vectors is
        function Sum  (A, B : Vector) return Vector;
        function Sigma(A    : Vector) return Item;
        Length_Error : exception;
     end On_Vectors;


File: arm2012.info,  Node: 12.2,  Next: 12.3,  Prev: 12.1,  Up: 12

12.2 Generic Bodies
===================

1
The body of a generic unit (a generic body) is a template for the
instance bodies.  The syntax of a generic body is identical to that of a
nongeneric body.

                          _Dynamic Semantics_

2
The elaboration of a generic body has no other effect than to establish
that the generic unit can from then on be instantiated without failing
the Elaboration_Check.  If the generic body is a child of a generic
package, then its elaboration establishes that each corresponding
declaration nested in an instance of the parent (see *note 10.1.1::) can
from then on be instantiated without failing the Elaboration_Check.

     NOTES

3
     4  The syntax of generic subprograms implies that a generic
     subprogram body is always the completion of a declaration.

                              _Examples_

4
Example of a generic procedure body:

5
     procedure Exchange(U, V : in out Elem) is  -- see *note 12.1::
        T : Elem;  --  the generic formal type
     begin
        T := U;
        U := V;
        V := T;
     end Exchange;

6
Example of a generic function body:

7
     function Squaring(X : Item) return Item is  --  see *note 12.1::
     begin
        return X*X;  --  the formal operator "*"
     end Squaring;

8
Example of a generic package body:

9
     package body On_Vectors is  --  see *note 12.1::

10
        function Sum(A, B : Vector) return Vector is
           Result : Vector(A'Range); --  the formal type Vector
           Bias   : constant Integer := B'First - A'First;
        begin
           if A'Length /= B'Length then
              raise Length_Error;
           end if;

11
           for N in A'Range loop
              Result(N) := Sum(A(N), B(N + Bias)); -- the formal function Sum
           end loop;
           return Result;
        end Sum;

12
        function Sigma(A : Vector) return Item is
           Total : Item := A(A'First); --  the formal type Item
        begin
           for N in A'First + 1 .. A'Last loop
              Total := Sum(Total, A(N)); --  the formal function Sum
           end loop;
           return Total;
        end Sigma;
     end On_Vectors;


File: arm2012.info,  Node: 12.3,  Next: 12.4,  Prev: 12.2,  Up: 12

12.3 Generic Instantiation
==========================

1
An instance of a generic unit is declared by a generic_instantiation.

                               _Syntax_

2/3
     generic_instantiation ::=
          package defining_program_unit_name is
              new generic_package_name [generic_actual_part]
                 [aspect_specification];
        | [overriding_indicator]
          procedure defining_program_unit_name is
              new generic_procedure_name [generic_actual_part]
                 [aspect_specification];
        | [overriding_indicator]
          function defining_designator is
              new generic_function_name [generic_actual_part]
                 [aspect_specification];

3
     generic_actual_part ::=
        (generic_association {, generic_association})

4
     generic_association ::=
        [generic_formal_parameter_selector_name =>] 
     explicit_generic_actual_parameter

5
     explicit_generic_actual_parameter ::= expression | variable_name
        | subprogram_name | entry_name | subtype_mark
        | package_instance_name

6
     A generic_association is named or positional according to whether
     or not the generic_formal_parameter_selector_name (*note 4.1.3:
     S0099.) is specified.  Any positional associations shall precede
     any named associations.

7/3
The generic actual parameter is either the
explicit_generic_actual_parameter given in a generic_association (*note
12.3: S0278.) for each formal, or the corresponding default_expression
(*note 3.7: S0063.) or default_name (*note 12.6: S0300.) if no
generic_association (*note 12.3: S0278.) is given for the formal.  When
the meaning is clear from context, the term "generic actual," or simply
"actual," is used as a synonym for "generic actual parameter" and also
for the view denoted by one, or the value of one.

                           _Legality Rules_

8
In a generic_instantiation for a particular kind of program unit
(package, procedure, or function), the name shall denote a generic unit
of the corresponding kind (generic package, generic procedure, or
generic function, respectively).

9/3
The generic_formal_parameter_selector_name of a named
generic_association shall denote a generic_formal_parameter_declaration
of the generic unit being instantiated.  If two or more formal
subprograms have the same defining name, then named associations are not
allowed for the corresponding actuals.

9.1/3
The generic_formal_parameter_declaration for a positional
generic_association is the parameter with the corresponding position in
the generic_formal_part of the generic unit being instantiated.

10
A generic_instantiation shall contain at most one generic_association
for each formal.  Each formal without an association shall have a
default_expression or subprogram_default.

11
In a generic unit Legality Rules are enforced at compile time of the
generic_declaration and generic body, given the properties of the
formals.  In the visible part and formal part of an instance, Legality
Rules are enforced at compile time of the generic_instantiation, given
the properties of the actuals.  In other parts of an instance, Legality
Rules are not enforced; this rule does not apply when a given rule
explicitly specifies otherwise.

                          _Static Semantics_

12
A generic_instantiation declares an instance; it is equivalent to the
instance declaration (a package_declaration (*note 7.1: S0190.) or
subprogram_declaration (*note 6.1: S0163.)) immediately followed by the
instance body, both at the place of the instantiation.

13
The instance is a copy of the text of the template.  Each use of a
formal parameter becomes (in the copy) a use of the actual, as explained
below. An instance of a generic package is a package, that of a generic
procedure is a procedure, and that of a generic function is a function.

14
The interpretation of each construct within a generic declaration or
body is determined using the overloading rules when that generic
declaration or body is compiled.  In an instance, the interpretation of
each (copied) construct is the same, except in the case of a name that
denotes the generic_declaration or some declaration within the generic
unit; the corresponding name in the instance then denotes the
corresponding copy of the denoted declaration.  The overloading rules do
not apply in the instance.

15
In an instance, a generic_formal_parameter_declaration declares a view
whose properties are identical to those of the actual, except as
specified in *note 12.4::, "*note 12.4:: Formal Objects" and *note
12.6::, "*note 12.6:: Formal Subprograms".  Similarly, for a declaration
within a generic_formal_parameter_declaration, the corresponding
declaration in an instance declares a view whose properties are
identical to the corresponding declaration within the declaration of the
actual.

16
Implicit declarations are also copied, and a name that denotes an
implicit declaration in the generic denotes the corresponding copy in
the instance.  However, for a type declared within the visible part of
the generic, a whole new set of primitive subprograms is implicitly
declared for use outside the instance, and may differ from the copied
set if the properties of the type in some way depend on the properties
of some actual type specified in the instantiation.  For example, if the
type in the generic is derived from a formal private type, then in the
instance the type will inherit subprograms from the corresponding actual
type.

17
These new implicit declarations occur immediately after the type
declaration in the instance, and override the copied ones.  The copied
ones can be called only from within the instance; the new ones can be
called only from outside the instance, although for tagged types, the
body of a new one can be executed by a call to an old one.

18
In the visible part of an instance, an explicit declaration overrides an
implicit declaration if they are homographs, as described in *note
8.3::.  On the other hand, an explicit declaration in the private part
of an instance overrides an implicit declaration in the instance, only
if the corresponding explicit declaration in the generic overrides a
corresponding implicit declaration in the generic.  Corresponding rules
apply to the other kinds of overriding described in *note 8.3::.

                       _Post-Compilation Rules_

19
Recursive generic instantiation is not allowed in the following sense:
if a given generic unit includes an instantiation of a second generic
unit, then the instance generated by this instantiation shall not
include an instance of the first generic unit (whether this instance is
generated directly, or indirectly by intermediate instantiations).

                          _Dynamic Semantics_

20
For the elaboration of a generic_instantiation, each generic_association
is first evaluated.  If a default is used, an implicit
generic_association is assumed for this rule.  These evaluations are
done in an arbitrary order, except that the evaluation for a default
actual takes place after the evaluation for another actual if the
default includes a name that denotes the other one.  Finally, the
instance declaration and body are elaborated.

21
For the evaluation of a generic_association the generic actual parameter
is evaluated.  Additional actions are performed in the case of a formal
object of mode in (see *note 12.4::).

     NOTES

22
     5  If a formal type is not tagged, then the type is treated as an
     untagged type within the generic body.  Deriving from such a type
     in a generic body is permitted; the new type does not get a new tag
     value, even if the actual is tagged.  Overriding operations for
     such a derived type cannot be dispatched to from outside the
     instance.

                              _Examples_

23
Examples of generic instantiations (see *note 12.1::):

24
     procedure Swap is new Exchange(Elem => Integer);
     procedure Swap is new Exchange(Character);     --  Swap is overloaded 
     function Square is new Squaring(Integer);    --  "*" of Integer used by default
     function Square is new Squaring(Item => Matrix, "*" => Matrix_Product);
     function Square is new Squaring(Matrix, Matrix_Product); -- same as previous    

25
     package Int_Vectors is new On_Vectors(Integer, Table, "+");

26
Examples of uses of instantiated units:

27
     Swap(A, B);
     A := Square(A);

28
     T : Table(1 .. 5) := (10, 20, 30, 40, 50);
     N : Integer := Int_Vectors.Sigma(T);  --  150 (see *note 12.2::, "*note 12.2:: Generic Bodies" for the body of Sigma)

29
     use Int_Vectors;
     M : Integer := Sigma(T);  --  150


File: arm2012.info,  Node: 12.4,  Next: 12.5,  Prev: 12.3,  Up: 12

12.4 Formal Objects
===================

1
A generic formal object can be used to pass a value or variable to a
generic unit.

                               _Syntax_

2/3
     formal_object_declaration ::=
         defining_identifier_list : mode [null_exclusion] 
     subtype_mark [:= default_expression]
             [aspect_specification];
       |  defining_identifier_list : mode access_definition [:= 
     default_expression]
             [aspect_specification];

                        _Name Resolution Rules_

3
The expected type for the default_expression, if any, of a formal object
is the type of the formal object.

4
For a generic formal object of mode in, the expected type for the actual
is the type of the formal.

5/2
For a generic formal object of mode in out, the type of the actual shall
resolve to the type determined by the subtype_mark, or for a
formal_object_declaration with an access_definition, to a specific
anonymous access type.  If the anonymous access type is an
access-to-object type, the type of the actual shall have the same
designated type as that of the access_definition.  If the anonymous
access type is an access-to-subprogram type, the type of the actual
shall have a designated profile which is type conformant with that of
the access_definition. 

                           _Legality Rules_

6
If a generic formal object has a default_expression, then the mode shall
be in (either explicitly or by default); otherwise, its mode shall be
either in or in out.

7
For a generic formal object of mode in, the actual shall be an
expression.  For a generic formal object of mode in out, the actual
shall be a name that denotes a variable for which renaming is allowed
(see *note 8.5.1::).

8/2
In the case where the type of the formal is defined by an
access_definition, the type of the actual and the type of the formal:

8.1/2
   * shall both be access-to-object types with statically matching
     designated subtypes and with both or neither being
     access-to-constant types; or 

8.2/2
   * shall both be access-to-subprogram types with subtype conformant
     designated profiles. 

8.3/2
For a formal_object_declaration with a null_exclusion or an
access_definition that has a null_exclusion:

8.4/2
   * if the actual matching the formal_object_declaration denotes the
     generic formal object of another generic unit G, and the
     instantiation containing the actual occurs within the body of G or
     within the body of a generic unit declared within the declarative
     region of G, then the declaration of the formal object of G shall
     have a null_exclusion;

8.5/2
   * otherwise, the subtype of the actual matching the
     formal_object_declaration shall exclude null. In addition to the
     places where Legality Rules normally apply (see *note 12.3::), this
     rule applies also in the private part of an instance of a generic
     unit.

                          _Static Semantics_

9/2
A formal_object_declaration declares a generic formal object.  The
default mode is in. For a formal object of mode in, the nominal subtype
is the one denoted by the subtype_mark or access_definition in the
declaration of the formal. For a formal object of mode in out, its type
is determined by the subtype_mark or access_definition in the
declaration; its nominal subtype is nonstatic, even if the subtype_mark
denotes a static subtype; for a composite type, its nominal subtype is
unconstrained if the first subtype of the type is unconstrained, even if
the subtype_mark denotes a constrained subtype.

10/2
In an instance, a formal_object_declaration of mode in is a full
constant declaration and declares a new stand-alone constant object
whose initialization expression is the actual, whereas a
formal_object_declaration of mode in out declares a view whose
properties are identical to those of the actual.

                          _Dynamic Semantics_

11
For the evaluation of a generic_association for a formal object of mode
in, a constant object is created, the value of the actual parameter is
converted to the nominal subtype of the formal object, and assigned to
the object, including any value adjustment -- see *note 7.6::. 

     NOTES

12
     6  The constraints that apply to a generic formal object of mode in
     out are those of the corresponding generic actual parameter (not
     those implied by the subtype_mark that appears in the
     formal_object_declaration).  Therefore, to avoid confusion, it is
     recommended that the name of a first subtype be used for the
     declaration of such a formal object.


File: arm2012.info,  Node: 12.5,  Next: 12.6,  Prev: 12.4,  Up: 12

12.5 Formal Types
=================

1/2
A generic formal subtype can be used to pass to a generic unit a subtype
whose type is in a certain category of types.

                               _Syntax_

2/3
     formal_type_declaration ::=
           formal_complete_type_declaration
         | formal_incomplete_type_declaration

2.1/3
     formal_complete_type_declaration ::=
         type defining_identifier[discriminant_part] is 
     formal_type_definition
             [aspect_specification];

2.2/3
     formal_incomplete_type_declaration ::=
         type defining_identifier[discriminant_part] [is tagged];

3/2
     formal_type_definition ::=
           formal_private_type_definition
         | formal_derived_type_definition
         | formal_discrete_type_definition
         | formal_signed_integer_type_definition
         | formal_modular_type_definition
         | formal_floating_point_definition
         | formal_ordinary_fixed_point_definition
         | formal_decimal_fixed_point_definition
         | formal_array_type_definition
         | formal_access_type_definition
         | formal_interface_type_definition

                           _Legality Rules_

4
For a generic formal subtype, the actual shall be a subtype_mark; it
denotes the (generic) actual subtype.

                          _Static Semantics_

5
A formal_type_declaration declares a (generic) formal type, and its
first subtype, the (generic) formal subtype.

6/3
The form of a formal_type_definition determines a category (of types) to
which the formal type belongs.  For a formal_private_type_definition the
reserved words tagged and limited indicate the category of types (see
*note 12.5.1::).  The reserved word tagged also plays this role in the
case of a formal_incomplete_type_declaration.  For a
formal_derived_type_definition the category of types is the derivation
class rooted at the ancestor type.  For other formal types, the name of
the syntactic category indicates the category of types; a
formal_discrete_type_definition defines a discrete type, and so on.

                           _Legality Rules_

7/2
The actual type shall be in the category determined for the formal.

                          _Static Semantics_

8/3
The formal type also belongs to each category that contains the
determined category.  The primitive subprograms of the type are as for
any type in the determined category.  For a formal type other than a
formal derived type, these are the predefined operators of the type.
For an elementary formal type, the predefined operators are implicitly
declared immediately after the declaration of the formal type.  For a
composite formal type, the predefined operators are implicitly declared
either immediately after the declaration of the formal type, or later
immediately within the declarative region in which the type is declared
according to the rules of *note 7.3.1::.  In an instance, the copy of
such an implicit declaration declares a view of the predefined operator
of the actual type, even if this operator has been overridden for the
actual type and even if it is never declared for the actual type.  The
rules specific to formal derived types are given in *note 12.5.1::.

     NOTES

9
     7  Generic formal types, like all types, are not named.  Instead, a
     name can denote a generic formal subtype.  Within a generic unit, a
     generic formal type is considered as being distinct from all other
     (formal or nonformal) types.

10
     8  A discriminant_part is allowed only for certain kinds of types,
     and therefore only for certain kinds of generic formal types.  See
     *note 3.7::.

                              _Examples_

11
Examples of generic formal types:

12
     type Item is private;
     type Buffer(Length : Natural) is limited private;

13
     type Enum  is (<>);
     type Int   is range <>;
     type Angle is delta <>;
     type Mass  is digits <>;

14
     type Table is array (Enum) of Item;

15
Example of a generic formal part declaring a formal integer type:

16
     generic
        type Rank is range <>;
        First  : Rank := Rank'First;
        Second : Rank := First + 1;  --  the operator "+" of the type Rank  

* Menu:

* 12.5.1 ::   Formal Private and Derived Types
* 12.5.2 ::   Formal Scalar Types
* 12.5.3 ::   Formal Array Types
* 12.5.4 ::   Formal Access Types
* 12.5.5 ::   Formal Interface Types


File: arm2012.info,  Node: 12.5.1,  Next: 12.5.2,  Up: 12.5

12.5.1 Formal Private and Derived Types
---------------------------------------

1/3
In its most general form, the category determined for a formal private
type is all types, but the category can be restricted to only nonlimited
types or to only tagged types.  Similarly, the category for a formal
incomplete type is all types but the category can be restricted to only
tagged types; unlike other formal types, the actual type does not need
to be able to be frozen (see *note 13.14::).  The category determined
for a formal derived type is the derivation class rooted at the ancestor
type.

                               _Syntax_

2
     formal_private_type_definition ::=
     [[abstract] tagged] [limited] private

3/2
     formal_derived_type_definition ::=
          [abstract] [limited | synchronized] new subtype_mark [[and 
     interface_list]with private]

                           _Legality Rules_

4
If a generic formal type declaration has a known_discriminant_part, then
it shall not include a default_expression for a discriminant.

5/3
The ancestor subtype of a formal derived type is the subtype denoted by
the subtype_mark of the formal_derived_type_definition.  For a formal
derived type declaration, the reserved words with private shall appear
if and only if the ancestor type is a tagged type; in this case the
formal derived type is a private extension of the ancestor type and the
ancestor shall not be a class-wide type.  Similarly, an interface_list
or the optional reserved words abstract or synchronized shall appear
only if the ancestor type is a tagged type.  The reserved word limited
or synchronized shall appear only if the ancestor type and any
progenitor types are limited types.  The reserved word synchronized
shall appear (rather than limited) if the ancestor type or any of the
progenitor types are synchronized interfaces.  The ancestor type shall
be a limited interface if the reserved word synchronized appears.

5.1/4
The actual type for a formal derived type shall be a descendant of the
ancestor type and every progenitor of the formal type.  If the formal
type is nonlimited, the actual type shall be nonlimited.  The actual
type for a formal derived type shall be tagged if and only if the formal
derived type is a private extension.  If the reserved word synchronized
appears in the declaration of the formal derived type, the actual type
shall be a synchronized tagged type.

6/3
If a formal private or derived subtype is definite, then the actual
subtype shall also be definite.

6.1/3
A formal_incomplete_type_declaration declares a formal incomplete type.
The only view of a formal incomplete type is an incomplete view.  Thus,
a formal incomplete type is subject to the same usage restrictions as
any other incomplete type -- see *note 3.10.1::.

7
For a generic formal derived type with no discriminant_part:

8
   * If the ancestor subtype is constrained, the actual subtype shall be
     constrained, and shall be statically compatible with the ancestor;

9
   * If the ancestor subtype is an unconstrained access or composite
     subtype, the actual subtype shall be unconstrained.

10
   * If the ancestor subtype is an unconstrained discriminated subtype,
     then the actual shall have the same number of discriminants, and
     each discriminant of the actual shall correspond to a discriminant
     of the ancestor, in the sense of *note 3.7::.

10.1/2
   * If the ancestor subtype is an access subtype, the actual subtype
     shall exclude null if and only if the ancestor subtype excludes
     null.

11/3
The declaration of a formal derived type shall not have a
known_discriminant_part.  For a generic formal private or incomplete
type with a known_discriminant_part:

12
   * The actual type shall be a type with the same number of
     discriminants.

13
   * The actual subtype shall be unconstrained.

14
   * The subtype of each discriminant of the actual type shall
     statically match the subtype of the corresponding discriminant of
     the formal type. 

15
For a generic formal type with an unknown_discriminant_part, the actual
may, but need not, have discriminants, and may be definite or
indefinite.

15.1/4
When enforcing Legality Rules, for the purposes of determining within a
generic body whether a type is unconstrained in any partial view, a
discriminated subtype is considered to have a constrained partial view
if it is a descendant of an untagged generic formal private or derived
type.

                          _Static Semantics_

16/2
The category determined for a formal private type is as follows:

17/2
     Type Definition    Determined Category

     limited private    the category of all types
     private    the category of all nonlimited types
     tagged limited private    the category of all tagged types
     tagged private    the category of all nonlimited tagged types

18
The presence of the reserved word abstract determines whether the actual
type may be abstract.

18.1/3
The category determined for a formal incomplete type is the category of
all types, unless the formal_type_declaration includes the reserved word
tagged; in this case, it is the category of all tagged types.

19
A formal private or derived type is a private or derived type,
respectively.  A formal derived tagged type is a private extension.  A
formal private or derived type is abstract if the reserved word abstract
appears in its declaration.

20/3
For a formal derived type, the characteristics (including components,
but excluding discriminants if there is a new discriminant_part),
predefined operators, and inherited user-defined primitive subprograms
are determined by its ancestor type and its progenitor types (if any),
in the same way that those of a derived type are determined by those of
its parent type and its progenitor types (see *note 3.4:: and *note
7.3.1::).

21/3
In an instance, the copy of an implicit declaration of a primitive
subprogram of a formal derived type declares a view of the corresponding
primitive subprogram of the ancestor or progenitor of the formal derived
type, even if this primitive has been overridden for the actual type and
even if it is never declared for the actual type.  When the ancestor or
progenitor of the formal derived type is itself a formal type, the copy
of the implicit declaration declares a view of the corresponding copied
operation of the ancestor or progenitor.  In the case of a formal
private extension, however, the tag of the formal type is that of the
actual type, so if the tag in a call is statically determined to be that
of the formal type, the body executed will be that corresponding to the
actual type.

22/1
For a prefix S that denotes a formal indefinite subtype, the following
attribute is defined:

23/3
S'Definite
               S'Definite yields True if the actual subtype
               corresponding to S is definite; otherwise, it yields
               False.  The value of this attribute is of the predefined
               type Boolean.

                          _Dynamic Semantics_

23.1/3
In the case where a formal type has unknown discriminants, and the
actual type is a class-wide type T'Class:

23.2/2
   * For the purposes of defining the primitive operations of the formal
     type, each of the primitive operations of the actual type is
     considered to be a subprogram (with an intrinsic calling convention
     -- see *note 6.3.1::) whose body consists of a dispatching call
     upon the corresponding operation of T, with its formal parameters
     as the actual parameters.  If it is a function, the result of the
     dispatching call is returned.

23.3/2
   * If the corresponding operation of T has no controlling formal
     parameters, then the controlling tag value is determined by the
     context of the call, according to the rules for tag-indeterminate
     calls (see *note 3.9.2:: and *note 5.2::).  In the case where the
     tag would be statically determined to be that of the formal type,
     the call raises Program_Error.  If such a function is renamed, any
     call on the renaming raises Program_Error. 

     NOTES

24/2
     9  In accordance with the general rule that the actual type shall
     belong to the category determined for the formal (see *note 12.5::,
     "*note 12.5:: Formal Types"):

25
        * If the formal type is nonlimited, then so shall be the actual;

26
        * For a formal derived type, the actual shall be in the class
          rooted at the ancestor subtype.

27
     10  The actual type can be abstract only if the formal type is
     abstract (see *note 3.9.3::).

28
     11  If the formal has a discriminant_part, the actual can be either
     definite or indefinite.  Otherwise, the actual has to be definite.


File: arm2012.info,  Node: 12.5.2,  Next: 12.5.3,  Prev: 12.5.1,  Up: 12.5

12.5.2 Formal Scalar Types
--------------------------

1/2
A formal scalar type is one defined by any of the
formal_type_definitions in this subclause.  The category determined for
a formal scalar type is the category of all discrete, signed integer,
modular, floating point, ordinary fixed point, or decimal types.

                               _Syntax_

2
     formal_discrete_type_definition ::= (<>)

3
     formal_signed_integer_type_definition ::= range <>

4
     formal_modular_type_definition ::= mod <>

5
     formal_floating_point_definition ::= digits <>

6
     formal_ordinary_fixed_point_definition ::= delta <>

7
     formal_decimal_fixed_point_definition ::= delta <> digits <>

                           _Legality Rules_

8
The actual type for a formal scalar type shall not be a nonstandard
numeric type.

     NOTES

9
     12  The actual type shall be in the class of types implied by the
     syntactic category of the formal type definition (see *note 12.5::,
     "*note 12.5:: Formal Types").  For example, the actual for a
     formal_modular_type_definition shall be a modular type.


File: arm2012.info,  Node: 12.5.3,  Next: 12.5.4,  Prev: 12.5.2,  Up: 12.5

12.5.3 Formal Array Types
-------------------------

1/2
The category determined for a formal array type is the category of all
array types.

                               _Syntax_

2
     formal_array_type_definition ::= array_type_definition

                           _Legality Rules_

3
The only form of discrete_subtype_definition that is allowed within the
declaration of a generic formal (constrained) array subtype is a
subtype_mark.

4
For a formal array subtype, the actual subtype shall satisfy the
following conditions:

5
   * The formal array type and the actual array type shall have the same
     dimensionality; the formal subtype and the actual subtype shall be
     either both constrained or both unconstrained.

6
   * For each index position, the index types shall be the same, and the
     index subtypes (if unconstrained), or the index ranges (if
     constrained), shall statically match (see *note 4.9.1::). 

7
   * The component subtypes of the formal and actual array types shall
     statically match. 

8
   * If the formal type has aliased components, then so shall the
     actual.

                              _Examples_

9
Example of formal array types:

10
     --  given the generic package 

11
     generic
        type Item   is private;
        type Index  is (<>);
        type Vector is array (Index range <>) of Item;
        type Table  is array (Index) of Item;
     package P is
        ...
     end P;

12
     --  and the types 

13
     type Mix    is array (Color range <>) of Boolean;
     type Option is array (Color) of Boolean;

14
     --  then Mix can match Vector and Option can match Table 

15
     package R is new P(Item   => Boolean, Index => Color,
                        Vector => Mix,     Table => Option);

16
     --  Note that Mix cannot match Table and Option cannot match Vector


File: arm2012.info,  Node: 12.5.4,  Next: 12.5.5,  Prev: 12.5.3,  Up: 12.5

12.5.4 Formal Access Types
--------------------------

1/2
The category determined for a formal access type is the category of all
access types.

                               _Syntax_

2
     formal_access_type_definition ::= access_type_definition

                           _Legality Rules_

3
For a formal access-to-object type, the designated subtypes of the
formal and actual types shall statically match. 

4/2
If and only if the general_access_modifier constant applies to the
formal, the actual shall be an access-to-constant type.  If the
general_access_modifier all applies to the formal, then the actual shall
be a general access-to-variable type (see *note 3.10::).  If and only if
the formal subtype excludes null, the actual subtype shall exclude null.

5/3
For a formal access-to-subprogram subtype, the designated profiles of
the formal and the actual shall be subtype conformant. 

                              _Examples_

6
Example of formal access types:

7
     --  the formal types of the generic package 

8
     generic
        type Node is private;
        type Link is access Node;
     package P is
        ...
     end P;

9
     --  can be matched by the actual types 

10
     type Car;
     type Car_Name is access Car;

11
     type Car is
        record
           Pred, Succ : Car_Name;
           Number     : License_Number;
           Owner      : Person;
        end record;

12
     --  in the following generic instantiation 

13
     package R is new P(Node => Car, Link => Car_Name);


File: arm2012.info,  Node: 12.5.5,  Prev: 12.5.4,  Up: 12.5

12.5.5 Formal Interface Types
-----------------------------

1/2
The category determined for a formal interface type is the category of
all interface types.

                               _Syntax_

2/2
     formal_interface_type_definition ::= interface_type_definition

                           _Legality Rules_

3/2
The actual type shall be a descendant of every progenitor of the formal
type.

4/2
The actual type shall be a limited, task, protected, or synchronized
interface if and only if the formal type is also, respectively, a
limited, task, protected, or synchronized interface.

                              _Examples_

5/2
     type Root_Work_Item is tagged private;

6/2
     generic
        type Managed_Task is task interface;
        type Work_Item(<>) is new Root_Work_Item with private;
     package Server_Manager is
        task type Server is new Managed_Task with
           entry Start(Data : in out Work_Item);
        end Server;
     end Server_Manager;

7/2
This generic allows an application to establish a standard interface
that all tasks need to implement so they can be managed appropriately by
an application-specific scheduler.


File: arm2012.info,  Node: 12.6,  Next: 12.7,  Prev: 12.5,  Up: 12

12.6 Formal Subprograms
=======================

1
Formal subprograms can be used to pass callable entities to a generic
unit.

                               _Syntax_

2/2
     formal_subprogram_declaration ::=
     formal_concrete_subprogram_declaration
         | formal_abstract_subprogram_declaration

2.1/3
     formal_concrete_subprogram_declaration ::=
          with subprogram_specification [is subprogram_default]
             [aspect_specification];

2.2/3
     formal_abstract_subprogram_declaration ::=
          with subprogram_specification is abstract [subprogram_default]
             [aspect_specification];

3/2
     subprogram_default ::= default_name | <> | null

4
     default_name ::= name

4.1/2
     A subprogram_default of null shall not be specified for a formal
     function or for a formal_abstract_subprogram_declaration.

                        _Name Resolution Rules_

5
The expected profile for the default_name, if any, is that of the formal
subprogram.

6
For a generic formal subprogram, the expected profile for the actual is
that of the formal subprogram.

                           _Legality Rules_

7/3
The profiles of the formal and any named default shall be mode
conformant. 

8/3
The profiles of the formal and actual shall be mode conformant. 

8.1/2
For a parameter or result subtype of a formal_subprogram_declaration
that has an explicit null_exclusion:

8.2/2
   * if the actual matching the formal_subprogram_declaration denotes a
     generic formal object of another generic unit G, and the
     instantiation containing the actual that occurs within the body of
     a generic unit G or within the body of a generic unit declared
     within the declarative region of the generic unit G, then the
     corresponding parameter or result type of the formal subprogram of
     G shall have a null_exclusion;

8.3/2
   * otherwise, the subtype of the corresponding parameter or result
     type of the actual matching the formal_subprogram_declaration shall
     exclude null. In addition to the places where Legality Rules
     normally apply (see *note 12.3::), this rule applies also in the
     private part of an instance of a generic unit.

8.4/3
If a formal parameter of a formal_abstract_subprogram_declaration (*note
12.6: S0298.) is of a specific tagged type T or of an anonymous access
type designating a specific tagged type T, T is called a controlling
type of the formal_abstract_subprogram_declaration (*note 12.6: S0298.).
Similarly, if the result of a formal_abstract_subprogram_declaration
(*note 12.6: S0298.) for a function is of a specific tagged type T or of
an anonymous access type designating a specific tagged type T, T is
called a controlling type of the formal_abstract_subprogram_declaration
(*note 12.6: S0298.).  A formal_abstract_subprogram_declaration (*note
12.6: S0298.) shall have exactly one controlling type, and that type
shall not be incomplete. 

8.5/2
The actual subprogram for a formal_abstract_subprogram_declaration
(*note 12.6: S0298.) shall be a dispatching operation of the controlling
type or of the actual type corresponding to the controlling type.

                          _Static Semantics_

9
A formal_subprogram_declaration declares a generic formal subprogram.
The types of the formal parameters and result, if any, of the formal
subprogram are those determined by the subtype_marks given in the
formal_subprogram_declaration; however, independent of the particular
subtypes that are denoted by the subtype_marks, the nominal subtypes of
the formal parameters and result, if any, are defined to be nonstatic,
and unconstrained if of an array type (no applicable index constraint is
provided in a call on a formal subprogram).  In an instance, a
formal_subprogram_declaration declares a view of the actual.  The
profile of this view takes its subtypes and calling convention from the
original profile of the actual entity, while taking the formal parameter
names and default_expression (*note 3.7: S0063.)s from the profile given
in the formal_subprogram_declaration (*note 12.6: S0296.).  The view is
a function or procedure, never an entry.

9.1/3
If a subtype_mark in the profile of the formal_subprogram_declaration
denotes a formal private or formal derived type and the actual type for
this formal type is a class-wide type T'Class, then for the purposes of
resolving the corresponding actual subprogram at the point of the
instantiation, certain implicit declarations may be available as
possible resolutions as follows:

9.2/3
          For each primitive subprogram of T that is directly visible at
          the point of the instantiation, and that has at least one
          controlling formal parameter, a corresponding implicitly
          declared subprogram with the same defining name, and having
          the same profile as the primitive subprogram except that T is
          systematically replaced by T'Class in the types of its
          profile, is potentially use-visible.  The body of such a
          subprogram is as defined in *note 12.5.1:: for primitive
          subprograms of a formal type when the actual type is
          class-wide.

10
If a generic unit has a subprogram_default specified by a box, and the
corresponding actual parameter is omitted, then it is equivalent to an
explicit actual parameter that is a usage name identical to the defining
name of the formal.

10.1/2
If a generic unit has a subprogram_default specified by the reserved
word null, and the corresponding actual parameter is omitted, then it is
equivalent to an explicit actual parameter that is a null procedure
having the profile given in the formal_subprogram_declaration (*note
12.6: S0296.).

10.2/2
The subprogram declared by a formal_abstract_subprogram_declaration
(*note 12.6: S0298.) with a controlling type T is a dispatching
operation of type T.

     NOTES

11
     13  The matching rules for formal subprograms state requirements
     that are similar to those applying to
     subprogram_renaming_declarations (see *note 8.5.4::).  In
     particular, the name of a parameter of the formal subprogram need
     not be the same as that of the corresponding parameter of the
     actual subprogram; similarly, for these parameters,
     default_expressions need not correspond.

12
     14  The constraints that apply to a parameter of a formal
     subprogram are those of the corresponding formal parameter of the
     matching actual subprogram (not those implied by the corresponding
     subtype_mark in the _specification of the formal subprogram).  A
     similar remark applies to the result of a function.  Therefore, to
     avoid confusion, it is recommended that the name of a first subtype
     be used in any declaration of a formal subprogram.

13
     15  The subtype specified for a formal parameter of a generic
     formal subprogram can be any visible subtype, including a generic
     formal subtype of the same generic_formal_part.

14
     16  A formal subprogram is matched by an attribute of a type if the
     attribute is a function with a matching specification.  An
     enumeration literal of a given type matches a parameterless formal
     function whose result type is the given type.

15
     17  A default_name denotes an entity that is visible or directly
     visible at the place of the generic_declaration; a box used as a
     default is equivalent to a name that denotes an entity that is
     directly visible at the place of the _instantiation.

16/2
     18  The actual subprogram cannot be abstract unless the formal
     subprogram is a formal_abstract_subprogram_declaration (*note 12.6:
     S0298.) (see *note 3.9.3::).

16.1/2
     19  The subprogram declared by a
     formal_abstract_subprogram_declaration (*note 12.6: S0298.) is an
     abstract subprogram.  All calls on a subprogram declared by a
     formal_abstract_subprogram_declaration (*note 12.6: S0298.) must be
     dispatching calls.  See *note 3.9.3::.

16.2/2
     20  A null procedure as a subprogram default has convention
     Intrinsic (see *note 6.3.1::).

                              _Examples_

17
Examples of generic formal subprograms:

18/2
     with function "+"(X, Y : Item) return Item is <>;
     with function Image(X : Enum) return String is Enum'Image;
     with procedure Update is Default_Update;
     with procedure Pre_Action(X : in Item) is null;  -- defaults to no action
     with procedure Write(S    : not null access Root_Stream_Type'Class;
                          Desc : Descriptor)
                          is abstract Descriptor'Write;  -- see *note 13.13.2::
     -- Dispatching operation on Descriptor with default

19
     --  given the generic procedure declaration 

20
     generic
        with procedure Action (X : in Item);
     procedure Iterate(Seq : in Item_Sequence);

21
     --  and the procedure 

22
     procedure Put_Item(X : in Item);

23
     --  the following instantiation is possible 

24
     procedure Put_List is new Iterate(Action => Put_Item);


File: arm2012.info,  Node: 12.7,  Next: 12.8,  Prev: 12.6,  Up: 12

12.7 Formal Packages
====================

1
Formal packages can be used to pass packages to a generic unit.  The
formal_package_declaration declares that the formal package is an
instance of a given generic package.  Upon instantiation, the actual
package has to be an instance of that generic package.

                               _Syntax_

2/3
     formal_package_declaration ::=
         with package defining_identifier is new generic_package_name  
     formal_package_actual_part
             [aspect_specification];

3/2
     formal_package_actual_part ::=
         ([others =>] <>)
       | [generic_actual_part]
       | (formal_package_association {, 
     formal_package_association} [, others => <>])

3.1/2
     formal_package_association ::=
         generic_association
       | generic_formal_parameter_selector_name => <>

3.2/2
     Any positional formal_package_associations shall precede any named
     formal_package_associations.

                           _Legality Rules_

4
The generic_package_name shall denote a generic package (the template
for the formal package); the formal package is an instance of the
template.

4.1/3
The generic_formal_parameter_selector_name of a
formal_package_association shall denote a
generic_formal_parameter_declaration of the template.  If two or more
formal subprograms of the template have the same defining name, then
named associations are not allowed for the corresponding actuals.

4.2/3
A formal_package_actual_part shall contain at most one
formal_package_association for each formal parameter.  If the
formal_package_actual_part does not include "others => <>", each formal
parameter without an association shall have a default_expression or
subprogram_default.

4.3/3
The rules for matching between formal_package_associations and the
generic formals of the template are as follows:

4.4/3
   * If all of the formal_package_associations are given by generic
     associations, the explicit_generic_actual_parameters of the
     formal_package_associations shall be legal for an instantiation of
     the template.

4.5/3
   * If a formal_package_association for a formal type T of the template
     is given by <>, then the formal_package_association for any other
     generic_formal_parameter_declaration of the template that mentions
     T directly or indirectly must be given by <> as well.

5/2
The actual shall be an instance of the template.  If the
formal_package_actual_part is (<>) or (others => <>), then the actual
may be any instance of the template; otherwise, certain of the actual
parameters of the actual instance shall match the corresponding actual
parameters of the formal package, determined as follows:

5.1/2
   * If the formal_package_actual_part (*note 12.7: S0302.) includes
     generic_associations as well as associations with <>, then only the
     actual parameters specified explicitly with generic_associations
     are required to match;

5.2/2
   * Otherwise, all actual parameters shall match, whether any actual
     parameter is given explicitly or by default.

5.3/2
The rules for matching of actual parameters between the actual instance
and the formal package are as follows:

6/2
   * For a formal object of mode in, the actuals match if they are
     static expressions with the same value, or if they statically
     denote the same constant, or if they are both the literal null.

7
   * For a formal subtype, the actuals match if they denote statically
     matching subtypes. 

8
   * For other kinds of formals, the actuals match if they statically
     denote the same entity.

8.1/1
For the purposes of matching, any actual parameter that is the name of a
formal object of mode in is replaced by the formal object's actual
expression (recursively).

                          _Static Semantics_

9
A formal_package_declaration declares a generic formal package.

10/2
The visible part of a formal package includes the first list of
basic_declarative_items of the package_specification (*note 7.1:
S0191.).  In addition, for each actual parameter that is not required to
match, a copy of the declaration of the corresponding formal parameter
of the template is included in the visible part of the formal package.
If the copied declaration is for a formal type, copies of the implicit
declarations of the primitive subprograms of the formal type are also
included in the visible part of the formal package.

11/2
For the purposes of matching, if the actual instance A is itself a
formal package, then the actual parameters of A are those specified
explicitly or implicitly in the formal_package_actual_part for A, plus,
for those not specified, the copies of the formal parameters of the
template included in the visible part of A.

                              _Examples_

12/2
Example of a generic package with formal package parameters:

13/2
     with Ada.Containers.Ordered_Maps;  -- see *note A.18.6::
     generic
        with package Mapping_1 is new Ada.Containers.Ordered_Maps(<>);
        with package Mapping_2 is new Ada.Containers.Ordered_Maps
                                         (Key_Type => Mapping_1.Element_Type,
                                          others => <>);
     package Ordered_Join is
        -- Provide a "join" between two mappings

14/2
        subtype Key_Type is Mapping_1.Key_Type;
        subtype Element_Type is Mapping_2.Element_Type;

15/2
        function Lookup(Key : Key_Type) return Element_Type;

16/2
        ...
     end Ordered_Join;

17/2
Example of an instantiation of a package with formal packages:

18/2
     with Ada.Containers.Ordered_Maps;
     package Symbol_Package is

19/2
        type String_Id is ...

20/2
        type Symbol_Info is ...

21/2
        package String_Table is new Ada.Containers.Ordered_Maps
                (Key_Type => String,
                 Element_Type => String_Id);

22/2
        package Symbol_Table is new Ada.Containers.Ordered_Maps
                (Key_Type => String_Id,
                 Element_Type => Symbol_Info);

23/2
        package String_Info is new Ordered_Join(Mapping_1 => String_Table,
                                                Mapping_2 => Symbol_Table);

24/2
        Apple_Info : constant Symbol_Info := String_Info.Lookup("Apple");

25/2
     end Symbol_Package;


File: arm2012.info,  Node: 12.8,  Prev: 12.7,  Up: 12

12.8 Example of a Generic Package
=================================

1
The following example provides a possible formulation of stacks by means
of a generic package.  The size of each stack and the type of the stack
elements are provided as generic formal parameters.

                              _Examples_

2/1
This paragraph was deleted.

3
     generic
        Size : Positive;
        type Item is private;
     package Stack is
        procedure Push(E : in  Item);
        procedure Pop (E : out Item);
        Overflow, Underflow : exception;
     end Stack;

4
     package body Stack is

5
        type Table is array (Positive range <>) of Item;
        Space : Table(1 .. Size);
        Index : Natural := 0;

6
        procedure Push(E : in Item) is
        begin
           if Index >= Size then
              raise Overflow;
           end if;
           Index := Index + 1;
           Space(Index) := E;
        end Push;

7
        procedure Pop(E : out Item) is
        begin
           if Index = 0 then
              raise Underflow;
           end if;
           E := Space(Index);
           Index := Index - 1;
        end Pop;

8
     end Stack;

9
Instances of this generic package can be obtained as follows:

10
     package Stack_Int  is new Stack(Size => 200, Item => Integer);
     package Stack_Bool is new Stack(100, Boolean);

11
Thereafter, the procedures of the instantiated packages can be called as
follows:

12
     Stack_Int.Push(N);
     Stack_Bool.Push(True);

13
Alternatively, a generic formulation of the type Stack can be given as
follows (package body omitted):

14
     generic
        type Item is private;
     package On_Stacks is
        type Stack(Size : Positive) is limited private;
        procedure Push(S : in out Stack; E : in  Item);
        procedure Pop (S : in out Stack; E : out Item);
        Overflow, Underflow : exception;
     private
        type Table is array (Positive range <>) of Item;
        type Stack(Size : Positive) is
           record
              Space : Table(1 .. Size);
              Index : Natural := 0;
           end record;
     end On_Stacks;

15
In order to use such a package, an instance has to be created and
thereafter stacks of the corresponding type can be declared:

16
     declare
        package Stack_Real is new On_Stacks(Real); use Stack_Real;
        S : Stack(100);
     begin
        ...
        Push(S, 2.54);
        ...
     end;


File: arm2012.info,  Node: 13,  Next: Annex A,  Prev: 12,  Up: Top

13 Representation Issues
************************

1/3
This clause describes features for querying and controlling certain
aspects of entities and for interfacing to hardware.

* Menu:

* 13.1 ::     Operational and Representation Aspects
* 13.2 ::     Packed Types
* 13.3 ::     Operational and Representation Attributes
* 13.4 ::     Enumeration Representation Clauses
* 13.5 ::     Record Layout
* 13.6 ::     Change of Representation
* 13.7 ::     The Package System
* 13.8 ::     Machine Code Insertions
* 13.9 ::     Unchecked Type Conversions
* 13.10 ::    Unchecked Access Value Creation
* 13.11 ::    Storage Management
* 13.12 ::    Pragma Restrictions and Pragma Profile
* 13.13 ::    Streams
* 13.14 ::    Freezing Rules


File: arm2012.info,  Node: 13.1,  Next: 13.2,  Up: 13

13.1 Operational and Representation Aspects
===========================================

0.1/3
Two kinds of aspects of entities can be specified: representation
aspects and operational aspects.  Representation aspects affect how the
types and other entities of the language are to be mapped onto the
underlying machine.  Operational aspects determine other properties of
entities.

0.2/3
Either kind of aspect of an entity may be specified by means of an
aspect_specification (see *note 13.1.1::), which is an optional element
of most kinds of declarations and applies to the entity or entities
being declared.  Aspects may also be specified by certain other
constructs occurring subsequent to the declaration of the affected
entity: a representation aspect value may be specified by means of a
representation item and an operational aspect value may be specified by
means of an operational item.

1/1
There are six kinds of representation items: attribute_definition_clause
(*note 13.3: S0310.)s for representation attributes,
enumeration_representation_clause (*note 13.4: S0311.)s,
record_representation_clause (*note 13.5.1: S0313.)s, at_clauses,
component_clauses, and representation pragmas.  They can be provided to
give more efficient representation or to interface with features that
are outside the domain of the language (for example, peripheral
hardware).

1.1/1
An operational item is an attribute_definition_clause for an operational
attribute.

1.2/1
An operational item or a representation item applies to an entity
identified by a local_name, which denotes an entity declared local to
the current declarative region, or a library unit declared immediately
preceding a representation pragma in a compilation.

                               _Syntax_

2/1
     aspect_clause ::= attribute_definition_clause
           | enumeration_representation_clause
           | record_representation_clause
           | at_clause

3
     local_name ::= direct_name
           | direct_name'attribute_designator
           | library_unit_name

4/1
     A representation pragma is allowed only at places where an
     aspect_clause or compilation_unit is allowed. 

                        _Name Resolution Rules_

5/1
In an operational item or representation item, if the local_name is a
direct_name, then it shall resolve to denote a declaration (or, in the
case of a pragma, one or more declarations) that occurs immediately
within the same declarative region as the item.  If the local_name has
an attribute_designator, then it shall resolve to denote an
implementation-defined component (see *note 13.5.1::) or a class-wide
type implicitly declared immediately within the same declarative region
as the item.  A local_name that is a library_unit_name (only permitted
in a representation pragma) shall resolve to denote the library_item
that immediately precedes (except for other pragmas) the representation
pragma.

                           _Legality Rules_

6/1
The local_name of an aspect_clause or representation pragma shall
statically denote an entity (or, in the case of a pragma, one or more
entities) declared immediately preceding it in a compilation, or within
the same declarative_part (*note 3.11: S0086.), package_specification
(*note 7.1: S0191.), task_definition (*note 9.1: S0207.),
protected_definition (*note 9.4: S0212.), or record_definition (*note
3.8: S0067.) as the representation or operational item.  If a local_name
denotes a local callable entity, it may do so through a local
subprogram_renaming_declaration (*note 8.5.4: S0203.) (as a way to
resolve ambiguity in the presence of overloading); otherwise, the
local_name shall not denote a renaming_declaration (*note 8.5: S0199.).

7/2
The representation of an object consists of a certain number of bits
(the size of the object).  For an object of an elementary type, these
are the bits that are normally read or updated by the machine code when
loading, storing, or operating-on the value of the object.  For an
object of a composite type, these are the bits reserved for this object,
and include bits occupied by subcomponents of the object.  If the size
of an object is greater than that of its subtype, the additional bits
are padding bits. For an elementary object, these padding bits are
normally read and updated along with the others.  For a composite
object, padding bits might not be read or updated in any given composite
operation, depending on the implementation.

8/3
A representation item directly specifies a representation aspect of the
entity denoted by the local_name, except in the case of a type-related
representation item, whose local_name shall denote a first subtype, and
which directly specifies an aspect of the subtype's type. A
representation item that names a subtype is either subtype-specific
(Size and Alignment clauses) or type-related (all others).
Subtype-specific aspects may differ for different subtypes of the same
type.

8.1/3
An operational item directly specifies an operational aspect of the
entity denoted by the local_name, except in the case of a type-related
operational item, whose local_name shall denote a first subtype, and
which directly specifies an aspect of the type of the subtype. 

9/4
A representation item that directly specifies an aspect of a subtype or
type shall appear after the type is completely defined (see *note
3.11.1::), and before the subtype or type is frozen (see *note 13.14::).

9.1/4
An operational item that directly specifies an aspect of an entity shall
appear before the entity is frozen (see *note 13.14::).

9.2/4
If a representation item, operational item, or aspect_specification is
given that directly specifies an aspect of an entity, then it is illegal
to give another representation item, operational item, or
aspect_specification that directly specifies the same aspect of the
entity.

9.3/4
Unless otherwise specified, it is illegal to specify an operational or
representation aspect of a generic formal parameter.

10/4
For an untagged derived type, it is illegal to specify a type-related
representation aspect if the parent type is a by-reference type, or has
any user-defined primitive subprograms.  Similarly, it is illegal to
specify a nonconfirming type-related representation aspect for an
untagged by-reference type after one or more types have been derived
from it.

11/3
Operational and representation aspects of a generic formal parameter are
the same as those of the actual.  Operational and representation aspects
are the same for all views of a type.  Specification of a type-related
representation aspect is not allowed for a descendant of a generic
formal untagged type.

12/3
The specification of the Size aspect for a given subtype, or the size or
storage place for an object (including a component) of a given subtype,
shall allow for enough storage space to accommodate any value of the
subtype.

13/3
If a specification of a representation or operational aspect is not
supported by the implementation, it is illegal or raises an exception at
run time.

13.1/3
A type_declaration is illegal if it has one or more progenitors, and a
nonconfirming value was specified for a representation aspect of an
ancestor, and this conflicts with the representation of some other
ancestor.  The cases that cause conflicts are implementation defined.

                          _Static Semantics_

14
If two subtypes statically match, then their subtype-specific aspects
(Size and Alignment) are the same. 

15/3
A derived type inherits each type-related representation aspect of its
parent type that was directly specified before the declaration of the
derived type, or (in the case where the parent is derived) that was
inherited by the parent type from the grandparent type.  A derived
subtype inherits each subtype-specific representation aspect of its
parent subtype that was directly specified before the declaration of the
derived type, or (in the case where the parent is derived) that was
inherited by the parent subtype from the grandparent subtype, but only
if the parent subtype statically matches the first subtype of the parent
type.  An inherited representation aspect is overridden by a subsequent
aspect_specification or representation item that specifies a different
value for the same aspect of the type or subtype.

15.1/3
In contrast, whether operational aspects are inherited by a derived type
depends on each specific aspect; unless specified, an operational aspect
is not inherited.  When operational aspects are inherited by a derived
type, aspects that were directly specified by aspect_specifications or
operational items that are visible at the point of the derived type
declaration, or (in the case where the parent is derived) that were
inherited by the parent type from the grandparent type are inherited.
An inherited operational aspect is overridden by a subsequent
aspect_specification or operational item that specifies the same aspect
of the type.

15.2/2
When an aspect that is a subprogram is inherited, the derived type
inherits the aspect in the same way that a derived type inherits a
user-defined primitive subprogram from its parent (see *note 3.4::).

16
Each aspect of representation of an entity is as follows:

17
   * If the aspect is specified for the entity, meaning that it is
     either directly specified or inherited, then that aspect of the
     entity is as specified, except in the case of Storage_Size, which
     specifies a minimum.

18
   * If an aspect of representation of an entity is not specified, it is
     chosen by default in an unspecified manner.

18.1/1
If an operational aspect is specified for an entity (meaning that it is
either directly specified or inherited), then that aspect of the entity
is as specified.  Otherwise, the aspect of the entity has the default
value for that aspect.

18.2/3
An aspect_specification or representation item that specifies a
representation aspect that would have been chosen in the absence of the
aspect_specification or representation item is said to be confirming.
The aspect value specified in this case is said to be a confirming
representation aspect value.  Other values of the aspect are said to be
nonconfirming, as are the aspect_specifications and representation items
that specified them. 

                          _Dynamic Semantics_

19/1
For the elaboration of an aspect_clause, any evaluable constructs within
it are evaluated.

                     _Implementation Permissions_

20/3
An implementation may interpret representation aspects in an
implementation-defined manner.  An implementation may place
implementation-defined restrictions on the specification of
representation aspects. A recommended level of support is defined for
the specification of representation aspects and related features in each
subclause.  These recommendations are changed to requirements for
implementations that support the Systems Programming Annex (see *note
C.2::, "*note C.2:: Required Representation Support").

                        _Implementation Advice_

21/3
The recommended level of support for the specification of all
representation aspects is qualified as follows:

21.1/3
   * A confirming specification for a representation aspect should be
     supported.

22/3
   * An implementation need not support the specification for a
     representation aspect that contains nonstatic expressions, unless
     each nonstatic expression is a name that statically denotes a
     constant declared before the entity.

23
   * An implementation need not support a specification for the Size for
     a given composite subtype, nor the size or storage place for an
     object (including a component) of a given composite subtype, unless
     the constraints on the subtype and its composite subcomponents (if
     any) are all static constraints.

24/3
   * An implementation need not support specifying a nonconfirming
     representation aspect value if it could cause an aliased object or
     an object of a by-reference type to be allocated at a
     nonaddressable location or, when the alignment attribute of the
     subtype of such an object is nonzero, at an address that is not an
     integral multiple of that alignment.

25/3
   * An implementation need not support specifying a nonconfirming
     representation aspect value if it could cause an aliased object of
     an elementary type to have a size other than that which would have
     been chosen by default.

26/3
   * An implementation need not support specifying a nonconfirming
     representation aspect value if it could cause an aliased object of
     a composite type, or an object whose type is by-reference, to have
     a size smaller than that which would have been chosen by default.

27/3
   * An implementation need not support specifying a nonconfirming
     subtype-specific representation aspect value for an indefinite or
     abstract subtype.

28/3
For purposes of these rules, the determination of whether specifying a
representation aspect value for a type could cause an object to have
some property is based solely on the properties of the type itself, not
on any available information about how the type is used.  In particular,
it presumes that minimally aligned objects of this type might be
declared at some point.

     NOTES

29/3
     1  Aspects that can be specified are defined throughout this
     International Standard, and are summarized in *note K.1::.

* Menu:

* 13.1.1 ::   Aspect Specifications


File: arm2012.info,  Node: 13.1.1,  Up: 13.1

13.1.1 Aspect Specifications
----------------------------

1/3
Certain representation or operational aspects of an entity may be
specified as part of its declaration using an aspect_specification,
rather than using a separate representation or operational item.  The
declaration with the aspect_specification is termed the associated
declaration.

                               _Syntax_

2/3
     aspect_specification ::=
        with aspect_mark [=> aspect_definition] {,
                aspect_mark [=> aspect_definition] }

3/3
     aspect_mark ::= aspect_identifier['Class]

4/3
     aspect_definition ::= name | expression | identifier

                        _Name Resolution Rules_

5/3
An aspect_mark identifies an aspect of the entity defined by the
associated declaration (the associated entity); the aspect denotes an
object, a value, an expression, a subprogram, or some other kind of
entity.  If the aspect_mark identifies:

6/3
   * an aspect that denotes an object, the aspect_definition shall be a
     name.  The expected type for the name is the type of the identified
     aspect of the associated entity;

7/3
   * an aspect that is a value or an expression, the aspect_definition
     shall be an expression.  The expected type for the expression is
     the type of the identified aspect of the associated entity;

8/3
   * an aspect that denotes a subprogram, the aspect_definition shall be
     a name; the expected profile for the name is the profile required
     for the aspect of the associated entity;

9/3
   * an aspect that denotes some other kind of entity, the
     aspect_definition shall be a name, and the name shall resolve to
     denote an entity of the appropriate kind;

10/3
   * an aspect that is given by an identifier specific to the aspect,
     the aspect_definition shall be an identifier, and the identifier
     shall be one of the identifiers specific to the identified aspect.

11/3
The usage names in an aspect_definition are not resolved at the point of
the associated declaration, but rather are resolved at the end of the
immediately enclosing declaration list.

12/3
If the associated declaration is for a subprogram or entry, the names of
the formal parameters are directly visible within the aspect_definition,
as are certain attributes, as specified elsewhere in this International
Standard for the identified aspect.  If the associated declaration is a
type_declaration, within the aspect_definition the names of any
components are directly visible, and the name of the first subtype
denotes the current instance of the type (see *note 8.6::).  If the
associated declaration is a subtype_declaration, within the
aspect_definition the name of the new subtype denotes the current
instance of the subtype.

                           _Legality Rules_

13/3
If the first freezing point of the associated entity comes before the
end of the immediately enclosing declaration list, then each usage name
in the aspect_definition shall resolve to the same entity at the first
freezing point as it does at the end of the immediately enclosing
declaration list.

14/3
At most one occurrence of each aspect_mark is allowed within a single
aspect_specification.  The aspect identified by the aspect_mark shall be
an aspect that can be specified for the associated entity (or view of
the entity defined by the associated declaration).

15/3
The aspect_definition associated with a given aspect_mark may be omitted
only when the aspect_mark identifies an aspect of a boolean type, in
which case it is equivalent to the aspect_definition being specified as
True.

16/3
If the aspect_mark includes 'Class, then the associated entity shall be
a tagged type or a primitive subprogram of a tagged type.

17/3
There are no language-defined aspects that may be specified on a
renaming_declaration, a generic_formal_parameter_declaration, a subunit,
a package_body, a task_body, a protected_body, or a body_stub other than
a subprogram_body_stub.

18/4
A language-defined aspect shall not be specified in an
aspect_specification given on a completion of a subprogram or generic
subprogram.

18.1/4
If an aspect of a derived type is inherited from an ancestor type and
has the boolean value True, the inherited value shall not be overridden
to have the value False for the derived type, unless otherwise specified
in this International Standard.

18.2/4
Certain type-related aspects are defined to be nonoverridable; all such
aspects are specified using an aspect_definition that is a name.

18.3/4
If a nonoverridable aspect is directly specified for a type T, then any
explicit specification of that aspect for any other descendant of T
shall be confirming; that is, the specified name shall match the
inherited aspect, meaning that the specified name shall denote the same
declarations as would the inherited name.

18.4/4
If a full type has a partial view, and a given nonoverridable aspect is
allowed for both the full view and the partial view, then the given
aspect for the partial view and the full view shall be the same: the
aspect shall be directly specified only on the partial view; if the full
type inherits the aspect, then a matching definition shall be specified
(directly or by inheritance) for the partial view.

18.5/4
In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules about nonoverridable aspects also apply in the
private part of an instance of a generic unit.

18.6/4
The Default_Iterator, Iterator_Element, Implicit_Dereference,
Constant_Indexing, and Variable_Indexing aspects are nonoverridable.

                          _Static Semantics_

19/3
Depending on which aspect is identified by the aspect_mark, an
aspect_definition specifies:

20/3
   * a name that denotes a subprogram, object, or other kind of entity;

21/3
   * an expression, which is either evaluated to produce a single value,
     or which (as in a precondition) is to be evaluated at particular
     points during later execution; or

22/3
   * an identifier specific to the aspect.

23/3
The identified aspect of the associated entity, or in some cases, the
view of the entity defined by the declaration, is as specified by the
aspect_definition (or by the default of True when boolean).  Whether an
aspect_specification applies to an entity or only to the particular view
of the entity defined by the declaration is determined by the
aspect_mark and the kind of entity.  The following aspects are view
specific:

24/3
   * An aspect specified on an object_declaration;

25/3
   * An aspect specified on a subprogram_declaration;

26/3
   * An aspect specified on a renaming_declaration.

27/3
All other aspect_specifications are associated with the entity, and
apply to all views of the entity, unless otherwise specified in this
International Standard.

28/4
If the aspect_mark includes 'Class (a class-wide aspect), then, unless
specified otherwise for a particular class-wide aspect:

29/3
   * if the associated entity is a tagged type, the specification
     applies to all descendants of the type;

30/3
   * if the associated entity is a primitive subprogram of a tagged type
     T, the specification applies to the corresponding primitive
     subprogram of all descendants of T.

31/3
All specifiable operational and representation attributes may be
specified with an aspect_specification instead of an
attribute_definition_clause (see *note 13.3::).

32/4
Any aspect specified by a representation pragma or library unit pragma
that has a local_name as its single argument may be specified by an
aspect_specification, with the entity being the local_name.  The
aspect_definition is expected to be of type Boolean.  The expression
shall be static.  Notwithstanding what this International Standard says
elsewhere, the expression of an aspect that can be specified by a
library unit pragma is resolved and evaluated at the point where it
occurs in the aspect_specification, rather than the first freezing point
of the associated package.

33/3
In addition, other operational and representation aspects not associated
with specifiable attributes or representation pragmas may be specified,
as specified elsewhere in this International Standard.

34/4
This paragraph was deleted.

35/3
If a Legality Rule or Static Semantics rule only applies when a
particular aspect has been specified, the aspect is considered to have
been specified only when the aspect_specification or
attribute_definition_clause is visible (see *note 8.3::) at the point of
the application of the rule.

36/3
Alternative legality and semantics rules may apply for particular
aspects, as specified elsewhere in this International Standard.

                          _Dynamic Semantics_

37/3
At the freezing point of the associated entity, the aspect_specification
is elaborated.  The elaboration of the aspect_specification includes the
evaluation of the name or expression, if any, unless the aspect itself
is an expression.  If the corresponding aspect represents an expression
(as in a precondition), the elaboration has no effect; the expression is
evaluated later at points within the execution as specified elsewhere in
this International Standard for the particular aspect.

                     _Implementation Permissions_

38/3
Implementations may support implementation-defined aspects.  The
aspect_specification for an implementation-defined aspect may use an
implementation-defined syntax for the aspect_definition, and may follow
implementation-defined legality and semantics rules.


File: arm2012.info,  Node: 13.2,  Next: 13.3,  Prev: 13.1,  Up: 13

13.2 Packed Types
=================

1/3
The Pack aspect having the value True specifies that storage
minimization should be the main criterion when selecting the
representation of a composite type.

Paragraphs 2 through 4 were moved to *note Annex J::, "*note Annex J::
Obsolescent Features".

                          _Static Semantics_

5/3
For a full type declaration of a composite type, the following
language-defined representation aspect may be specified:

5.1/3
Pack
               The type of aspect Pack is Boolean.  When aspect Pack is
               True for a type, the type (or the extension part) is said
               to be packed.  For a type extension, the parent part is
               packed as for the parent type, and specifying Pack causes
               packing only of the extension part. 

5.2/3
               If directly specified, the aspect_definition shall be a
               static expression.  If not specified (including by
               inheritance), the aspect is False.

                        _Implementation Advice_

6
If a type is packed, then the implementation should try to minimize
storage allocated to objects of the type, possibly at the expense of
speed of accessing components, subject to reasonable complexity in
addressing calculations.

6.1/4
This paragraph was deleted.

7/3
The recommended level of support for the Pack aspect is:

7.1/4
   * Any component of a packed type that is of a by-reference type, that
     is specified as independently addressable, or that contains an
     aliased part, shall be aligned according to the alignment of its
     subtype.

8/4
   * For a packed record type, the components should be packed as
     tightly as possible subject to the above alignment requirements,
     the Sizes of the component subtypes, and any
     record_representation_clause that applies to the type; the
     implementation may, but need not, reorder components or cross
     aligned word boundaries to improve the packing.  A component whose
     Size is greater than the word size may be allocated an integral
     number of words.

9/4
   * For a packed array type, if the Size of the component subtype is
     less than or equal to the word size, Component_Size should be less
     than or equal to the Size of the component subtype, rounded up to
     the nearest factor of the word size, unless this would violate the
     above alignment requirements.


File: arm2012.info,  Node: 13.3,  Next: 13.4,  Prev: 13.2,  Up: 13

13.3 Operational and Representation Attributes
==============================================

1/1
The values of certain implementation-dependent characteristics can be
obtained by interrogating appropriate operational or representation
attributes. Some of these attributes are specifiable via an
attribute_definition_clause.

                               _Syntax_

2
     attribute_definition_clause ::=
           for local_name'attribute_designator use expression;
         | for local_name'attribute_designator use name;

                        _Name Resolution Rules_

3
For an attribute_definition_clause that specifies an attribute that
denotes a value, the form with an expression shall be used.  Otherwise,
the form with a name shall be used.

4
For an attribute_definition_clause that specifies an attribute that
denotes a value or an object, the expected type for the expression or
name is that of the attribute. For an attribute_definition_clause that
specifies an attribute that denotes a subprogram, the expected profile
for the name is the profile required for the attribute.  For an
attribute_definition_clause that specifies an attribute that denotes
some other kind of entity, the name shall resolve to denote an entity of
the appropriate kind.

                           _Legality Rules_

5/3
An attribute_designator is allowed in an attribute_definition_clause
only if this International Standard explicitly allows it, or for an
implementation-defined attribute if the implementation allows it. Each
specifiable attribute constitutes an operational aspect or aspect of
representation; the name of the aspect is that of the attribute.

6
For an attribute_definition_clause that specifies an attribute that
denotes a subprogram, the profile shall be mode conformant with the one
required for the attribute, and the convention shall be Ada.  Additional
requirements are defined for particular attributes. 

                          _Static Semantics_

7/2
A Size clause is an attribute_definition_clause whose
attribute_designator is Size.  Similar definitions apply to the other
specifiable attributes.

8
A storage element is an addressable element of storage in the machine. A
word is the largest amount of storage that can be conveniently and
efficiently manipulated by the hardware, given the implementation's
run-time model.  A word consists of an integral number of storage
elements.

8.1/3
A machine scalar is an amount of storage that can be conveniently and
efficiently loaded, stored, or operated upon by the hardware.  Machine
scalars consist of an integral number of storage elements.  The set of
machine scalars is implementation defined, but includes at least the
storage element and the word.  Machine scalars are used to interpret
component_clauses when the nondefault bit ordering applies.

9/3
The following representation attributes are defined: Address, Alignment,
Size, Storage_Size, Component_Size, Has_Same_Storage, and
Overlaps_Storage.

10/1
For a prefix X that denotes an object, program unit, or label:

11
X'Address
               Denotes the address of the first of the storage elements
               allocated to X. For a program unit or label, this value
               refers to the machine code associated with the
               corresponding body or statement.  The value of this
               attribute is of type System.Address.

11.1/3
               The prefix of X'Address shall not statically denote a
               subprogram that has convention Intrinsic.  X'Address
               raises Program_Error if X denotes a subprogram that has
               convention Intrinsic.

12
               Address may be specified for stand-alone objects and for
               program units via an attribute_definition_clause.

                         _Erroneous Execution_

13/3
If an Address is specified, it is the programmer's responsibility to
ensure that the address is valid and appropriate for the entity and its
use; otherwise, program execution is erroneous.

                        _Implementation Advice_

14
For an array X, X'Address should point at the first component of the
array, and not at the array bounds.

15
The recommended level of support for the Address attribute is:

16
   * X'Address should produce a useful result if X is an object that is
     aliased or of a by-reference type, or is an entity whose Address
     has been specified.

17
   * An implementation should support Address clauses for imported
     subprograms.

18/2
   * This paragraph was deleted.

19
   * If the Address of an object is specified, or it is imported or
     exported, then the implementation should not perform optimizations
     based on assumptions of no aliases.

     NOTES

20
     2  The specification of a link name with the Link_Name aspect (see
     *note B.1::) for a subprogram or object is an alternative to
     explicit specification of its link-time address, allowing a
     link-time directive to place the subprogram or object within
     memory.

21
     3  The rules for the Size attribute imply, for an aliased object X,
     that if X'Size = Storage_Unit, then X'Address points at a storage
     element containing all of the bits of X, and only the bits of X.

                          _Static Semantics_

22/2
For a prefix X that denotes an object:

23/2
X'Alignment
               The value of this attribute is of type universal_integer,
               and nonnegative; zero means that the object is not
               necessarily aligned on a storage element boundary.  If
               X'Alignment is not zero, then X is aligned on a storage
               unit boundary and X'Address is an integral multiple of
               X'Alignment (that is, the Address modulo the Alignment is
               zero).

24/2

               This paragraph was deleted.

25/2
               Alignment may be specified for stand-alone objects via an
               attribute_definition_clause (*note 13.3: S0310.); the
               expression of such a clause shall be static, and its
               value nonnegative.

26/2

               This paragraph was deleted.

26.1/2
For every subtype S:

26.2/2
S'Alignment
               The value of this attribute is of type universal_integer,
               and nonnegative.

26.3/2
               For an object X of subtype S, if S'Alignment is not zero,
               then X'Alignment is a nonzero integral multiple of
               S'Alignment unless specified otherwise by a
               representation item.

26.4/2
               Alignment may be specified for first subtypes via an
               attribute_definition_clause (*note 13.3: S0310.); the
               expression of such a clause shall be static, and its
               value nonnegative.

                         _Erroneous Execution_

27
Program execution is erroneous if an Address clause is given that
conflicts with the Alignment.

28/2
For an object that is not allocated under control of the implementation,
execution is erroneous if the object is not aligned according to its
Alignment.

                        _Implementation Advice_

28.1/3
For any tagged specific subtype S, S'Class'Alignment should equal
S'Alignment.

29
The recommended level of support for the Alignment attribute for
subtypes is:

30/2
   * An implementation should support an Alignment clause for a discrete
     type, fixed point type, record type, or array type, specifying an
     Alignment value that is zero or a power of two, subject to the
     following:

31/2
   * An implementation need not support an Alignment clause for a signed
     integer type specifying an Alignment greater than the largest
     Alignment value that is ever chosen by default by the
     implementation for any signed integer type.  A corresponding
     limitation may be imposed for modular integer types, fixed point
     types, enumeration types, record types, and array types.

32/2
   * An implementation need not support a nonconfirming Alignment clause
     which could enable the creation of an object of an elementary type
     which cannot be easily loaded and stored by available machine
     instructions.

32.1/2
   * An implementation need not support an Alignment specified for a
     derived tagged type which is not a multiple of the Alignment of the
     parent type.  An implementation need not support a nonconfirming
     Alignment specified for a derived untagged by-reference type.

33
The recommended level of support for the Alignment attribute for objects
is:

34/2
   * This paragraph was deleted.

35
   * For stand-alone library-level objects of statically constrained
     subtypes, the implementation should support all Alignments
     supported by the target linker.  For example, page alignment is
     likely to be supported for such objects, but not for subtypes.

35.1/2
   * For other objects, an implementation should at least support the
     alignments supported for their subtype, subject to the following:

35.2/2
   * An implementation need not support Alignments specified for objects
     of a by-reference type or for objects of types containing aliased
     subcomponents if the specified Alignment is not a multiple of the
     Alignment of the subtype of the object.

     NOTES

36
     4  Alignment is a subtype-specific attribute.

37/2
     This paragraph was deleted.

38/3
     5  A component_clause, Component_Size clause, or specifying the
     Pack aspect as True can override a specified Alignment.

                          _Static Semantics_

39/1
For a prefix X that denotes an object:

40
X'Size
               Denotes the size in bits of the representation of the
               object.  The value of this attribute is of the type
               universal_integer.

41
               Size may be specified for stand-alone objects via an
               attribute_definition_clause; the expression of such a
               clause shall be static and its value nonnegative.

                        _Implementation Advice_

41.1/2
The size of an array object should not include its bounds.

42/2
The recommended level of support for the Size attribute of objects is
the same as for subtypes (see below), except that only a confirming Size
clause need be supported for an aliased elementary object.

43/2
   * This paragraph was deleted.

                          _Static Semantics_

44
For every subtype S:

45
S'Size
               If S is definite, denotes the size (in bits) that the
               implementation would choose for the following objects of
               subtype S:

46
                  * A record component of subtype S when the record type
                    is packed.

47
                  * The formal parameter of an instance of
                    Unchecked_Conversion that converts from subtype S to
                    some other subtype.

48
               If S is indefinite, the meaning is implementation
               defined.  The value of this attribute is of the type
               universal_integer. The Size of an object is at least as
               large as that of its subtype, unless the object's Size is
               determined by a Size clause, a component_clause, or a
               Component_Size clause.  Size may be specified for first
               subtypes via an attribute_definition_clause (*note 13.3:
               S0310.); the expression of such a clause shall be static
               and its value nonnegative.

                     _Implementation Requirements_

49
In an implementation, Boolean'Size shall be 1.

                        _Implementation Advice_

50/2
If the Size of a subtype allows for efficient independent addressability
(see *note 9.10::) on the target architecture, then the Size of the
following objects of the subtype should equal the Size of the subtype:

51
   * Aliased objects (including components).

52
   * Unaliased components, unless the Size of the component is
     determined by a component_clause or Component_Size clause.

53
A Size clause on a composite subtype should not affect the internal
layout of components.

54
The recommended level of support for the Size attribute of subtypes is:

55
   * The Size (if not specified) of a static discrete or fixed point
     subtype should be the number of bits needed to represent each value
     belonging to the subtype using an unbiased representation, leaving
     space for a sign bit only if the subtype contains negative values.
     If such a subtype is a first subtype, then an implementation should
     support a specified Size for it that reflects this representation.

56
   * For a subtype implemented with levels of indirection, the Size
     should include the size of the pointers, but not the size of what
     they point at.

56.1/2
   * An implementation should support a Size clause for a discrete type,
     fixed point type, record type, or array type, subject to the
     following:

56.2/2
             * An implementation need not support a Size clause for a
               signed integer type specifying a Size greater than that
               of the largest signed integer type supported by the
               implementation in the absence of a size clause (that is,
               when the size is chosen by default).  A corresponding
               limitation may be imposed for modular integer types,
               fixed point types, enumeration types, record types, and
               array types.

56.3/2
             * A nonconfirming size clause for the first subtype of a
               derived untagged by-reference type need not be supported.

     NOTES

57
     6  Size is a subtype-specific attribute.

58/3
     7  A component_clause or Component_Size clause can override a
     specified Size.  Aspect Pack cannot.

                          _Static Semantics_

59/1
For a prefix T that denotes a task object (after any implicit
dereference):

60/3
T'Storage_Size
               Denotes the number of storage elements reserved for the
               task.  The value of this attribute is of the type
               universal_integer.  The Storage_Size includes the size of
               the task's stack, if any.  The language does not specify
               whether or not it includes other storage associated with
               the task (such as the "task control block" used by some
               implementations.)  If the aspect Storage_Size is
               specified for the type of the object, the value of the
               Storage_Size attribute is at least the value determined
               by the aspect.

61/3
Aspect Storage_Size specifies the amount of storage to be reserved for
the execution of a task.

Paragraphs 62 through 65 were moved to *note Annex J::, "*note Annex J::
Obsolescent Features".

                          _Static Semantics_

65.1/3
For a task type (including the anonymous type of a
single_task_declaration), the following language-defined representation
aspect may be specified:

65.2/3
Storage_Size
               The Storage_Size aspect is an expression, which shall be
               of any integer type.

                           _Legality Rules_

65.3/3
The Storage_Size aspect shall not be specified for a task interface
type.

                          _Dynamic Semantics_

66/3
When a task object is created, the expression (if any) associated with
the Storage_Size aspect of its type is evaluated; the Storage_Size
attribute of the newly created task object is at least the value of the
expression.

67
At the point of task object creation, or upon task activation,
Storage_Error is raised if there is insufficient free storage to
accommodate the requested Storage_Size.

                          _Static Semantics_

68/1
For a prefix X that denotes an array subtype or array object (after any
implicit dereference):

69
X'Component_Size
               Denotes the size in bits of components of the type of X.
               The value of this attribute is of type universal_integer.

70
               Component_Size may be specified for array types via an
               attribute_definition_clause (*note 13.3: S0310.); the
               expression of such a clause shall be static, and its
               value nonnegative.

                        _Implementation Advice_

71
The recommended level of support for the Component_Size attribute is:

72
   * An implementation need not support specified Component_Sizes that
     are less than the Size of the component subtype.

73/3
   * An implementation should support specified Component_Sizes that are
     factors and multiples of the word size.  For such Component_Sizes,
     the array should contain no gaps between components.  For other
     Component_Sizes (if supported), the array should contain no gaps
     between components when Pack is also specified; the implementation
     should forbid this combination in cases where it cannot support a
     no-gaps representation.

                          _Static Semantics_

73.1/3
For a prefix X that denotes an object:

73.2/4
X'Has_Same_Storage
               X'Has_Same_Storage denotes a function with the following
               specification:

73.3/3
                    function X'Has_Same_Storage (Arg : any_type)
                      return Boolean

73.4/4
               The actual parameter shall be a name that denotes an
               object.  The object denoted by the actual parameter can
               be of any type.  This function evaluates the names of the
               objects involved.  It returns True if the representation
               of the object denoted by the actual parameter occupies
               exactly the same bits as the representation of the object
               denoted by X and the objects occupy at least one bit;
               otherwise, it returns False.

73.5/3
For a prefix X that denotes an object:

73.6/3
X'Overlaps_Storage
               X'Overlaps_Storage denotes a function with the following
               specification:

73.7/3
                    function X'Overlaps_Storage (Arg : any_type)
                      return Boolean

73.8/3
               The actual parameter shall be a name that denotes an
               object.  The object denoted by the actual parameter can
               be of any type.  This function evaluates the names of the
               objects involved and returns True if the representation
               of the object denoted by the actual parameter shares at
               least one bit with the representation of the object
               denoted by X; otherwise, it returns False.

     NOTES

73.9/3
     8  X'Has_Same_Storage(Y) implies X'Overlaps_Storage(Y).

73.10/3
     9  X'Has_Same_Storage(Y) and X'Overlaps_Storage(Y) are not
     considered to be reads of X and Y.

                          _Static Semantics_

73.11/3
The following type-related operational attribute is defined:
External_Tag.

74/1
For every subtype S of a tagged type T (specific or class-wide):

75/3
S'External_Tag
               S'External_Tag denotes an external string representation
               for S'Tag; it is of the predefined type String.
               External_Tag may be specified for a specific tagged type
               via an attribute_definition_clause; the expression of
               such a clause shall be static.  The default external tag
               representation is implementation defined.  See *note
               13.13.2::.  The value of External_Tag is never inherited;
               the default value is always used unless a new value is
               directly specified for a type.

                          _Dynamic Semantics_

75.1/3
If a user-specified external tag S'External_Tag is the same as
T'External_Tag for some other tagged type declared by a different
declaration in the partition, Program_Error is raised by the elaboration
of the attribute_definition_clause.

                     _Implementation Requirements_

76
In an implementation, the default external tag for each specific tagged
type declared in a partition shall be distinct, so long as the type is
declared outside an instance of a generic body.  If the compilation unit
in which a given tagged type is declared, and all compilation units on
which it semantically depends, are the same in two different partitions,
then the external tag for the type shall be the same in the two
partitions.  What it means for a compilation unit to be the same in two
different partitions is implementation defined.  At a minimum, if the
compilation unit is not recompiled between building the two different
partitions that include it, the compilation unit is considered the same
in the two partitions.

                     _Implementation Permissions_

76.1/3
If a user-specified external tag S'External_Tag is the same as
T'External_Tag for some other tagged type declared by a different
declaration in the partition, the partition may be rejected.

     NOTES

77/2
     10  The following language-defined attributes are specifiable, at
     least for some of the kinds of entities to which they apply:
     Address, Alignment, Bit_Order, Component_Size, External_Tag, Input,
     Machine_Radix, Output, Read, Size, Small, Storage_Pool,
     Storage_Size, Stream_Size, and Write.

78
     11  It follows from the general rules in *note 13.1:: that if one
     writes "for X'Size use Y;" then the X'Size attribute_reference will
     return Y (assuming the implementation allows the Size clause).  The
     same is true for all of the specifiable attributes except
     Storage_Size.

                              _Examples_

79
Examples of attribute definition clauses:

80
     Byte : constant := 8;
     Page : constant := 2**12;

81
     type Medium is range 0 .. 65_000;
     for Medium'Size use 2*Byte;
     for Medium'Alignment use 2;
     Device_Register : Medium;
     for Device_Register'Size use Medium'Size;
     for Device_Register'Address use System.Storage_Elements.To_Address(16#FFFF_0020#);

82
     type Short is delta 0.01 range -100.0 .. 100.0;
     for Short'Size use 15;

83
     for Car_Name'Storage_Size use -- specify access type's storage pool size
             2000*((Car'Size/System.Storage_Unit) +1); -- approximately 2000 cars

84/2
     function My_Input(Stream : not null access Ada.Streams.Root_Stream_Type'Class)
       return T;
     for T'Input use My_Input; -- see *note 13.13.2::

     NOTES

85
     12  Notes on the examples: In the Size clause for Short, fifteen
     bits is the minimum necessary, since the type definition requires
     Short'Small <= 2**(-7).


File: arm2012.info,  Node: 13.4,  Next: 13.5,  Prev: 13.3,  Up: 13

13.4 Enumeration Representation Clauses
=======================================

1
An enumeration_representation_clause specifies the internal codes for
enumeration literals.

                               _Syntax_

2
     enumeration_representation_clause ::=
         for first_subtype_local_name use enumeration_aggregate;

3
     enumeration_aggregate ::= array_aggregate

                        _Name Resolution Rules_

4
The enumeration_aggregate shall be written as a one-dimensional
array_aggregate, for which the index subtype is the unconstrained
subtype of the enumeration type, and each component expression is
expected to be of any integer type.

                           _Legality Rules_

5
The first_subtype_local_name of an enumeration_representation_clause
shall denote an enumeration subtype.

6/2
Each component of the array_aggregate shall be given by an expression
rather than a <>.  The expressions given in the array_aggregate shall be
static, and shall specify distinct integer codes for each value of the
enumeration type; the associated integer codes shall satisfy the
predefined ordering relation of the type.

                          _Static Semantics_

7
An enumeration_representation_clause specifies the coding aspect of
representation. The coding consists of the internal code for each
enumeration literal, that is, the integral value used internally to
represent each literal.

                     _Implementation Requirements_

8
For nonboolean enumeration types, if the coding is not specified for the
type, then for each value of the type, the internal code shall be equal
to its position number.

                        _Implementation Advice_

9
The recommended level of support for enumeration_representation_clauses
is:

10
   * An implementation should support at least the internal codes in the
     range System.Min_Int..System.Max_Int.  An implementation need not
     support enumeration_representation_clause (*note 13.4: S0311.)s for
     boolean types.

     NOTES

11/3
     13  Unchecked_Conversion may be used to query the internal codes
     used for an enumeration type.  The attributes of the type, such as
     Succ, Pred, and Pos, are unaffected by the
     enumeration_representation_clause.  For example, Pos always returns
     the position number, not the internal integer code that might have
     been specified in an enumeration_representation_clause.

                              _Examples_

12
Example of an enumeration representation clause:

13
     type Mix_Code is (ADD, SUB, MUL, LDA, STA, STZ);

14
     for Mix_Code use
        (ADD => 1, SUB => 2, MUL => 3, LDA => 8, STA => 24, STZ =>33);


File: arm2012.info,  Node: 13.5,  Next: 13.6,  Prev: 13.4,  Up: 13

13.5 Record Layout
==================

1
The (record) layout aspect of representation consists of the storage
places for some or all components, that is, storage place attributes of
the components.  The layout can be specified with a
record_representation_clause (*note 13.5.1: S0313.).

* Menu:

* 13.5.1 ::   Record Representation Clauses
* 13.5.2 ::   Storage Place Attributes
* 13.5.3 ::   Bit Ordering


File: arm2012.info,  Node: 13.5.1,  Next: 13.5.2,  Up: 13.5

13.5.1 Record Representation Clauses
------------------------------------

1
A record_representation_clause specifies the storage representation of
records and record extensions, that is, the order, position, and size of
components (including discriminants, if any). 

                               _Syntax_

2
     record_representation_clause ::=
         for first_subtype_local_name use
           record [mod_clause]
             {component_clause}
           end record;

3
     component_clause ::=
         component_local_name at position range first_bit .. last_bit;

4
     position ::= static_expression

5
     first_bit ::= static_simple_expression

6
     last_bit ::= static_simple_expression

                        _Name Resolution Rules_

7
Each position, first_bit, and last_bit is expected to be of any integer
type.

                           _Legality Rules_

8/2
The first_subtype_local_name of a record_representation_clause shall
denote a specific record or record extension subtype.

9
If the component_local_name is a direct_name, the local_name shall
denote a component of the type.  For a record extension, the component
shall not be inherited, and shall not be a discriminant that corresponds
to a discriminant of the parent type.  If the component_local_name
(*note 13.1: S0306.) has an attribute_designator (*note 4.1.4: S0101.),
the direct_name (*note 4.1: S0092.) of the local_name (*note 13.1:
S0306.) shall denote either the declaration of the type or a component
of the type, and the attribute_designator (*note 4.1.4: S0101.) shall
denote an implementation-defined implicit component of the type.

10
The position, first_bit, and last_bit shall be static expressions.  The
value of position and first_bit shall be nonnegative.  The value of
last_bit shall be no less than first_bit - 1.

10.1/2
If the nondefault bit ordering applies to the type, then either:

10.2/2
   * the value of last_bit shall be less than the size of the largest
     machine scalar; or

10.3/2
   * the value of first_bit shall be zero and the value of last_bit + 1
     shall be a multiple of System.Storage_Unit.

11
At most one component_clause is allowed for each component of the type,
including for each discriminant (component_clauses may be given for
some, all, or none of the components).  Storage places within a
component_list shall not overlap, unless they are for components in
distinct variants of the same variant_part.

12
A name that denotes a component of a type is not allowed within a
record_representation_clause for the type, except as the
component_local_name of a component_clause.

                          _Static Semantics_

13/2
A record_representation_clause (without the mod_clause) specifies the
layout.

13.1/2
If the default bit ordering applies to the type, the position,
first_bit, and last_bit of each component_clause directly specify the
position and size of the corresponding component.

13.2/3
If the nondefault bit ordering applies to the type, then the layout is
determined as follows:

13.3/2
   * the component_clauses for which the value of last_bit is greater
     than or equal to the size of the largest machine scalar directly
     specify the position and size of the corresponding component;

13.4/2
   * for other component_clauses, all of the components having the same
     value of position are considered to be part of a single machine
     scalar, located at that position; this machine scalar has a size
     which is the smallest machine scalar size larger than the largest
     last_bit for all component_clauses at that position; the first_bit
     and last_bit of each component_clause are then interpreted as bit
     offsets in this machine scalar.

14
A record_representation_clause for a record extension does not override
the layout of the parent part; if the layout was specified for the
parent type, it is inherited by the record extension.

                     _Implementation Permissions_

15
An implementation may generate implementation-defined components (for
example, one containing the offset of another component).  An
implementation may generate names that denote such
implementation-defined components; such names shall be
implementation-defined attribute_references.  An implementation may
allow such implementation-defined names to be used in
record_representation_clause (*note 13.5.1: S0313.)s.  An implementation
can restrict such component_clause (*note 13.5.1: S0314.)s in any manner
it sees fit.

16
If a record_representation_clause is given for an untagged derived type,
the storage place attributes for all of the components of the derived
type may differ from those of the corresponding components of the parent
type, even for components whose storage place is not specified
explicitly in the record_representation_clause (*note 13.5.1: S0313.).

                        _Implementation Advice_

17
The recommended level of support for record_representation_clauses is:

17.1/2
   * An implementation should support machine scalars that correspond to
     all of the integer, floating point, and address formats supported
     by the machine.

18
   * An implementation should support storage places that can be
     extracted with a load, mask, shift sequence of machine code, and
     set with a load, shift, mask, store sequence, given the available
     machine instructions and run-time model.

19
   * A storage place should be supported if its size is equal to the
     Size of the component subtype, and it starts and ends on a boundary
     that obeys the Alignment of the component subtype.

20/2
   * For a component with a subtype whose Size is less than the word
     size, any storage place that does not cross an aligned word
     boundary should be supported.

21
   * An implementation may reserve a storage place for the tag field of
     a tagged type, and disallow other components from overlapping that
     place.

22
   * An implementation need not support a component_clause for a
     component of an extension part if the storage place is not after
     the storage places of all components of the parent type, whether or
     not those storage places had been specified.

     NOTES

23
     14  If no component_clause is given for a component, then the
     choice of the storage place for the component is left to the
     implementation.  If component_clauses are given for all components,
     the record_representation_clause completely specifies the
     representation of the type and will be obeyed exactly by the
     implementation.

                              _Examples_

24
Example of specifying the layout of a record type:

25
     Word : constant := 4;  --  storage element is byte, 4 bytes per word

26
     type State         is (A,M,W,P);
     type Mode          is (Fix, Dec, Exp, Signif);

27
     type Byte_Mask     is array (0..7)  of Boolean;
     type State_Mask    is array (State) of Boolean;
     type Mode_Mask     is array (Mode)  of Boolean;

28
     type Program_Status_Word is
       record
           System_Mask        : Byte_Mask;
           Protection_Key     : Integer range 0 .. 3;
           Machine_State      : State_Mask;
           Interrupt_Cause    : Interruption_Code;
           Ilc                : Integer range 0 .. 3;
           Cc                 : Integer range 0 .. 3;
           Program_Mask       : Mode_Mask;
           Inst_Address       : Address;
     end record;

29
     for Program_Status_Word use
       record
           System_Mask      at 0*Word range 0  .. 7;
           Protection_Key   at 0*Word range 10 .. 11; -- bits 8,9 unused
           Machine_State    at 0*Word range 12 .. 15;
           Interrupt_Cause  at 0*Word range 16 .. 31;
           Ilc              at 1*Word range 0  .. 1;  -- second word
           Cc               at 1*Word range 2  .. 3;
           Program_Mask     at 1*Word range 4  .. 7;
           Inst_Address     at 1*Word range 8  .. 31;
       end record;

30
     for Program_Status_Word'Size use 8*System.Storage_Unit;
     for Program_Status_Word'Alignment use 8;

     NOTES

31
     15  Note on the example: The record_representation_clause defines
     the record layout.  The Size clause guarantees that (at least)
     eight storage elements are used for objects of the type.  The
     Alignment clause guarantees that aliased, imported, or exported
     objects of the type will have addresses divisible by eight.


File: arm2012.info,  Node: 13.5.2,  Next: 13.5.3,  Prev: 13.5.1,  Up: 13.5

13.5.2 Storage Place Attributes
-------------------------------

                          _Static Semantics_

1
For a component C of a composite, non-array object R, the storage place
attributes are defined:

2/2
R.C'Position
               If the nondefault bit ordering applies to the composite
               type, and if a component_clause specifies the placement
               of C, denotes the value given for the position of the
               component_clause; otherwise, denotes the same value as
               R.C'Address - R'Address.  The value of this attribute is
               of the type universal_integer.

3/2
R.C'First_Bit
               If the nondefault bit ordering applies to the composite
               type, and if a component_clause specifies the placement
               of C, denotes the value given for the first_bit of the
               component_clause; otherwise, denotes the offset, from the
               start of the first of the storage elements occupied by C,
               of the first bit occupied by C. This offset is measured
               in bits.  The first bit of a storage element is numbered
               zero.  The value of this attribute is of the type
               universal_integer.

4/2
R.C'Last_Bit
               If the nondefault bit ordering applies to the composite
               type, and if a component_clause specifies the placement
               of C, denotes the value given for the last_bit of the
               component_clause; otherwise, denotes the offset, from the
               start of the first of the storage elements occupied by C,
               of the last bit occupied by C. This offset is measured in
               bits.  The value of this attribute is of the type
               universal_integer.

                        _Implementation Advice_

5
If a component is represented using some form of pointer (such as an
offset) to the actual data of the component, and this data is contiguous
with the rest of the object, then the storage place attributes should
reflect the place of the actual data, not the pointer.  If a component
is allocated discontiguously from the rest of the object, then a warning
should be generated upon reference to one of its storage place
attributes.


File: arm2012.info,  Node: 13.5.3,  Prev: 13.5.2,  Up: 13.5

13.5.3 Bit Ordering
-------------------

1
The Bit_Order attribute specifies the interpretation of the storage
place attributes.

                          _Static Semantics_

2
A bit ordering is a method of interpreting the meaning of the storage
place attributes. High_Order_First (known in the vernacular as "big
endian") means that the first bit of a storage element (bit 0) is the
most significant bit (interpreting the sequence of bits that represent a
component as an unsigned integer value). Low_Order_First (known in the
vernacular as "little endian") means the opposite: the first bit is the
least significant.

3
For every specific record subtype S, the following attribute is defined:

4
S'Bit_Order
               Denotes the bit ordering for the type of S. The value of
               this attribute is of type System.Bit_Order. Bit_Order may
               be specified for specific record types via an
               attribute_definition_clause; the expression of such a
               clause shall be static.

5
If Word_Size = Storage_Unit, the default bit ordering is implementation
defined.  If Word_Size > Storage_Unit, the default bit ordering is the
same as the ordering of storage elements in a word, when interpreted as
an integer. 

6
The storage place attributes of a component of a type are interpreted
according to the bit ordering of the type.

                        _Implementation Advice_

7
The recommended level of support for the nondefault bit ordering is:

8/2
   * The implementation should support the nondefault bit ordering in
     addition to the default bit ordering.

     NOTES

9/2
     16  Bit_Order clauses make it possible to write
     record_representation_clauses that can be ported between machines
     having different bit ordering.  They do not guarantee transparent
     exchange of data between such machines.


File: arm2012.info,  Node: 13.6,  Next: 13.7,  Prev: 13.5,  Up: 13

13.6 Change of Representation
=============================

1/3
A type_conversion (see *note 4.6::) can be used to convert between two
different representations of the same array or record.  To convert an
array from one representation to another, two array types need to be
declared with matching component subtypes, and convertible index types.
If one type has Pack specified and the other does not, then explicit
conversion can be used to pack or unpack an array.

2
To convert a record from one representation to another, two record types
with a common ancestor type need to be declared, with no inherited
subprograms.  Distinct representations can then be specified for the
record types, and explicit conversion between the types can be used to
effect a change in representation.

                              _Examples_

3
Example of change of representation:

4
     -- Packed_Descriptor and Descriptor are two different types
     -- with identical characteristics, apart from their
     -- representation

5
     type Descriptor is
         record
           -- components of a descriptor
         end record;

6
     type Packed_Descriptor is new Descriptor;

7
     for Packed_Descriptor use
         record
           -- component clauses for some or for all components
         end record;

8
     -- Change of representation can now be accomplished by explicit type conversions:

9
     D : Descriptor;
     P : Packed_Descriptor;

10
     P := Packed_Descriptor(D);  -- pack D
     D := Descriptor(P);         -- unpack P


File: arm2012.info,  Node: 13.7,  Next: 13.8,  Prev: 13.6,  Up: 13

13.7 The Package System
=======================

1
For each implementation there is a library package called System which
includes the definitions of certain configuration-dependent
characteristics.

                          _Static Semantics_

2
The following language-defined library package exists:

3/2
     package System is
        pragma Pure(System);

4
        type Name is implementation-defined-enumeration-type;
        System_Name : constant Name := implementation-defined;

5
        -- System-Dependent Named Numbers:

6
        Min_Int               : constant := root_integer'First;
        Max_Int               : constant := root_integer'Last;

7
        Max_Binary_Modulus    : constant := implementation-defined;
        Max_Nonbinary_Modulus : constant := implementation-defined;

8
        Max_Base_Digits       : constant := root_real'Digits;
        Max_Digits            : constant := implementation-defined;

9
        Max_Mantissa          : constant := implementation-defined;
        Fine_Delta            : constant := implementation-defined;

10
        Tick                  : constant := implementation-defined;

11
        -- Storage-related Declarations:

12
        type Address is implementation-defined;
        Null_Address : constant Address;

13
        Storage_Unit : constant := implementation-defined;
        Word_Size    : constant := implementation-defined * Storage_Unit;
        Memory_Size  : constant := implementation-defined;

14/3
        -- Address Comparison:
        function "<" (Left, Right : Address) return Boolean
           with Convention => Intrinsic;
        function "<="(Left, Right : Address) return Boolean
           with Convention => Intrinsic;
        function ">" (Left, Right : Address) return Boolean
           with Convention => Intrinsic;
        function ">="(Left, Right : Address) return Boolean
           with Convention => Intrinsic;
        function "=" (Left, Right : Address) return Boolean
           with Convention => Intrinsic;
     -- function "/=" (Left, Right : Address) return Boolean;
        -- "/=" is implicitly defined

15/2
        -- Other System-Dependent Declarations:
        type Bit_Order is (High_Order_First, Low_Order_First);
        Default_Bit_Order : constant Bit_Order := implementation-defined;

16
        -- Priority-related declarations (see *note D.1::):
        subtype Any_Priority is Integer range implementation-defined;
        subtype Priority is Any_Priority range Any_Priority'First ..
                  implementation-defined;
        subtype Interrupt_Priority is Any_Priority range Priority'Last+1 ..
                  Any_Priority'Last;

17
        Default_Priority : constant Priority :=
                  (Priority'First + Priority'Last)/2;

18
     private
        ... -- not specified by the language
     end System;

19
Name is an enumeration subtype.  Values of type Name are the names of
alternative machine configurations handled by the implementation.
System_Name represents the current machine configuration.

20
The named numbers Fine_Delta and Tick are of the type universal_real;
the others are of the type universal_integer.

21
The meanings of the named numbers are:

22
Min_Int
               The smallest (most negative) value allowed for the
               expressions of a signed_integer_type_definition (*note
               3.5.4: S0042.).

23
Max_Int
               The largest (most positive) value allowed for the
               expressions of a signed_integer_type_definition (*note
               3.5.4: S0042.).

24
Max_Binary_Modulus
               A power of two such that it, and all lesser positive
               powers of two, are allowed as the modulus of a
               modular_type_definition.

25
Max_Nonbinary_Modulus
               A value such that it, and all lesser positive integers,
               are allowed as the modulus of a modular_type_definition.

26
Max_Base_Digits
               The largest value allowed for the requested decimal
               precision in a floating_point_definition (*note 3.5.7:
               S0045.).

27
Max_Digits
               The largest value allowed for the requested decimal
               precision in a floating_point_definition (*note 3.5.7:
               S0045.) that has no real_range_specification (*note
               3.5.7: S0046.).  Max_Digits is less than or equal to
               Max_Base_Digits.

28
Max_Mantissa
               The largest possible number of binary digits in the
               mantissa of machine numbers of a user-defined ordinary
               fixed point type.  (The mantissa is defined in *note
               Annex G::.)

29
Fine_Delta
               The smallest delta allowed in an
               ordinary_fixed_point_definition that has the
               real_range_specification (*note 3.5.7: S0046.) range -1.0
               ..  1.0.

30
Tick
               A period in seconds approximating the real time interval
               during which the value of Calendar.Clock remains
               constant.

31
Storage_Unit
               The number of bits per storage element.

32
Word_Size
               The number of bits per word.

33
Memory_Size
               An implementation-defined value that is intended to
               reflect the memory size of the configuration in storage
               elements.

34/2
Address is a definite, nonlimited type with preelaborable initialization
(see *note 10.2.1::).  Address represents machine addresses capable of
addressing individual storage elements.  Null_Address is an address that
is distinct from the address of any object or program unit. 

35/2
Default_Bit_Order shall be a static constant.  See *note 13.5.3:: for an
explanation of Bit_Order and Default_Bit_Order.

                     _Implementation Permissions_

36/2
An implementation may add additional implementation-defined declarations
to package System and its children.  However, it is usually better for
the implementation to provide additional functionality via
implementation-defined children of System.

                        _Implementation Advice_

37
Address should be a private type.

     NOTES

38
     17  There are also some language-defined child packages of System
     defined elsewhere.

* Menu:

* 13.7.1 ::   The Package System.Storage_Elements
* 13.7.2 ::   The Package System.Address_To_Access_Conversions


File: arm2012.info,  Node: 13.7.1,  Next: 13.7.2,  Up: 13.7

13.7.1 The Package System.Storage_Elements
------------------------------------------

                          _Static Semantics_

1
The following language-defined library package exists:

2/2
     package System.Storage_Elements is
        pragma Pure(Storage_Elements);

3
        type Storage_Offset is range implementation-defined;

4
        subtype Storage_Count is Storage_Offset range 0..Storage_Offset'Last;

5
        type Storage_Element is mod implementation-defined;
        for Storage_Element'Size use Storage_Unit;
        type Storage_Array is array
          (Storage_Offset range <>) of aliased Storage_Element;
        for Storage_Array'Component_Size use Storage_Unit;

6
        -- Address Arithmetic:

7/3
        function "+"(Left : Address; Right : Storage_Offset) return Address
           with Convention => Intrinsic;
        function "+"(Left : Storage_Offset; Right : Address) return Address
           with Convention => Intrinsic;
        function "-"(Left : Address; Right : Storage_Offset) return Address
           with Convention => Intrinsic;
        function "-"(Left, Right : Address) return Storage_Offset
           with Convention => Intrinsic;

8/3
        function "mod"(Left : Address; Right : Storage_Offset)
           return Storage_Offset
              with Convention => Intrinsic;

9
        -- Conversion to/from integers:

10/3
        type Integer_Address is implementation-defined;
        function To_Address(Value : Integer_Address) return Address
           with Convention => Intrinsic;
        function To_Integer(Value : Address) return Integer_Address
           with Convention => Intrinsic;

11/3
     end System.Storage_Elements;

12
Storage_Element represents a storage element.  Storage_Offset represents
an offset in storage elements.  Storage_Count represents a number of
storage elements. Storage_Array represents a contiguous sequence of
storage elements.

13
Integer_Address is a (signed or modular) integer subtype.  To_Address
and To_Integer convert back and forth between this type and Address.

                     _Implementation Requirements_

14
Storage_Offset'Last shall be greater than or equal to Integer'Last or
the largest possible storage offset, whichever is smaller.
Storage_Offset'First shall be <= (-Storage_Offset'Last).

Paragraph 15 was deleted.

                        _Implementation Advice_

16
Operations in System and its children should reflect the target
environment semantics as closely as is reasonable.  For example, on most
machines, it makes sense for address arithmetic to "wrap around."
Operations that do not make sense should raise Program_Error.


File: arm2012.info,  Node: 13.7.2,  Prev: 13.7.1,  Up: 13.7

13.7.2 The Package System.Address_To_Access_Conversions
-------------------------------------------------------

                          _Static Semantics_

1
The following language-defined generic library package exists:

2
     generic
         type Object(<>) is limited private;
     package System.Address_To_Access_Conversions is
        pragma Preelaborate(Address_To_Access_Conversions);

3/3
        type Object_Pointer is access all Object;
        function To_Pointer(Value : Address) return Object_Pointer
           with Convention => Intrinsic;
        function To_Address(Value : Object_Pointer) return Address
           with Convention => Intrinsic;

4/3
     end System.Address_To_Access_Conversions;

5/2
The To_Pointer and To_Address subprograms convert back and forth between
values of types Object_Pointer and Address.  To_Pointer(X'Address) is
equal to X'Unchecked_Access for any X that allows Unchecked_Access.
To_Pointer(Null_Address) returns null. For other addresses, the behavior
is unspecified.  To_Address(null) returns Null_Address.  To_Address(Y),
where Y /= null, returns Y.all'Address.

                     _Implementation Permissions_

6
An implementation may place restrictions on instantiations of
Address_To_Access_Conversions.


File: arm2012.info,  Node: 13.8,  Next: 13.9,  Prev: 13.7,  Up: 13

13.8 Machine Code Insertions
============================

1
A machine code insertion can be achieved by a call to a subprogram whose
sequence_of_statements contains code_statements.

                               _Syntax_

2
     code_statement ::= qualified_expression;

3
     A code_statement is only allowed in the
     handled_sequence_of_statements (*note 11.2: S0265.) of a
     subprogram_body (*note 6.3: S0177.).  If a subprogram_body (*note
     6.3: S0177.) contains any code_statement (*note 13.8: S0318.)s,
     then within this subprogram_body (*note 6.3: S0177.) the only
     allowed form of statement is a code_statement (*note 13.8: S0318.)
     (labeled or not), the only allowed declarative_item (*note 3.11:
     S0087.)s are use_clause (*note 8.4: S0196.)s, and no
     exception_handler (*note 11.2: S0266.) is allowed (comments and
     pragmas are allowed as usual).

                        _Name Resolution Rules_

4
The qualified_expression is expected to be of any type.

                           _Legality Rules_

5
The qualified_expression shall be of a type declared in package
System.Machine_Code.

6
A code_statement shall appear only within the scope of a with_clause
that mentions package System.Machine_Code.

                          _Static Semantics_

7
The contents of the library package System.Machine_Code (if provided)
are implementation defined.  The meaning of code_statements is
implementation defined.  Typically, each qualified_expression represents
a machine instruction or assembly directive.

                     _Implementation Permissions_

8
An implementation may place restrictions on code_statements.  An
implementation is not required to provide package System.Machine_Code.

     NOTES

9
     18  An implementation may provide implementation-defined pragmas
     specifying register conventions and calling conventions.

10/2
     19  Machine code functions are exempt from the rule that a return
     statement is required.  In fact, return statements are forbidden,
     since only code_statements are allowed.

11
     20  Intrinsic subprograms (see *note 6.3.1::, "*note 6.3.1::
     Conformance Rules") can also be used to achieve machine code
     insertions.  Interface to assembly language can be achieved using
     the features in *note Annex B::, "*note Annex B:: Interface to
     Other Languages".

                              _Examples_

12
Example of a code statement:

13/3
     M : Mask;
     procedure Set_Mask
       with Inline;

14
     procedure Set_Mask is
       use System.Machine_Code; -- assume "with System.Machine_Code;" appears somewhere above
     begin
       SI_Format'(Code => SSM, B => M'Base_Reg, D => M'Disp);
       --  Base_Reg and Disp are implementation-defined attributes
     end Set_Mask;


File: arm2012.info,  Node: 13.9,  Next: 13.10,  Prev: 13.8,  Up: 13

13.9 Unchecked Type Conversions
===============================

1
An unchecked type conversion can be achieved by a call to an instance of
the generic function Unchecked_Conversion.

                          _Static Semantics_

2
The following language-defined generic library function exists:

3/3
     generic
        type Source(<>) is limited private;
        type Target(<>) is limited private;
     function Ada.Unchecked_Conversion(S : Source) return Target
        with Convention => Intrinsic;
     pragma Pure(Ada.Unchecked_Conversion);

                          _Dynamic Semantics_

4
The size of the formal parameter S in an instance of
Unchecked_Conversion is that of its subtype.  This is the actual subtype
passed to Source, except when the actual is an unconstrained composite
subtype, in which case the subtype is constrained by the bounds or
discriminants of the value of the actual expression passed to S.

5
If all of the following are true, the effect of an unchecked conversion
is to return the value of an object of the target subtype whose
representation is the same as that of the source object S:

6
   * S'Size = Target'Size.

7/3
   * S'Alignment is a multiple of Target'Alignment or Target'Alignment
     is zero.

8
   * The target subtype is not an unconstrained composite subtype.

9
   * S and the target subtype both have a contiguous representation.

10
   * The representation of S is a representation of an object of the
     target subtype.

11/2
Otherwise, if the result type is scalar, the result of the function is
implementation defined, and can have an invalid representation (see
*note 13.9.1::).  If the result type is nonscalar, the effect is
implementation defined; in particular, the result can be abnormal (see
*note 13.9.1::).

                     _Implementation Permissions_

12
An implementation may return the result of an unchecked conversion by
reference, if the Source type is not a by-copy type.  In this case, the
result of the unchecked conversion represents simply a different
(read-only) view of the operand of the conversion.

13
An implementation may place restrictions on Unchecked_Conversion.

                        _Implementation Advice_

14/2
Since the Size of an array object generally does not include its bounds,
the bounds should not be part of the converted data.

15
The implementation should not generate unnecessary run-time checks to
ensure that the representation of S is a representation of the target
type.  It should take advantage of the permission to return by reference
when possible.  Restrictions on unchecked conversions should be avoided
unless required by the target environment.

16
The recommended level of support for unchecked conversions is:

17/3
   * Unchecked conversions should be supported and should be reversible
     in the cases where this subclause defines the result. To enable
     meaningful use of unchecked conversion, a contiguous representation
     should be used for elementary subtypes, for statically constrained
     array subtypes whose component subtype is one of the subtypes
     described in this paragraph, and for record subtypes without
     discriminants whose component subtypes are described in this
     paragraph.

* Menu:

* 13.9.1 ::   Data Validity
* 13.9.2 ::   The Valid Attribute


File: arm2012.info,  Node: 13.9.1,  Next: 13.9.2,  Up: 13.9

13.9.1 Data Validity
--------------------

1
Certain actions that can potentially lead to erroneous execution are not
directly erroneous, but instead can cause objects to become abnormal.
Subsequent uses of abnormal objects can be erroneous.

2
A scalar object can have an invalid representation, which means that the
object's representation does not represent any value of the object's
subtype. The primary cause of invalid representations is uninitialized
variables.

3
Abnormal objects and invalid representations are explained in this
subclause.

                          _Dynamic Semantics_

4
When an object is first created, and any explicit or default
initializations have been performed, the object and all of its parts are
in the normal state.  Subsequent operations generally leave them normal.
However, an object or part of an object can become abnormal in the
following ways:

5
   * An assignment to the object is disrupted due to an abort (see *note
     9.8::) or due to the failure of a language-defined check (see *note
     11.6::).

6/2
   * The object is not scalar, and is passed to an in out or out
     parameter of an imported procedure, the Read procedure of an
     instance of Sequential_IO, Direct_IO, or Storage_IO, or the stream
     attribute T'Read, if after return from the procedure the
     representation of the parameter does not represent a value of the
     parameter's subtype.

6.1/2
   * The object is the return object of a function call of a nonscalar
     type, and the function is an imported function, an instance of
     Unchecked_Conversion, or the stream attribute T'Input, if after
     return from the function the representation of the return object
     does not represent a value of the function's subtype.

6.2/2
For an imported object, it is the programmer's responsibility to ensure
that the object remains in a normal state.

7
Whether or not an object actually becomes abnormal in these cases is not
specified.  An abnormal object becomes normal again upon successful
completion of an assignment to the object as a whole.

                         _Erroneous Execution_

8
It is erroneous to evaluate a primary that is a name denoting an
abnormal object, or to evaluate a prefix that denotes an abnormal
object.

                      _Bounded (Run-Time) Errors_

9
If the representation of a scalar object does not represent a value of
the object's subtype (perhaps because the object was not initialized),
the object is said to have an invalid representation.  It is a bounded
error to evaluate the value of such an object. If the error is detected,
either Constraint_Error or Program_Error is raised.  Otherwise,
execution continues using the invalid representation.  The rules of the
language outside this subclause assume that all objects have valid
representations.  The semantics of operations on invalid representations
are as follows:

10
   * If the representation of the object represents a value of the
     object's type, the value of the type is used.

11
   * If the representation of the object does not represent a value of
     the object's type, the semantics of operations on such
     representations is implementation-defined, but does not by itself
     lead to erroneous or unpredictable execution, or to other objects
     becoming abnormal.

                         _Erroneous Execution_

12/3
A call to an imported function or an instance of Unchecked_Conversion is
erroneous if the result is scalar, the result object has an invalid
representation, and the result is used other than as the expression of
an assignment_statement or an object_declaration, as the object_name of
an object_renaming_declaration, or as the prefix of a Valid attribute.
If such a result object is used as the source of an assignment, and the
assigned value is an invalid representation for the target of the
assignment, then any use of the target object prior to a further
assignment to the target object, other than as the prefix of a Valid
attribute reference, is erroneous.

13/3
The dereference of an access value is erroneous if it does not designate
an object of an appropriate type or a subprogram with an appropriate
profile, if it designates a nonexistent object, or if it is an
access-to-variable value that designates a constant object and it did
not originate from an attribute_reference applied to an aliased variable
view of a controlled or immutably limited object.  An access value whose
dereference is erroneous can exist, for example, because of
Unchecked_Deallocation, Unchecked_Access, or Unchecked_Conversion.

     NOTES

14
     21  Objects can become abnormal due to other kinds of actions that
     directly update the object's representation; such actions are
     generally considered directly erroneous, however.


File: arm2012.info,  Node: 13.9.2,  Prev: 13.9.1,  Up: 13.9

13.9.2 The Valid Attribute
--------------------------

1
The Valid attribute can be used to check the validity of data produced
by unchecked conversion, input, interface to foreign languages, and the
like.

                          _Static Semantics_

2
For a prefix X that denotes a scalar object (after any implicit
dereference), the following attribute is defined:

3/4
X'Valid
               Yields True if and only if the object denoted by X is
               normal, has a valid representation, and then, if the
               preceding conditions hold, the value of X also satisfies
               the predicates of the nominal subtype of X. The value of
               this attribute is of the predefined type Boolean.

     NOTES

4
     22  Invalid data can be created in the following cases (not
     counting erroneous or unpredictable execution):

5
        * an uninitialized scalar object,

6
        * the result of an unchecked conversion,

7
        * input,

8
        * interface to another language (including machine code),

9
        * aborting an assignment,

10
        * disrupting an assignment due to the failure of a
          language-defined check (see *note 11.6::), and

11
        * use of an object whose Address has been specified.

12/4
     23  Determining whether X is normal and has a valid representation
     as part of the evaluation of X'Valid is not considered to include
     an evaluation of X; hence, it is not an error to check the validity
     of an object that is invalid or abnormal.  Determining whether X
     satisfies the predicates of its nominal subtype may include an
     evaluation of X, but only after it has been determined that X has a
     valid representation.

13/4
     If X is volatile, the evaluation of X'Valid is considered a read of
     X.

14/2
     24  The Valid attribute may be used to check the result of calling
     an instance of Unchecked_Conversion (or any other operation that
     can return invalid values).  However, an exception handler should
     also be provided because implementations are permitted to raise
     Constraint_Error or Program_Error if they detect the use of an
     invalid representation (see *note 13.9.1::).


File: arm2012.info,  Node: 13.10,  Next: 13.11,  Prev: 13.9,  Up: 13

13.10 Unchecked Access Value Creation
=====================================

1
The attribute Unchecked_Access is used to create access values in an
unsafe manner -- the programmer is responsible for preventing "dangling
references."

                          _Static Semantics_

2
The following attribute is defined for a prefix X that denotes an
aliased view of an object:

3
X'Unchecked_Access
               All rules and semantics that apply to X'Access (see *note
               3.10.2::) apply also to X'Unchecked_Access, except that,
               for the purposes of accessibility rules and checks, it is
               as if X were declared immediately within a library
               package. 

     NOTES

4
     25  This attribute is provided to support the situation where a
     local object is to be inserted into a global linked data structure,
     when the programmer knows that it will always be removed from the
     data structure prior to exiting the object's scope.  The Access
     attribute would be illegal in this case (see *note 3.10.2::, "*note
     3.10.2:: Operations of Access Types").

5
     26  There is no Unchecked_Access attribute for subprograms.


File: arm2012.info,  Node: 13.11,  Next: 13.12,  Prev: 13.10,  Up: 13

13.11 Storage Management
========================

1
Each access-to-object type has an associated storage pool.  The storage
allocated by an allocator comes from the pool; instances of
Unchecked_Deallocation return storage to the pool.  Several access types
can share the same pool.

2/2
A storage pool is a variable of a type in the class rooted at
Root_Storage_Pool, which is an abstract limited controlled type.  By
default, the implementation chooses a standard storage pool for each
access-to-object type.  The user may define new pool types, and may
override the choice of pool for an access-to-object type by specifying
Storage_Pool for the type.

                           _Legality Rules_

3
If Storage_Pool is specified for a given access type, Storage_Size shall
not be specified for it.

                          _Static Semantics_

4
The following language-defined library package exists:

5
     with Ada.Finalization;
     with System.Storage_Elements;
     package System.Storage_Pools is
         pragma Preelaborate(System.Storage_Pools);

6/2
         type Root_Storage_Pool is
             abstract new Ada.Finalization.Limited_Controlled with private;
         pragma Preelaborable_Initialization(Root_Storage_Pool);

7
         procedure Allocate(
           Pool : in out Root_Storage_Pool;
           Storage_Address : out Address;
           Size_In_Storage_Elements : in Storage_Elements.Storage_Count;
           Alignment : in Storage_Elements.Storage_Count) is abstract;

8
         procedure Deallocate(
           Pool : in out Root_Storage_Pool;
           Storage_Address : in Address;
           Size_In_Storage_Elements : in Storage_Elements.Storage_Count;
           Alignment : in Storage_Elements.Storage_Count) is abstract;

9
         function Storage_Size(Pool : Root_Storage_Pool)
             return Storage_Elements.Storage_Count is abstract;

10
     private
        ... -- not specified by the language
     end System.Storage_Pools;

11
A storage pool type (or pool type) is a descendant of Root_Storage_Pool.
The elements of a storage pool are the objects allocated in the pool by
allocators.

12/2
For every access-to-object subtype S, the following representation
attributes are defined:

13
S'Storage_Pool
               Denotes the storage pool of the type of S. The type of
               this attribute is Root_Storage_Pool'Class.

14
S'Storage_Size
               Yields the result of calling
               Storage_Size(S'Storage_Pool), which is intended to be a
               measure of the number of storage elements reserved for
               the pool.  The type of this attribute is
               universal_integer.

15
Storage_Size or Storage_Pool may be specified for a nonderived
access-to-object type via an attribute_definition_clause (*note 13.3:
S0310.); the name in a Storage_Pool clause shall denote a variable.

16/3
An allocator of a type T that does not support subpools allocates
storage from T's storage pool.  If the storage pool is a user-defined
object, then the storage is allocated by calling Allocate as described
below.  Allocators for types that support subpools are described in
*note 13.11.4::.

17
If Storage_Pool is not specified for a type defined by an
access_to_object_definition, then the implementation chooses a standard
storage pool for it in an implementation-defined manner. In this case,
the exception Storage_Error is raised by an allocator if there is not
enough storage.  It is implementation defined whether or not the
implementation provides user-accessible names for the standard pool
type(s).

18/4
If Storage_Size is specified for an access type T, an
implementation-defined pool P is used for the type.  The Storage_Size of
P is at least that requested, and the storage for P is reclaimed when
the master containing the declaration of the access type is left. If the
implementation cannot satisfy the request, Storage_Error is raised at
the freezing point of type T. The storage pool P is used only for
allocators returning type T or other access types specified to use
T'Storage_Pool.  Storage_Error is raised by an allocator returning such
a type if the storage space of P is exhausted (additional memory is not
allocated).

18.1/4
If neither Storage_Pool nor Storage_Size are specified, then the meaning
of Storage_Size is implementation defined.

19
If Storage_Pool is specified for an access type, then the specified pool
is used.

20
The effect of calling Allocate and Deallocate for a standard storage
pool directly (rather than implicitly via an allocator or an instance of
Unchecked_Deallocation) is unspecified.

                         _Erroneous Execution_

21
If Storage_Pool is specified for an access type, then if Allocate can
satisfy the request, it should allocate a contiguous block of memory,
and return the address of the first storage element in Storage_Address.
The block should contain Size_In_Storage_Elements storage elements, and
should be aligned according to Alignment.  The allocated storage should
not be used for any other purpose while the pool element remains in
existence.  If the request cannot be satisfied, then Allocate should
propagate an exception (such as Storage_Error).  If Allocate behaves in
any other manner, then the program execution is erroneous.

                     _Implementation Requirements_

21.1/3
The Allocate procedure of a user-defined storage pool object P may be
called by the implementation only to allocate storage for a type T whose
pool is P, only at the following points:

21.2/3
   * During the execution of an allocator of type T;

21.3/3
   * During the execution of a return statement for a function whose
     result is built-in-place in the result of an allocator of type T;

21.4/3
   * During the execution of an assignment operation with a target of an
     allocated object of type T with a part that has an unconstrained
     discriminated subtype with defaults.

21.5/3
For each of the calls of Allocate described above, P (equivalent to
T'Storage_Pool) is passed as the Pool parameter.  The
Size_In_Storage_Elements parameter indicates the number of storage
elements to be allocated, and is no more than
D'Max_Size_In_Storage_Elements, where D is the designated subtype of T.
The Alignment parameter is a nonzero integral multiple of D'Alignment if
D is a specific type, and otherwise is a nonzero integral multiple of
the alignment of the specific type identified by the tag of the object
being created; it is unspecified if there is no such value.  The
Alignment parameter is no more than D'Max_Alignment_For_Allocation.  The
result returned in the Storage_Address parameter is used as the address
of the allocated storage, which is a contiguous block of memory of
Size_In_Storage_Elements storage elements.  Any exception propagated by
Allocate is propagated by the construct that contained the call.

21.6/3
The number of calls to Allocate needed to implement an allocator for any
particular type is unspecified. The number of calls to Deallocate needed
to implement an instance of Unchecked_Deallocation (see *note 13.11.2::)
for any particular object is the same as the number of Allocate calls
for that object.

21.7/3
The Deallocate procedure of a user-defined storage pool object P may be
called by the implementation to deallocate storage for a type T whose
pool is P only at the places when an Allocate call is allowed for P,
during the execution of an instance of Unchecked_Deallocation for T, or
as part of the finalization of the collection of T. For such a call of
Deallocate, P (equivalent to T'Storage_Pool) is passed as the Pool
parameter.  The value of the Storage_Address parameter for a call to
Deallocate is the value returned in the Storage_Address parameter of the
corresponding successful call to Allocate.  The values of the
Size_In_Storage_Elements and Alignment parameters are the same values
passed to the corresponding Allocate call.  Any exception propagated by
Deallocate is propagated by the construct that contained the call.

                     _Documentation Requirements_

22
An implementation shall document the set of values that a user-defined
Allocate procedure needs to accept for the Alignment parameter.  An
implementation shall document how the standard storage pool is chosen,
and how storage is allocated by standard storage pools.

                        _Implementation Advice_

23
An implementation should document any cases in which it dynamically
allocates heap storage for a purpose other than the evaluation of an
allocator.

24
A default (implementation-provided) storage pool for an
access-to-constant type should not have overhead to support deallocation
of individual objects.

25/2
The storage pool used for an allocator of an anonymous access type
should be determined as follows:

25.1/2
   * If the allocator is defining a coextension (see *note 3.10.2::) of
     an object being created by an outer allocator, then the storage
     pool used for the outer allocator should also be used for the
     coextension;

25.2/2
   * For other access discriminants and access parameters, the storage
     pool should be created at the point of the allocator, and be
     reclaimed when the allocated object becomes inaccessible;

25.3/3
   * If the allocator defines the result of a function with an access
     result, the storage pool is determined as though the allocator were
     in place of the call of the function.  If the call is the operand
     of a type conversion, the storage pool is that of the target access
     type of the conversion.  If the call is itself defining the result
     of a function with an access result, this rule is applied
     recursively;

25.4/2
   * Otherwise, a default storage pool should be created at the point
     where the anonymous access type is elaborated; such a storage pool
     need not support deallocation of individual objects.

     NOTES

26
     27  A user-defined storage pool type can be obtained by extending
     the Root_Storage_Pool type, and overriding the primitive
     subprograms Allocate, Deallocate, and Storage_Size.  A user-defined
     storage pool can then be obtained by declaring an object of the
     type extension.  The user can override Initialize and Finalize if
     there is any need for nontrivial initialization and finalization
     for a user-defined pool type.  For example, Finalize might reclaim
     blocks of storage that are allocated separately from the pool
     object itself.

27
     28  The writer of the user-defined allocation and deallocation
     procedures, and users of allocators for the associated access type,
     are responsible for dealing with any interactions with tasking.  In
     particular:

28
        * If the allocators are used in different tasks, they require
          mutual exclusion.

29
        * If they are used inside protected objects, they cannot block.

30
        * If they are used by interrupt handlers (see *note C.3::,
          "*note C.3:: Interrupt Support"), the mutual exclusion
          mechanism has to work properly in that context.

31
     29  The primitives Allocate, Deallocate, and Storage_Size are
     declared as abstract (see *note 3.9.3::), and therefore they have
     to be overridden when a new (nonabstract) storage pool type is
     declared.

                              _Examples_

32
To associate an access type with a storage pool object, the user first
declares a pool object of some type derived from Root_Storage_Pool.
Then, the user defines its Storage_Pool attribute, as follows:

33
     Pool_Object : Some_Storage_Pool_Type;

34
     type T is access Designated;
     for T'Storage_Pool use Pool_Object;

35
Another access type may be added to an existing storage pool, via:

36
     for T2'Storage_Pool use T'Storage_Pool;

37
The semantics of this is implementation defined for a standard storage
pool.

38/3
As usual, a derivative of Root_Storage_Pool may define additional
operations.  For example, consider the Mark_Release_Pool_Type defined in
*note 13.11.6::, that has two additional operations, Mark and Release,
the following is a possible use:

39/3
     type Mark_Release_Pool_Type
        (Pool_Size : Storage_Elements.Storage_Count)
             is new Subpools.Root_Storage_Pool_With_Subpools with private;
                -- As defined in package MR_Pool, see *note 13.11.6::

40
     ...

41/3
     Our_Pool : Mark_Release_Pool_Type (Pool_Size => 2000);
     My_Mark : MR_Pool.Subpool_Handle; -- See *note 13.11.6::

42/3
     type Acc is access ...;
     for Acc'Storage_Pool use Our_Pool;
     ...

43/3
     My_Mark := Mark(Our_Pool);
     ... -- Allocate objects using "new (My_Mark) Designated(...)".
     Release(My_Mark); -- Finalize objects and reclaim storage.

* Menu:

* 13.11.1 ::  Storage Allocation Attributes
* 13.11.2 ::  Unchecked Storage Deallocation
* 13.11.3 ::  Default Storage Pools
* 13.11.4 ::  Storage Subpools
* 13.11.5 ::  Subpool Reclamation
* 13.11.6 ::  Storage Subpool Example


File: arm2012.info,  Node: 13.11.1,  Next: 13.11.2,  Up: 13.11

13.11.1 Storage Allocation Attributes
-------------------------------------

1/3
The Max_Size_In_Storage_Elements and Max_Alignment_For_Allocation
attributes may be useful in writing user-defined pool types.

                          _Static Semantics_

2/3
For every subtype S, the following attributes are defined:

3/3
S'Max_Size_In_Storage_Elements
               Denotes the maximum value for Size_In_Storage_Elements
               that could be requested by the implementation via
               Allocate for an access type whose designated subtype is
               S. The value of this attribute is of type
               universal_integer.

4/3
S'Max_Alignment_For_Allocation
               Denotes the maximum value for Alignment that could be
               requested by the implementation via Allocate for an
               access type whose designated subtype is S. The value of
               this attribute is of type universal_integer.

5/3
For a type with access discriminants, if the implementation allocates
space for a coextension in the same pool as that of the object having
the access discriminant, then these attributes account for any calls on
Allocate that could be performed to provide space for such coextensions.


File: arm2012.info,  Node: 13.11.2,  Next: 13.11.3,  Prev: 13.11.1,  Up: 13.11

13.11.2 Unchecked Storage Deallocation
--------------------------------------

1
Unchecked storage deallocation of an object designated by a value of an
access type is achieved by a call to an instance of the generic
procedure Unchecked_Deallocation.

                          _Static Semantics_

2
The following language-defined generic library procedure exists:

3/3
     generic
        type Object(<>) is limited private;
        type Name   is access  Object;
     procedure Ada.Unchecked_Deallocation(X : in out Name)
        with Convention => Intrinsic;
     pragma Preelaborate(Ada.Unchecked_Deallocation);

                           _Legality Rules_

3.1/3
A call on an instance of Unchecked_Deallocation is illegal if the actual
access type of the instance is a type for which the Storage_Size has
been specified by a static expression with value zero or is defined by
the language to be zero. In addition to the places where Legality Rules
normally apply (see *note 12.3::), this rule applies also in the private
part of an instance of a generic unit.

                          _Dynamic Semantics_

4
Given an instance of Unchecked_Deallocation declared as follows:

5
     procedure Free is
         new Ada.Unchecked_Deallocation(
             object_subtype_name, access_to_variable_subtype_name);

6
Procedure Free has the following effect:

7
     1.  After executing Free(X), the value of X is null.

8
     2.  Free(X), when X is already equal to null, has no effect.

9/3
     3.  Free(X), when X is not equal to null first performs
     finalization of the object designated by X (and any coextensions of
     the object -- see *note 3.10.2::), as described in *note 7.6.1::.
     It then deallocates the storage occupied by the object designated
     by X (and any coextensions).  If the storage pool is a user-defined
     object, then the storage is deallocated by calling Deallocate as
     described in *note 13.11::.  There is one exception: if the object
     being freed contains tasks, the object might not be deallocated.

10/4
After the finalization step of Free(X), the object designated by X, and
any subcomponents (and coextensions) thereof, no longer exist; their
storage can be reused for other purposes.

                      _Bounded (Run-Time) Errors_

11
It is a bounded error to free a discriminated, unterminated task object.
The possible consequences are:

12
   * No exception is raised.

13
   * Program_Error or Tasking_Error is raised at the point of the
     deallocation.

14
   * Program_Error or Tasking_Error is raised in the task the next time
     it references any of the discriminants.

15
In the first two cases, the storage for the discriminants (and for any
enclosing object if it is designated by an access discriminant of the
task) is not reclaimed prior to task termination.

15.1/4
An access value that designates a nonexistent object is called a
dangling reference.

15.2/4
If a dangling reference is dereferenced (implicitly or explicitly),
execution is erroneous (see below).  If there is no explicit or implicit
dereference, then it is a bounded error to evaluate an expression whose
result is a dangling reference.  If the error is detected, either
Constraint_Error or Program_Error is raised. Otherwise, execution
proceeds normally, but with the possibility that the access value
designates some other existing object.

                         _Erroneous Execution_

16/3
Evaluating a name that denotes a nonexistent object, or a protected
subprogram or subprogram renaming whose associated object (if any) is
nonexistent, is erroneous.  The execution of a call to an instance of
Unchecked_Deallocation is erroneous if the object was created other than
by an allocator for an access type whose pool is Name'Storage_Pool.

                        _Implementation Advice_

17
For a standard storage pool, Free should actually reclaim the storage.

17.1/3
A call on an instance of Unchecked_Deallocation with a nonnull access
value should raise Program_Error if the actual access type of the
instance is a type for which the Storage_Size has been specified to be
zero or is defined by the language to be zero.

     NOTES

18
     30  The rules here that refer to Free apply to any instance of
     Unchecked_Deallocation.

19
     31  Unchecked_Deallocation cannot be instantiated for an
     access-to-constant type.  This is implied by the rules of *note
     12.5.4::.


File: arm2012.info,  Node: 13.11.3,  Next: 13.11.4,  Prev: 13.11.2,  Up: 13.11

13.11.3 Default Storage Pools
-----------------------------

1/4
Pragma and aspect Default_Storage_Pool specify the storage pool that
will be used in the absence of an explicit specification of a storage
pool or storage size for an access type.

                               _Syntax_

2/3
     The form of a pragma Default_Storage_Pool is as follows:

3/3
       pragma Default_Storage_Pool (storage_pool_indicator);

3.1/4
     storage_pool_indicator ::= storage_pool_name | null | Standard

3.2/3
     A pragma Default_Storage_Pool is allowed immediately within the
     visible part of a package_specification, immediately within a
     declarative_part, or as a configuration pragma.

                        _Name Resolution Rules_

3.3/3
The storage_pool_name is expected to be of type Root_Storage_Pool'Class.

                           _Legality Rules_

4/3
The storage_pool_name shall denote a variable.

4.1/4
The Standard storage_pool_indicator is an identifier specific to a
pragma (see *note 2.8::) and does not denote any declaration.  If the
storage_pool_indicator is Standard, then there shall not be a
declaration with defining_identifier Standard that is immediately
visible at the point of the pragma, other than package Standard itself.

4.2/4
If the pragma is used as a configuration pragma, the
storage_pool_indicator shall be either null or Standard, and it defines
the default pool to be the given storage_pool_indicator within all
applicable compilation units (see *note 10.1.5::), except within the
immediate scope of another pragma Default_Storage_Pool.  Otherwise, the
pragma occurs immediately within a sequence of declarations, and it
defines the default pool within the immediate scope of the pragma to be
the given storage_pool_indicator, except within the immediate scope of a
later pragma Default_Storage_Pool.  Thus, an inner pragma overrides an
outer one.

4.3/4
A pragma Default_Storage_Pool shall not be used as a configuration
pragma that applies to a compilation unit that is within the immediate
scope of another pragma Default_Storage_Pool.

                          _Static Semantics_

5/4
The language-defined aspect Default_Storage_Pool may be specified for a
generic instance; it defines the default pool for access types within an
instance.  .

5.1/4
The Default_Storage_Pool aspect may be specified as Standard, which is
an identifier specific to an aspect (see *note 13.1.1::) and defines the
default pool to be Standard.  In this case, there shall not be a
declaration with defining_identifier Standard that is immediately
visible at the point of the aspect specification, other than package
Standard itself.

5.2/4
Otherwise, the expected type for the Default_Storage_Pool aspect is
Root_Storage_Pool'Class and the aspect_definition shall be a name that
denotes a variable.  This aspect overrides any Default_Storage_Pool
pragma that might apply to the generic unit; if the aspect is not
specified, the default pool of the instance is that defined for the
generic unit.

5.3/4
The effect of specifying the aspect Default_Storage_Pool on an instance
of a language-defined generic unit is implementation-defined.

6/3
For nonderived access types declared in places where the default pool is
defined by the pragma or aspect, their Storage_Pool or Storage_Size
attribute is determined as follows, unless Storage_Pool or Storage_Size
is specified for the type:

6.1/3
   * If the default pool is null, the Storage_Size attribute is defined
     by the language to be zero.  Therefore, an allocator for such a
     type is illegal.

6.2/4
   * If the default pool is neither null nor Standard, the Storage_Pool
     attribute is that pool.

6.3/4
Otherwise (including when the default pool is specified as Standard),
the standard storage pool is used for the type as described in *note
13.11::.

7/3
This paragraph was deleted.

                     _Implementation Permissions_

8/3
An object created by an allocator that is passed as the actual parameter
to an access parameter may be allocated on the stack, and automatically
reclaimed, regardless of the default pool.

     NOTES

9/3
     32  Default_Storage_Pool may be used with restrictions
     No_Coextensions and No_Access_Parameter_Allocators (see *note
     H.4::) to ensure that all allocators use the default pool.


File: arm2012.info,  Node: 13.11.4,  Next: 13.11.5,  Prev: 13.11.3,  Up: 13.11

13.11.4 Storage Subpools
------------------------

1/3
This subclause defines a package to support the partitioning of a
storage pool into subpools.  A subpool may be specified as the default
to be used for allocation from the associated storage pool, or a
particular subpool may be specified as part of an allocator (see *note
4.8::).

                          _Static Semantics_

2/3
The following language-defined library package exists:

3/3
     package System.Storage_Pools.Subpools is
        pragma Preelaborate (Subpools);

4/3
        type Root_Storage_Pool_With_Subpools is
           abstract new Root_Storage_Pool with private;

5/3
        type Root_Subpool is abstract tagged limited private;

6/3
        type Subpool_Handle is access all Root_Subpool'Class;
        for Subpool_Handle'Storage_Size use 0;

7/3
        function Create_Subpool (Pool : in out Root_Storage_Pool_With_Subpools)
           return not null Subpool_Handle is abstract;

8/3
        -- The following operations are intended for pool implementers:

9/3
        function Pool_of_Subpool (Subpool : not null Subpool_Handle)
           return access Root_Storage_Pool_With_Subpools'Class;

10/3
        procedure Set_Pool_of_Subpool (
           Subpool : in not null Subpool_Handle;
           To : in out Root_Storage_Pool_With_Subpools'Class);

11/3
        procedure Allocate_From_Subpool (
           Pool : in out Root_Storage_Pool_With_Subpools;
           Storage_Address : out Address;
           Size_In_Storage_Elements : in Storage_Elements.Storage_Count;
           Alignment : in Storage_Elements.Storage_Count;
           Subpool : in not null Subpool_Handle) is abstract
              with Pre'Class => Pool_of_Subpool(Subpool) = Pool'Access;

12/3
        procedure Deallocate_Subpool (
           Pool : in out Root_Storage_Pool_With_Subpools;
           Subpool : in out Subpool_Handle) is abstract
              with Pre'Class => Pool_of_Subpool(Subpool) = Pool'Access;

13/3
        function Default_Subpool_for_Pool (
           Pool : in out Root_Storage_Pool_With_Subpools)
              return not null Subpool_Handle;

14/3
        overriding
        procedure Allocate (
           Pool : in out Root_Storage_Pool_With_Subpools;
           Storage_Address : out Address;
           Size_In_Storage_Elements : in Storage_Elements.Storage_Count;
           Alignment : in Storage_Elements.Storage_Count);

15/3
        overriding
        procedure Deallocate (
           Pool : in out Root_Storage_Pool_With_Subpools;
           Storage_Address : in Address;
           Size_In_Storage_Elements : in Storage_Elements.Storage_Count;
           Alignment : in Storage_Elements.Storage_Count) is null;

16/3
        overriding
        function Storage_Size (Pool : Root_Storage_Pool_With_Subpools)
           return Storage_Elements.Storage_Count
               is (Storage_Elements.Storage_Count'Last);

17/3
     private
        ... -- not specified by the language
     end System.Storage_Pools.Subpools;

18/3
A subpool is a separately reclaimable portion of a storage pool,
identified by an object of type Subpool_Handle (a subpool handle).  A
subpool handle also identifies the enclosing storage pool, a storage
pool that supports subpools, which is a storage pool whose type is
descended from Root_Storage_Pool_With_Subpools.  A subpool is created by
calling Create_Subpool or a similar constructor; the constructor returns
the subpool handle.

19/3
A subpool object is an object of a type descended from Root_Subpool.
Typically, subpool objects are managed by the containing storage pool;
only the handles need be exposed to clients of the storage pool.
Subpool objects are designated by subpool handles, and are the run-time
representation of a subpool.

20/4
Each subpool belongs to a single storage pool (which will always be a
pool that supports subpools).  An access to the pool that a subpool
belongs to can be obtained by calling Pool_of_Subpool with the subpool
handle.  Set_Pool_of_Subpool causes the subpool of the subpool handle to
belong to the given pool; this is intended to be called from subpool
constructors like Create_Subpool.  Set_Pool_of_Subpool propagates
Program_Error if the subpool already belongs to a pool.  If
Set_Pool_of_Subpool has not yet been called for a subpool,
Pool_of_Subpool returns null.

21/3
When an allocator for a type whose storage pool supports subpools is
evaluated, a call is made on Allocate_From_Subpool passing in a
Subpool_Handle, in addition to the parameters as defined for calls on
Allocate (see *note 13.11::).  The subpool designated by the
subpool_handle_name is used, if specified in an allocator.  Otherwise,
Default_Subpool_for_Pool of the Pool is used to provide a subpool
handle.  All requirements on the Allocate procedure also apply to
Allocate_from_Subpool.

                           _Legality Rules_

22/3
If a storage pool that supports subpools is specified as the
Storage_Pool for an access type, the access type is called a subpool
access type.  A subpool access type shall be a pool-specific access
type.

23/3
The accessibility level of a subpool access type shall not be statically
deeper than that of the storage pool object.  If the specified storage
pool object is a storage pool that supports subpools, then the name that
denotes the object shall not denote part of a formal parameter, nor
shall it denote part of a dereference of a value of a non-library-level
general access type. In addition to the places where Legality Rules
normally apply (see *note 12.3::), these rules also apply in the private
part of an instance of a generic unit.

                          _Dynamic Semantics_

24/3
When an access type with a specified storage pool is frozen (see *note
13.14::), if the tag of the storage pool object identifies a storage
pool that supports subpools, the following checks are made:

25/3
   * the name used to specify the storage pool object does not denote
     part of a formal parameter nor part of a dereference of a value of
     a non-library-level general access type; and

26/3
   * the accessibility level of the access type is not deeper than that
     of the storage pool object.

27/3
Program_Error is raised if either of these checks fail.

28/3
A call to Subpools.Allocate(P, Addr, Size, Align) does the following:

29/3
     Allocate_From_Subpool
       (Root_Storage_Pool_With_Subpools'Class(P),
        Addr, Size, Align,
        Subpool => Default_Subpool_for_Pool
                     (Root_Storage_Pool_With_Subpools'Class(P)));

30/3
An allocator that allocates in a subpool raises Program_Error if the
allocated object has task parts.

31/3
Unless overridden, Default_Subpool_for_Pool propagates Program_Error.

                         _Erroneous Execution_

31.1/4
If Allocate_From_Subpool does not meet one or more of the requirements
on the Allocate procedure as given in the Erroneous Execution rules of
*note 13.11::, then the program execution is erroneous.

                     _Implementation Permissions_

32/3
When an allocator for a type whose storage pool is of type
Root_Storage_Pool'Class is evaluated, but supports subpools, the
implementation may call Allocate rather than Allocate_From_Subpool.
This will have the same effect, so long as Allocate has not been
overridden.

     NOTES

33/3
     33  A user-defined storage pool type that supports subpools can be
     implemented by extending the Root_Storage_Pool_With_Subpools type,
     and overriding the primitive subprograms Create_Subpool,
     Allocate_From_Subpool, and Deallocate_Subpool.  Create_Subpool
     should call Set_Pool_Of_Subpool before returning the subpool
     handle.  To make use of such a pool, a user would declare an object
     of the type extension, use it to define the Storage_Pool attribute
     of one or more access types, and then call Create_Subpool to obtain
     subpool handles associated with the pool.

34/3
     34  A user-defined storage pool type that supports subpools may
     define additional subpool constructors similar to Create_Subpool
     (these typically will have additional parameters).

35/3
     35  The pool implementor should override Default_Subpool_For_Pool
     if the pool is to support a default subpool for the pool.  The
     implementor can override Deallocate if individual object
     reclamation is to be supported, and can override Storage_Size if
     there is some limit on the total size of the storage pool.  The
     implementor can override Initialize and Finalize if there is any
     need for nontrivial initialization and finalization for the pool as
     a whole.  For example, Finalize might reclaim blocks of storage
     that are allocated over and above the space occupied by the pool
     object itself.  The pool implementor may extend the Root_Subpool
     type as necessary to carry additional information with each subpool
     provided by Create_Subpool.


File: arm2012.info,  Node: 13.11.5,  Next: 13.11.6,  Prev: 13.11.4,  Up: 13.11

13.11.5 Subpool Reclamation
---------------------------

1/3
A subpool may be explicitly deallocated using
Unchecked_Deallocate_Subpool.

                          _Static Semantics_

2/3
The following language-defined library procedure exists:

3/3
     with System.Storage_Pools.Subpools;
     procedure Ada.Unchecked_Deallocate_Subpool
        (Subpool : in out System.Storage_Pools.Subpools.Subpool_Handle);

4/3
If Subpool is null, a call on Unchecked_Deallocate_Subpool has no
effect.  Otherwise, the subpool is finalized, and Subpool is set to
null.

5/3
Finalization of a subpool has the following effects:

6/3
   * The subpool no longer belongs to any pool;

7/3
   * Any of the objects allocated from the subpool that still exist are
     finalized in an arbitrary order;

7.1/4
   * All of the objects allocated from the subpool cease to exist;

8/3
   * The following dispatching call is then made:

9/3
        Deallocate_Subpool(Pool_of_Subpool(Subpool).all, Subpool);

10/3
Finalization of a Root_Storage_Pool_With_Subpools object finalizes all
subpools that belong to that pool that have not yet been finalized.


File: arm2012.info,  Node: 13.11.6,  Prev: 13.11.5,  Up: 13.11

13.11.6 Storage Subpool Example
-------------------------------

                              _Examples_

1/3
The following example is a simple but complete implementation of the
classic Mark/Release pool using subpools:

2/3
     with System.Storage_Pools.Subpools;
     with System.Storage_Elements;
     with Ada.Unchecked_Deallocate_Subpool;
     package MR_Pool is

3/3
        use System.Storage_Pools;
           -- For uses of Subpools.
        use System.Storage_Elements;
           -- For uses of Storage_Count and Storage_Array.

4/3
        -- Mark and Release work in a stack fashion, and allocations are not allowed
        -- from a subpool other than the one at the top of the stack. This is also
        -- the default pool.

5/3
        subtype Subpool_Handle is Subpools.Subpool_Handle;

6/3
        type Mark_Release_Pool_Type (Pool_Size : Storage_Count) is new
           Subpools.Root_Storage_Pool_With_Subpools with private;

7/3
        function Mark (Pool : in out Mark_Release_Pool_Type)
           return not null Subpool_Handle;

8/3
        procedure Release (Subpool : in out Subpool_Handle) renames
           Ada.Unchecked_Deallocate_Subpool;

9/3
     private

10/3
        type MR_Subpool is new Subpools.Root_Subpool with record
           Start : Storage_Count;
        end record;
        subtype Subpool_Indexes is Positive range 1 .. 10;
        type Subpool_Array is array (Subpool_Indexes) of aliased MR_Subpool;

11/4
        type Mark_Release_Pool_Type (Pool_Size : Storage_Count) is new
           Subpools.Root_Storage_Pool_With_Subpools with record
           Storage         : Storage_Array (0 .. Pool_Size);
           Next_Allocation : Storage_Count := 0;
           Markers         : Subpool_Array;
           Current_Pool    : Subpool_Indexes := 1;
        end record;

12/3
        overriding
        function Create_Subpool (Pool : in out Mark_Release_Pool_Type)
           return not null Subpool_Handle;

13/3
        function Mark (Pool : in out Mark_Release_Pool_Type)
           return not null Subpool_Handle renames Create_Subpool;

14/3
        overriding
        procedure Allocate_From_Subpool (
           Pool : in out Mark_Release_Pool_Type;
           Storage_Address : out System.Address;
           Size_In_Storage_Elements : in Storage_Count;
           Alignment : in Storage_Count;
           Subpool : not null Subpool_Handle);

15/3
        overriding
        procedure Deallocate_Subpool (
           Pool : in out Mark_Release_Pool_Type;
           Subpool : in out Subpool_Handle);

16/3
        overriding
        function Default_Subpool_for_Pool (Pool : in out Mark_Release_Pool_Type)
           return not null Subpool_Handle;

17/3
        overriding
        procedure Initialize (Pool : in out Mark_Release_Pool_Type);

18/3
        -- We don't need Finalize.

19/3
     end MR_Pool;

20/3
     package body MR_Pool is

21/3
        use type Subpool_Handle;

22/3
        procedure Initialize (Pool : in out Mark_Release_Pool_Type) is
           -- Initialize the first default subpool.
        begin
           Pool.Markers(1).Start := 1;
           Subpools.Set_Pool_of_Subpool
              (Pool.Markers(1)'Unchecked_Access, Pool);
        end Initialize;

23/3
        function Create_Subpool (Pool : in out Mark_Release_Pool_Type)
           return not null Subpool_Handle is
           -- Mark the current allocation location.
        begin
           if Pool.Current_Pool = Subpool_Indexes'Last then
              raise Storage_Error; -- No more subpools.
           end if;
           Pool.Current_Pool := Pool.Current_Pool + 1; -- Move to the next subpool

24/3
           return Result : constant not null Subpool_Handle :=
              Pool.Markers(Pool.Current_Pool)'Unchecked_Access
           do
              Pool.Markers(Pool.Current_Pool).Start := Pool.Next_Allocation;
              Subpools.Set_Pool_of_Subpool (Result, Pool);
           end return;
        end Create_Subpool;

25/3
        procedure Deallocate_Subpool (
           Pool : in out Mark_Release_Pool_Type;
           Subpool : in out Subpool_Handle) is
        begin
           if Subpool /= Pool.Markers(Pool.Current_Pool)'Unchecked_Access then
              raise Program_Error; -- Only the last marked subpool can be released.
           end if;
           if Pool.Current_Pool /= 1 then
              Pool.Next_Allocation := Pool.Markers(Pool.Current_Pool).Start;
              Pool.Current_Pool := Pool.Current_Pool - 1; -- Move to the previous subpool
           else -- Reinitialize the default subpool:
              Pool.Next_Allocation := 1;
              Subpools.Set_Pool_of_Subpool
                 (Pool.Markers(1)'Unchecked_Access, Pool);
           end if;
        end Deallocate_Subpool;

26/3
        function Default_Subpool_for_Pool (Pool : in out Mark_Release_Pool_Type)
           return not null Subpool_Handle is
        begin
           return Pool.Markers(Pool.Current_Pool)'Unchecked_Access;
        end Default_Subpool_for_Pool;

27/3
        procedure Allocate_From_Subpool (
           Pool : in out Mark_Release_Pool_Type;
           Storage_Address : out System.Address;
           Size_In_Storage_Elements : in Storage_Count;
           Alignment : in Storage_Count;
           Subpool : not null Subpool_Handle) is
        begin
           if Subpool /= Pool.Markers(Pool.Current_Pool)'Unchecked_Access then
              raise Program_Error; -- Only the last marked subpool can be used for allocations.
           end if;

28/4
           -- Check for the maximum supported alignment, which is the alignment of the storage area:
           if Alignment > Pool.Storage'Alignment then
              raise Program_Error;
           end if;
           -- Correct the alignment if necessary:
           Pool.Next_Allocation := Pool.Next_Allocation +
              ((-Pool.Next_Allocation) mod Alignment);
           if Pool.Next_Allocation + Size_In_Storage_Elements >
              Pool.Pool_Size then
              raise Storage_Error; -- Out of space.
           end if;
           Storage_Address := Pool.Storage (Pool.Next_Allocation)'Address;
           Pool.Next_Allocation :=
              Pool.Next_Allocation + Size_In_Storage_Elements;
        end Allocate_From_Subpool;

29/3
     end MR_Pool;


File: arm2012.info,  Node: 13.12,  Next: 13.13,  Prev: 13.11,  Up: 13

13.12 Pragma Restrictions and Pragma Profile
============================================

1/3
A pragma Restrictions expresses the user's intent to abide by certain
restrictions.  A pragma Profile expresses the user's intent to abide by
a set of Restrictions or other specified run-time policies.  These may
facilitate the construction of simpler run-time environments.

                               _Syntax_

2
     The form of a pragma Restrictions is as follows:

3
       pragma Restrictions(restriction{, restriction});

4/2
     restriction ::= restriction_identifier
         | restriction_parameter_identifier => 
     restriction_parameter_argument

4.1/2
     restriction_parameter_argument ::= name | expression

                        _Name Resolution Rules_

5
Unless otherwise specified for a particular restriction, the expression
is expected to be of any integer type.

                           _Legality Rules_

6
Unless otherwise specified for a particular restriction, the expression
shall be static, and its value shall be nonnegative.

Paragraph 7 was deleted.

                       _Post-Compilation Rules_

8/3
A pragma Restrictions is a configuration pragma.  If a pragma
Restrictions applies to any compilation unit included in the partition,
this may impose either (or both) of two kinds of requirements, as
specified for the particular restriction:

8.1/3
   * A restriction may impose requirements on some or all of the units
     comprising the partition.  Unless otherwise specified for a
     particular restriction, such a requirement applies to all of the
     units comprising the partition and is enforced via a
     post-compilation check.

8.2/3
   * A restriction may impose requirements on the run-time behavior of
     the program, as indicated by the specification of run-time behavior
     associated with a violation of the requirement.

8.3/1
For the purpose of checking whether a partition contains constructs that
violate any restriction (unless specified otherwise for a particular
restriction):

8.4/1
   * Generic instances are logically expanded at the point of
     instantiation;

8.5/1
   * If an object of a type is declared or allocated and not explicitly
     initialized, then all expressions appearing in the definition for
     the type and any of its ancestors are presumed to be used;

8.6/1
   * A default_expression for a formal parameter or a generic formal
     object is considered to be used if and only if the corresponding
     actual parameter is not provided in a given call or instantiation.

                     _Implementation Permissions_

8.7/3
An implementation may provide implementation-defined restrictions; the
identifier for an implementation-defined restriction shall differ from
those of the language-defined restrictions.

9
An implementation may place limitations on the values of the expression
that are supported, and limitations on the supported combinations of
restrictions.  The consequences of violating such limitations are
implementation defined.

9.1/1
An implementation is permitted to omit restriction checks for code that
is recognized at compile time to be unreachable and for which no code is
generated.

9.2/1
Whenever enforcement of a restriction is not required prior to
execution, an implementation may nevertheless enforce the restriction
prior to execution of a partition to which the restriction applies,
provided that every execution of the partition would violate the
restriction.

                               _Syntax_

10/3
     The form of a pragma Profile is as follows:

11/3
       pragma Profile (profile_identifier {, profile_
     pragma_argument_association});

                           _Legality Rules_

12/3
The profile_identifier shall be the name of a usage profile.  The
semantics of any profile_pragma_argument_association (*note 2.8:
S0020.)s are defined by the usage profile specified by the
profile_identifier.

                          _Static Semantics_

13/3
A profile is equivalent to the set of configuration pragmas that is
defined for each usage profile.

                       _Post-Compilation Rules_

14/3
A pragma Profile is a configuration pragma.  There may be more than one
pragma Profile for a partition.

                     _Implementation Permissions_

15/3
An implementation may provide implementation-defined usage profiles; the
identifier for an implementation-defined usage profile shall differ from
those of the language-defined usage profiles.

     NOTES

16/2
     36  Restrictions intended to facilitate the construction of
     efficient tasking run-time systems are defined in *note D.7::.
     Restrictions intended for use when constructing high integrity
     systems are defined in *note H.4::.

17
     37  An implementation has to enforce the restrictions in cases
     where enforcement is required, even if it chooses not to take
     advantage of the restrictions in terms of efficiency.

* Menu:

* 13.12.1 ::  Language-Defined Restrictions and Profiles


File: arm2012.info,  Node: 13.12.1,  Up: 13.12

13.12.1 Language-Defined Restrictions and Profiles
--------------------------------------------------

                          _Static Semantics_

1/2
The following restriction_identifiers are language defined (additional
restrictions are defined in the Specialized Needs Annexes):

1.1/3
No_Implementation_Aspect_Specifications
               There are no implementation-defined aspects specified by
               an aspect_specification.  This restriction applies only
               to the current compilation or environment, not the entire
               partition.

2/2
No_Implementation_Attributes
               There are no implementation-defined attributes.  This
               restriction applies only to the current compilation or
               environment, not the entire partition.

2.1/3
No_Implementation_Identifiers
               There are no usage names that denote declarations with
               implementation-defined identifiers that occur within
               language-defined packages or instances of
               language-defined generic packages.  Such identifiers can
               arise as follows:

2.2/3
                  * The following language-defined packages and generic
                    packages allow implementation-defined identifiers:

2.3/3
                            * package System (see *note 13.7::);

2.4/3
                            * package Standard (see *note A.1::);

2.5/3
                            * package Ada.Command_Line (see *note
                              A.15::);

2.6/3
                            * package Interfaces.C (see *note B.3::);

2.7/3
                            * package Interfaces.C.Strings (see *note
                              B.3.1::);

2.8/3
                            * package Interfaces.C.Pointers (see *note
                              B.3.2::);

2.9/3
                            * package Interfaces.COBOL (see *note
                              B.4::);

2.10/3
                            * package Interfaces.Fortran (see *note
                              B.5::);

2.11/3
                  * The following language-defined packages contain only
                    implementation-defined identifiers:

2.12/3
                            * package System.Machine_Code (see *note
                              13.8::);

2.13/3
                            * package Ada.Directories.Information (see
                              *note A.16::);

2.14/3
                            * nested Implementation packages of the
                              Queue containers (see *note A.18.28::-31);

2.15/3
                            * package Interfaces (see *note B.2::);

2.16/3
                            * package Ada.Interrupts.Names (see *note
                              C.3.2::).

2.17/3
               For package Standard, Standard.Long_Integer and
               Standard.Long_Float are considered language-defined
               identifiers, but identifiers such as
               Standard.Short_Short_Integer are considered
               implementation-defined.

2.18/3
               This restriction applies only to the current compilation
               or environment, not the entire partition.

3/2
No_Implementation_Pragmas
               There are no implementation-defined pragmas or pragma
               arguments.  This restriction applies only to the current
               compilation or environment, not the entire partition.

3.1/3
No_Implementation_Units
               There is no mention in the context_clause of any
               implementation-defined descendants of packages Ada,
               Interfaces, or System.  This restriction applies only to
               the current compilation or environment, not the entire
               partition.

4/3
No_Obsolescent_Features
               There is no use of language features defined in Annex J.
               It is implementation defined whether uses of the
               renamings of *note J.1:: and of the pragmas of *note
               J.15:: are detected by this restriction.  This
               restriction applies only to the current compilation or
               environment, not the entire partition.

5/3
The following restriction_parameter_identifiers are language defined:

6/2
No_Dependence
               Specifies a library unit on which there are no semantic
               dependences.

6.1/3
No_Specification_of_Aspect
               Identifies an aspect for which no aspect_specification,
               attribute_definition_clause, or pragma is given.

6.2/3
No_Use_Of_Attribute
               Identifies an attribute for which no attribute_reference
               or attribute_definition_clause is given.

6.3/3
No_Use_Of_Pragma
               Identifies a pragma which is not to be used.

                           _Legality Rules_

7/2
The restriction_parameter_argument of a No_Dependence restriction shall
be a name; the name shall have the form of a full expanded name of a
library unit, but need not denote a unit present in the environment.

7.1/3
The restriction_parameter_argument of a No_Specification_of_Aspect
restriction shall be an identifier; this is an identifier specific to a
pragma (see *note 2.8::) and does not denote any declaration.

7.2/3
The restriction_parameter_argument of a No_Use_Of_Attribute restriction
shall be an identifier or one of the reserved words Access, Delta,
Digits, Mod, or Range; this is an identifier specific to a pragma.

7.3/3
The restriction_parameter_argument of a No_Use_Of_Pragma restriction
shall be an identifier or the reserved word Interface; this is an
identifier specific to a pragma.

                       _Post-Compilation Rules_

8/3
No compilation unit included in the partition shall depend semantically
on the library unit identified by the name of a No_Dependence
restriction.

                          _Static Semantics_

9/3
The following profile_identifier is language defined:

10/3
No_Implementation_Extensions

11/3
For usage profile No_Implementation_Extensions, there shall be no
profile_pragma_argument_associations.

12/3
The No_Implementation_Extensions usage profile is equivalent to the
following restrictions:

13/3
     No_Implementation_Aspect_Specifications,
     No_Implementation_Attributes,
     No_Implementation_Identifiers,
     No_Implementation_Pragmas,
     No_Implementation_Units.


File: arm2012.info,  Node: 13.13,  Next: 13.14,  Prev: 13.12,  Up: 13

13.13 Streams
=============

1
A stream is a sequence of elements comprising values from possibly
different types and allowing sequential access to these values.  A
stream type is a type in the class whose root type is
Streams.Root_Stream_Type.  A stream type may be implemented in various
ways, such as an external sequential file, an internal buffer, or a
network channel.

* Menu:

* 13.13.1 ::  The Package Streams
* 13.13.2 ::  Stream-Oriented Attributes


File: arm2012.info,  Node: 13.13.1,  Next: 13.13.2,  Up: 13.13

13.13.1 The Package Streams
---------------------------

                          _Static Semantics_

1
The abstract type Root_Stream_Type is the root type of the class of
stream types.  The types in this class represent different kinds of
streams.  A new stream type is defined by extending the root type (or
some other stream type), overriding the Read and Write operations, and
optionally defining additional primitive subprograms, according to the
requirements of the particular kind of stream.  The predefined
stream-oriented attributes like T'Read and T'Write make dispatching
calls on the Read and Write procedures of the Root_Stream_Type.
(User-defined T'Read and T'Write attributes can also make such calls, or
can call the Read and Write attributes of other types.)

2
     package Ada.Streams is
         pragma Pure(Streams);

3/2
         type Root_Stream_Type is abstract tagged limited private;
         pragma Preelaborable_Initialization(Root_Stream_Type);

4/1
         type Stream_Element is mod implementation-defined;
         type Stream_Element_Offset is range implementation-defined;
         subtype Stream_Element_Count is
             Stream_Element_Offset range 0..Stream_Element_Offset'Last;
         type Stream_Element_Array is
             array(Stream_Element_Offset range <>) of aliased Stream_Element;

5
         procedure Read(
           Stream : in out Root_Stream_Type;
           Item   : out Stream_Element_Array;
           Last   : out Stream_Element_Offset) is abstract;

6
         procedure Write(
           Stream : in out Root_Stream_Type;
           Item   : in Stream_Element_Array) is abstract;

7
     private
        ... -- not specified by the language
     end Ada.Streams;

8/2
The Read operation transfers stream elements from the specified stream
to fill the array Item.  Elements are transferred until Item'Length
elements have been transferred, or until the end of the stream is
reached.  If any elements are transferred, the index of the last stream
element transferred is returned in Last.  Otherwise, Item'First - 1 is
returned in Last.  Last is less than Item'Last only if the end of the
stream is reached.

9
The Write operation appends Item to the specified stream.

                     _Implementation Permissions_

9.1/1
If Stream_Element'Size is not a multiple of System.Storage_Unit, then
the components of Stream_Element_Array need not be aliased.

     NOTES

10
     38  See *note A.12.1::, "*note A.12.1:: The Package
     Streams.Stream_IO" for an example of extending type
     Root_Stream_Type.

11/2
     39  If the end of stream has been reached, and Item'First is
     Stream_Element_Offset'First, Read will raise Constraint_Error.


File: arm2012.info,  Node: 13.13.2,  Prev: 13.13.1,  Up: 13.13

13.13.2 Stream-Oriented Attributes
----------------------------------

1/3
The type-related operational attributes Write, Read, Output, and Input
convert values to a stream of elements and reconstruct values from a
stream.

                          _Static Semantics_

1.1/2
For every subtype S of an elementary type T, the following
representation attribute is defined:

1.2/3
S'Stream_Size
               Denotes the number of bits read from or written to a
               stream by the default implementations of S'Read and
               S'Write.  Hence, the number of stream elements required
               per item of elementary type T is:

1.3/2
                    T'Stream_Size / Ada.Streams.Stream_Element'Size

1.4/2
               The value of this attribute is of type universal_integer
               and is a multiple of Stream_Element'Size.

1.5/2
               Stream_Size may be specified for first subtypes via an
               attribute_definition_clause; the expression of such a
               clause shall be static, nonnegative, and a multiple of
               Stream_Element'Size.

                        _Implementation Advice_

1.6/2
If not specified, the value of Stream_Size for an elementary type should
be the number of bits that corresponds to the minimum number of stream
elements required by the first subtype of the type, rounded up to the
nearest factor or multiple of the word size that is also a multiple of
the stream element size.

1.7/2
The recommended level of support for the Stream_Size attribute is:

1.8/2
   * A Stream_Size clause should be supported for a discrete or fixed
     point type T if the specified Stream_Size is a multiple of
     Stream_Element'Size and is no less than the size of the first
     subtype of T, and no greater than the size of the largest type of
     the same elementary class (signed integer, modular integer,
     enumeration, ordinary fixed point, or decimal fixed point).

                          _Static Semantics_

2
For every subtype S of a specific type T, the following attributes are
defined.

3
S'Write
               S'Write denotes a procedure with the following
               specification:

4/2
                    procedure S'Write(
                       Stream : not null access Ada.Streams.Root_Stream_Type'Class;
                       Item : in T)

5
               S'Write writes the value of Item to Stream.

6
S'Read
               S'Read denotes a procedure with the following
               specification:

7/2
                    procedure S'Read(
                       Stream : not null access Ada.Streams.Root_Stream_Type'Class;
                       Item : out T)

8
               S'Read reads the value of Item from Stream.

8.1/3
For an untagged derived type, the Write (resp.  Read) attribute is
inherited according to the rules given in *note 13.1:: if the attribute
is specified and available for the parent type at the point where T is
declared.  For a tagged derived type, these attributes are not
inherited, but rather the default implementations are used.

8.2/2
The default implementations of the Write and Read attributes, where
available, execute as follows:

9/3
For elementary types, Read reads (and Write writes) the number of stream
elements implied by the Stream_Size for the type T; the representation
of those stream elements is implementation defined.  For composite
types, the Write or Read attribute for each component is called in
canonical order, which is last dimension varying fastest for an array
(unless the convention of the array is Fortran, in which case it is
first dimension varying fastest), and positional aggregate order for a
record.  Bounds are not included in the stream if T is an array type.
If T is a discriminated type, discriminants are included only if they
have defaults.  If T is a tagged type, the tag is not included.  For
type extensions, the Write or Read attribute for the parent type is
called, followed by the Write or Read attribute of each component of the
extension part, in canonical order.  For a limited type extension, if
the attribute of the parent type or any progenitor type of T is
available anywhere within the immediate scope of T, and the attribute of
the parent type or the type of any of the extension components is not
available at the freezing point of T, then the attribute of T shall be
directly specified.

9.1/3
If T is a discriminated type and its discriminants have defaults, then
S'Read first reads the discriminants from the stream without modifying
Item.  S'Read then creates an object of type T constrained by these
discriminants.  The value of this object is then converted to the
subtype of Item and is assigned to Item.  Finally, the Read attribute
for each nondiscriminant component of Item is called in canonical order
as described above.  Normal default initialization and finalization take
place for the created object.

9.2/3
Constraint_Error is raised by the predefined Write attribute if the
value of the elementary item is outside the range of values
representable using Stream_Size bits.  For a signed integer type, an
enumeration type, or a fixed point type, the range is unsigned only if
the integer code for the lower bound of the first subtype is
nonnegative, and a (symmetric) signed range that covers all values of
the first subtype would require more than Stream_Size bits; otherwise,
the range is signed.

10
For every subtype S'Class of a class-wide type T'Class:

11
S'Class'Write
               S'Class'Write denotes a procedure with the following
               specification:

12/2
                    procedure S'Class'Write(
                       Stream : not null access Ada.Streams.Root_Stream_Type'Class;
                       Item   : in T'Class)

13
               Dispatches to the subprogram denoted by the Write
               attribute of the specific type identified by the tag of
               Item.

14
S'Class'Read
               S'Class'Read denotes a procedure with the following
               specification:

15/2
                    procedure S'Class'Read(
                       Stream : not null access Ada.Streams.Root_Stream_Type'Class;
                       Item : out T'Class)

16
               Dispatches to the subprogram denoted by the Read
               attribute of the specific type identified by the tag of
               Item.

Paragraph 17 was deleted.

                          _Static Semantics_

18
For every subtype S of a specific type T, the following attributes are
defined.

19
S'Output
               S'Output denotes a procedure with the following
               specification:

20/2
                    procedure S'Output(
                       Stream : not null access Ada.Streams.Root_Stream_Type'Class;
                       Item : in T)

21
               S'Output writes the value of Item to Stream, including
               any bounds or discriminants.

22
S'Input
               S'Input denotes a function with the following
               specification:

23/2
                    function S'Input(
                       Stream : not null access Ada.Streams.Root_Stream_Type'Class)
                       return T

24
               S'Input reads and returns one value from Stream, using
               any bounds or discriminants written by a corresponding
               S'Output to determine how much to read.

25/3
For an untagged derived type, the Output (resp.  Input) attribute is
inherited according to the rules given in *note 13.1:: if the attribute
is specified and available for the parent type at the point where T is
declared.  For a tagged derived type, these attributes are not
inherited, but rather the default implementations are used.

25.1/2
The default implementations of the Output and Input attributes, where
available, execute as follows:

26/3
   * If T is an array type, S'Output first writes the bounds, and
     S'Input first reads the bounds.  If T has discriminants without
     defaults, S'Output first writes the discriminants (using the Write
     attribute of the discriminant type for each), and S'Input first
     reads the discriminants (using the Read attribute of the
     discriminant type for each).

27/3
   * S'Output then calls S'Write to write the value of Item to the
     stream.  S'Input then creates an object of type T, with the bounds
     or (when without defaults) the discriminants, if any, taken from
     the stream, passes it to S'Read, and returns the value of the
     object.  If T has discriminants, then this object is unconstrained
     if and only the discriminants have defaults.  Normal default
     initialization and finalization take place for this object (see
     *note 3.3.1::, *note 7.6::, and *note 7.6.1::).

27.1/2
If T is an abstract type, then S'Input is an abstract function.

28
For every subtype S'Class of a class-wide type T'Class:

29
S'Class'Output
               S'Class'Output denotes a procedure with the following
               specification:

30/2
                    procedure S'Class'Output(
                       Stream : not null access Ada.Streams.Root_Stream_Type'Class;
                       Item   : in T'Class)

31/2
               First writes the external tag of Item to Stream (by
               calling String'Output(Stream,
               Tags.External_Tag(Item'Tag)) -- see *note 3.9::) and then
               dispatches to the subprogram denoted by the Output
               attribute of the specific type identified by the tag.
               Tag_Error is raised if the tag of Item identifies a type
               declared at an accessibility level deeper than that of S.

32
S'Class'Input
               S'Class'Input denotes a function with the following
               specification:

33/2
                    function S'Class'Input(
                       Stream : not null access Ada.Streams.Root_Stream_Type'Class)
                       return T'Class

34/3
               First reads the external tag from Stream and determines
               the corresponding internal tag (by calling
               Tags.Descendant_Tag(String'Input(Stream), S'Tag) which
               might raise Tag_Error -- see *note 3.9::) and then
               dispatches to the subprogram denoted by the Input
               attribute of the specific type identified by the internal
               tag; returns that result.  If the specific type
               identified by the internal tag is abstract,
               Constraint_Error is raised.

35/3
In the default implementation of Read and Input for a composite type,
for each scalar component that is a discriminant or that has an implicit
initial value, a check is made that the value returned by Read for the
component belongs to its subtype. Constraint_Error is raised if this
check fails.  For other scalar components, no check is made.  For each
component that is of an access type, if the implementation can detect
that the value returned by Read for the component is not a value of its
subtype, Constraint_Error is raised.  If the value is not a value of its
subtype and this error is not detected, the component has an abnormal
value, and erroneous execution can result (see *note 13.9.1::).  In the
default implementation of Read for a composite type with defaulted
discriminants, if the actual parameter of Read is constrained, a check
is made that the discriminants read from the stream are equal to those
of the actual parameter.  Constraint_Error is raised if this check
fails.

36/2
It is unspecified at which point and in which order these checks are
performed.  In particular, if Constraint_Error is raised due to the
failure of one of these checks, it is unspecified how many stream
elements have been read from the stream.

37/1
In the default implementation of Read and Input for a type, End_Error is
raised if the end of the stream is reached before the reading of a value
of the type is completed.

38/4
The stream-oriented attributes may be specified for any type via an
attribute_definition_clause.  Alternatively, each of the specific
stream-oriented attributes may be specified using an
aspect_specification on any type_declaration, with the aspect name being
the corresponding attribute name.  Each of the class-wide
stream-oriented attributes may be specified using an
aspect_specification for a tagged type T using the name of the
stream-oriented attribute followed by 'Class; such class-wide aspects do
not apply to other descendants of T. 

38.1/4
The subprogram name given in such an attribute_definition_clause (*note
13.3: S0310.) or aspect_specification (*note 13.1.1: S0307.) shall
statically denote a subprogram that is not an abstract subprogram.
Furthermore, if a specific stream-oriented attribute is specified for an
interface type, the subprogram name given in the
attribute_definition_clause or aspect_specification shall statically
denote a null procedure.

39/2
A stream-oriented attribute for a subtype of a specific type T is
available at places where one of the following conditions is true: 

40/2
   * T is nonlimited.

41/2
   * The attribute_designator is Read (resp.  Write) and T is a limited
     record extension, and the attribute Read (resp.  Write) is
     available for the parent type of T and for the types of all of the
     extension components.

42/2
   * T is a limited untagged derived type, and the attribute was
     inherited for the type.

43/2
   * The attribute_designator is Input (resp.  Output), and T is a
     limited type, and the attribute Read (resp.  Write) is available
     for T.

44/2
   * The attribute has been specified via an
     attribute_definition_clause, and the attribute_definition_clause is
     visible.

45/2
A stream-oriented attribute for a subtype of a class-wide type T'Class
is available at places where one of the following conditions is true:

46/2
   * T is nonlimited;

47/2
   * the attribute has been specified via an
     attribute_definition_clause, and the attribute_definition_clause is
     visible; or

48/2
   * the corresponding attribute of T is available, provided that if T
     has a partial view, the corresponding attribute is available at the
     end of the visible part where T is declared.

49/4
An attribute_reference for one of the stream-oriented attributes is
illegal unless the attribute is available at the place of the
attribute_reference.  Furthermore, an attribute_reference for T'Input is
illegal if T is an abstract type.  In addition to the places where
Legality Rules normally apply (see *note 12.3::), these rules also apply
in the private part of an instance of a generic unit.

49.1/4
Unless inherited from a parent type, if any, for an untagged type having
a task, protected, or explicitly limited record part, the default
implementation of each of the Read, Write, Input, and Output attributes
raises Program_Error and performs no other action.

50/3
In the parameter_and_result_profiles for the default implementations of
the stream-oriented attributes, the subtype of the Item parameter is the
base subtype of T if T is a scalar type, and the first subtype
otherwise.  The same rule applies to the result of the Input attribute.

51/3
For an attribute_definition_clause specifying one of these attributes,
the subtype of the Item parameter shall be the first subtype or the base
subtype if scalar, and the first subtype if not scalar.  The same rule
applies to the result of the Input function.

52/3
A type is said to support external streaming if Read and Write
attributes are provided for sending values of such a type between active
partitions, with Write marshalling the representation, and Read
unmarshalling the representation.  A limited type supports external
streaming only if it has available Read and Write attributes.  A type
with a part that is of a nonremote access type supports external
streaming only if that access type or the type of some part that
includes the access type component, has Read and Write attributes that
have been specified via an attribute_definition_clause, and that
attribute_definition_clause is visible.  An anonymous access type does
not support external streaming.  All other types (including remote
access types, see *note E.2.2::) support external streaming.

                         _Erroneous Execution_

53/2
If the internal tag returned by Descendant_Tag to T'Class'Input
identifies a type that is not library-level and whose tag has not been
created, or does not exist in the partition at the time of the call,
execution is erroneous.

                     _Implementation Requirements_

54/1
For every subtype S of a language-defined nonlimited specific type T,
the output generated by S'Output or S'Write shall be readable by S'Input
or S'Read, respectively.  This rule applies across partitions if the
implementation conforms to the Distributed Systems Annex.

55/3
If Constraint_Error is raised during a call to Read because of failure
of one the above checks, the implementation shall ensure that the
discriminants of the actual parameter of Read are not modified.

                     _Implementation Permissions_

56/3
The number of calls performed by the predefined implementation of the
stream-oriented attributes on the Read and Write operations of the
stream type is unspecified.  An implementation may take advantage of
this permission to perform internal buffering.  However, all the calls
on the Read and Write operations of the stream type needed to implement
an explicit invocation of a stream-oriented attribute shall take place
before this invocation returns.  An explicit invocation is one appearing
explicitly in the program text, possibly through a generic instantiation
(see *note 12.3::).

56.1/3
If T is a discriminated type and its discriminants have defaults, then
in two cases an execution of the default implementation of S'Read is not
required to create an anonymous object of type T: If the discriminant
values that are read in are equal to the corresponding discriminant
values of Item, then no object of type T need be created and Item may be
used instead.  If they are not equal and Item is a constrained variable,
then Constraint_Error may be raised at that point, before any further
values are read from the stream and before the object of type T is
created.

56.2/3
A default implementation of S'Input that calls the default
implementation of S'Read may create a constrained anonymous object with
discriminants that match those in the stream.

     NOTES

57
     40  For a definite subtype S of a type T, only T'Write and T'Read
     are needed to pass an arbitrary value of the subtype through a
     stream.  For an indefinite subtype S of a type T, T'Output and
     T'Input will normally be needed, since T'Write and T'Read do not
     pass bounds, discriminants, or tags.

58
     41  User-specified attributes of S'Class are not inherited by other
     class-wide types descended from S.

                              _Examples_

59
Example of user-defined Write attribute:

60/2
     procedure My_Write(
       Stream : not null access Ada.Streams.Root_Stream_Type'Class;
       Item   : My_Integer'Base);
     for My_Integer'Write use My_Write;


File: arm2012.info,  Node: 13.14,  Prev: 13.13,  Up: 13

13.14 Freezing Rules
====================

1/3
This subclause defines a place in the program text where each declared
entity becomes "frozen."  A use of an entity, such as a reference to it
by name, or (for a type) an expression of the type, causes freezing of
the entity in some contexts, as described below.  The Legality Rules
forbid certain kinds of uses of an entity in the region of text where it
is frozen.

2
The freezing of an entity occurs at one or more places (freezing points)
in the program text where the representation for the entity has to be
fully determined.  Each entity is frozen from its first freezing point
to the end of the program text (given the ordering of compilation units
defined in *note 10.1.4::).

2.1/3
This subclause also defines a place in the program text where the
profile of each declared callable entity becomes frozen.  A use of a
callable entity causes freezing of its profile in some contexts, as
described below.  At the place where the profile of a callable entity
becomes frozen, the entity itself becomes frozen.

3/4
The end of a declarative_part, protected_body, or a declaration of a
library package or generic library package, causes freezing of each
entity and profile declared within it, except for incomplete types. A
proper_body, body_stub, or entry_body causes freezing of each entity and
profile declared before it within the same declarative_part that is not
an incomplete type; it only causes freezing of an incomplete type if the
body is within the immediate scope of the incomplete type.

4/1
A construct that (explicitly or implicitly) references an entity can
cause the freezing of the entity, as defined by subsequent paragraphs.
At the place where a construct causes freezing, each name, expression,
implicit_dereference, or range within the construct causes freezing:

5/3
   * The occurrence of a generic_instantiation causes freezing, except
     that a name which is a generic actual parameter whose corresponding
     generic formal parameter is a formal incomplete type (see *note
     12.5.1::) does not cause freezing.  In addition, if a parameter of
     the instantiation is defaulted, the default_expression or
     default_name for that parameter causes freezing.

5.1/4
   * At the occurrence of an expression_function_declaration that is a
     completion, the return expression of the expression function causes
     freezing.

5.2/4
   * At the occurrence of a renames-as-body whose callable_entity_name
     denotes an expression function, the return expression of the
     expression function causes freezing.

6
   * The occurrence of an object_declaration that has no corresponding
     completion causes freezing.

7
   * The declaration of a record extension causes freezing of the parent
     subtype.

7.1/2
   * The declaration of a record extension, interface type, task unit,
     or protected unit causes freezing of any progenitor types specified
     in the declaration.

7.2/3
   * At the freezing point of the entity associated with an
     aspect_specification, any expressions or names within the
     aspect_specification cause freezing.  Any static expressions within
     an aspect_specification also cause freezing at the end of the
     immediately enclosing declaration list.

8/4
A static expression (other than within an aspect_specification) causes
freezing where it occurs. An object name or nonstatic expression causes
freezing where it occurs, unless the name or expression is part of a
default_expression, a default_name, the return expression of an
expression function, an aspect_specification, or a per-object expression
of a component's constraint, in which case, the freezing occurs later as
part of another construct or at the freezing point of an associated
entity.

8.1/3
An implicit call freezes the same entities and profiles that would be
frozen by an explicit call.  This is true even if the implicit call is
removed via implementation permissions.

8.2/1
If an expression is implicitly converted to a type or subtype T, then at
the place where the expression causes freezing, T is frozen.

9
The following rules define which entities are frozen at the place where
a construct causes freezing:

10
   * At the place where an expression causes freezing, the type of the
     expression is frozen, unless the expression is an enumeration
     literal used as a discrete_choice of the array_aggregate (*note
     4.3.3: S0113.) of an enumeration_representation_clause (*note 13.4:
     S0311.).

10.1/4
   * At the place where a function call causes freezing, the profile of
     the function is frozen.  Furthermore, if a parameter of the call is
     defaulted, the default_expression for that parameter causes
     freezing.  If the function call is to an expression function, the
     return expression of the expression function causes freezing.

10.2/4
   * At the place where a generic_instantiation causes freezing of a
     callable entity, the profile of that entity is frozen unless the
     formal subprogram corresponding to the callable entity has a
     parameter or result of a formal untagged incomplete type; if the
     callable entity is an expression function, the return expression of
     the expression function causes freezing.

10.3/4
   * At the place where a use of the Access or Unchecked_Access
     attribute whose prefix denotes an expression function causes
     freezing, the return expression of the expression function causes
     freezing.

11
   * At the place where a name causes freezing, the entity denoted by
     the name is frozen, unless the name is a prefix of an expanded
     name; at the place where an object name causes freezing, the
     nominal subtype associated with the name is frozen.

11.1/1
   * At the place where an implicit_dereference causes freezing, the
     nominal subtype associated with the implicit_dereference is frozen.

12
   * At the place where a range causes freezing, the type of the range
     is frozen.

13
   * At the place where an allocator causes freezing, the designated
     subtype of its type is frozen.  If the type of the allocator is a
     derived type, then all ancestor types are also frozen.

14/3
   * At the place where a profile is frozen, each subtype of the profile
     is frozen.  If the corresponding callable entity is a member of an
     entry family, the index subtype of the family is frozen.

15
   * At the place where a subtype is frozen, its type is frozen. At the
     place where a type is frozen, any expressions or names within the
     full type definition cause freezing; the first subtype, and any
     component subtypes, index subtypes, and parent subtype of the type
     are frozen as well. For a specific tagged type, the corresponding
     class-wide type is frozen as well.  For a class-wide type, the
     corresponding specific type is frozen as well.

15.1/3
   * At the place where a specific tagged type is frozen, the primitive
     subprograms of the type are frozen.  At the place where a type is
     frozen, any subprogram named in an attribute_definition_clause for
     the type is frozen.

                           _Legality Rules_

16
The explicit declaration of a primitive subprogram of a tagged type
shall occur before the type is frozen (see *note 3.9.2::).

17
A type shall be completely defined before it is frozen (see *note
3.11.1:: and *note 7.3::).

18
The completion of a deferred constant declaration shall occur before the
constant is frozen (see *note 7.4::).

19/1
An operational or representation item that directly specifies an aspect
of an entity shall appear before the entity is frozen (see *note
13.1::).

                          _Dynamic Semantics_

20/2
The tag (see *note 3.9::) of a tagged type T is created at the point
where T is frozen.


File: arm2012.info,  Node: Annex A,  Next: Annex B,  Prev: 13,  Up: Top

Annex A Predefined Language Environment
***************************************

1
This Annex contains the specifications of library units that shall be
provided by every implementation.  There are three root library units:
Ada, Interfaces, and System; other library units are children of these:

2/3
 
 

     Standard -- *note A.1::
        Ada -- *note A.2::
           Assertions -- *note 11.4.2::
           Asynchronous_Task_Control -- *note D.11::
           Calendar -- *note 9.6::
              Arithmetic -- *note 9.6.1::
              Formatting -- *note 9.6.1::
              Time_Zones -- *note 9.6.1::
           Characters -- *note A.3.1::
              Conversions -- *note A.3.4::
              Handling -- *note A.3.2::
              Latin_1 -- *note A.3.3::
           Command_Line -- *note A.15::
           Complex_Text_IO -- *note G.1.3::
           Containers -- *note A.18.1::
              Bounded_Doubly_Linked_Lists
                       -- *note A.18.20::
              Bounded_Hashed_Maps -- *note A.18.21::
              Bounded_Hashed_Sets -- *note A.18.23::
              Bounded_Multiway_Trees -- *note A.18.25::
              Bounded_Ordered_Maps -- *note A.18.22::
              Bounded_Ordered_Sets -- *note A.18.24::
              Bounded_Priority_Queues -- *note A.18.31::
              Bounded_Synchronized_Queues
                        -- *note A.18.29::
              Bounded_Vectors -- *note A.18.19::
              Doubly_Linked_Lists -- *note A.18.3::
              Generic_Array_Sort -- *note A.18.26::
              Generic_Constrained_Array_Sort
                       -- *note A.18.26::
              Generic_Sort -- *note A.18.26::
              Hashed_Maps -- *note A.18.5::
              Hashed_Sets -- *note A.18.8::
              Indefinite_Doubly_Linked_Lists
                       -- *note A.18.12::
              Indefinite_Hashed_Maps -- *note A.18.13::
              Indefinite_Hashed_Sets -- *note A.18.15::
              Indefinite_Holders -- *note A.18.18::
              Indefinite_Multiway_Trees -- *note A.18.17::
              Indefinite_Ordered_Maps -- *note A.18.14::
              Indefinite_Ordered_Sets -- *note A.18.16::
              Indefinite_Vectors -- *note
     A.18.11::Standard (...continued)
        Ada (...continued)
           Containers (...continued)
              Multiway_Trees -- *note A.18.10::
              Ordered_Maps -- *note A.18.6::
              Ordered_Sets -- *note A.18.9::
              Synchronized_Queue_Interfaces
                       -- *note A.18.27::
              Unbounded_Priority_Queues
                       -- *note A.18.30::
              Unbounded_Synchronized_Queues
                       -- *note A.18.28::
              Vectors -- *note A.18.2::
           Decimal -- *note F.2::
           Direct_IO -- *note A.8.4::
           Directories -- *note A.16::
              Hierarchical_File_Names -- *note A.16.1::
              Information -- *note A.16::
           Dispatching -- *note D.2.1::
              EDF -- *note D.2.6::
              Non_Preemptive -- *note D.2.4::
              Round_Robin -- *note D.2.5::
           Dynamic_Priorities -- *note D.5.1::
           Environment_Variables -- *note A.17::
           Exceptions -- *note 11.4.1::
           Execution_Time -- *note D.14::
              Group_Budgets -- *note D.14.2::
              Interrupts -- *note D.14.3::
              Timers -- *note D.14.1::
           Finalization -- *note 7.6::
           Float_Text_IO -- *note A.10.9::
           Float_Wide_Text_IO -- *note A.11::
           Float_Wide_Wide_Text_IO -- *note A.11::
           Integer_Text_IO -- *note A.10.8::
           Integer_Wide_Text_IO -- *note A.11::
           Integer_Wide_Wide_Text_IO -- *note A.11::
           Interrupts -- *note C.3.2::
              Names -- *note C.3.2::
           IO_Exceptions -- *note A.13::
           Iterator_Interfaces -- *note 5.5.1::
           Locales -- *note A.19::
     Standard (...continued)
        Ada (...continued)
           Numerics -- *note A.5::
              Complex_Arrays -- *note G.3.2::
              Complex_Elementary_Functions -- *note G.1.2::
              Complex_Types -- *note G.1.1::
              Discrete_Random -- *note A.5.2::
              Elementary_Functions -- *note A.5.1::
              Float_Random -- *note A.5.2::
              Generic_Complex_Arrays -- *note G.3.2::
              Generic_Complex_Elementary_Functions
                       -- *note G.1.2::
              Generic_Complex_Types -- *note G.1.1::
              Generic_Elementary_Functions -- *note A.5.1::
              Generic_Real_Arrays -- *note G.3.1::
              Real_Arrays -- *note G.3.1::
           Real_Time -- *note D.8::
              Timing_Events -- *note D.15::
           Sequential_IO -- *note A.8.1::
           Storage_IO -- *note A.9::
           Streams -- *note 13.13.1::
              Stream_IO -- *note A.12.1::
           Strings -- *note A.4.1::
              Bounded -- *note A.4.4::
                 Equal_Case_Insensitive -- *note A.4.10::
                 Hash -- *note A.4.9::
                 Hash_Case_Insensitive -- *note A.4.9::
                 Less_Case_Insensitive -- *note A.4.10::
              Fixed -- *note A.4.3::
                 Equal_Case_Insensitive -- *note A.4.10::
                 Hash -- *note A.4.9::
                 Hash_Case_Insensitive -- *note A.4.9::
                 Less_Case_Insensitive -- *note A.4.10::
              Equal_Case_Insensitive -- *note A.4.10::
              Hash -- *note A.4.9::
              Hash_Case_Insensitive -- *note A.4.9::
              Less_Case_Insensitive -- *note A.4.10::
              Maps -- *note A.4.2::
                 Constants -- *note A.4.6::
              Unbounded -- *note A.4.5::
                 Equal_Case_Insensitive -- *note A.4.10::
                 Hash -- *note A.4.9::
                 Hash_Case_Insensitive -- *note A.4.9::
                 Less_Case_Insensitive -- *note A.4.10::
              UTF_Encoding -- *note A.4.11::
                 Conversions -- *note A.4.11::
                 Strings -- *note A.4.11::
                 Wide_Strings -- *note A.4.11::
                 Wide_Wide_Strings -- *note A.4.11::
     Standard (...continued)
        Ada (...continued)
           Strings (...continued)
              Wide_Bounded -- *note A.4.7::
                 Wide_Equal_Case_Insensitive
                          -- *note A.4.7::
                 Wide_Hash -- *note A.4.7::
                 Wide_Hash_Case_Insensitive -- *note A.4.7::
              Wide_Equal_Case_Insensitive -- *note A.4.7::
              Wide_Fixed -- *note A.4.7::
                 Wide_Equal_Case_Insensitive
                          -- *note A.4.7::
                 Wide_Hash -- *note A.4.7::
                 Wide_Hash_Case_Insensitive -- *note A.4.7::
              Wide_Hash -- *note A.4.7::
              Wide_Hash_Case_Insensitive -- *note A.4.7::
              Wide_Maps -- *note A.4.7::
                 Wide_Constants -- *note A.4.7::
              Wide_Unbounded -- *note A.4.7::
                 Wide_Equal_Case_Insensitive
                          -- *note A.4.7::
                 Wide_Hash -- *note A.4.7::
                 Wide_Hash_Case_Insensitive -- *note A.4.7::
              Wide_Wide_Bounded -- *note A.4.8::
                 Wide_Wide_Equal_Case_Insensitive
                          -- *note A.4.8::
                 Wide_Wide_Hash -- *note A.4.8::
                 Wide_Wide_Hash_Case_Insensitive
                          -- *note A.4.8::
              Wide_Wide_Equal_Case_Insensitive
                       -- *note A.4.8::
              Wide_Wide_Fixed -- *note A.4.8::
                 Wide_Wide_Equal_Case_Insensitive
                          -- *note A.4.8::
                 Wide_Wide_Hash -- *note A.4.8::
                 Wide_Wide_Hash_Case_Insensitive
                          -- *note A.4.8::
              Wide_Wide_Hash -- *note A.4.8::
              Wide_Wide_Hash_Case_Insensitive
                          -- *note A.4.8::
              Wide_Wide_Maps -- *note A.4.8::
                 Wide_Wide_Constants -- *note A.4.8::
              Wide_Wide_Unbounded -- *note A.4.8::
                 Wide_Wide_Equal_Case_Insensitive
                          -- *note A.4.8::
                 Wide_Wide_Hash -- *note A.4.8::
                 Wide_Wide_Hash_Case_Insensitive
                          -- *note A.4.8::
           Synchronous_Barriers -- *note D.10.1::
           Synchronous_Task_Control -- *note D.10::
              EDF -- *note D.10::
     Standard (...continued)
        Ada (...continued)
           Tags -- *note 3.9::
              Generic_Dispatching_Constructor -- *note 3.9::
           Task_Attributes -- *note C.7.2::
           Task_Identification -- *note C.7.1::
           Task_Termination -- *note C.7.3::
           Text_IO -- *note A.10.1::
              Bounded_IO -- *note A.10.11::
              Complex_IO -- *note G.1.3::
              Editing -- *note F.3.3::
              Text_Streams -- *note A.12.2::
              Unbounded_IO -- *note A.10.12::
           Unchecked_Conversion -- *note 13.9::
           Unchecked_Deallocate_Subpool -- *note 13.11.5::
           Unchecked_Deallocation -- *note 13.11.2::
           Wide_Characters -- *note A.3.1::
              Handling -- *note A.3.5::
           Wide_Text_IO -- *note A.11::
              Complex_IO -- *note G.1.4::
              Editing -- *note F.3.4::
              Text_Streams -- *note A.12.3::
              Wide_Bounded_IO -- *note A.11::
              Wide_Unbounded_IO -- *note A.11::
           Wide_Wide_Characters -- *note A.3.1::
              Handling -- *note A.3.6::
           Wide_Wide_Text_IO -- *note A.11::
              Complex_IO -- *note G.1.5::
              Editing -- *note F.3.5::
              Text_Streams -- *note A.12.4::
              Wide_Wide_Bounded_IO -- *note A.11::
              Wide_Wide_Unbounded_IO -- *note A.11::

        Interfaces -- *note B.2::
           C -- *note B.3::
              Pointers -- *note B.3.2::
              Strings -- *note B.3.1::
           COBOL -- *note B.4::
           Fortran -- *note B.5::

        System -- *note 13.7::
           Address_To_Access_Conversions -- *note 13.7.2::
           Machine_Code -- *note 13.8::
           Multiprocessors -- *note D.16::
              Dispatching_Domains -- *note D.16.1::
           RPC -- *note E.5::
           Storage_Elements -- *note 13.7.1::
           Storage_Pools -- *note 13.11::
              Subpools -- *note 13.11.4::

                     _Implementation Requirements_

3/4
The implementation shall ensure that each language-defined subprogram is
reentrant in the sense that concurrent calls on any language-defined
subprogram perform as specified, so long as all objects that are denoted
by parameters that could be passed by reference or designated by
parameters of an access type are nonoverlapping.

3.1/4
For the purpose of determining whether concurrent calls on text
input-output subprograms are required to perform as specified above,
when calling a subprogram within Text_IO or its children that implicitly
operates on one of the default input-output files, the subprogram is
considered to have a parameter of Current_Input or Current_Output (as
appropriate).

3.2/3
If a descendant of a language-defined tagged type is declared, the
implementation shall ensure that each inherited language-defined
subprogram behaves as described in this International Standard.  In
particular, overriding a language-defined subprogram shall not alter the
effect of any inherited language-defined subprogram.

                     _Implementation Permissions_

4
The implementation may restrict the replacement of language-defined
compilation units.  The implementation may restrict children of
language-defined library units (other than Standard).

* Menu:

* A.1 ::      The Package Standard
* A.2 ::      The Package Ada
* A.3 ::      Character Handling
* A.4 ::      String Handling
* A.5 ::      The Numerics Packages
* A.6 ::      Input-Output
* A.7 ::      External Files and File Objects
* A.8 ::      Sequential and Direct Files
* A.9 ::      The Generic Package Storage_IO
* A.10 ::     Text Input-Output
* A.11 ::     Wide Text Input-Output and Wide Wide Text Input-Output
* A.12 ::     Stream Input-Output
* A.13 ::     Exceptions in Input-Output
* A.14 ::     File Sharing
* A.15 ::     The Package Command_Line
* A.16 ::     The Package Directories
* A.17 ::     The Package Environment_Variables
* A.18 ::     Containers
* A.19 ::     The Package Locales


File: arm2012.info,  Node: A.1,  Next: A.2,  Up: Annex A

A.1 The Package Standard
========================

1/3
This subclause outlines the specification of the package Standard
containing all predefined identifiers in the language. The corresponding
package body is not specified by the language.

2
The operators that are predefined for the types declared in the package
Standard are given in comments since they are implicitly declared.
Italics are used for pseudo-names of anonymous types (such as root_real)
and for undefined information (such as implementation-defined).

                          _Static Semantics_

3
The library package Standard has the following declaration:

4
     package Standard is
        pragma Pure(Standard);

5
        type Boolean is (False, True);

6
        -- The predefined relational operators for this type are as follows:

7/1
        -- function "="   (Left, Right : Boolean'Base) return Boolean;
        -- function "/="  (Left, Right : Boolean'Base) return Boolean;
        -- function "<"   (Left, Right : Boolean'Base) return Boolean;
        -- function "<="  (Left, Right : Boolean'Base) return Boolean;
        -- function ">"   (Left, Right : Boolean'Base) return Boolean;
        -- function ">="  (Left, Right : Boolean'Base) return Boolean;

8
        -- The predefined logical operators and the predefined logical
        -- negation operator are as follows:

9/1
        -- function "and" (Left, Right : Boolean'Base) return Boolean'Base;
        -- function "or"  (Left, Right : Boolean'Base) return Boolean'Base;
        -- function "xor" (Left, Right : Boolean'Base) return Boolean'Base;

10/1
        -- function "not" (Right : Boolean'Base) return Boolean'Base;

11/2
        -- The integer type root_integer and the
        -- corresponding universal type universal_integer are predefined.

12
        type Integer is range implementation-defined;

13
        subtype Natural  is Integer range 0 .. Integer'Last;
        subtype Positive is Integer range 1 .. Integer'Last;

14
        -- The predefined operators for type Integer are as follows:

15
        -- function "="  (Left, Right : Integer'Base) return Boolean;
        -- function "/=" (Left, Right : Integer'Base) return Boolean;
        -- function "<"  (Left, Right : Integer'Base) return Boolean;
        -- function "<=" (Left, Right : Integer'Base) return Boolean;
        -- function ">"  (Left, Right : Integer'Base) return Boolean;
        -- function ">=" (Left, Right : Integer'Base) return Boolean;

16
        -- function "+"   (Right : Integer'Base) return Integer'Base;
        -- function "-"   (Right : Integer'Base) return Integer'Base;
        -- function "abs" (Right : Integer'Base) return Integer'Base;

17
        -- function "+"   (Left, Right : Integer'Base) return Integer'Base;
        -- function "-"   (Left, Right : Integer'Base) return Integer'Base;
        -- function "*"   (Left, Right : Integer'Base) return Integer'Base;
        -- function "/"   (Left, Right : Integer'Base) return Integer'Base;
        -- function "rem" (Left, Right : Integer'Base) return Integer'Base;
        -- function "mod" (Left, Right : Integer'Base) return Integer'Base;

18
        -- function "**"  (Left : Integer'Base; Right : Natural)
        --                  return Integer'Base;

19
        -- The specification of each operator for the type
        -- root_integer, or for any additional predefined integer
        -- type, is obtained by replacing Integer by the name of the type
        -- in the specification of the corresponding operator of the type
        -- Integer. The right operand of the exponentiation operator
        -- remains as subtype Natural.

20/2
        -- The floating point type root_real and the
        -- corresponding universal type universal_real are predefined.

21
        type Float is digits implementation-defined;

22
        -- The predefined operators for this type are as follows:

23
        -- function "="   (Left, Right : Float) return Boolean;
        -- function "/="  (Left, Right : Float) return Boolean;
        -- function "<"   (Left, Right : Float) return Boolean;
        -- function "<="  (Left, Right : Float) return Boolean;
        -- function ">"   (Left, Right : Float) return Boolean;
        -- function ">="  (Left, Right : Float) return Boolean;

24
        -- function "+"   (Right : Float) return Float;
        -- function "-"   (Right : Float) return Float;
        -- function "abs" (Right : Float) return Float;

25
        -- function "+"   (Left, Right : Float) return Float;
        -- function "-"   (Left, Right : Float) return Float;
        -- function "*"   (Left, Right : Float) return Float;
        -- function "/"   (Left, Right : Float) return Float;

26
        -- function "**"  (Left : Float; Right : Integer'Base) return Float;

27
        -- The specification of each operator for the type root_real, or for
        -- any additional predefined floating point type, is obtained by
        -- replacing Float by the name of the type in the specification of the
        -- corresponding operator of the type Float.

28
        -- In addition, the following operators are predefined for the root
        -- numeric types:

29
        function "*" (Left : root_integer; Right : root_real)
          return root_real;

30
        function "*" (Left : root_real;    Right : root_integer)
          return root_real;

31
        function "/" (Left : root_real;    Right : root_integer)
          return root_real;

32
        -- The type universal_fixed is predefined.
        -- The only multiplying operators defined between
        -- fixed point types are

33
        function "*" (Left : universal_fixed; Right : universal_fixed)
          return universal_fixed;

34
        function "/" (Left : universal_fixed; Right : universal_fixed)
          return universal_fixed;

34.1/2
        -- The type universal_access is predefined.
        -- The following equality operators are predefined:

34.2/2
        function "="  (Left, Right: universal_access) return Boolean;
        function "/=" (Left, Right: universal_access) return Boolean;

35/3
           -- The declaration of type Character is based on the standard ISO 8859-1 character set.

           -- There are no character literals corresponding to the positions for control characters.
           -- They are indicated in italics in this definition. See *note 3.5.2::.

        type Character is
          (nul,   soh,   stx,   etx,   eot,   enq,   ack,   bel,   --0 (16#00#) .. 7 (16#07#)
           bs,   ht,   lf,   vt,   ff,   cr,   so,   si,   --8 (16#08#) .. 15 (16#0F#)

           dle,   dc1,   dc2,   dc3,   dc4,   nak,   syn,   etb,   --16 (16#10#) .. 23 (16#17#)
           can,   em,   sub,   esc,   fs,   gs,   rs,   us,   --24 (16#18#) .. 31 (16#1F#)

           ' ',   '!',   '"',   '#',   '$',   '%',   '&',   ''',   --32 (16#20#) .. 39 (16#27#)
           '(',   ')',   '*',   '+',   ',',   '-',   '.',   '/',   --40 (16#28#) .. 47 (16#2F#)

           '0',   '1',   '2',   '3',   '4',   '5',   '6',   '7',   --48 (16#30#) .. 55 (16#37#)
           '8',   '9',   ':',   ';',   '<',   '=',   '>',   '?',   --56 (16#38#) .. 63 (16#3F#)

           '@',   'A',   'B',   'C',   'D',   'E',   'F',   'G',   --64 (16#40#) .. 71 (16#47#)
           'H',   'I',   'J',   'K',   'L',   'M',   'N',   'O',   --72 (16#48#) .. 79 (16#4F#)

           'P',   'Q',   'R',   'S',   'T',   'U',   'V',   'W',   --80 (16#50#) .. 87 (16#57#)
           'X',   'Y',   'Z',   '[',   '\',   ']',   '^',   '_',   --88 (16#58#) .. 95 (16#5F#)

           '`',   'a',   'b',   'c',   'd',   'e',   'f',   'g',   --96 (16#60#) .. 103 (16#67#)
           'h',   'i',   'j',   'k',   'l',   'm',   'n',   'o',   --104 (16#68#) .. 111 (16#6F#)

           'p',   'q',   'r',   's',   't',   'u',   'v',   'w',   --112 (16#70#) .. 119 (16#77#)
           'x',   'y',   'z',   '{',   '|',   '}',   '~',   del,   --120 (16#78#) .. 127 (16#7F#)

           reserved_128,   reserved_129,   bph,   nbh,         --128 (16#80#) .. 131 (16#83#)
           reserved_132,   nel,   ssa,   esa,            --132 (16#84#) .. 135 (16#87#)
           hts,   htj,   vts,   pld,   plu,   ri,   ss2,   ss3,   --136 (16#88#) .. 143 (16#8F#)

           dcs,   pu1,   pu2,   sts,   cch,   mw,   spa,   epa,   --144 (16#90#) .. 151 (16#97#)
           sos,   reserved_153,   sci,   csi,            --152 (16#98#) .. 155 (16#9B#)
           st,   osc,   pm,   apc,               --156 (16#9C#) .. 159 (16#9F#)

           ' ',   '¡',   '¢',   '£',   '¤',   '¥',   '¦',   '§',   --160 (16#A0#) .. 167 (16#A7#)
           '¨',   '©',   'ª',   '«',               --168 (16#A8#) .. 171 (16#AB#)
           ¬',   soft_hyphen,   '®',   '¯',            --172 (16#AC#) .. 175 (16#AF#)

           '°',   '±',   '²',   '³',   '´',   'µ',   '¶',   '·',   --176 (16#B0#) .. 183 (16#B7#)
           '¸',   '¹',   'º',   '»',   '¼',   '½',   '¾',   '¿',   --184 (16#B8#) .. 191 (16#BF#)

           'À',   'Á',   'Â',   'Ã',   'Ä',   'Å',   'Æ',   'Ç',   --192 (16#C0#) .. 199 (16#C7#)
           'È',   'É',   'Ê',   'Ë',   'Ì',   'Í',   'Î',   'Ï',   --200 (16#C8#) .. 207 (16#CF#)

           'Ð',   'Ñ',   'Ò',   'Ó',   'Ô',   'Õ',   'Ö',   '×',   --208 (16#D0#) .. 215 (16#D7#)
           'Ø',   'Ù',   'Ú',   'Û',   'Ü',   'Ý',   'Þ',   'ß',   --216 (16#D8#) .. 223 (16#DF#)

           'à',   'á',   'â',   'ã',   'ä',   'å',   'æ',   'ç',   --224 (16#E0#) .. 231 (16#E7#)
           'è',   'é',   'ê',   'ë',   'ì',   'í',   'î',   'ï',   --232 (16#E8#) .. 239 (16#EF#)

           'ð',   'ñ',   'ò',   'ó',   'ô',   'õ',   'ö',   '÷',   --240 (16#F0#) .. 247 (16#F7#)
           'ø',   'ù',   'ú',   'û',   'ü',   'ý',   'þ',   'ÿ');--248 (16#F8#) .. 255 (16#FF#)

36
        -- The predefined operators for the type Character are the same as for
        -- any enumeration type.


36.1/3
        -- The declaration of type Wide_Character is based on the standard ISO/IEC 10646:2011 BMP character
        -- set. The first 256 positions have the same contents as type Character. See *note 3.5.2::.

        type Wide_Character is (nul, soh ... Hex_0000FFFE, Hex_0000FFFF);

36.2/3
        -- The declaration of type Wide_Wide_Character is based on the full
        -- ISO/IEC 10646:2011 character set. The first 65536 positions have the
        -- same contents as type Wide_Character. See *note 3.5.2::.

        type Wide_Wide_Character is (nul, soh ... Hex_7FFFFFFE, Hex_7FFFFFFF);
        for Wide_Wide_Character'Size use 32;

36.3/2
        package ASCII is ... end ASCII;  --Obsolescent; see *note J.5::



37/3
        -- Predefined string types:

        type String is array(Positive range <>) of Character
           with Pack;

38
        -- The predefined operators for this type are as follows:

39
        --     function "="  (Left, Right: String) return Boolean;
        --     function "/=" (Left, Right: String) return Boolean;
        --     function "<"  (Left, Right: String) return Boolean;
        --     function "<=" (Left, Right: String) return Boolean;
        --     function ">"  (Left, Right: String) return Boolean;
        --     function ">=" (Left, Right: String) return Boolean;

40
        --     function "&" (Left: String;    Right: String)    return String;
        --     function "&" (Left: Character; Right: String)    return String;
        --     function "&" (Left: String;    Right: Character) return String;
        --     function "&" (Left: Character; Right: Character) return String;

41/3
        type Wide_String is array(Positive range <>) of Wide_Character
           with Pack;

42
        -- The predefined operators for this type correspond to those for String.

42.1/3
        type Wide_Wide_String is array (Positive range <>)
           of Wide_Wide_Character
              with Pack;

42.2/2
        -- The predefined operators for this type correspond to those for String.

43
        type Duration is delta implementation-defined range implementation-defined;

44
           -- The predefined operators for the type Duration are the same as for
           -- any fixed point type.

45
        -- The predefined exceptions:

46
        Constraint_Error: exception;
        Program_Error   : exception;
        Storage_Error   : exception;
        Tasking_Error   : exception;

47
     end Standard;

48
Standard has no private part.

49/2
In each of the types Character, Wide_Character, and Wide_Wide_Character,
the character literals for the space character (position 32) and the
non-breaking space character (position 160) correspond to different
values.  Unless indicated otherwise, each occurrence of the character
literal ' ' in this International Standard refers to the space
character.  Similarly, the character literals for hyphen (position 45)
and soft hyphen (position 173) correspond to different values.  Unless
indicated otherwise, each occurrence of the character literal '-' in
this International Standard refers to the hyphen character.

                          _Dynamic Semantics_

50
Elaboration of the body of Standard has no effect.

                     _Implementation Permissions_

51
An implementation may provide additional predefined integer types and
additional predefined floating point types.  Not all of these types need
have names.

                        _Implementation Advice_

52
If an implementation provides additional named predefined integer types,
then the names should end with "Integer" as in "Long_Integer".  If an
implementation provides additional named predefined floating point
types, then the names should end with "Float" as in "Long_Float".

     NOTES

53
     1  Certain aspects of the predefined entities cannot be completely
     described in the language itself.  For example, although the
     enumeration type Boolean can be written showing the two enumeration
     literals False and True, the short-circuit control forms cannot be
     expressed in the language.

54
     2  As explained in *note 8.1::, "*note 8.1:: Declarative Region"
     and *note 10.1.4::, "*note 10.1.4:: The Compilation Process", the
     declarative region of the package Standard encloses every library
     unit and consequently the main subprogram; the declaration of every
     library unit is assumed to occur within this declarative region.
     Library_items are assumed to be ordered in such a way that there
     are no forward semantic dependences.  However, as explained in
     *note 8.3::, "*note 8.3:: Visibility", the only library units that
     are visible within a given compilation unit are the library units
     named by all with_clauses that apply to the given unit, and
     moreover, within the declarative region of a given library unit,
     that library unit itself.

55
     3  If all block_statements of a program are named, then the name of
     each program unit can always be written as an expanded name
     starting with Standard (unless Standard is itself hidden).  The
     name of a library unit cannot be a homograph of a name (such as
     Integer) that is already declared in Standard.

56
     4  The exception Standard.Numeric_Error is defined in *note J.6::.


File: arm2012.info,  Node: A.2,  Next: A.3,  Prev: A.1,  Up: Annex A

A.2 The Package Ada
===================

                          _Static Semantics_

1
The following language-defined library package exists:

2
     package Ada is
         pragma Pure(Ada);
     end Ada;

3
Ada serves as the parent of most of the other language-defined library
units; its declaration is empty (except for the pragma Pure).

                           _Legality Rules_

4
In the standard mode, it is illegal to compile a child of package Ada.


File: arm2012.info,  Node: A.3,  Next: A.4,  Prev: A.2,  Up: Annex A

A.3 Character Handling
======================

1/3
This subclause presents the packages related to character processing: an
empty declared pure package Characters and child packages
Characters.Handling and Characters.Latin_1.  The package
Characters.Handling provides classification and conversion functions for
Character data, and some simple functions for dealing with
Wide_Character and Wide_Wide_Character data.  The child package
Characters.Latin_1 declares a set of constants initialized to values of
type Character.

* Menu:

* A.3.1 ::    The Packages Characters, Wide_Characters, and Wide_Wide_Characters
* A.3.2 ::    The Package Characters.Handling
* A.3.3 ::    The Package Characters.Latin_1
* A.3.4 ::    The Package Characters.Conversions
* A.3.5 ::    The Package Wide_Characters.Handling
* A.3.6 ::    The Package Wide_Wide_Characters.Handling


File: arm2012.info,  Node: A.3.1,  Next: A.3.2,  Up: A.3

A.3.1 The Packages Characters, Wide_Characters, and Wide_Wide_Characters
------------------------------------------------------------------------

                          _Static Semantics_

1
The library package Characters has the following declaration:

2
     package Ada.Characters is
       pragma Pure(Characters);
     end Ada.Characters;

3/2
The library package Wide_Characters has the following declaration:

4/2
     package Ada.Wide_Characters is
       pragma Pure(Wide_Characters);
     end Ada.Wide_Characters;

5/2
The library package Wide_Wide_Characters has the following declaration:

6/2
     package Ada.Wide_Wide_Characters is
       pragma Pure(Wide_Wide_Characters);
     end Ada.Wide_Wide_Characters;

                        _Implementation Advice_

7/3
If an implementation chooses to provide implementation-defined
operations on Wide_Character or Wide_String (such as collating and
sorting, etc.)  it should do so by providing child units of
Wide_Characters.  Similarly if it chooses to provide
implementation-defined operations on Wide_Wide_Character or
Wide_Wide_String it should do so by providing child units of
Wide_Wide_Characters.


File: arm2012.info,  Node: A.3.2,  Next: A.3.3,  Prev: A.3.1,  Up: A.3

A.3.2 The Package Characters.Handling
-------------------------------------

                          _Static Semantics_

1
The library package Characters.Handling has the following declaration:

2/2
     with Ada.Characters.Conversions;
     package Ada.Characters.Handling is
       pragma Pure(Handling);

3
     --Character classification functions

4/3
       function Is_Control           (Item : in Character) return Boolean;
       function Is_Graphic           (Item : in Character) return Boolean;
       function Is_Letter            (Item : in Character) return Boolean;
       function Is_Lower             (Item : in Character) return Boolean;
       function Is_Upper             (Item : in Character) return Boolean;
       function Is_Basic             (Item : in Character) return Boolean;
       function Is_Digit             (Item : in Character) return Boolean;
       function Is_Decimal_Digit     (Item : in Character) return Boolean
                          renames Is_Digit;
       function Is_Hexadecimal_Digit (Item : in Character) return Boolean;
       function Is_Alphanumeric      (Item : in Character) return Boolean;
       function Is_Special           (Item : in Character) return Boolean;
       function Is_Line_Terminator   (Item : in Character) return Boolean;
       function Is_Mark              (Item : in Character) return Boolean;
       function Is_Other_Format      (Item : in Character) return Boolean;
       function Is_Punctuation_Connector (Item : in Character) return Boolean;
       function Is_Space             (Item : in Character) return Boolean;

5
     --Conversion functions for Character and String

6
       function To_Lower (Item : in Character) return Character;
       function To_Upper (Item : in Character) return Character;
       function To_Basic (Item : in Character) return Character;

7
       function To_Lower (Item : in String) return String;
       function To_Upper (Item : in String) return String;
       function To_Basic (Item : in String) return String;

8
     --Classifications of and conversions between Character and ISO 646

9
       subtype ISO_646 is
         Character range Character'Val(0) .. Character'Val(127);

10
       function Is_ISO_646 (Item : in Character) return Boolean;
       function Is_ISO_646 (Item : in String)    return Boolean;

11
       function To_ISO_646 (Item       : in Character;
                            Substitute : in ISO_646 := ' ')
         return ISO_646;

12
       function To_ISO_646 (Item       : in String;
                            Substitute : in ISO_646 := ' ')
         return String;

13/2
     -- The functions Is_Character, Is_String, To_Character, To_String, To_Wide_Character,
     -- and To_Wide_String are obsolescent; see *note J.14::.

     Paragraphs 14 through 18 were deleted.

19
     end Ada.Characters.Handling;

20
In the description below for each function that returns a Boolean
result, the effect is described in terms of the conditions under which
the value True is returned.  If these conditions are not met, then the
function returns False.

21
Each of the following classification functions has a formal Character
parameter, Item, and returns a Boolean result.

22
Is_Control
               True if Item is a control character.  A control character
               is a character whose position is in one of the ranges
               0..31 or 127..159.

23
Is_Graphic
               True if Item is a graphic character.  A graphic character
               is a character whose position is in one of the ranges
               32..126 or 160..255.

24
Is_Letter
               True if Item is a letter.  A letter is a character that
               is in one of the ranges 'A'..'Z' or 'a'..'z', or whose
               position is in one of the ranges 192..214, 216..246, or
               248..255.

25
Is_Lower
               True if Item is a lower-case letter.  A lower-case letter
               is a character that is in the range 'a'..'z', or whose
               position is in one of the ranges 223..246 or 248..255.

26
Is_Upper
               True if Item is an upper-case letter.  An upper-case
               letter is a character that is in the range 'A'..'Z' or
               whose position is in one of the ranges 192..214 or 216..
               222.

27
Is_Basic
               True if Item is a basic letter.  A basic letter is a
               character that is in one of the ranges 'A'..'Z' and
               'a'..'z', or that is one of the following: 'Æ', 'æ', 'Ð',
               'ð', 'Þ', 'þ', or 'ß'.

28
Is_Digit
               True if Item is a decimal digit.  A decimal digit is a
               character in the range '0'..'9'.

29
Is_Decimal_Digit
               A renaming of Is_Digit.

30
Is_Hexadecimal_Digit
               True if Item is a hexadecimal digit.  A hexadecimal digit
               is a character that is either a decimal digit or that is
               in one of the ranges 'A' ..  'F' or 'a' ..  'f'.

31
Is_Alphanumeric
               True if Item is an alphanumeric character.  An
               alphanumeric character is a character that is either a
               letter or a decimal digit.

32
Is_Special
               True if Item is a special graphic character.  A special
               graphic character is a graphic character that is not
               alphanumeric.

32.1/3
Is_Line_Terminator
               True if Item is a character with position 10 ..  13
               (Line_Feed, Line_Tabulation, Form_Feed, Carriage_Return)
               or 133 (Next_Line).

32.2/3
Is_Mark
               Never True (no value of type Character has categories
               Mark, Non-Spacing or Mark, Spacing Combining).

32.3/3
Is_Other_Format
               True if Item is a character with position 173
               (Soft_Hyphen).

32.4/3
Is_Punctuation_Connector
               True if Item is a character with position 95 ('_', known
               as Low_Line or Underscore).

32.5/3
Is_Space
               True if Item is a character with position 32 (' ') or 160
               (No_Break_Space).

33
Each of the names To_Lower, To_Upper, and To_Basic refers to two
functions: one that converts from Character to Character, and the other
that converts from String to String.  The result of each
Character-to-Character function is described below, in terms of the
conversion applied to Item, its formal Character parameter.  The result
of each String-to-String conversion is obtained by applying to each
element of the function's String parameter the corresponding
Character-to-Character conversion; the result is the null String if the
value of the formal parameter is the null String.  The lower bound of
the result String is 1.

34
To_Lower
               Returns the corresponding lower-case value for Item if
               Is_Upper(Item), and returns Item otherwise.

35
To_Upper
               Returns the corresponding upper-case value for Item if
               Is_Lower(Item) and Item has an upper-case form, and
               returns Item otherwise.  The lower case letters 'ß' and
               'ÿ' do not have upper case forms.

36
To_Basic
               Returns the letter corresponding to Item but with no
               diacritical mark, if Item is a letter but not a basic
               letter; returns Item otherwise.

37
The following set of functions test for membership in the ISO 646
character range, or convert between ISO 646 and Character.

38
Is_ISO_646
               The function whose formal parameter, Item, is of type
               Character returns True if Item is in the subtype ISO_646.

39
Is_ISO_646
               The function whose formal parameter, Item, is of type
               String returns True if Is_ISO_646(Item(I)) is True for
               each I in Item'Range.

40
To_ISO_646
               The function whose first formal parameter, Item, is of
               type Character returns Item if Is_ISO_646(Item), and
               returns the Substitute ISO_646 character otherwise.

41
To_ISO_646
               The function whose first formal parameter, Item, is of
               type String returns the String whose Range is
               1..Item'Length and each of whose elements is given by
               To_ISO_646 of the corresponding element in Item.

Paragraphs 42 through 49 were deleted.

     NOTES

50
     5  A basic letter is a letter without a diacritical mark.

51
     6  Except for the hexadecimal digits, basic letters, and ISO_646
     characters, the categories identified in the classification
     functions form a strict hierarchy:

52
          -- Control characters

53
          -- Graphic characters

54
             -- Alphanumeric characters

55
                -- Letters

56
                   -- Upper-case letters

57
                   -- Lower-case letters

58
                -- Decimal digits

59
             -- Special graphic characters

60/3
     7  There are certain characters which are defined to be lower case
     letters by ISO 10646 and are therefore allowed in identifiers, but
     are not considered lower case letters by Ada.Characters.Handling.


File: arm2012.info,  Node: A.3.3,  Next: A.3.4,  Prev: A.3.2,  Up: A.3

A.3.3 The Package Characters.Latin_1
------------------------------------

1
The package Characters.Latin_1 declares constants for characters in ISO
8859-1.

                          _Static Semantics_

2
The library package Characters.Latin_1 has the following declaration:

3
     package Ada.Characters.Latin_1 is
         pragma Pure(Latin_1);

4
     -- Control characters:

5
         NUL                  : constant Character := Character'Val(0);
         SOH                  : constant Character := Character'Val(1);
         STX                  : constant Character := Character'Val(2);
         ETX                  : constant Character := Character'Val(3);
         EOT                  : constant Character := Character'Val(4);
         ENQ                  : constant Character := Character'Val(5);
         ACK                  : constant Character := Character'Val(6);
         BEL                  : constant Character := Character'Val(7);
         BS                   : constant Character := Character'Val(8);
         HT                   : constant Character := Character'Val(9);
         LF                   : constant Character := Character'Val(10);
         VT                   : constant Character := Character'Val(11);
         FF                   : constant Character := Character'Val(12);
         CR                   : constant Character := Character'Val(13);
         SO                   : constant Character := Character'Val(14);
         SI                   : constant Character := Character'Val(15);

6
         DLE                  : constant Character := Character'Val(16);
         DC1                  : constant Character := Character'Val(17);
         DC2                  : constant Character := Character'Val(18);
         DC3                  : constant Character := Character'Val(19);
         DC4                  : constant Character := Character'Val(20);
         NAK                  : constant Character := Character'Val(21);
         SYN                  : constant Character := Character'Val(22);
         ETB                  : constant Character := Character'Val(23);
         CAN                  : constant Character := Character'Val(24);
         EM                   : constant Character := Character'Val(25);
         SUB                  : constant Character := Character'Val(26);
         ESC                  : constant Character := Character'Val(27);
         FS                   : constant Character := Character'Val(28);
         GS                   : constant Character := Character'Val(29);
         RS                   : constant Character := Character'Val(30);
         US                   : constant Character := Character'Val(31);

7
     -- ISO 646 graphic characters:

8
         Space                : constant Character := ' ';  -- Character'Val(32)
         Exclamation          : constant Character := '!';  -- Character'Val(33)
         Quotation            : constant Character := '"';  -- Character'Val(34)
         Number_Sign          : constant Character := '#';  -- Character'Val(35)
         Dollar_Sign          : constant Character := '$';  -- Character'Val(36)
         Percent_Sign         : constant Character := '%';  -- Character'Val(37)
         Ampersand            : constant Character := '&';  -- Character'Val(38)
         Apostrophe           : constant Character := ''';  -- Character'Val(39)
         Left_Parenthesis     : constant Character := '(';  -- Character'Val(40)
         Right_Parenthesis    : constant Character := ')';  -- Character'Val(41)
         Asterisk             : constant Character := '*';  -- Character'Val(42)
         Plus_Sign            : constant Character := '+';  -- Character'Val(43)
         Comma                : constant Character := ',';  -- Character'Val(44)
         Hyphen               : constant Character := '-';  -- Character'Val(45)
         Minus_Sign           : Character renames Hyphen;
         Full_Stop            : constant Character := '.';  -- Character'Val(46)
         Solidus              : constant Character := '/';  -- Character'Val(47)

9
         -- Decimal digits '0' though '9' are at positions 48 through 57

10
         Colon                : constant Character := ':';  -- Character'Val(58)
         Semicolon            : constant Character := ';';  -- Character'Val(59)
         Less_Than_Sign       : constant Character := '<';  -- Character'Val(60)
         Equals_Sign          : constant Character := '=';  -- Character'Val(61)
         Greater_Than_Sign    : constant Character := '>';  -- Character'Val(62)
         Question             : constant Character := '?';  -- Character'Val(63)
         Commercial_At        : constant Character := '@';  -- Character'Val(64)

11
         -- Letters 'A' through 'Z' are at positions 65 through 90

12
         Left_Square_Bracket  : constant Character := '[';  -- Character'Val(91)
         Reverse_Solidus      : constant Character := '\';  -- Character'Val(92)
         Right_Square_Bracket : constant Character := ']';  -- Character'Val(93)
         Circumflex           : constant Character := '^';  -- Character'Val(94)
         Low_Line             : constant Character := '_';  -- Character'Val(95)

13
         Grave                : constant Character := '`';  -- Character'Val(96)
         LC_A                 : constant Character := 'a';  -- Character'Val(97)
         LC_B                 : constant Character := 'b';  -- Character'Val(98)
         LC_C                 : constant Character := 'c';  -- Character'Val(99)
         LC_D                 : constant Character := 'd';  -- Character'Val(100)
         LC_E                 : constant Character := 'e';  -- Character'Val(101)
         LC_F                 : constant Character := 'f';  -- Character'Val(102)
         LC_G                 : constant Character := 'g';  -- Character'Val(103)
         LC_H                 : constant Character := 'h';  -- Character'Val(104)
         LC_I                 : constant Character := 'i';  -- Character'Val(105)
         LC_J                 : constant Character := 'j';  -- Character'Val(106)
         LC_K                 : constant Character := 'k';  -- Character'Val(107)
         LC_L                 : constant Character := 'l';  -- Character'Val(108)
         LC_M                 : constant Character := 'm';  -- Character'Val(109)
         LC_N                 : constant Character := 'n';  -- Character'Val(110)
         LC_O                 : constant Character := 'o';  -- Character'Val(111)

14
         LC_P                 : constant Character := 'p';  -- Character'Val(112)
         LC_Q                 : constant Character := 'q';  -- Character'Val(113)
         LC_R                 : constant Character := 'r';  -- Character'Val(114)
         LC_S                 : constant Character := 's';  -- Character'Val(115)
         LC_T                 : constant Character := 't';  -- Character'Val(116)
         LC_U                 : constant Character := 'u';  -- Character'Val(117)
         LC_V                 : constant Character := 'v';  -- Character'Val(118)
         LC_W                 : constant Character := 'w';  -- Character'Val(119)
         LC_X                 : constant Character := 'x';  -- Character'Val(120)
         LC_Y                 : constant Character := 'y';  -- Character'Val(121)
         LC_Z                 : constant Character := 'z';  -- Character'Val(122)
         Left_Curly_Bracket   : constant Character := '{';  -- Character'Val(123)
         Vertical_Line        : constant Character := '|';  -- Character'Val(124)
         Right_Curly_Bracket  : constant Character := '}';  -- Character'Val(125)
         Tilde                : constant Character := '~';  -- Character'Val(126)
         DEL                  : constant Character := Character'Val(127);

15
     -- ISO 6429 control characters:

16
         IS4                  : Character renames FS;
         IS3                  : Character renames GS;
         IS2                  : Character renames RS;
         IS1                  : Character renames US;

17
         Reserved_128         : constant Character := Character'Val(128);
         Reserved_129         : constant Character := Character'Val(129);
         BPH                  : constant Character := Character'Val(130);
         NBH                  : constant Character := Character'Val(131);
         Reserved_132         : constant Character := Character'Val(132);
         NEL                  : constant Character := Character'Val(133);
         SSA                  : constant Character := Character'Val(134);
         ESA                  : constant Character := Character'Val(135);
         HTS                  : constant Character := Character'Val(136);
         HTJ                  : constant Character := Character'Val(137);
         VTS                  : constant Character := Character'Val(138);
         PLD                  : constant Character := Character'Val(139);
         PLU                  : constant Character := Character'Val(140);
         RI                   : constant Character := Character'Val(141);
         SS2                  : constant Character := Character'Val(142);
         SS3                  : constant Character := Character'Val(143);

18
         DCS                  : constant Character := Character'Val(144);
         PU1                  : constant Character := Character'Val(145);
         PU2                  : constant Character := Character'Val(146);
         STS                  : constant Character := Character'Val(147);
         CCH                  : constant Character := Character'Val(148);
         MW                   : constant Character := Character'Val(149);
         SPA                  : constant Character := Character'Val(150);
         EPA                  : constant Character := Character'Val(151);

19
         SOS                  : constant Character := Character'Val(152);
         Reserved_153         : constant Character := Character'Val(153);
         SCI                  : constant Character := Character'Val(154);
         CSI                  : constant Character := Character'Val(155);
         ST                   : constant Character := Character'Val(156);
         OSC                  : constant Character := Character'Val(157);
         PM                   : constant Character := Character'Val(158);
         APC                  : constant Character := Character'Val(159);

20
     -- Other graphic characters:

21/3
     -- Character positions 160 (16#A0#) .. 175 (16#AF#):
         No_Break_Space             : constant Character := ' '; --Character'Val(160)
         NBSP                       : Character renames No_Break_Space;
         Inverted_Exclamation       : constant Character := '¡'; --Character'Val(161)
         Cent_Sign                  : constant Character := '¢'; --Character'Val(162)
         Pound_Sign                 : constant Character := '£'; --Character'Val(163)
         Currency_Sign              : constant Character := '¤'; --Character'Val(164)
         Yen_Sign                   : constant Character := '¥'; --Character'Val(165)
         Broken_Bar                 : constant Character := '¦'; --Character'Val(166)
         Section_Sign               : constant Character := '§'; --Character'Val(167)
         Diaeresis                  : constant Character := '¨'; --Character'Val(168)
         Copyright_Sign             : constant Character := '©'; --Character'Val(169)
         Feminine_Ordinal_Indicator : constant Character := 'ª'; --Character'Val(170)
         Left_Angle_Quotation       : constant Character := '«'; --Character'Val(171)
         Not_Sign                   : constant Character := '¬'; --Character'Val(172)
         Soft_Hyphen                : constant Character := Character'Val(173);
         Registered_Trade_Mark_Sign : constant Character := '®'; --Character'Val(174)
         Macron                     : constant Character := '¯'; --Character'Val(175)

22
     -- Character positions 176 (16#B0#) .. 191 (16#BF#):
         Degree_Sign                : constant Character := '°'; --Character'Val(176)
         Ring_Above                 : Character renames Degree_Sign;
         Plus_Minus_Sign            : constant Character := '±'; --Character'Val(177)
         Superscript_Two            : constant Character := '²'; --Character'Val(178)
         Superscript_Three          : constant Character := '³'; --Character'Val(179)
         Acute                      : constant Character := '´'; --Character'Val(180)
         Micro_Sign                 : constant Character := 'µ'; --Character'Val(181)
         Pilcrow_Sign               : constant Character := '¶'; --Character'Val(182)
         Paragraph_Sign             : Character renames Pilcrow_Sign;
         Middle_Dot                 : constant Character := '·'; --Character'Val(183)
         Cedilla                    : constant Character := '¸'; --Character'Val(184)
         Superscript_One            : constant Character := '¹'; --Character'Val(185)
         Masculine_Ordinal_Indicator: constant Character := 'º'; --Character'Val(186)
         Right_Angle_Quotation      : constant Character := '»'; --Character'Val(187)
         Fraction_One_Quarter       : constant Character := '¼'; --Character'Val(188)
         Fraction_One_Half          : constant Character := '½'; --Character'Val(189)
         Fraction_Three_Quarters    : constant Character := '¾'; --Character'Val(190)
         Inverted_Question          : constant Character := '¿'; --Character'Val(191)

23
     -- Character positions 192 (16#C0#) .. 207 (16#CF#):
         UC_A_Grave                 : constant Character := 'À'; --Character'Val(192)
         UC_A_Acute                 : constant Character := 'Á'; --Character'Val(193)
         UC_A_Circumflex            : constant Character := 'Â'; --Character'Val(194)
         UC_A_Tilde                 : constant Character := 'Ã'; --Character'Val(195)
         UC_A_Diaeresis             : constant Character := 'Ä'; --Character'Val(196)
         UC_A_Ring                  : constant Character := 'Å'; --Character'Val(197)
         UC_AE_Diphthong            : constant Character := 'Æ'; --Character'Val(198)
         UC_C_Cedilla               : constant Character := 'Ç'; --Character'Val(199)
         UC_E_Grave                 : constant Character := 'È'; --Character'Val(200)
         UC_E_Acute                 : constant Character := 'É'; --Character'Val(201)
         UC_E_Circumflex            : constant Character := 'Ê'; --Character'Val(202)
         UC_E_Diaeresis             : constant Character := 'Ë'; --Character'Val(203)
         UC_I_Grave                 : constant Character := 'Ì'; --Character'Val(204)
         UC_I_Acute                 : constant Character := 'Í'; --Character'Val(205)
         UC_I_Circumflex            : constant Character := 'Î'; --Character'Val(206)
         UC_I_Diaeresis             : constant Character := 'Ï'; --Character'Val(207)

24
     -- Character positions 208 (16#D0#) .. 223 (16#DF#):
         UC_Icelandic_Eth           : constant Character := 'Ð'; --Character'Val(208)
         UC_N_Tilde                 : constant Character := 'Ñ'; --Character'Val(209)
         UC_O_Grave                 : constant Character := 'Ò'; --Character'Val(210)
         UC_O_Acute                 : constant Character := 'Ó'; --Character'Val(211)
         UC_O_Circumflex            : constant Character := 'Ô'; --Character'Val(212)
         UC_O_Tilde                 : constant Character := 'Õ'; --Character'Val(213)
         UC_O_Diaeresis             : constant Character := 'Ö'; --Character'Val(214)
         Multiplication_Sign        : constant Character := '×'; --Character'Val(215)
         UC_O_Oblique_Stroke        : constant Character := 'Ø'; --Character'Val(216)
         UC_U_Grave                 : constant Character := 'Ù'; --Character'Val(217)
         UC_U_Acute                 : constant Character := 'Ú'; --Character'Val(218)
         UC_U_Circumflex            : constant Character := 'Û'; --Character'Val(219)
         UC_U_Diaeresis             : constant Character := 'Ü'; --Character'Val(220)
         UC_Y_Acute                 : constant Character := 'Ý'; --Character'Val(221)
         UC_Icelandic_Thorn         : constant Character := 'Þ'; --Character'Val(222)
         LC_German_Sharp_S          : constant Character := 'ß'; --Character'Val(223)

25
     -- Character positions 224 (16#E0#) .. 239 (16#EF#):
         LC_A_Grave                 : constant Character := 'à'; --Character'Val(224)
         LC_A_Acute                 : constant Character := 'á'; --Character'Val(225)
         LC_A_Circumflex            : constant Character := 'â'; --Character'Val(226)
         LC_A_Tilde                 : constant Character := 'ã'; --Character'Val(227)
         LC_A_Diaeresis             : constant Character := 'ä'; --Character'Val(228)
         LC_A_Ring                  : constant Character := 'å'; --Character'Val(229)
         LC_AE_Diphthong            : constant Character := 'æ'; --Character'Val(230)
         LC_C_Cedilla               : constant Character := 'ç'; --Character'Val(231)
         LC_E_Grave                 : constant Character := 'è'; --Character'Val(232)
         LC_E_Acute                 : constant Character := 'é'; --Character'Val(233)
         LC_E_Circumflex            : constant Character := 'ê'; --Character'Val(234)
         LC_E_Diaeresis             : constant Character := 'ë'; --Character'Val(235)
         LC_I_Grave                 : constant Character := 'ì'; --Character'Val(236)
         LC_I_Acute                 : constant Character := 'í'; --Character'Val(237)
         LC_I_Circumflex            : constant Character := 'î'; --Character'Val(238)
         LC_I_Diaeresis             : constant Character := 'ï'; --Character'Val(239)

26
     -- Character positions 240 (16#F0#) .. 255 (16#FF#):
         LC_Icelandic_Eth           : constant Character := 'ð'; --Character'Val(240)
         LC_N_Tilde                 : constant Character := 'ñ'; --Character'Val(241)
         LC_O_Grave                 : constant Character := 'ò'; --Character'Val(242)
         LC_O_Acute                 : constant Character := 'ó'; --Character'Val(243)
         LC_O_Circumflex            : constant Character := 'ô'; --Character'Val(244)
         LC_O_Tilde                 : constant Character := 'õ'; --Character'Val(245)
         LC_O_Diaeresis             : constant Character := 'ö'; --Character'Val(246)
         Division_Sign              : constant Character := '÷'; --Character'Val(247)
         LC_O_Oblique_Stroke        : constant Character := 'ø'; --Character'Val(248)
         LC_U_Grave                 : constant Character := 'ù'; --Character'Val(249)
         LC_U_Acute                 : constant Character := 'ú'; --Character'Val(250)
         LC_U_Circumflex            : constant Character := 'û'; --Character'Val(251)
         LC_U_Diaeresis             : constant Character := 'ü'; --Character'Val(252)
         LC_Y_Acute                 : constant Character := 'ý'; --Character'Val(253)
         LC_Icelandic_Thorn         : constant Character := 'þ'; --Character'Val(254)
         LC_Y_Diaeresis             : constant Character := 'ÿ'; --Character'Val(255)
     end Ada.Characters.Latin_1;

                     _Implementation Permissions_

27
An implementation may provide additional packages as children of
Ada.Characters, to declare names for the symbols of the local character
set or other character sets.


File: arm2012.info,  Node: A.3.4,  Next: A.3.5,  Prev: A.3.3,  Up: A.3

A.3.4 The Package Characters.Conversions
----------------------------------------

                          _Static Semantics_

1/2
The library package Characters.Conversions has the following
declaration:

2/2
     package Ada.Characters.Conversions is
        pragma Pure(Conversions);

3/2
        function Is_Character (Item : in Wide_Character)      return Boolean;
        function Is_String    (Item : in Wide_String)         return Boolean;
        function Is_Character (Item : in Wide_Wide_Character) return Boolean;
        function Is_String    (Item : in Wide_Wide_String)    return Boolean;
        function Is_Wide_Character (Item : in Wide_Wide_Character)
           return Boolean;
        function Is_Wide_String    (Item : in Wide_Wide_String)
           return Boolean;

4/2
        function To_Wide_Character (Item : in Character) return Wide_Character;
        function To_Wide_String    (Item : in String)    return Wide_String;
        function To_Wide_Wide_Character (Item : in Character)
           return Wide_Wide_Character;
        function To_Wide_Wide_String    (Item : in String)
           return Wide_Wide_String;
        function To_Wide_Wide_Character (Item : in Wide_Character)
           return Wide_Wide_Character;
        function To_Wide_Wide_String    (Item : in Wide_String)
           return Wide_Wide_String;

5/2
        function To_Character (Item       : in Wide_Character;
                              Substitute : in Character := ' ')
           return Character;
        function To_String    (Item       : in Wide_String;
                               Substitute : in Character := ' ')
           return String;
        function To_Character (Item :       in Wide_Wide_Character;
                               Substitute : in Character := ' ')
           return Character;
        function To_String    (Item :       in Wide_Wide_String;
                               Substitute : in Character := ' ')
           return String;
        function To_Wide_Character (Item :       in Wide_Wide_Character;
                                    Substitute : in Wide_Character := ' ')
           return Wide_Character;
        function To_Wide_String    (Item :       in Wide_Wide_String;
                                    Substitute : in Wide_Character := ' ')
           return Wide_String;

6/2
     end Ada.Characters.Conversions;

7/2
The functions in package Characters.Conversions test Wide_Wide_Character
or Wide_Character values for membership in Wide_Character or Character,
or convert between corresponding characters of Wide_Wide_Character,
Wide_Character, and Character.

8/2
     function Is_Character (Item : in Wide_Character) return Boolean;

9/2
          Returns True if Wide_Character'Pos(Item) <=
          Character'Pos(Character'Last).

10/2
     function Is_Character (Item : in Wide_Wide_Character) return Boolean;

11/2
          Returns True if Wide_Wide_Character'Pos(Item) <=
          Character'Pos(Character'Last).

12/2
     function Is_Wide_Character (Item : in Wide_Wide_Character) return Boolean;

13/2
          Returns True if Wide_Wide_Character'Pos(Item) <=
          Wide_Character'Pos(Wide_Character'Last).

14/2
     function Is_String (Item : in Wide_String)      return Boolean;
     function Is_String (Item : in Wide_Wide_String) return Boolean;

15/2
          Returns True if Is_Character(Item(I)) is True for each I in
          Item'Range.

16/2
     function Is_Wide_String (Item : in Wide_Wide_String) return Boolean;

17/2
          Returns True if Is_Wide_Character(Item(I)) is True for each I
          in Item'Range.

18/2
     function To_Character (Item :       in Wide_Character;
                            Substitute : in Character := ' ') return Character;
     function To_Character (Item :       in Wide_Wide_Character;
                            Substitute : in Character := ' ') return Character;

19/2
          Returns the Character corresponding to Item if
          Is_Character(Item), and returns the Substitute Character
          otherwise.

20/2
     function To_Wide_Character (Item : in Character) return Wide_Character;

21/2
          Returns the Wide_Character X such that Character'Pos(Item) =
          Wide_Character'Pos (X).

22/2
     function To_Wide_Character (Item :       in Wide_Wide_Character;
                                 Substitute : in Wide_Character := ' ')
        return Wide_Character;

23/2
          Returns the Wide_Character corresponding to Item if
          Is_Wide_Character(Item), and returns the Substitute
          Wide_Character otherwise.

24/2
     function To_Wide_Wide_Character (Item : in Character)
        return Wide_Wide_Character;

25/2
          Returns the Wide_Wide_Character X such that
          Character'Pos(Item) = Wide_Wide_Character'Pos (X).

26/2
     function To_Wide_Wide_Character (Item : in Wide_Character)
        return Wide_Wide_Character;

27/2
          Returns the Wide_Wide_Character X such that
          Wide_Character'Pos(Item) = Wide_Wide_Character'Pos (X).

28/2
     function To_String (Item :       in Wide_String;
                         Substitute : in Character := ' ') return String;
     function To_String (Item :       in Wide_Wide_String;
                         Substitute : in Character := ' ') return String;

29/2
          Returns the String whose range is 1..Item'Length and each of
          whose elements is given by To_Character of the corresponding
          element in Item.

30/2
     function To_Wide_String (Item : in String) return Wide_String;

31/2
          Returns the Wide_String whose range is 1..Item'Length and each
          of whose elements is given by To_Wide_Character of the
          corresponding element in Item.

32/2
     function To_Wide_String (Item :       in Wide_Wide_String;
                              Substitute : in Wide_Character := ' ')
        return Wide_String;

33/2
          Returns the Wide_String whose range is 1..Item'Length and each
          of whose elements is given by To_Wide_Character of the
          corresponding element in Item with the given Substitute
          Wide_Character.

34/2
     function To_Wide_Wide_String (Item : in String) return Wide_Wide_String;
     function To_Wide_Wide_String (Item : in Wide_String)
        return Wide_Wide_String;

35/2
          Returns the Wide_Wide_String whose range is 1..Item'Length and
          each of whose elements is given by To_Wide_Wide_Character of
          the corresponding element in Item.


File: arm2012.info,  Node: A.3.5,  Next: A.3.6,  Prev: A.3.4,  Up: A.3

A.3.5 The Package Wide_Characters.Handling
------------------------------------------

1/3
The package Wide_Characters.Handling provides operations for classifying
Wide_Characters and case folding for Wide_Characters.

                          _Static Semantics_

2/3
The library package Wide_Characters.Handling has the following
declaration:

3/3
     package Ada.Wide_Characters.Handling is
        pragma Pure(Handling);

4/3
        function Character_Set_Version return String;

5/3
        function Is_Control (Item : Wide_Character) return Boolean;

6/3
        function Is_Letter (Item : Wide_Character) return Boolean;

7/3
        function Is_Lower (Item : Wide_Character) return Boolean;

8/3
        function Is_Upper (Item : Wide_Character) return Boolean;

9/3
        function Is_Digit (Item : Wide_Character) return Boolean;

10/3
        function Is_Decimal_Digit (Item : Wide_Character) return Boolean
           renames Is_Digit;

11/3
        function Is_Hexadecimal_Digit (Item : Wide_Character) return Boolean;

12/3
        function Is_Alphanumeric (Item : Wide_Character) return Boolean;

13/3
        function Is_Special (Item : Wide_Character) return Boolean;

14/3
        function Is_Line_Terminator (Item : Wide_Character) return Boolean;

15/3
        function Is_Mark (Item : Wide_Character) return Boolean;

16/3
        function Is_Other_Format (Item : Wide_Character) return Boolean;

17/3
        function Is_Punctuation_Connector (Item : Wide_Character) return Boolean;

18/3
        function Is_Space (Item : Wide_Character) return Boolean;

19/3
        function Is_Graphic (Item : Wide_Character) return Boolean;

20/3
        function To_Lower (Item : Wide_Character) return Wide_Character;
        function To_Upper (Item : Wide_Character) return Wide_Character;

21/3
        function To_Lower (Item : Wide_String) return Wide_String;
        function To_Upper (Item : Wide_String) return Wide_String;

22/3
     end Ada.Wide_Characters.Handling;

23/3
The subprograms defined in Wide_Characters.Handling are locale
independent.

24/3
     function Character_Set_Version return String;

25/3
          Returns an implementation-defined identifier that identifies
          the version of the character set standard that is used for
          categorizing characters by the implementation.

26/3
     function Is_Control (Item : Wide_Character) return Boolean;

27/3
          Returns True if the Wide_Character designated by Item is
          categorized as other_control; otherwise returns False.

28/3
     function Is_Letter (Item : Wide_Character) return Boolean;

29/3
          Returns True if the Wide_Character designated by Item is
          categorized as letter_uppercase, letter_lowercase,
          letter_titlecase, letter_modifier, letter_other, or
          number_letter; otherwise returns False.

30/3
     function Is_Lower (Item : Wide_Character) return Boolean;

31/3
          Returns True if the Wide_Character designated by Item is
          categorized as letter_lowercase; otherwise returns False.

32/3
     function Is_Upper (Item : Wide_Character) return Boolean;

33/3
          Returns True if the Wide_Character designated by Item is
          categorized as letter_uppercase; otherwise returns False.

34/3
     function Is_Digit (Item : Wide_Character) return Boolean;

35/3
          Returns True if the Wide_Character designated by Item is
          categorized as number_decimal; otherwise returns False.

36/3
     function Is_Hexadecimal_Digit (Item : Wide_Character) return Boolean;

37/3
          Returns True if the Wide_Character designated by Item is
          categorized as number_decimal, or is in the range 'A' ..  'F'
          or 'a' ..  'f'; otherwise returns False.

38/3
     function Is_Alphanumeric (Item : Wide_Character) return Boolean;

39/3
          Returns True if the Wide_Character designated by Item is
          categorized as letter_uppercase, letter_lowercase,
          letter_titlecase, letter_modifier, letter_other,
          number_letter, or number_decimal; otherwise returns False.

40/3
     function Is_Special (Item : Wide_Character) return Boolean;

41/3
          Returns True if the Wide_Character designated by Item is
          categorized as graphic_character, but not categorized as
          letter_uppercase, letter_lowercase, letter_titlecase,
          letter_modifier, letter_other, number_letter, or
          number_decimal; otherwise returns False.

42/3
     function Is_Line_Terminator (Item : Wide_Character) return Boolean;

43/3
          Returns True if the Wide_Character designated by Item is
          categorized as separator_line or separator_paragraph, or if
          Item is a conventional line terminator character (Line_Feed,
          Line_Tabulation, Form_Feed, Carriage_Return, Next_Line);
          otherwise returns False.

44/3
     function Is_Mark (Item : Wide_Character) return Boolean;

45/3
          Returns True if the Wide_Character designated by Item is
          categorized as mark_non_spacing or mark_spacing_combining;
          otherwise returns False.

46/3
     function Is_Other_Format (Item : Wide_Character) return Boolean;

47/3
          Returns True if the Wide_Character designated by Item is
          categorized as other_format; otherwise returns False.

48/3
     function Is_Punctuation_Connector (Item : Wide_Character) return Boolean;

49/3
          Returns True if the Wide_Character designated by Item is
          categorized as punctuation_connector; otherwise returns False.

50/3
     function Is_Space (Item : Wide_Character) return Boolean;

51/3
          Returns True if the Wide_Character designated by Item is
          categorized as separator_space; otherwise returns False.

52/3
     function Is_Graphic (Item : Wide_Character) return Boolean;

53/3
          Returns True if the Wide_Character designated by Item is
          categorized as graphic_character; otherwise returns False.

54/3
     function To_Lower (Item : Wide_Character) return Wide_Character;

55/3
          Returns the Simple Lowercase Mapping as defined by documents
          referenced in the note in Clause 1 of ISO/IEC 10646:2011 of
          the Wide_Character designated by Item.  If the Simple
          Lowercase Mapping does not exist for the Wide_Character
          designated by Item, then the value of Item is returned.

56/3
     function To_Lower (Item : Wide_String) return Wide_String;

57/3
          Returns the result of applying the To_Lower conversion to each
          Wide_Character element of the Wide_String designated by Item.
          The result is the null Wide_String if the value of the formal
          parameter is the null Wide_String.  The lower bound of the
          result Wide_String is 1.

58/3
     function To_Upper (Item : Wide_Character) return Wide_Character;

59/3
          Returns the Simple Uppercase Mapping as defined by documents
          referenced in the note in Clause 1 of ISO/IEC 10646:2011 of
          the Wide_Character designated by Item.  If the Simple
          Uppercase Mapping does not exist for the Wide_Character
          designated by Item, then the value of Item is returned.

60/3
     function To_Upper (Item : Wide_String) return Wide_String;

61/3
          Returns the result of applying the To_Upper conversion to each
          Wide_Character element of the Wide_String designated by Item.
          The result is the null Wide_String if the value of the formal
          parameter is the null Wide_String.  The lower bound of the
          result Wide_String is 1.

                        _Implementation Advice_

62/3
The string returned by Character_Set_Version should include either
"10646:" or "Unicode".

     NOTES

63/3
     8  The results returned by these functions may depend on which
     particular version of the 10646 standard is supported by the
     implementation (see *note 2.1::).

64/3
     9  The case insensitive equality comparison routines provided in
     *note A.4.10::, "*note A.4.10:: String Comparison" are also
     available for wide strings (see *note A.4.7::).


File: arm2012.info,  Node: A.3.6,  Prev: A.3.5,  Up: A.3

A.3.6 The Package Wide_Wide_Characters.Handling
-----------------------------------------------

1/3
The package Wide_Wide_Characters.Handling has the same contents as
Wide_Characters.Handling except that each occurrence of Wide_Character
is replaced by Wide_Wide_Character, and each occurrence of Wide_String
is replaced by Wide_Wide_String.


File: arm2012.info,  Node: A.4,  Next: A.5,  Prev: A.3,  Up: Annex A

A.4 String Handling
===================

1/3
This subclause presents the specifications of the package Strings and
several child packages, which provide facilities for dealing with string
data.  Fixed-length, bounded-length, and unbounded-length strings are
supported, for String, Wide_String, and Wide_Wide_String.  The
string-handling subprograms include searches for pattern strings and for
characters in program-specified sets, translation (via a
character-to-character mapping), and transformation (replacing,
inserting, overwriting, and deleting of substrings).

* Menu:

* A.4.1 ::    The Package Strings
* A.4.2 ::    The Package Strings.Maps
* A.4.3 ::    Fixed-Length String Handling
* A.4.4 ::    Bounded-Length String Handling
* A.4.5 ::    Unbounded-Length String Handling
* A.4.6 ::    String-Handling Sets and Mappings
* A.4.7 ::    Wide_String Handling
* A.4.8 ::    Wide_Wide_String Handling
* A.4.9 ::    String Hashing
* A.4.10 ::   String Comparison
* A.4.11 ::   String Encoding


File: arm2012.info,  Node: A.4.1,  Next: A.4.2,  Up: A.4

A.4.1 The Package Strings
-------------------------

1
The package Strings provides declarations common to the string handling
packages.

                          _Static Semantics_

2
The library package Strings has the following declaration:

3
     package Ada.Strings is
        pragma Pure(Strings);

4/2
        Space      : constant Character      := ' ';
        Wide_Space : constant Wide_Character := ' ';
        Wide_Wide_Space : constant Wide_Wide_Character := ' ';

5
        Length_Error, Pattern_Error, Index_Error, Translation_Error : exception;

6
        type Alignment  is (Left, Right, Center);
        type Truncation is (Left, Right, Error);
        type Membership is (Inside, Outside);
        type Direction  is (Forward, Backward);
        type Trim_End   is (Left, Right, Both);
     end Ada.Strings;


File: arm2012.info,  Node: A.4.2,  Next: A.4.3,  Prev: A.4.1,  Up: A.4

A.4.2 The Package Strings.Maps
------------------------------

1
The package Strings.Maps defines the types, operations, and other
entities needed for character sets and character-to-character mappings.

                          _Static Semantics_

2
The library package Strings.Maps has the following declaration:

3/2
     package Ada.Strings.Maps is
        pragma Pure(Maps);

4/2
        -- Representation for a set of character values:
        type Character_Set is private;
        pragma Preelaborable_Initialization(Character_Set);

5
        Null_Set : constant Character_Set;

6
        type Character_Range is
          record
             Low  : Character;
             High : Character;
          end record;
        -- Represents Character range Low..High

7
        type Character_Ranges is array (Positive range <>) of Character_Range;

8
        function To_Set    (Ranges : in Character_Ranges)return Character_Set;

9
        function To_Set    (Span   : in Character_Range)return Character_Set;

10
        function To_Ranges (Set    : in Character_Set)  return Character_Ranges;

11
        function "="   (Left, Right : in Character_Set) return Boolean;

12
        function "not" (Right : in Character_Set)       return Character_Set;
        function "and" (Left, Right : in Character_Set) return Character_Set;
        function "or"  (Left, Right : in Character_Set) return Character_Set;
        function "xor" (Left, Right : in Character_Set) return Character_Set;
        function "-"   (Left, Right : in Character_Set) return Character_Set;

13
        function Is_In (Element : in Character;
                        Set     : in Character_Set)
           return Boolean;

14
        function Is_Subset (Elements : in Character_Set;
                            Set      : in Character_Set)
           return Boolean;

15
        function "<=" (Left  : in Character_Set;
                       Right : in Character_Set)
           return Boolean renames Is_Subset;

16
        -- Alternative representation for a set of character values:
        subtype Character_Sequence is String;

17
        function To_Set (Sequence  : in Character_Sequence)return Character_Set;

18
        function To_Set (Singleton : in Character)     return Character_Set;

19
        function To_Sequence (Set  : in Character_Set) return Character_Sequence;

20/2
        -- Representation for a character to character mapping:
        type Character_Mapping is private;
        pragma Preelaborable_Initialization(Character_Mapping);

21
        function Value (Map     : in Character_Mapping;
                        Element : in Character)
           return Character;

22
        Identity : constant Character_Mapping;

23
        function To_Mapping (From, To : in Character_Sequence)
           return Character_Mapping;

24
        function To_Domain (Map : in Character_Mapping)
           return Character_Sequence;
        function To_Range  (Map : in Character_Mapping)
           return Character_Sequence;

25
        type Character_Mapping_Function is
           access function (From : in Character) return Character;

26
     private
        ... -- not specified by the language
     end Ada.Strings.Maps;

27
An object of type Character_Set represents a set of characters.

28
Null_Set represents the set containing no characters.

29
An object Obj of type Character_Range represents the set of characters
in the range Obj.Low ..  Obj.High.

30
An object Obj of type Character_Ranges represents the union of the sets
corresponding to Obj(I) for I in Obj'Range.

31
     function To_Set (Ranges : in Character_Ranges) return Character_Set;

32/3
          If Ranges'Length=0 then Null_Set is returned; otherwise, the
          returned value represents the set corresponding to Ranges.

33
     function To_Set (Span : in Character_Range) return Character_Set;

34
          The returned value represents the set containing each
          character in Span.

35
     function To_Ranges (Set : in Character_Set) return Character_Ranges;

36/3
          If Set = Null_Set, then an empty Character_Ranges array is
          returned; otherwise, the shortest array of contiguous ranges
          of Character values in Set, in increasing order of Low, is
          returned.

37
     function "=" (Left, Right : in Character_Set) return Boolean;

38
          The function "=" returns True if Left and Right represent
          identical sets, and False otherwise.

39
Each of the logical operators "not", "and", "or", and "xor" returns a
Character_Set value that represents the set obtained by applying the
corresponding operation to the set(s) represented by the parameter(s) of
the operator.  "-"(Left, Right) is equivalent to "and"(Left,
"not"(Right)).

40
     function Is_In (Element : in Character;
                     Set     : in Character_Set);
        return Boolean;

41
          Is_In returns True if Element is in Set, and False otherwise.

42
     function Is_Subset (Elements : in Character_Set;
                         Set      : in Character_Set)
        return Boolean;

43
          Is_Subset returns True if Elements is a subset of Set, and
          False otherwise.

44
     subtype Character_Sequence is String;

45
          The Character_Sequence subtype is used to portray a set of
          character values and also to identify the domain and range of
          a character mapping.

46
     function To_Set (Sequence  : in Character_Sequence) return Character_Set;

     function To_Set (Singleton : in Character)          return Character_Set;

47
          Sequence portrays the set of character values that it
          explicitly contains (ignoring duplicates).  Singleton portrays
          the set comprising a single Character.  Each of the To_Set
          functions returns a Character_Set value that represents the
          set portrayed by Sequence or Singleton.

48
     function To_Sequence (Set : in Character_Set) return Character_Sequence;

49
          The function To_Sequence returns a Character_Sequence value
          containing each of the characters in the set represented by
          Set, in ascending order with no duplicates.

50
     type Character_Mapping is private;

51
          An object of type Character_Mapping represents a
          Character-to-Character mapping.

52
     function Value (Map     : in Character_Mapping;
                     Element : in Character)
        return Character;

53
          The function Value returns the Character value to which
          Element maps with respect to the mapping represented by Map.

54
A character C matches a pattern character P with respect to a given
Character_Mapping value Map if Value(Map, C) = P. A string S matches a
pattern string P with respect to a given Character_Mapping if their
lengths are the same and if each character in S matches its
corresponding character in the pattern string P.

55
String handling subprograms that deal with character mappings have
parameters whose type is Character_Mapping.

56
     Identity : constant Character_Mapping;

57
          Identity maps each Character to itself.

58
     function To_Mapping (From, To : in Character_Sequence)
         return Character_Mapping;

59
          To_Mapping produces a Character_Mapping such that each element
          of From maps to the corresponding element of To, and each
          other character maps to itself.  If From'Length /= To'Length,
          or if some character is repeated in From, then
          Translation_Error is propagated.

60
     function To_Domain (Map : in Character_Mapping) return Character_Sequence;

61
          To_Domain returns the shortest Character_Sequence value D such
          that each character not in D maps to itself, and such that the
          characters in D are in ascending order.  The lower bound of D
          is 1.

62
     function To_Range  (Map : in Character_Mapping) return Character_Sequence;

63/1
          To_Range returns the Character_Sequence value R, such that if
          D = To_Domain(Map), then R has the same bounds as D, and D(I)
          maps to R(I) for each I in D'Range.

64
An object F of type Character_Mapping_Function maps a Character value C
to the Character value F.all(C), which is said to match C with respect
to mapping function F. 

     NOTES

65
     10  Character_Mapping and Character_Mapping_Function are used both
     for character equivalence mappings in the search subprograms (such
     as for case insensitivity) and as transformational mappings in the
     Translate subprograms.

66
     11  To_Domain(Identity) and To_Range(Identity) each returns the
     null string.

                              _Examples_

67
To_Mapping("ABCD", "ZZAB") returns a Character_Mapping that maps 'A' and
'B' to 'Z', 'C' to 'A', 'D' to 'B', and each other Character to itself.


File: arm2012.info,  Node: A.4.3,  Next: A.4.4,  Prev: A.4.2,  Up: A.4

A.4.3 Fixed-Length String Handling
----------------------------------

1
The language-defined package Strings.Fixed provides string-handling
subprograms for fixed-length strings; that is, for values of type
Standard.String.  Several of these subprograms are procedures that
modify the contents of a String that is passed as an out or an in out
parameter; each has additional parameters to control the effect when the
logical length of the result differs from the parameter's length.

2
For each function that returns a String, the lower bound of the returned
value is 1.

3
The basic model embodied in the package is that a fixed-length string
comprises significant characters and possibly padding (with space
characters) on either or both ends.  When a shorter string is copied to
a longer string, padding is inserted, and when a longer string is copied
to a shorter one, padding is stripped.  The Move procedure in
Strings.Fixed, which takes a String as an out parameter, allows the
programmer to control these effects.  Similar control is provided by the
string transformation procedures.

                          _Static Semantics_

4
The library package Strings.Fixed has the following declaration:

5
     with Ada.Strings.Maps;
     package Ada.Strings.Fixed is
        pragma Preelaborate(Fixed);

6
     -- "Copy" procedure for strings of possibly different lengths

7
        procedure Move (Source  : in  String;
                        Target  : out String;
                        Drop    : in  Truncation := Error;
                        Justify : in  Alignment  := Left;
                        Pad     : in  Character  := Space);

8
     -- Search subprograms

8.1/2
        function Index (Source  : in String;
                        Pattern : in String;
                        From    : in Positive;
                        Going   : in Direction := Forward;
                        Mapping : in Maps.Character_Mapping := Maps.Identity)
           return Natural;

8.2/2
        function Index (Source  : in String;
                        Pattern : in String;
                        From    : in Positive;
                        Going   : in Direction := Forward;
                        Mapping : in Maps.Character_Mapping_Function)
           return Natural;

9
        function Index (Source   : in String;
                        Pattern  : in String;
                        Going    : in Direction := Forward;
                        Mapping  : in Maps.Character_Mapping
                                     := Maps.Identity)
           return Natural;

10
        function Index (Source   : in String;
                        Pattern  : in String;
                        Going    : in Direction := Forward;
                        Mapping  : in Maps.Character_Mapping_Function)
           return Natural;

10.1/2
        function Index (Source  : in String;
                        Set     : in Maps.Character_Set;
                        From    : in Positive;
                        Test    : in Membership := Inside;
                        Going   : in Direction := Forward)
           return Natural;

11
        function Index (Source : in String;
                        Set    : in Maps.Character_Set;
                        Test   : in Membership := Inside;
                        Going  : in Direction  := Forward)
           return Natural;

11.1/2
        function Index_Non_Blank (Source : in String;
                                  From   : in Positive;
                                  Going  : in Direction := Forward)
           return Natural;

12
        function Index_Non_Blank (Source : in String;
                                  Going  : in Direction := Forward)
           return Natural;

13
        function Count (Source   : in String;
                        Pattern  : in String;
                        Mapping  : in Maps.Character_Mapping
                                      := Maps.Identity)
           return Natural;

14
        function Count (Source   : in String;
                        Pattern  : in String;
                        Mapping  : in Maps.Character_Mapping_Function)
           return Natural;

15
        function Count (Source   : in String;
                        Set      : in Maps.Character_Set)
           return Natural;

15.1/3
        procedure Find_Token (Source : in String;
                              Set    : in Maps.Character_Set;
                              From   : in Positive;
                              Test   : in Membership;
                              First  : out Positive;
                              Last   : out Natural);

16
        procedure Find_Token (Source : in String;
                              Set    : in Maps.Character_Set;
                              Test   : in Membership;
                              First  : out Positive;
                              Last   : out Natural);

17
     -- String translation subprograms

18
        function Translate (Source  : in String;
                            Mapping : in Maps.Character_Mapping)
           return String;

19
        procedure Translate (Source  : in out String;
                             Mapping : in Maps.Character_Mapping);

20
        function Translate (Source  : in String;
                            Mapping : in Maps.Character_Mapping_Function)
           return String;

21
        procedure Translate (Source  : in out String;
                             Mapping : in Maps.Character_Mapping_Function);

22
     -- String transformation subprograms

23
        function Replace_Slice (Source   : in String;
                                Low      : in Positive;
                                High     : in Natural;
                                By       : in String)
           return String;

24
        procedure Replace_Slice (Source   : in out String;
                                 Low      : in Positive;
                                 High     : in Natural;
                                 By       : in String;
                                 Drop     : in Truncation := Error;
                                 Justify  : in Alignment  := Left;
                                 Pad      : in Character  := Space);

25
        function Insert (Source   : in String;
                         Before   : in Positive;
                         New_Item : in String)
           return String;

26
        procedure Insert (Source   : in out String;
                          Before   : in Positive;
                          New_Item : in String;
                          Drop     : in Truncation := Error);

27
        function Overwrite (Source   : in String;
                            Position : in Positive;
                            New_Item : in String)
           return String;

28
        procedure Overwrite (Source   : in out String;
                             Position : in Positive;
                             New_Item : in String;
                             Drop     : in Truncation := Right);

29
        function Delete (Source  : in String;
                         From    : in Positive;
                         Through : in Natural)
           return String;

30
        procedure Delete (Source  : in out String;
                          From    : in Positive;
                          Through : in Natural;
                          Justify : in Alignment := Left;
                          Pad     : in Character := Space);

31
      --String selector subprograms
        function Trim (Source : in String;
                       Side   : in Trim_End)
           return String;

32
        procedure Trim (Source  : in out String;
                        Side    : in Trim_End;
                        Justify : in Alignment := Left;
                        Pad     : in Character := Space);

33
        function Trim (Source : in String;
                       Left   : in Maps.Character_Set;
                       Right  : in Maps.Character_Set)
           return String;

34
        procedure Trim (Source  : in out String;
                        Left    : in Maps.Character_Set;
                        Right   : in Maps.Character_Set;
                        Justify : in Alignment := Strings.Left;
                        Pad     : in Character := Space);

35
        function Head (Source : in String;
                       Count  : in Natural;
                       Pad    : in Character := Space)
           return String;

36
        procedure Head (Source  : in out String;
                        Count   : in Natural;
                        Justify : in Alignment := Left;
                        Pad     : in Character := Space);

37
        function Tail (Source : in String;
                       Count  : in Natural;
                       Pad    : in Character := Space)
           return String;

38
        procedure Tail (Source  : in out String;
                        Count   : in Natural;
                        Justify : in Alignment := Left;
                        Pad     : in Character := Space);

39
     --String constructor functions

40
        function "*" (Left  : in Natural;
                      Right : in Character) return String;

41
        function "*" (Left  : in Natural;
                      Right : in String) return String;

42
     end Ada.Strings.Fixed;

43
The effects of the above subprograms are as follows.

44
     procedure Move (Source  : in  String;
                     Target  : out String;
                     Drop    : in  Truncation := Error;
                     Justify : in  Alignment  := Left;
                     Pad     : in  Character  := Space);

45/3
          The Move procedure copies characters from Source to Target.
          If Source has the same length as Target, then the effect is to
          assign Source to Target.  If Source is shorter than Target,
          then:

46
             * If Justify=Left, then Source is copied into the first
               Source'Length characters of Target.

47
             * If Justify=Right, then Source is copied into the last
               Source'Length characters of Target.

48
             * If Justify=Center, then Source is copied into the middle
               Source'Length characters of Target.  In this case, if the
               difference in length between Target and Source is odd,
               then the extra Pad character is on the right.

49
             * Pad is copied to each Target character not otherwise
               assigned.

50
          If Source is longer than Target, then the effect is based on
          Drop.

51
             * If Drop=Left, then the rightmost Target'Length characters
               of Source are copied into Target.

52
             * If Drop=Right, then the leftmost Target'Length characters
               of Source are copied into Target.

53
             * If Drop=Error, then the effect depends on the value of
               the Justify parameter and also on whether any characters
               in Source other than Pad would fail to be copied:

54
                       * If Justify=Left, and if each of the rightmost
                         Source'Length-Target'Length characters in
                         Source is Pad, then the leftmost Target'Length
                         characters of Source are copied to Target.

55
                       * If Justify=Right, and if each of the leftmost
                         Source'Length-Target'Length characters in
                         Source is Pad, then the rightmost Target'Length
                         characters of Source are copied to Target.

56
                       * Otherwise, Length_Error is propagated.

56.1/2
     function Index (Source  : in String;
                     Pattern : in String;
                     From    : in Positive;
                     Going   : in Direction := Forward;
                     Mapping : in Maps.Character_Mapping := Maps.Identity)
        return Natural;

     function Index (Source  : in String;
                     Pattern : in String;
                     From    : in Positive;
                     Going   : in Direction := Forward;
                     Mapping : in Maps.Character_Mapping_Function)
        return Natural;

56.2/3
          Each Index function searches, starting from From, for a slice
          of Source, with length Pattern'Length, that matches Pattern
          with respect to Mapping; the parameter Going indicates the
          direction of the lookup.  If Source is the null string, Index
          returns 0; otherwise, if From is not in Source'Range, then
          Index_Error is propagated.  If Going = Forward, then Index
          returns the smallest index I which is greater than or equal to
          From such that the slice of Source starting at I matches
          Pattern.  If Going = Backward, then Index returns the largest
          index I such that the slice of Source starting at I matches
          Pattern and has an upper bound less than or equal to From.  If
          there is no such slice, then 0 is returned.  If Pattern is the
          null string, then Pattern_Error is propagated.

57
     function Index (Source   : in String;
                     Pattern  : in String;
                     Going    : in Direction := Forward;
                     Mapping  : in Maps.Character_Mapping
                                   := Maps.Identity)
        return Natural;

     function Index (Source   : in String;
                     Pattern  : in String;
                     Going    : in Direction := Forward;
                     Mapping  : in Maps.Character_Mapping_Function)
        return Natural;

58/2
          If Going = Forward, returns

58.1/2
           Index (Source, Pattern, Source'First, Forward, Mapping);

58.2/3
          otherwise, returns

58.3/2
           Index (Source, Pattern, Source'Last, Backward, Mapping);

58.4/2
     function Index (Source  : in String;
                     Set     : in Maps.Character_Set;
                     From    : in Positive;
                     Test    : in Membership := Inside;
                     Going   : in Direction := Forward)
        return Natural;

58.5/3
          Index searches for the first or last occurrence of any of a
          set of characters (when Test=Inside), or any of the complement
          of a set of characters (when Test=Outside).  If Source is the
          null string, Index returns 0; otherwise, if From is not in
          Source'Range, then Index_Error is propagated.  Otherwise, it
          returns the smallest index I >= From (if Going=Forward) or the
          largest index I <= From (if Going=Backward) such that
          Source(I) satisfies the Test condition with respect to Set; it
          returns 0 if there is no such Character in Source.

59
     function Index (Source : in String;
                     Set    : in Maps.Character_Set;
                     Test   : in Membership := Inside;
                     Going  : in Direction  := Forward)
        return Natural;

60/2
          If Going = Forward, returns

60.1/2
           Index (Source, Set, Source'First, Test, Forward);

60.2/3
          otherwise, returns

60.3/2
           Index (Source, Set, Source'Last, Test, Backward);

60.4/2
     function Index_Non_Blank (Source : in String;
                               From   : in Positive;
                               Going  : in Direction := Forward)
        return Natural;

60.5/2
          Returns Index (Source, Maps.To_Set(Space), From, Outside,
          Going);

61
     function Index_Non_Blank (Source : in String;
                               Going  : in Direction := Forward)
        return Natural;

62
          Returns Index(Source, Maps.To_Set(Space), Outside, Going)

63
     function Count (Source   : in String;
                     Pattern  : in String;
                     Mapping  : in Maps.Character_Mapping
                                  := Maps.Identity)
        return Natural;

     function Count (Source   : in String;
                     Pattern  : in String;
                     Mapping  : in Maps.Character_Mapping_Function)
        return Natural;

64
          Returns the maximum number of nonoverlapping slices of Source
          that match Pattern with respect to Mapping.  If Pattern is the
          null string then Pattern_Error is propagated.

65
     function Count (Source   : in String;
                     Set      : in Maps.Character_Set)
        return Natural;

66
          Returns the number of occurrences in Source of characters that
          are in Set.

66.1/3
     procedure Find_Token (Source : in String;
                           Set    : in Maps.Character_Set;
                           From   : in Positive;
                           Test   : in Membership;
                           First  : out Positive;
                           Last   : out Natural);

66.2/3
          If Source is not the null string and From is not in
          Source'Range, then Index_Error is raised.  Otherwise, First is
          set to the index of the first character in Source(From ..
          Source'Last) that satisfies the Test condition.  Last is set
          to the largest index such that all characters in Source(First
          ..  Last) satisfy the Test condition.  If no characters in
          Source(From ..  Source'Last) satisfy the Test condition, First
          is set to From, and Last is set to 0.

67
     procedure Find_Token (Source : in String;
                           Set    : in Maps.Character_Set;
                           Test   : in Membership;
                           First  : out Positive;
                           Last   : out Natural);

68/3
          Equivalent to Find_Token (Source, Set, Source'First, Test,
          First, Last).

69
     function Translate (Source  : in String;
                         Mapping : in Maps.Character_Mapping)
        return String;

     function Translate (Source  : in String;
                         Mapping : in Maps.Character_Mapping_Function)
        return String;

70
          Returns the string S whose length is Source'Length and such
          that S(I) is the character to which Mapping maps the
          corresponding element of Source, for I in 1..Source'Length.

71
     procedure Translate (Source  : in out String;
                          Mapping : in Maps.Character_Mapping);

     procedure Translate (Source  : in out String;
                          Mapping : in Maps.Character_Mapping_Function);

72
          Equivalent to Source := Translate(Source, Mapping).

73
     function Replace_Slice (Source   : in String;
                             Low      : in Positive;
                             High     : in Natural;
                             By       : in String)
        return String;

74/1
          If Low > Source'Last+1, or High < Source'First-1, then
          Index_Error is propagated.  Otherwise:

74.1/1
             * If High >= Low, then the returned string comprises
               Source(Source'First..Low-1) & By &
               Source(High+1..Source'Last), but with lower bound 1.

74.2/1
             * If High < Low, then the returned string is Insert(Source,
               Before=>Low, New_Item=>By).

75
     procedure Replace_Slice (Source   : in out String;
                              Low      : in Positive;
                              High     : in Natural;
                              By       : in String;
                              Drop     : in Truncation := Error;
                              Justify  : in Alignment  := Left;
                              Pad      : in Character  := Space);

76
          Equivalent to Move(Replace_Slice(Source, Low, High, By),
          Source, Drop, Justify, Pad).

77
     function Insert (Source   : in String;
                      Before   : in Positive;
                      New_Item : in String)
        return String;

78/3
          Propagates Index_Error if Before is not in Source'First ..
          Source'Last+1; otherwise, returns
          Source(Source'First..Before-1) & New_Item &
          Source(Before..Source'Last), but with lower bound 1.

79
     procedure Insert (Source   : in out String;
                       Before   : in Positive;
                       New_Item : in String;
                       Drop     : in Truncation := Error);

80
          Equivalent to Move(Insert(Source, Before, New_Item), Source,
          Drop).

81
     function Overwrite (Source   : in String;
                         Position : in Positive;
                         New_Item : in String)
        return String;

82/3
          Propagates Index_Error if Position is not in Source'First ..
          Source'Last+1; otherwise, returns the string obtained from
          Source by consecutively replacing characters starting at
          Position with corresponding characters from New_Item.  If the
          end of Source is reached before the characters in New_Item are
          exhausted, the remaining characters from New_Item are appended
          to the string.

83
     procedure Overwrite (Source   : in out String;
                          Position : in Positive;
                          New_Item : in String;
                          Drop     : in Truncation := Right);

84
          Equivalent to Move(Overwrite(Source, Position, New_Item),
          Source, Drop).

85
     function Delete (Source  : in String;
                      From    : in Positive;
                      Through : in Natural)
        return String;

86/3
          If From <= Through, the returned string is
          Replace_Slice(Source, From, Through, ""); otherwise, it is
          Source with lower bound 1.

87
     procedure Delete (Source  : in out String;
                       From    : in Positive;
                       Through : in Natural;
                       Justify : in Alignment := Left;
                       Pad     : in Character := Space);

88
          Equivalent to Move(Delete(Source, From, Through), Source,
          Justify => Justify, Pad => Pad).

89
     function Trim (Source : in String;
                    Side   : in Trim_End)
       return String;

90
          Returns the string obtained by removing from Source all
          leading Space characters (if Side = Left), all trailing Space
          characters (if Side = Right), or all leading and trailing
          Space characters (if Side = Both).

91
     procedure Trim (Source  : in out String;
                     Side    : in Trim_End;
                     Justify : in Alignment := Left;
                     Pad     : in Character := Space);

92
          Equivalent to Move(Trim(Source, Side), Source,
          Justify=>Justify, Pad=>Pad).

93
     function Trim (Source : in String;
                    Left   : in Maps.Character_Set;
                    Right  : in Maps.Character_Set)
        return String;

94
          Returns the string obtained by removing from Source all
          leading characters in Left and all trailing characters in
          Right.

95
     procedure Trim (Source  : in out String;
                     Left    : in Maps.Character_Set;
                     Right   : in Maps.Character_Set;
                     Justify : in Alignment := Strings.Left;
                     Pad     : in Character := Space);

96
          Equivalent to Move(Trim(Source, Left, Right), Source, Justify
          => Justify, Pad=>Pad).

97
     function Head (Source : in String;
                    Count  : in Natural;
                    Pad    : in Character := Space)
        return String;

98/3
          Returns a string of length Count.  If Count <= Source'Length,
          the string comprises the first Count characters of Source.
          Otherwise, its contents are Source concatenated with
          Count-Source'Length Pad characters.

99
     procedure Head (Source  : in out String;
                     Count   : in Natural;
                     Justify : in Alignment := Left;
                     Pad     : in Character := Space);

100
          Equivalent to Move(Head(Source, Count, Pad), Source,
          Drop=>Error, Justify=>Justify, Pad=>Pad).

101
     function Tail (Source : in String;
                    Count  : in Natural;
                    Pad    : in Character := Space)
        return String;

102/3
          Returns a string of length Count.  If Count <= Source'Length,
          the string comprises the last Count characters of Source.
          Otherwise, its contents are Count-Source'Length Pad characters
          concatenated with Source.

103
     procedure Tail (Source  : in out String;
                     Count   : in Natural;
                     Justify : in Alignment := Left;
                     Pad     : in Character := Space);

104
          Equivalent to Move(Tail(Source, Count, Pad), Source,
          Drop=>Error, Justify=>Justify, Pad=>Pad).

105
     function "*" (Left  : in Natural;
                   Right : in Character) return String;

     function "*" (Left  : in Natural;
                   Right : in String) return String;

106/1
          These functions replicate a character or string a specified
          number of times.  The first function returns a string whose
          length is Left and each of whose elements is Right.  The
          second function returns a string whose length is
          Left*Right'Length and whose value is the null string if Left =
          0 and otherwise is (Left-1)*Right & Right with lower bound 1.

     NOTES

107/3
     12  In the Index and Count functions taking Pattern and Mapping
     parameters, the actual String parameter passed to Pattern should
     comprise characters occurring as target characters of the mapping.
     Otherwise, the pattern will not match.

108
     13  In the Insert subprograms, inserting at the end of a string is
     obtained by passing Source'Last+1 as the Before parameter.

109
     14  If a null Character_Mapping_Function is passed to any of the
     string handling subprograms, Constraint_Error is propagated.


File: arm2012.info,  Node: A.4.4,  Next: A.4.5,  Prev: A.4.3,  Up: A.4

A.4.4 Bounded-Length String Handling
------------------------------------

1
The language-defined package Strings.Bounded provides a generic package
each of whose instances yields a private type Bounded_String and a set
of operations.  An object of a particular Bounded_String type represents
a String whose low bound is 1 and whose length can vary conceptually
between 0 and a maximum size established at the generic instantiation.
The subprograms for fixed-length string handling are either overloaded
directly for Bounded_String, or are modified as needed to reflect the
variability in length.  Additionally, since the Bounded_String type is
private, appropriate constructor and selector operations are provided.

                          _Static Semantics_

2
The library package Strings.Bounded has the following declaration:

3
     with Ada.Strings.Maps;
     package Ada.Strings.Bounded is
        pragma Preelaborate(Bounded);

4
        generic
           Max   : Positive;    -- Maximum length of a Bounded_String
        package Generic_Bounded_Length is

5
           Max_Length : constant Positive := Max;

6
           type Bounded_String is private;

7
           Null_Bounded_String : constant Bounded_String;

8
           subtype Length_Range is Natural range 0 .. Max_Length;

9
           function Length (Source : in Bounded_String) return Length_Range;

10
        -- Conversion, Concatenation, and Selection functions

11
           function To_Bounded_String (Source : in String;
                                       Drop   : in Truncation := Error)
              return Bounded_String;

12
           function To_String (Source : in Bounded_String) return String;

12.1/2
           procedure Set_Bounded_String
              (Target :    out Bounded_String;
               Source : in     String;
               Drop   : in     Truncation := Error);

13
           function Append (Left, Right : in Bounded_String;
                            Drop        : in Truncation  := Error)
              return Bounded_String;

14
           function Append (Left  : in Bounded_String;
                            Right : in String;
                            Drop  : in Truncation := Error)
              return Bounded_String;

15
           function Append (Left  : in String;
                            Right : in Bounded_String;
                            Drop  : in Truncation := Error)
              return Bounded_String;

16
           function Append (Left  : in Bounded_String;
                            Right : in Character;
                            Drop  : in Truncation := Error)
              return Bounded_String;

17
           function Append (Left  : in Character;
                            Right : in Bounded_String;
                            Drop  : in Truncation := Error)
              return Bounded_String;

18
           procedure Append (Source   : in out Bounded_String;
                             New_Item : in Bounded_String;
                             Drop     : in Truncation  := Error);

19
           procedure Append (Source   : in out Bounded_String;
                             New_Item : in String;
                             Drop     : in Truncation  := Error);

20
           procedure Append (Source   : in out Bounded_String;
                             New_Item : in Character;
                             Drop     : in Truncation  := Error);

21
           function "&" (Left, Right : in Bounded_String)
              return Bounded_String;

22
           function "&" (Left : in Bounded_String; Right : in String)
              return Bounded_String;

23
           function "&" (Left : in String; Right : in Bounded_String)
              return Bounded_String;

24
           function "&" (Left : in Bounded_String; Right : in Character)
              return Bounded_String;

25
           function "&" (Left : in Character; Right : in Bounded_String)
              return Bounded_String;

26
           function Element (Source : in Bounded_String;
                             Index  : in Positive)
              return Character;

27
           procedure Replace_Element (Source : in out Bounded_String;
                                      Index  : in Positive;
                                      By     : in Character);

28
           function Slice (Source : in Bounded_String;
                           Low    : in Positive;
                           High   : in Natural)
              return String;

28.1/2
           function Bounded_Slice
              (Source : in Bounded_String;
               Low    : in Positive;
               High   : in Natural)
                  return Bounded_String;

28.2/2
           procedure Bounded_Slice
              (Source : in     Bounded_String;
               Target :    out Bounded_String;
               Low    : in     Positive;
               High   : in     Natural);

29
           function "="  (Left, Right : in Bounded_String) return Boolean;
           function "="  (Left : in Bounded_String; Right : in String)
             return Boolean;

30
           function "="  (Left : in String; Right : in Bounded_String)
             return Boolean;

31
           function "<"  (Left, Right : in Bounded_String) return Boolean;

32
           function "<"  (Left : in Bounded_String; Right : in String)
             return Boolean;

33
           function "<"  (Left : in String; Right : in Bounded_String)
             return Boolean;

34
           function "<=" (Left, Right : in Bounded_String) return Boolean;

35
           function "<="  (Left : in Bounded_String; Right : in String)
             return Boolean;

36
           function "<="  (Left : in String; Right : in Bounded_String)
             return Boolean;

37
           function ">"  (Left, Right : in Bounded_String) return Boolean;

38
           function ">"  (Left : in Bounded_String; Right : in String)
             return Boolean;

39
           function ">"  (Left : in String; Right : in Bounded_String)
             return Boolean;

40
           function ">=" (Left, Right : in Bounded_String) return Boolean;

41
           function ">="  (Left : in Bounded_String; Right : in String)
             return Boolean;

42
           function ">="  (Left : in String; Right : in Bounded_String)
             return Boolean;

43/2
        -- Search subprograms

43.1/2
           function Index (Source  : in Bounded_String;
                           Pattern : in String;
                           From    : in Positive;
                           Going   : in Direction := Forward;
                           Mapping : in Maps.Character_Mapping := Maps.Identity)
              return Natural;

43.2/2
           function Index (Source  : in Bounded_String;
                           Pattern : in String;
                           From    : in Positive;
                           Going   : in Direction := Forward;
                           Mapping : in Maps.Character_Mapping_Function)
              return Natural;

44
           function Index (Source   : in Bounded_String;
                           Pattern  : in String;
                           Going    : in Direction := Forward;
                           Mapping  : in Maps.Character_Mapping
                                      := Maps.Identity)
              return Natural;

45
           function Index (Source   : in Bounded_String;
                           Pattern  : in String;
                           Going    : in Direction := Forward;
                           Mapping  : in Maps.Character_Mapping_Function)
              return Natural;

45.1/2
           function Index (Source  : in Bounded_String;
                           Set     : in Maps.Character_Set;
                           From    : in Positive;
                           Test    : in Membership := Inside;
                           Going   : in Direction := Forward)
              return Natural;

46
           function Index (Source : in Bounded_String;
                           Set    : in Maps.Character_Set;
                           Test   : in Membership := Inside;
                           Going  : in Direction  := Forward)
              return Natural;

46.1/2
           function Index_Non_Blank (Source : in Bounded_String;
                                     From   : in Positive;
                                     Going  : in Direction := Forward)
              return Natural;

47
           function Index_Non_Blank (Source : in Bounded_String;
                                     Going  : in Direction := Forward)
              return Natural;

48
           function Count (Source   : in Bounded_String;
                           Pattern  : in String;
                           Mapping  : in Maps.Character_Mapping
                                        := Maps.Identity)
              return Natural;

49
           function Count (Source   : in Bounded_String;
                           Pattern  : in String;
                           Mapping  : in Maps.Character_Mapping_Function)
              return Natural;

50
           function Count (Source   : in Bounded_String;
                           Set      : in Maps.Character_Set)
              return Natural;

50.1/3
           procedure Find_Token (Source : in Bounded_String;
                                 Set    : in Maps.Character_Set;
                                 From   : in Positive;
                                 Test   : in Membership;
                                 First  : out Positive;
                                 Last   : out Natural);

51
           procedure Find_Token (Source : in Bounded_String;
                                 Set    : in Maps.Character_Set;
                                 Test   : in Membership;
                                 First  : out Positive;
                                 Last   : out Natural);

52
        -- String translation subprograms

53
           function Translate (Source  : in Bounded_String;
                               Mapping : in Maps.Character_Mapping)
              return Bounded_String;

54
           procedure Translate (Source  : in out Bounded_String;
                                Mapping : in Maps.Character_Mapping);

55
           function Translate (Source  : in Bounded_String;
                               Mapping : in Maps.Character_Mapping_Function)
              return Bounded_String;

56
           procedure Translate (Source  : in out Bounded_String;
                                Mapping : in Maps.Character_Mapping_Function);

57
        -- String transformation subprograms

58
           function Replace_Slice (Source   : in Bounded_String;
                                   Low      : in Positive;
                                   High     : in Natural;
                                   By       : in String;
                                   Drop     : in Truncation := Error)
              return Bounded_String;

59
           procedure Replace_Slice (Source   : in out Bounded_String;
                                    Low      : in Positive;
                                    High     : in Natural;
                                    By       : in String;
                                    Drop     : in Truncation := Error);

60
           function Insert (Source   : in Bounded_String;
                            Before   : in Positive;
                            New_Item : in String;
                            Drop     : in Truncation := Error)
              return Bounded_String;

61
           procedure Insert (Source   : in out Bounded_String;
                             Before   : in Positive;
                             New_Item : in String;
                             Drop     : in Truncation := Error);

62
           function Overwrite (Source    : in Bounded_String;
                               Position  : in Positive;
                               New_Item  : in String;
                               Drop      : in Truncation := Error)
              return Bounded_String;

63
           procedure Overwrite (Source    : in out Bounded_String;
                                Position  : in Positive;
                                New_Item  : in String;
                                Drop      : in Truncation := Error);

64
           function Delete (Source  : in Bounded_String;
                            From    : in Positive;
                            Through : in Natural)
              return Bounded_String;

65
           procedure Delete (Source  : in out Bounded_String;
                             From    : in Positive;
                             Through : in Natural);

66
        --String selector subprograms

67
           function Trim (Source : in Bounded_String;
                          Side   : in Trim_End)
              return Bounded_String;
           procedure Trim (Source : in out Bounded_String;
                           Side   : in Trim_End);

68
           function Trim (Source : in Bounded_String;
                          Left   : in Maps.Character_Set;
                          Right  : in Maps.Character_Set)
              return Bounded_String;

69
           procedure Trim (Source : in out Bounded_String;
                           Left   : in Maps.Character_Set;
                           Right  : in Maps.Character_Set);

70
           function Head (Source : in Bounded_String;
                          Count  : in Natural;
                          Pad    : in Character  := Space;
                          Drop   : in Truncation := Error)
              return Bounded_String;

71
           procedure Head (Source : in out Bounded_String;
                           Count  : in Natural;
                           Pad    : in Character  := Space;
                           Drop   : in Truncation := Error);

72
           function Tail (Source : in Bounded_String;
                          Count  : in Natural;
                          Pad    : in Character  := Space;
                          Drop   : in Truncation := Error)
              return Bounded_String;

73
           procedure Tail (Source : in out Bounded_String;
                           Count  : in Natural;
                           Pad    : in Character  := Space;
                           Drop   : in Truncation := Error);

74
        --String constructor subprograms

75
           function "*" (Left  : in Natural;
                         Right : in Character)
              return Bounded_String;

76
           function "*" (Left  : in Natural;
                         Right : in String)
              return Bounded_String;

77
           function "*" (Left  : in Natural;
                         Right : in Bounded_String)
              return Bounded_String;

78
           function Replicate (Count : in Natural;
                               Item  : in Character;
                               Drop  : in Truncation := Error)
              return Bounded_String;

79
           function Replicate (Count : in Natural;
                               Item  : in String;
                               Drop  : in Truncation := Error)
              return Bounded_String;

80
           function Replicate (Count : in Natural;
                               Item  : in Bounded_String;
                               Drop  : in Truncation := Error)
              return Bounded_String;

81
        private
            ... -- not specified by the language
        end Generic_Bounded_Length;

82
     end Ada.Strings.Bounded;

83
Null_Bounded_String represents the null string.  If an object of type
Bounded_String is not otherwise initialized, it will be initialized to
the same value as Null_Bounded_String.

84
     function Length (Source : in Bounded_String) return Length_Range;

85
          The Length function returns the length of the string
          represented by Source.

86
     function To_Bounded_String (Source : in String;
                                 Drop   : in Truncation := Error)
        return Bounded_String;

87/3
          If Source'Length <= Max_Length, then this function returns a
          Bounded_String that represents Source.  Otherwise, the effect
          depends on the value of Drop:

88
             * If Drop=Left, then the result is a Bounded_String that
               represents the string comprising the rightmost Max_Length
               characters of Source.

89
             * If Drop=Right, then the result is a Bounded_String that
               represents the string comprising the leftmost Max_Length
               characters of Source.

90
             * If Drop=Error, then Strings.Length_Error is propagated.

91
     function To_String (Source : in Bounded_String) return String;

92
          To_String returns the String value with lower bound 1
          represented by Source.  If B is a Bounded_String, then B =
          To_Bounded_String(To_String(B)).

92.1/2
     procedure Set_Bounded_String
        (Target :    out Bounded_String;
         Source : in     String;
         Drop   : in     Truncation := Error);

92.2/2
          Equivalent to Target := To_Bounded_String (Source, Drop);

93
Each of the Append functions returns a Bounded_String obtained by
concatenating the string or character given or represented by one of the
parameters, with the string or character given or represented by the
other parameter, and applying To_Bounded_String to the concatenation
result string, with Drop as provided to the Append function.

94
Each of the procedures Append(Source, New_Item, Drop) has the same
effect as the corresponding assignment Source := Append(Source,
New_Item, Drop).

95
Each of the "&" functions has the same effect as the corresponding
Append function, with Error as the Drop parameter.

96
     function Element (Source : in Bounded_String;
                       Index  : in Positive)
        return Character;

97
          Returns the character at position Index in the string
          represented by Source; propagates Index_Error if Index >
          Length(Source).

98
     procedure Replace_Element (Source : in out Bounded_String;
                                Index  : in Positive;
                                By     : in Character);

99
          Updates Source such that the character at position Index in
          the string represented by Source is By; propagates Index_Error
          if Index > Length(Source).

100
     function Slice (Source : in Bounded_String;
                     Low    : in Positive;
                     High   : in Natural)
        return String;

101/1
          Returns the slice at positions Low through High in the string
          represented by Source; propagates Index_Error if Low >
          Length(Source)+1 or High > Length(Source).  The bounds of the
          returned string are Low and High..

101.1/2
     function Bounded_Slice
        (Source : in Bounded_String;
         Low    : in Positive;
         High   : in Natural)
            return Bounded_String;

101.2/2
          Returns the slice at positions Low through High in the string
          represented by Source as a bounded string; propagates
          Index_Error if Low > Length(Source)+1 or High >
          Length(Source).

101.3/2
     procedure Bounded_Slice
        (Source : in     Bounded_String;
         Target :    out Bounded_String;
         Low    : in     Positive;
         High   : in     Natural);

101.4/2
          Equivalent to Target := Bounded_Slice (Source, Low, High);

102
Each of the functions "=", "<", ">", "<=", and ">=" returns the same
result as the corresponding String operation applied to the String
values given or represented by the two parameters.

103
Each of the search subprograms (Index, Index_Non_Blank, Count,
Find_Token) has the same effect as the corresponding subprogram in
Strings.Fixed applied to the string represented by the Bounded_String
parameter.

104
Each of the Translate subprograms, when applied to a Bounded_String, has
an analogous effect to the corresponding subprogram in Strings.Fixed.
For the Translate function, the translation is applied to the string
represented by the Bounded_String parameter, and the result is converted
(via To_Bounded_String) to a Bounded_String.  For the Translate
procedure, the string represented by the Bounded_String parameter after
the translation is given by the Translate function for fixed-length
strings applied to the string represented by the original value of the
parameter.

105/1
Each of the transformation subprograms (Replace_Slice, Insert,
Overwrite, Delete), selector subprograms (Trim, Head, Tail), and
constructor functions ("*") has an effect based on its corresponding
subprogram in Strings.Fixed, and Replicate is based on Fixed."*".  In
the case of a function, the corresponding fixed-length string subprogram
is applied to the string represented by the Bounded_String parameter.
To_Bounded_String is applied the result string, with Drop (or Error in
the case of Generic_Bounded_Length."*") determining the effect when the
string length exceeds Max_Length.  In the case of a procedure, the
corresponding function in Strings.Bounded.Generic_Bounded_Length is
applied, with the result assigned into the Source parameter.

                        _Implementation Advice_

106
Bounded string objects should not be implemented by implicit pointers
and dynamic allocation.


File: arm2012.info,  Node: A.4.5,  Next: A.4.6,  Prev: A.4.4,  Up: A.4

A.4.5 Unbounded-Length String Handling
--------------------------------------

1
The language-defined package Strings.Unbounded provides a private type
Unbounded_String and a set of operations.  An object of type
Unbounded_String represents a String whose low bound is 1 and whose
length can vary conceptually between 0 and Natural'Last.  The
subprograms for fixed-length string handling are either overloaded
directly for Unbounded_String, or are modified as needed to reflect the
flexibility in length.  Since the Unbounded_String type is private,
relevant constructor and selector operations are provided.

                          _Static Semantics_

2
The library package Strings.Unbounded has the following declaration:

3
     with Ada.Strings.Maps;
     package Ada.Strings.Unbounded is
        pragma Preelaborate(Unbounded);

4/2
        type Unbounded_String is private;
        pragma Preelaborable_Initialization(Unbounded_String);

5
        Null_Unbounded_String : constant Unbounded_String;

6
        function Length (Source : in Unbounded_String) return Natural;

7
        type String_Access is access all String;
        procedure Free (X : in out String_Access);

8
     -- Conversion, Concatenation, and Selection functions

9
        function To_Unbounded_String (Source : in String)
           return Unbounded_String;

10
        function To_Unbounded_String (Length : in Natural)
           return Unbounded_String;

11
        function To_String (Source : in Unbounded_String) return String;

11.1/2
        procedure Set_Unbounded_String
          (Target :    out Unbounded_String;
           Source : in     String);

12
        procedure Append (Source   : in out Unbounded_String;
                          New_Item : in Unbounded_String);

13
        procedure Append (Source   : in out Unbounded_String;
                          New_Item : in String);

14
        procedure Append (Source   : in out Unbounded_String;
                          New_Item : in Character);

15
        function "&" (Left, Right : in Unbounded_String)
           return Unbounded_String;

16
        function "&" (Left : in Unbounded_String; Right : in String)
           return Unbounded_String;

17
        function "&" (Left : in String; Right : in Unbounded_String)
           return Unbounded_String;

18
        function "&" (Left : in Unbounded_String; Right : in Character)
           return Unbounded_String;

19
        function "&" (Left : in Character; Right : in Unbounded_String)
           return Unbounded_String;

20
        function Element (Source : in Unbounded_String;
                          Index  : in Positive)
           return Character;

21
        procedure Replace_Element (Source : in out Unbounded_String;
                                   Index  : in Positive;
                                   By     : in Character);

22
        function Slice (Source : in Unbounded_String;
                        Low    : in Positive;
                        High   : in Natural)
           return String;

22.1/2
        function Unbounded_Slice
           (Source : in Unbounded_String;
            Low    : in Positive;
            High   : in Natural)
               return Unbounded_String;

22.2/2
        procedure Unbounded_Slice
           (Source : in     Unbounded_String;
            Target :    out Unbounded_String;
            Low    : in     Positive;
            High   : in     Natural);

23
        function "="  (Left, Right : in Unbounded_String) return Boolean;

24
        function "="  (Left : in Unbounded_String; Right : in String)
          return Boolean;

25
        function "="  (Left : in String; Right : in Unbounded_String)
          return Boolean;

26
        function "<"  (Left, Right : in Unbounded_String) return Boolean;

27
        function "<"  (Left : in Unbounded_String; Right : in String)
          return Boolean;

28
        function "<"  (Left : in String; Right : in Unbounded_String)
          return Boolean;

29
        function "<=" (Left, Right : in Unbounded_String) return Boolean;

30
        function "<="  (Left : in Unbounded_String; Right : in String)
          return Boolean;

31
        function "<="  (Left : in String; Right : in Unbounded_String)
          return Boolean;

32
        function ">"  (Left, Right : in Unbounded_String) return Boolean;

33
        function ">"  (Left : in Unbounded_String; Right : in String)
          return Boolean;

34
        function ">"  (Left : in String; Right : in Unbounded_String)
          return Boolean;

35
        function ">=" (Left, Right : in Unbounded_String) return Boolean;

36
        function ">="  (Left : in Unbounded_String; Right : in String)
          return Boolean;

37
        function ">="  (Left : in String; Right : in Unbounded_String)
          return Boolean;

38
     -- Search subprograms

38.1/2
        function Index (Source  : in Unbounded_String;
                        Pattern : in String;
                        From    : in Positive;
                        Going   : in Direction := Forward;
                        Mapping : in Maps.Character_Mapping := Maps.Identity)
           return Natural;

38.2/2
        function Index (Source  : in Unbounded_String;
                        Pattern : in String;
                        From    : in Positive;
                        Going   : in Direction := Forward;
                        Mapping : in Maps.Character_Mapping_Function)
           return Natural;

39
        function Index (Source   : in Unbounded_String;
                        Pattern  : in String;
                        Going    : in Direction := Forward;
                        Mapping  : in Maps.Character_Mapping
                                     := Maps.Identity)
           return Natural;

40
        function Index (Source   : in Unbounded_String;
                        Pattern  : in String;
                        Going    : in Direction := Forward;
                        Mapping  : in Maps.Character_Mapping_Function)
           return Natural;

40.1/2
        function Index (Source  : in Unbounded_String;
                        Set     : in Maps.Character_Set;
                        From    : in Positive;
                        Test    : in Membership := Inside;
                        Going    : in Direction := Forward)
           return Natural;

41
        function Index (Source : in Unbounded_String;
                        Set    : in Maps.Character_Set;
                        Test   : in Membership := Inside;
                        Going  : in Direction  := Forward) return Natural;

41.1/2
        function Index_Non_Blank (Source : in Unbounded_String;
                                  From   : in Positive;
                                  Going  : in Direction := Forward)
           return Natural;

42
        function Index_Non_Blank (Source : in Unbounded_String;
                                  Going  : in Direction := Forward)
           return Natural;

43
        function Count (Source   : in Unbounded_String;
                        Pattern  : in String;
                        Mapping  : in Maps.Character_Mapping
                                     := Maps.Identity)
           return Natural;

44
        function Count (Source   : in Unbounded_String;
                        Pattern  : in String;
                        Mapping  : in Maps.Character_Mapping_Function)
           return Natural;

45
        function Count (Source   : in Unbounded_String;
                        Set      : in Maps.Character_Set)
           return Natural;

45.1/3
        procedure Find_Token (Source : in Unbounded_String;
                              Set    : in Maps.Character_Set;
                              From   : in Positive;
                              Test   : in Membership;
                              First  : out Positive;
                              Last   : out Natural);

46
        procedure Find_Token (Source : in Unbounded_String;
                              Set    : in Maps.Character_Set;
                              Test   : in Membership;
                              First  : out Positive;
                              Last   : out Natural);

47
     -- String translation subprograms

48
        function Translate (Source  : in Unbounded_String;
                            Mapping : in Maps.Character_Mapping)
           return Unbounded_String;

49
        procedure Translate (Source  : in out Unbounded_String;
                             Mapping : in Maps.Character_Mapping);

50
        function Translate (Source  : in Unbounded_String;
                            Mapping : in Maps.Character_Mapping_Function)
           return Unbounded_String;

51
        procedure Translate (Source  : in out Unbounded_String;
                             Mapping : in Maps.Character_Mapping_Function);

52
     -- String transformation subprograms

53
        function Replace_Slice (Source   : in Unbounded_String;
                                Low      : in Positive;
                                High     : in Natural;
                                By       : in String)
           return Unbounded_String;

54
        procedure Replace_Slice (Source   : in out Unbounded_String;
                                 Low      : in Positive;
                                 High     : in Natural;
                                 By       : in String);

55
        function Insert (Source   : in Unbounded_String;
                         Before   : in Positive;
                         New_Item : in String)
           return Unbounded_String;

56
        procedure Insert (Source   : in out Unbounded_String;
                          Before   : in Positive;
                          New_Item : in String);

57
        function Overwrite (Source    : in Unbounded_String;
                            Position  : in Positive;
                            New_Item  : in String)
           return Unbounded_String;

58
        procedure Overwrite (Source    : in out Unbounded_String;
                             Position  : in Positive;
                             New_Item  : in String);

59
        function Delete (Source  : in Unbounded_String;
                         From    : in Positive;
                         Through : in Natural)
           return Unbounded_String;

60
        procedure Delete (Source  : in out Unbounded_String;
                          From    : in Positive;
                          Through : in Natural);

61
        function Trim (Source : in Unbounded_String;
                       Side   : in Trim_End)
           return Unbounded_String;

62
        procedure Trim (Source : in out Unbounded_String;
                        Side   : in Trim_End);

63
        function Trim (Source : in Unbounded_String;
                       Left   : in Maps.Character_Set;
                       Right  : in Maps.Character_Set)
           return Unbounded_String;

64
        procedure Trim (Source : in out Unbounded_String;
                        Left   : in Maps.Character_Set;
                        Right  : in Maps.Character_Set);

65
        function Head (Source : in Unbounded_String;
                       Count  : in Natural;
                       Pad    : in Character := Space)
           return Unbounded_String;

66
        procedure Head (Source : in out Unbounded_String;
                        Count  : in Natural;
                        Pad    : in Character := Space);

67
        function Tail (Source : in Unbounded_String;
                       Count  : in Natural;
                       Pad    : in Character := Space)
           return Unbounded_String;

68
        procedure Tail (Source : in out Unbounded_String;
                        Count  : in Natural;
                        Pad    : in Character := Space);

69
        function "*" (Left  : in Natural;
                      Right : in Character)
           return Unbounded_String;

70
        function "*" (Left  : in Natural;
                      Right : in String)
           return Unbounded_String;

71
        function "*" (Left  : in Natural;
                      Right : in Unbounded_String)
           return Unbounded_String;

72
     private
        ... -- not specified by the language
     end Ada.Strings.Unbounded;

72.1/2
The type Unbounded_String needs finalization (see *note 7.6::).

73
Null_Unbounded_String represents the null String.  If an object of type
Unbounded_String is not otherwise initialized, it will be initialized to
the same value as Null_Unbounded_String.

74
The function Length returns the length of the String represented by
Source.

75
The type String_Access provides a (nonprivate) access type for explicit
processing of unbounded-length strings.  The procedure Free performs an
unchecked deallocation of an object of type String_Access.

76
The function To_Unbounded_String(Source : in String) returns an
Unbounded_String that represents Source.  The function
To_Unbounded_String(Length : in Natural) returns an Unbounded_String
that represents an uninitialized String whose length is Length.

77
The function To_String returns the String with lower bound 1 represented
by Source.  To_String and To_Unbounded_String are related as follows:

78
   * If S is a String, then To_String(To_Unbounded_String(S)) = S.

79
   * If U is an Unbounded_String, then To_Unbounded_String(To_String(U))
     = U.

79.1/2
The procedure Set_Unbounded_String sets Target to an Unbounded_String
that represents Source.

80
For each of the Append procedures, the resulting string represented by
the Source parameter is given by the concatenation of the original value
of Source and the value of New_Item.

81
Each of the "&" functions returns an Unbounded_String obtained by
concatenating the string or character given or represented by one of the
parameters, with the string or character given or represented by the
other parameter, and applying To_Unbounded_String to the concatenation
result string.

82
The Element, Replace_Element, and Slice subprograms have the same effect
as the corresponding bounded-length string subprograms.

82.1/3
The function Unbounded_Slice returns the slice at positions Low through
High in the string represented by Source as an Unbounded_String.  The
procedure Unbounded_Slice sets Target to the Unbounded_String
representing the slice at positions Low through High in the string
represented by Source.  Both subprograms propagate Index_Error if Low >
Length(Source)+1 or High > Length(Source).

83
Each of the functions "=", "<", ">", "<=", and ">=" returns the same
result as the corresponding String operation applied to the String
values given or represented by Left and Right.

84
Each of the search subprograms (Index, Index_Non_Blank, Count,
Find_Token) has the same effect as the corresponding subprogram in
Strings.Fixed applied to the string represented by the Unbounded_String
parameter.

85
The Translate function has an analogous effect to the corresponding
subprogram in Strings.Fixed.  The translation is applied to the string
represented by the Unbounded_String parameter, and the result is
converted (via To_Unbounded_String) to an Unbounded_String.

86
Each of the transformation functions (Replace_Slice, Insert, Overwrite,
Delete), selector functions (Trim, Head, Tail), and constructor
functions ("*") is likewise analogous to its corresponding subprogram in
Strings.Fixed.  For each of the subprograms, the corresponding
fixed-length string subprogram is applied to the string represented by
the Unbounded_String parameter, and To_Unbounded_String is applied the
result string.

87
For each of the procedures Translate, Replace_Slice, Insert, Overwrite,
Delete, Trim, Head, and Tail, the resulting string represented by the
Source parameter is given by the corresponding function for fixed-length
strings applied to the string represented by Source's original value.

                     _Implementation Requirements_

88
No storage associated with an Unbounded_String object shall be lost upon
assignment or scope exit.


File: arm2012.info,  Node: A.4.6,  Next: A.4.7,  Prev: A.4.5,  Up: A.4

A.4.6 String-Handling Sets and Mappings
---------------------------------------

1
The language-defined package Strings.Maps.Constants declares
Character_Set and Character_Mapping constants corresponding to
classification and conversion functions in package Characters.Handling.

                          _Static Semantics_

2
The library package Strings.Maps.Constants has the following
declaration:

3/2
     package Ada.Strings.Maps.Constants is
        pragma Pure(Constants);

4
        Control_Set           : constant Character_Set;
        Graphic_Set           : constant Character_Set;
        Letter_Set            : constant Character_Set;
        Lower_Set             : constant Character_Set;
        Upper_Set             : constant Character_Set;
        Basic_Set             : constant Character_Set;
        Decimal_Digit_Set     : constant Character_Set;
        Hexadecimal_Digit_Set : constant Character_Set;
        Alphanumeric_Set      : constant Character_Set;
        Special_Set           : constant Character_Set;
        ISO_646_Set           : constant Character_Set;

5
        Lower_Case_Map        : constant Character_Mapping;
          --Maps to lower case for letters, else identity
        Upper_Case_Map        : constant Character_Mapping;
          --Maps to upper case for letters, else identity
        Basic_Map             : constant Character_Mapping;
          --Maps to basic letter for letters, else identity

6
     private
        ... -- not specified by the language
     end Ada.Strings.Maps.Constants;

7
Each of these constants represents a correspondingly named set of
characters or character mapping in Characters.Handling (see *note
A.3.2::).

     NOTES

8/3
     15  There are certain characters which are defined to be lower case
     letters by ISO 10646 and are therefore allowed in identifiers, but
     are not considered lower case letters by
     Ada.Strings.Maps.Constants.


File: arm2012.info,  Node: A.4.7,  Next: A.4.8,  Prev: A.4.6,  Up: A.4

A.4.7 Wide_String Handling
--------------------------

1/3
Facilities for handling strings of Wide_Character elements are found in
the packages Strings.Wide_Maps, Strings.Wide_Fixed,
Strings.Wide_Bounded, Strings.Wide_Unbounded, and
Strings.Wide_Maps.Wide_Constants, and in the library functions
Strings.Wide_Hash, Strings.Wide_Fixed.Wide_Hash,
Strings.Wide_Bounded.Wide_Hash, Strings.Wide_Unbounded.Wide_Hash,
Strings.Wide_Hash_Case_Insensitive,
Strings.Wide_Fixed.Wide_Hash_Case_Insensitive,
Strings.Wide_Bounded.Wide_Hash_Case_Insensitive,
Strings.Wide_Unbounded.Wide_Hash_Case_Insensitive,
Strings.Wide_Equal_Case_Insensitive,
Strings.Wide_Fixed.Wide_Equal_Case_Insensitive,
Strings.Wide_Bounded.Wide_Equal_Case_Insensitive, and
Strings.Wide_Unbounded.Wide_Equal_Case_Insensitive.  They provide the
same string-handling operations as the corresponding packages and
functions for strings of Character elements. 

                          _Static Semantics_

2
The package Strings.Wide_Maps has the following declaration.

3
     package Ada.Strings.Wide_Maps is
        pragma Preelaborate(Wide_Maps);

4/2
        -- Representation for a set of Wide_Character values:
        type Wide_Character_Set is private;
        pragma Preelaborable_Initialization(Wide_Character_Set);

5
        Null_Set : constant Wide_Character_Set;

6
        type Wide_Character_Range is
          record
              Low  : Wide_Character;
              High : Wide_Character;
          end record;
        -- Represents Wide_Character range Low..High

7
        type Wide_Character_Ranges is array (Positive range <>)
           of Wide_Character_Range;

8
        function To_Set    (Ranges : in Wide_Character_Ranges)
           return Wide_Character_Set;

9
        function To_Set    (Span   : in Wide_Character_Range)
           return Wide_Character_Set;

10
        function To_Ranges (Set    : in Wide_Character_Set)
           return Wide_Character_Ranges;

11
        function "="   (Left, Right : in Wide_Character_Set) return Boolean;

12
        function "not" (Right : in Wide_Character_Set)
           return Wide_Character_Set;
        function "and" (Left, Right : in Wide_Character_Set)
           return Wide_Character_Set;
        function "or"  (Left, Right : in Wide_Character_Set)
           return Wide_Character_Set;
        function "xor" (Left, Right : in Wide_Character_Set)
           return Wide_Character_Set;
        function "-"   (Left, Right : in Wide_Character_Set)
           return Wide_Character_Set;

13
        function Is_In (Element : in Wide_Character;
                        Set     : in Wide_Character_Set)
           return Boolean;

14
        function Is_Subset (Elements : in Wide_Character_Set;
                            Set      : in Wide_Character_Set)
           return Boolean;

15
        function "<=" (Left  : in Wide_Character_Set;
                       Right : in Wide_Character_Set)
           return Boolean renames Is_Subset;

16
        -- Alternative representation for a set of Wide_Character values:
        subtype Wide_Character_Sequence is Wide_String;

17
        function To_Set (Sequence  : in Wide_Character_Sequence)
           return Wide_Character_Set;

18
        function To_Set (Singleton : in Wide_Character)
           return Wide_Character_Set;

19
        function To_Sequence (Set  : in Wide_Character_Set)
           return Wide_Character_Sequence;

20/2
        -- Representation for a Wide_Character to Wide_Character mapping:
        type Wide_Character_Mapping is private;
        pragma Preelaborable_Initialization(Wide_Character_Mapping);

21
        function Value (Map     : in Wide_Character_Mapping;
                        Element : in Wide_Character)
           return Wide_Character;

22
        Identity : constant Wide_Character_Mapping;

23
        function To_Mapping (From, To : in Wide_Character_Sequence)
           return Wide_Character_Mapping;

24
        function To_Domain (Map : in Wide_Character_Mapping)
           return Wide_Character_Sequence;

25
        function To_Range  (Map : in Wide_Character_Mapping)
           return Wide_Character_Sequence;

26
        type Wide_Character_Mapping_Function is
           access function (From : in Wide_Character) return Wide_Character;

27
     private
        ... -- not specified by the language
     end Ada.Strings.Wide_Maps;

28
The context clause for each of the packages Strings.Wide_Fixed,
Strings.Wide_Bounded, and Strings.Wide_Unbounded identifies
Strings.Wide_Maps instead of Strings.Maps.

28.1/3
Types Wide_Character_Set and Wide_Character_Mapping need finalization.

29/3
For each of the packages Strings.Fixed, Strings.Bounded,
Strings.Unbounded, and Strings.Maps.Constants, and for library functions
Strings.Hash, Strings.Fixed.Hash, Strings.Bounded.Hash,
Strings.Unbounded.Hash, Strings.Hash_Case_Insensitive,
Strings.Fixed.Hash_Case_Insensitive,
Strings.Bounded.Hash_Case_Insensitive,
Strings.Unbounded.Hash_Case_Insensitive, Strings.Equal_Case_Insensitive,
Strings.Fixed.Equal_Case_Insensitive,
Strings.Bounded.Equal_Case_Insensitive, and
Strings.Unbounded.Equal_Case_Insensitive, the corresponding wide string
package or function has the same contents except that

30
   * Wide_Space replaces Space

31
   * Wide_Character replaces Character

32
   * Wide_String replaces String

33
   * Wide_Character_Set replaces Character_Set

34
   * Wide_Character_Mapping replaces Character_Mapping

35
   * Wide_Character_Mapping_Function replaces Character_Mapping_Function

36
   * Wide_Maps replaces Maps

37
   * Bounded_Wide_String replaces Bounded_String

38
   * Null_Bounded_Wide_String replaces Null_Bounded_String

39
   * To_Bounded_Wide_String replaces To_Bounded_String

40
   * To_Wide_String replaces To_String

40.1/2
   * Set_Bounded_Wide_String replaces Set_Bounded_String

41
   * Unbounded_Wide_String replaces Unbounded_String

42
   * Null_Unbounded_Wide_String replaces Null_Unbounded_String

43
   * Wide_String_Access replaces String_Access

44
   * To_Unbounded_Wide_String replaces To_Unbounded_String

44.1/2
   * Set_Unbounded_Wide_String replaces Set_Unbounded_String

45
The following additional declaration is present in
Strings.Wide_Maps.Wide_Constants:

46/2
     Character_Set : constant Wide_Maps.Wide_Character_Set;
     --Contains each Wide_Character value WC such that
     --Characters.Conversions.Is_Character(WC) is True

46.1/2
Each Wide_Character_Set constant in the package
Strings.Wide_Maps.Wide_Constants contains no values outside the
Character portion of Wide_Character.  Similarly, each
Wide_Character_Mapping constant in this package is the identity mapping
when applied to any element outside the Character portion of
Wide_Character.

46.2/2
Pragma Pure is replaced by pragma Preelaborate in
Strings.Wide_Maps.Wide_Constants.

     NOTES

47
     16  If a null Wide_Character_Mapping_Function is passed to any of
     the Wide_String handling subprograms, Constraint_Error is
     propagated.


File: arm2012.info,  Node: A.4.8,  Next: A.4.9,  Prev: A.4.7,  Up: A.4

A.4.8 Wide_Wide_String Handling
-------------------------------

1/3
Facilities for handling strings of Wide_Wide_Character elements are
found in the packages Strings.Wide_Wide_Maps, Strings.Wide_Wide_Fixed,
Strings.Wide_Wide_Bounded, Strings.Wide_Wide_Unbounded, and
Strings.Wide_Wide_Maps.Wide_Wide_Constants, and in the library functions
Strings.Wide_Wide_Hash, Strings.Wide_Wide_Fixed.Wide_Wide_Hash,
Strings.Wide_Wide_Bounded.Wide_Wide_Hash,
Strings.Wide_Wide_Unbounded.Wide_Wide_Hash,
Strings.Wide_Wide_Hash_Case_Insensitive,
Strings.Wide_Wide_Fixed.Wide_Wide_Hash_Case_Insensitive,
Strings.Wide_Wide_Bounded.Wide_Wide_Hash_Case_Insensitive,
Strings.Wide_Wide_Unbounded.Wide_Wide_Hash_Case_Insensitive,
Strings.Wide_Wide_Equal_Case_Insensitive,
Strings.Wide_Wide_Fixed.Wide_Wide_Equal_Case_Insensitive,
Strings.Wide_Wide_Bounded.Wide_Wide_Equal_Case_Insensitive, and
Strings.Wide_Wide_Unbounded.Wide_Wide_Equal_Case_Insensitive.  They
provide the same string-handling operations as the corresponding
packages and functions for strings of Character elements. 

                          _Static Semantics_

2/2
The library package Strings.Wide_Wide_Maps has the following
declaration.

3/2
     package Ada.Strings.Wide_Wide_Maps is
        pragma Preelaborate(Wide_Wide_Maps);

4/2
        -- Representation for a set of Wide_Wide_Character values:
        type Wide_Wide_Character_Set is private;
        pragma Preelaborable_Initialization(Wide_Wide_Character_Set);

5/2
        Null_Set : constant Wide_Wide_Character_Set;

6/2
        type Wide_Wide_Character_Range is
           record
              Low  : Wide_Wide_Character;
              High : Wide_Wide_Character;
           end record;
        -- Represents Wide_Wide_Character range Low..High

7/2
        type Wide_Wide_Character_Ranges is array (Positive range <>)
              of Wide_Wide_Character_Range;

8/2
        function To_Set (Ranges : in Wide_Wide_Character_Ranges)
              return Wide_Wide_Character_Set;

9/2
        function To_Set (Span : in Wide_Wide_Character_Range)
              return Wide_Wide_Character_Set;

10/2
        function To_Ranges (Set : in Wide_Wide_Character_Set)
              return Wide_Wide_Character_Ranges;

11/2
        function "=" (Left, Right : in Wide_Wide_Character_Set) return Boolean;

12/2
        function "not" (Right : in Wide_Wide_Character_Set)
              return Wide_Wide_Character_Set;
        function "and" (Left, Right : in Wide_Wide_Character_Set)
              return Wide_Wide_Character_Set;
        function "or" (Left, Right : in Wide_Wide_Character_Set)
              return Wide_Wide_Character_Set;
        function "xor" (Left, Right : in Wide_Wide_Character_Set)
              return Wide_Wide_Character_Set;
        function "-" (Left, Right : in Wide_Wide_Character_Set)
              return Wide_Wide_Character_Set;

13/2
        function Is_In (Element : in Wide_Wide_Character;
                        Set     : in Wide_Wide_Character_Set)
              return Boolean;

14/2
        function Is_Subset (Elements : in Wide_Wide_Character_Set;
                            Set      : in Wide_Wide_Character_Set)
              return Boolean;

15/2
        function "<=" (Left  : in Wide_Wide_Character_Set;
                       Right : in Wide_Wide_Character_Set)
              return Boolean renames Is_Subset;

16/2
        -- Alternative representation for a set of Wide_Wide_Character values:
        subtype Wide_Wide_Character_Sequence is Wide_Wide_String;

17/2
        function To_Set (Sequence : in Wide_Wide_Character_Sequence)
              return Wide_Wide_Character_Set;

18/2
        function To_Set (Singleton : in Wide_Wide_Character)
              return Wide_Wide_Character_Set;

19/2
        function To_Sequence (Set : in Wide_Wide_Character_Set)
              return Wide_Wide_Character_Sequence;

20/2
        -- Representation for a Wide_Wide_Character to Wide_Wide_Character
        -- mapping:
        type Wide_Wide_Character_Mapping is private;
        pragma Preelaborable_Initialization(Wide_Wide_Character_Mapping);

21/2
        function Value (Map     : in Wide_Wide_Character_Mapping;
                        Element : in Wide_Wide_Character)
              return Wide_Wide_Character;

22/2
        Identity : constant Wide_Wide_Character_Mapping;

23/2
        function To_Mapping (From, To : in Wide_Wide_Character_Sequence)
              return Wide_Wide_Character_Mapping;

24/2
        function To_Domain (Map : in Wide_Wide_Character_Mapping)
              return Wide_Wide_Character_Sequence;

25/2
        function To_Range (Map : in Wide_Wide_Character_Mapping)
              return Wide_Wide_Character_Sequence;

26/2
        type Wide_Wide_Character_Mapping_Function is
              access function (From : in Wide_Wide_Character)
              return Wide_Wide_Character;

27/2
     private
        ... -- not specified by the language
     end Ada.Strings.Wide_Wide_Maps;

28/2
The context clause for each of the packages Strings.Wide_Wide_Fixed,
Strings.Wide_Wide_Bounded, and Strings.Wide_Wide_Unbounded identifies
Strings.Wide_Wide_Maps instead of Strings.Maps.

28.1/3
Types Wide_Wide_Character_Set and Wide_Wide_Character_Mapping need
finalization.

29/3
For each of the packages Strings.Fixed, Strings.Bounded,
Strings.Unbounded, and Strings.Maps.Constants, and for library functions
Strings.Hash, Strings.Fixed.Hash, Strings.Bounded.Hash,
Strings.Unbounded.Hash, Strings.Hash_Case_Insensitive,
Strings.Fixed.Hash_Case_Insensitive,
Strings.Bounded.Hash_Case_Insensitive,
Strings.Unbounded.Hash_Case_Insensitive, Strings.Equal_Case_Insensitive,
Strings.Fixed.Equal_Case_Insensitive,
Strings.Bounded.Equal_Case_Insensitive, and
Strings.Unbounded.Equal_Case_Insensitive, the corresponding wide wide
string package or function has the same contents except that

30/2
   * Wide_Wide_Space replaces Space

31/2
   * Wide_Wide_Character replaces Character

32/2
   * Wide_Wide_String replaces String

33/2
   * Wide_Wide_Character_Set replaces Character_Set

34/2
   * Wide_Wide_Character_Mapping replaces Character_Mapping

35/2
   * Wide_Wide_Character_Mapping_Function replaces
     Character_Mapping_Function

36/2
   * Wide_Wide_Maps replaces Maps

37/2
   * Bounded_Wide_Wide_String replaces Bounded_String

38/2
   * Null_Bounded_Wide_Wide_String replaces Null_Bounded_String

39/2
   * To_Bounded_Wide_Wide_String replaces To_Bounded_String

40/2
   * To_Wide_Wide_String replaces To_String

41/2
   * Set_Bounded_Wide_Wide_String replaces Set_Bounded_String

42/2
   * Unbounded_Wide_Wide_String replaces Unbounded_String

43/2
   * Null_Unbounded_Wide_Wide_String replaces Null_Unbounded_String

44/2
   * Wide_Wide_String_Access replaces String_Access

45/2
   * To_Unbounded_Wide_Wide_String replaces To_Unbounded_String

46/2
   * Set_Unbounded_Wide_Wide_String replaces Set_Unbounded_String

47/2
The following additional declarations are present in
Strings.Wide_Wide_Maps.Wide_Wide_Constants:

48/2
     Character_Set : constant Wide_Wide_Maps.Wide_Wide_Character_Set;
     -- Contains each Wide_Wide_Character value WWC such that
     -- Characters.Conversions.Is_Character(WWC) is True
     Wide_Character_Set : constant Wide_Wide_Maps.Wide_Wide_Character_Set;
     -- Contains each Wide_Wide_Character value WWC such that
     -- Characters.Conversions.Is_Wide_Character(WWC) is True

49/2
Each Wide_Wide_Character_Set constant in the package
Strings.Wide_Wide_Maps.Wide_Wide_Constants contains no values outside
the Character portion of Wide_Wide_Character.  Similarly, each
Wide_Wide_Character_Mapping constant in this package is the identity
mapping when applied to any element outside the Character portion of
Wide_Wide_Character.

50/2
Pragma Pure is replaced by pragma Preelaborate in
Strings.Wide_Wide_Maps.Wide_Wide_Constants.

     NOTES

51/2
     17  If a null Wide_Wide_Character_Mapping_Function is passed to any
     of the Wide_Wide_String handling subprograms, Constraint_Error is
     propagated.


File: arm2012.info,  Node: A.4.9,  Next: A.4.10,  Prev: A.4.8,  Up: A.4

A.4.9 String Hashing
--------------------

                          _Static Semantics_

1/2
The library function Strings.Hash has the following declaration:

2/3
     with Ada.Containers;
     function Ada.Strings.Hash (Key : String) return Containers.Hash_Type;
     pragma Pure(Ada.Strings.Hash);

3/2
          Returns an implementation-defined value which is a function of
          the value of Key.  If A and B are strings such that A equals
          B, Hash(A) equals Hash(B).

4/2
The library function Strings.Fixed.Hash has the following declaration:

5/3
     with Ada.Containers, Ada.Strings.Hash;
     function Ada.Strings.Fixed.Hash (Key : String) return Containers.Hash_Type
        renames Ada.Strings.Hash;

6/2
The generic library function Strings.Bounded.Hash has the following
declaration:

7/3
     with Ada.Containers;
     generic
        with package Bounded is
           new Ada.Strings.Bounded.Generic_Bounded_Length (<>);
     function Ada.Strings.Bounded.Hash (Key : Bounded.Bounded_String)
        return Containers.Hash_Type;
     pragma Preelaborate(Ada.Strings.Bounded.Hash);

8/3
          Equivalent to Strings.Hash (Bounded.To_String (Key));

9/2
The library function Strings.Unbounded.Hash has the following
declaration:

10/3
     with Ada.Containers;
     function Ada.Strings.Unbounded.Hash (Key : Unbounded_String)
        return Containers.Hash_Type;
     pragma Preelaborate(Ada.Strings.Unbounded.Hash);

11/3
          Equivalent to Strings.Hash (To_String (Key));

11.1/3
The library function Strings.Hash_Case_Insensitive has the following
declaration:

11.2/3
     with Ada.Containers;
     function Ada.Strings.Hash_Case_Insensitive (Key : String)
        return Containers.Hash_Type;
     pragma Pure(Ada.Strings.Hash_Case_Insensitive);

11.3/3
          Returns an implementation-defined value which is a function of
          the value of Key, converted to lower case.  If A and B are
          strings such that Strings.Equal_Case_Insensitive (A, B) (see
          *note A.4.10::) is True, then Hash_Case_Insensitive(A) equals
          Hash_Case_Insensitive(B).

11.4/3
The library function Strings.Fixed.Hash_Case_Insensitive has the
following declaration:

11.5/3
     with Ada.Containers, Ada.Strings.Hash_Case_Insensitive;
     function Ada.Strings.Fixed.Hash_Case_Insensitive (Key : String)
        return Containers.Hash_Type renames Ada.Strings.Hash_Case_Insensitive;

11.6/3
The generic library function Strings.Bounded.Hash_Case_Insensitive has
the following declaration:

11.7/3
     with Ada.Containers;
     generic
        with package Bounded is
           new Ada.Strings.Bounded.Generic_Bounded_Length (<>);
     function Ada.Strings.Bounded.Hash_Case_Insensitive
        (Key : Bounded.Bounded_String) return Containers.Hash_Type;
     pragma Preelaborate(Ada.Strings.Bounded.Hash_Case_Insensitive);

11.8/3
          Equivalent to Strings.Hash_Case_Insensitive (Bounded.To_String
          (Key));

11.9/3
The library function Strings.Unbounded.Hash_Case_Insensitive has the
following declaration:

11.10/3
     with Ada.Containers;
     function Ada.Strings.Unbounded.Hash_Case_Insensitive
        (Key : Unbounded_String) return Containers.Hash_Type;
     pragma Preelaborate(Ada.Strings.Unbounded.Hash_Case_Insensitive);

11.11/3
          Equivalent to Strings.Hash_Case_Insensitive (To_String (Key));

                        _Implementation Advice_

12/2
The Hash functions should be good hash functions, returning a wide
spread of values for different string values.  It should be unlikely for
similar strings to return the same value.


File: arm2012.info,  Node: A.4.10,  Next: A.4.11,  Prev: A.4.9,  Up: A.4

A.4.10 String Comparison
------------------------

                          _Static Semantics_

1/3
The library function Strings.Equal_Case_Insensitive has the following
declaration:

2/3
     function Ada.Strings.Equal_Case_Insensitive (Left, Right : String)
        return Boolean;
     pragma Pure(Ada.Strings.Equal_Case_Insensitive);

3/3
          Returns True if the strings consist of the same sequence of
          characters after applying locale-independent simple case
          folding, as defined by documents referenced in the note in
          Clause 1 of ISO/IEC 10646:2011.  Otherwise, returns False.
          This function uses the same method as is used to determine
          whether two identifiers are the same.

4/3
The library function Strings.Fixed.Equal_Case_Insensitive has the
following declaration:

5/3
     with Ada.Strings.Equal_Case_Insensitive;
     function Ada.Strings.Fixed.Equal_Case_Insensitive
        (Left, Right : String) return Boolean
           renames Ada.Strings.Equal_Case_Insensitive;

6/3
The generic library function Strings.Bounded.Equal_Case_Insensitive has
the following declaration:

7/3
     generic
        with package Bounded is
           new Ada.Strings.Bounded.Generic_Bounded_Length (<>);
     function Ada.Strings.Bounded.Equal_Case_Insensitive
        (Left, Right : Bounded.Bounded_String) return Boolean;
     pragma Preelaborate(Ada.Strings.Bounded.Equal_Case_Insensitive);

8/3
          Equivalent to Strings.Equal_Case_Insensitive
          (Bounded.To_String (Left), Bounded.To_String (Right));

9/3
The library function Strings.Unbounded.Equal_Case_Insensitive has the
following declaration:

10/3
     function Ada.Strings.Unbounded.Equal_Case_Insensitive
        (Left, Right : Unbounded_String) return Boolean;
     pragma Preelaborate(Ada.Strings.Unbounded.Equal_Case_Insensitive);

11/3
          Equivalent to Strings.Equal_Case_Insensitive (To_String
          (Left), To_String (Right));

12/3
The library function Strings.Less_Case_Insensitive has the following
declaration:

13/3
     function Ada.Strings.Less_Case_Insensitive (Left, Right : String)
        return Boolean;
     pragma Pure(Ada.Strings.Less_Case_Insensitive);

14/3
          Performs a lexicographic comparison of strings Left and Right,
          converted to lower case.

15/3
The library function Strings.Fixed.Less_Case_Insensitive has the
following declaration:

16/3
     with Ada.Strings.Less_Case_Insensitive;
     function Ada.Strings.Fixed.Less_Case_Insensitive
        (Left, Right : String) return Boolean
           renames Ada.Strings.Less_Case_Insensitive;

17/3
The generic library function Strings.Bounded.Less_Case_Insensitive has
the following declaration:

18/3
     generic
        with package Bounded is
           new Ada.Strings.Bounded.Generic_Bounded_Length (<>);
     function Ada.Strings.Bounded.Less_Case_Insensitive
       (Left, Right : Bounded.Bounded_String) return Boolean;
     pragma Preelaborate(Ada.Strings.Bounded.Less_Case_Insensitive);

19/3
          Equivalent to Strings.Less_Case_Insensitive (Bounded.To_String
          (Left), Bounded.To_String (Right));

20/3
The library function Strings.Unbounded.Less_Case_Insensitive has the
following declaration:

21/3
     function Ada.Strings.Unbounded.Less_Case_Insensitive
       (Left, Right : Unbounded_String) return Boolean;
     pragma Preelaborate(Ada.Strings.Unbounded.Less_Case_Insensitive);

22/3
          Equivalent to Strings.Less_Case_Insensitive (To_String (Left),
          To_String (Right));


File: arm2012.info,  Node: A.4.11,  Prev: A.4.10,  Up: A.4

A.4.11 String Encoding
----------------------

1/3
Facilities for encoding, decoding, and converting strings in various
character encoding schemes are provided by packages
Strings.UTF_Encoding, Strings.UTF_Encoding.Conversions,
Strings.UTF_Encoding.Strings, Strings.UTF_Encoding.Wide_Strings, and
Strings.UTF_Encoding.Wide_Wide_Strings.

                          _Static Semantics_

2/3
The encoding library packages have the following declarations:

3/3
     package Ada.Strings.UTF_Encoding is
        pragma Pure (UTF_Encoding);

4/3
        -- Declarations common to the string encoding packages
        type Encoding_Scheme is (UTF_8, UTF_16BE, UTF_16LE);

5/3
        subtype UTF_String is String;

6/3
        subtype UTF_8_String is String;

7/3
        subtype UTF_16_Wide_String is Wide_String;

8/3
        Encoding_Error : exception;

9/3
        BOM_8    : constant UTF_8_String :=
                     Character'Val(16#EF#) &
                     Character'Val(16#BB#) &
                     Character'Val(16#BF#);

10/3
        BOM_16BE : constant UTF_String :=
                     Character'Val(16#FE#) &
                     Character'Val(16#FF#);

11/3
        BOM_16LE : constant UTF_String :=
                     Character'Val(16#FF#) &
                     Character'Val(16#FE#);

12/3
        BOM_16   : constant UTF_16_Wide_String :=
                    (1 => Wide_Character'Val(16#FEFF#));

13/3
        function Encoding (Item    : UTF_String;
                           Default : Encoding_Scheme := UTF_8)
           return Encoding_Scheme;

14/3
     end Ada.Strings.UTF_Encoding;

15/3
     package Ada.Strings.UTF_Encoding.Conversions is
        pragma Pure (Conversions);

16/3
        -- Conversions between various encoding schemes
        function Convert (Item          : UTF_String;
                          Input_Scheme  : Encoding_Scheme;
                          Output_Scheme : Encoding_Scheme;
                          Output_BOM    : Boolean := False) return UTF_String;

17/3
        function Convert (Item          : UTF_String;
                          Input_Scheme  : Encoding_Scheme;
                          Output_BOM    : Boolean := False)
           return UTF_16_Wide_String;

18/3
        function Convert (Item          : UTF_8_String;
                          Output_BOM    : Boolean := False)
           return UTF_16_Wide_String;

19/3
        function Convert (Item          : UTF_16_Wide_String;
                          Output_Scheme : Encoding_Scheme;
                          Output_BOM    : Boolean := False) return UTF_String;

20/3
        function Convert (Item          : UTF_16_Wide_String;
                          Output_BOM    : Boolean := False) return UTF_8_String;

21/3
     end Ada.Strings.UTF_Encoding.Conversions;

22/3
     package Ada.Strings.UTF_Encoding.Strings is
        pragma Pure (Strings);

23/3
        -- Encoding / decoding between String and various encoding schemes
        function Encode (Item          : String;
                         Output_Scheme : Encoding_Scheme;
                         Output_BOM    : Boolean  := False) return UTF_String;

24/3
        function Encode (Item       : String;
                         Output_BOM : Boolean  := False) return UTF_8_String;

25/3
        function Encode (Item       : String;
                         Output_BOM : Boolean  := False)
           return UTF_16_Wide_String;

26/3
        function Decode (Item         : UTF_String;
                         Input_Scheme : Encoding_Scheme) return String;

27/3
        function Decode (Item : UTF_8_String) return String;

28/3
        function Decode (Item : UTF_16_Wide_String) return String;

29/3
     end Ada.Strings.UTF_Encoding.Strings;

30/3
     package Ada.Strings.UTF_Encoding.Wide_Strings is
        pragma Pure (Wide_Strings);

31/3
        -- Encoding / decoding between Wide_String and various encoding schemes
        function Encode (Item          : Wide_String;
                         Output_Scheme : Encoding_Scheme;
                         Output_BOM    : Boolean  := False) return UTF_String;

32/3
        function Encode (Item       : Wide_String;
                         Output_BOM : Boolean  := False) return UTF_8_String;

33/3
        function Encode (Item       : Wide_String;
                         Output_BOM : Boolean  := False)
           return UTF_16_Wide_String;

34/3
        function Decode (Item         : UTF_String;
                         Input_Scheme : Encoding_Scheme) return Wide_String;

35/3
        function Decode (Item : UTF_8_String) return Wide_String;

36/3
        function Decode (Item : UTF_16_Wide_String) return Wide_String;

37/3
     end Ada.Strings.UTF_Encoding.Wide_Strings;

38/3
     package Ada.Strings.UTF_Encoding.Wide_Wide_Strings is
        pragma Pure (Wide_Wide_Strings);

39/3
        -- Encoding / decoding between Wide_Wide_String and various encoding schemes
        function Encode (Item          : Wide_Wide_String;
                         Output_Scheme : Encoding_Scheme;
                         Output_BOM    : Boolean  := False) return UTF_String;

40/3
        function Encode (Item       : Wide_Wide_String;
                         Output_BOM : Boolean  := False) return UTF_8_String;

41/3
        function Encode (Item       : Wide_Wide_String;
                         Output_BOM : Boolean  := False)
           return UTF_16_Wide_String;

42/3
        function Decode (Item         : UTF_String;
                         Input_Scheme : Encoding_Scheme) return Wide_Wide_String;

43/3
        function Decode (Item : UTF_8_String) return Wide_Wide_String;

44/3
        function Decode (Item : UTF_16_Wide_String) return Wide_Wide_String;

45/3
     end Ada.Strings.UTF_Encoding.Wide_Wide_Strings;

46/3
The type Encoding_Scheme defines encoding schemes.  UTF_8 corresponds to
the UTF-8 encoding scheme defined by Annex D of ISO/IEC 10646.  UTF_16BE
corresponds to the UTF-16 encoding scheme defined by Annex C of ISO/IEC
10646 in 8 bit, big-endian order; and UTF_16LE corresponds to the UTF-16
encoding scheme in 8 bit, little-endian order.

47/3
The subtype UTF_String is used to represent a String of 8-bit values
containing a sequence of values encoded in one of three ways (UTF-8,
UTF-16BE, or UTF-16LE). The subtype UTF_8_String is used to represent a
String of 8-bit values containing a sequence of values encoded in UTF-8.
The subtype UTF_16_Wide_String is used to represent a Wide_String of
16-bit values containing a sequence of values encoded in UTF-16.

48/3
The BOM_8, BOM_16BE, BOM_16LE, and BOM_16 constants correspond to values
used at the start of a string to indicate the encoding.

49/3
Each of the Encode functions takes a String, Wide_String, or
Wide_Wide_String Item parameter that is assumed to be an array of
unencoded characters.  Each of the Convert functions takes a UTF_String,
UTF_8_String, or UTF_16_String Item parameter that is assumed to contain
characters whose position values correspond to a valid encoding sequence
according to the encoding scheme required by the function or specified
by its Input_Scheme parameter.

50/3
Each of the Convert and Encode functions returns a UTF_String,
UTF_8_String, or UTF_16_String value whose characters have position
values that correspond to the encoding of the Item parameter according
to the encoding scheme required by the function or specified by its
Output_Scheme parameter.  For UTF_8, no overlong encoding is returned.
A BOM is included at the start of the returned string if the Output_BOM
parameter is set to True.  The lower bound of the returned string is 1.

51/3
Each of the Decode functions takes a UTF_String, UTF_8_String, or
UTF_16_String Item parameter which is assumed to contain characters
whose position values correspond to a valid encoding sequence according
to the encoding scheme required by the function or specified by its
Input_Scheme parameter, and returns the corresponding String,
Wide_String, or Wide_Wide_String value.  The lower bound of the returned
string is 1.

52/3
For each of the Convert and Decode functions, an initial BOM in the
input that matches the expected encoding scheme is ignored, and a
different initial BOM causes Encoding_Error to be propagated.

53/3
The exception Encoding_Error is also propagated in the following
situations:

54/4
   * By a Convert or Decode function when a UTF encoded string contains
     an invalid encoding sequence.

55/4
   * By a Convert or Decode function when the expected encoding is
     UTF-16BE or UTF-16LE and the input string has an odd length.

56/3
   * By a Decode function yielding a String when the decoding of a
     sequence results in a code point whose value exceeds 16#FF#.

57/3
   * By a Decode function yielding a Wide_String when the decoding of a
     sequence results in a code point whose value exceeds 16#FFFF#.

58/3
   * By an Encode function taking a Wide_String as input when an invalid
     character appears in the input.  In particular, the characters
     whose position is in the range 16#D800# ..  16#DFFF# are invalid
     because they conflict with UTF-16 surrogate encodings, and the
     characters whose position is 16#FFFE# or 16#FFFF# are also invalid
     because they conflict with BOM codes.

59/3
     function Encoding (Item    : UTF_String;
                        Default : Encoding_Scheme := UTF_8)
        return Encoding_Scheme;

60/3
          Inspects a UTF_String value to determine whether it starts
          with a BOM for UTF-8, UTF-16BE, or UTF_16LE. If so, returns
          the scheme corresponding to the BOM; otherwise, returns the
          value of Default.

61/3
     function Convert (Item          : UTF_String;
                       Input_Scheme  : Encoding_Scheme;
                       Output_Scheme : Encoding_Scheme;
                       Output_BOM    : Boolean := False) return UTF_String;

62/3
          Returns the value of Item (originally encoded in UTF-8,
          UTF-16LE, or UTF-16BE as specified by Input_Scheme) encoded in
          one of these three schemes as specified by Output_Scheme.

63/3
     function Convert (Item          : UTF_String;
                       Input_Scheme  : Encoding_Scheme;
                       Output_BOM    : Boolean := False)
        return UTF_16_Wide_String;

64/3
          Returns the value of Item (originally encoded in UTF-8,
          UTF-16LE, or UTF-16BE as specified by Input_Scheme) encoded in
          UTF-16.

65/3
     function Convert (Item          : UTF_8_String;
                       Output_BOM    : Boolean := False)
        return UTF_16_Wide_String;

66/3
          Returns the value of Item (originally encoded in UTF-8)
          encoded in UTF-16.

67/3
     function Convert (Item          : UTF_16_Wide_String;
                       Output_Scheme : Encoding_Scheme;
                       Output_BOM    : Boolean := False) return UTF_String;

68/3
          Returns the value of Item (originally encoded in UTF-16)
          encoded in UTF-8, UTF-16LE, or UTF-16BE as specified by
          Output_Scheme.

69/3
     function Convert (Item          : UTF_16_Wide_String;
                       Output_BOM    : Boolean := False) return UTF_8_String;

70/3
          Returns the value of Item (originally encoded in UTF-16)
          encoded in UTF-8.

71/3
     function Encode (Item          : String;
                      Output_Scheme : Encoding_Scheme;
                      Output_BOM    : Boolean  := False) return UTF_String;

72/3
          Returns the value of Item encoded in UTF-8, UTF-16LE, or
          UTF-16BE as specified by Output_Scheme.

73/3
     function Encode (Item       : String;
                      Output_BOM : Boolean  := False) return UTF_8_String;

74/3
          Returns the value of Item encoded in UTF-8.

75/3
     function Encode (Item       : String;
                      Output_BOM : Boolean  := False) return UTF_16_Wide_String;

76/3
          Returns the value of Item encoded in UTF_16.

77/3
     function Decode (Item         : UTF_String;
                      Input_Scheme : Encoding_Scheme) return String;

78/3
          Returns the result of decoding Item, which is encoded in
          UTF-8, UTF-16LE, or UTF-16BE as specified by Input_Scheme.

79/3
     function Decode (Item : UTF_8_String) return String;

80/3
          Returns the result of decoding Item, which is encoded in
          UTF-8.

81/3
     function Decode (Item : UTF_16_Wide_String) return String;

82/3
          Returns the result of decoding Item, which is encoded in
          UTF-16.

83/3
     function Encode (Item          : Wide_String;
                      Output_Scheme : Encoding_Scheme;
                      Output_BOM    : Boolean  := False) return UTF_String;

84/3
          Returns the value of Item encoded in UTF-8, UTF-16LE, or
          UTF-16BE as specified by Output_Scheme.

85/3
     function Encode (Item       : Wide_String;
                      Output_BOM : Boolean  := False) return UTF_8_String;

86/3
          Returns the value of Item encoded in UTF-8.

87/3
     function Encode (Item       : Wide_String;
                      Output_BOM : Boolean  := False) return UTF_16_Wide_String;

88/3
          Returns the value of Item encoded in UTF_16.

89/3
     function Decode (Item         : UTF_String;
                      Input_Scheme : Encoding_Scheme) return Wide_String;

90/3
          Returns the result of decoding Item, which is encoded in
          UTF-8, UTF-16LE, or UTF-16BE as specified by Input_Scheme.

91/3
     function Decode (Item : UTF_8_String) return Wide_String;

92/3
          Returns the result of decoding Item, which is encoded in
          UTF-8.

93/3
     function Decode (Item : UTF_16_Wide_String) return Wide_String;

94/3
          Returns the result of decoding Item, which is encoded in
          UTF-16.

95/3
     function Encode (Item          : Wide_Wide_String;
                      Output_Scheme : Encoding_Scheme;
                      Output_BOM    : Boolean  := False) return UTF_String;

96/3
          Returns the value of Item encoded in UTF-8, UTF-16LE, or
          UTF-16BE as specified by Output_Scheme.

97/3
     function Encode (Item       : Wide_Wide_String;
                      Output_BOM : Boolean  := False) return UTF_8_String;

98/3
          Returns the value of Item encoded in UTF-8.

99/3
     function Encode (Item       : Wide_Wide_String;
                      Output_BOM : Boolean  := False) return UTF_16_Wide_String;

100/3
          Returns the value of Item encoded in UTF_16.

101/3
     function Decode (Item         : UTF_String;
                      Input_Scheme : Encoding_Scheme) return Wide_Wide_String;

102/3
          Returns the result of decoding Item, which is encoded in
          UTF-8, UTF-16LE, or UTF-16BE as specified by Input_Scheme.

103/3
     function Decode (Item : UTF_8_String) return Wide_Wide_String;

104/3
          Returns the result of decoding Item, which is encoded in
          UTF-8.

105/3
     function Decode (Item : UTF_16_Wide_String) return Wide_Wide_String;

106/3
          Returns the result of decoding Item, which is encoded in
          UTF-16.

                        _Implementation Advice_

107/3
If an implementation supports other encoding schemes, another similar
child of Ada.Strings should be defined.

     NOTES

108/3
     18  A BOM (Byte-Order Mark, code position 16#FEFF#) can be included
     in a file or other entity to indicate the encoding; it is skipped
     when decoding.  Typically, only the first line of a file or other
     entity contains a BOM. When decoding, the Encoding function can be
     called on the first line to determine the encoding; this encoding
     will then be used in subsequent calls to Decode to convert all of
     the lines to an internal format.


File: arm2012.info,  Node: A.5,  Next: A.6,  Prev: A.4,  Up: Annex A

A.5 The Numerics Packages
=========================

1
The library package Numerics is the parent of several child units that
provide facilities for mathematical computation.  One child, the generic
package Generic_Elementary_Functions, is defined in *note A.5.1::,
together with nongeneric equivalents; two others, the package
Float_Random and the generic package Discrete_Random, are defined in
*note A.5.2::.  Additional (optional) children are defined in *note
Annex G::, "*note Annex G:: Numerics".

                          _Static Semantics_

2/1
This paragraph was deleted.

3/2
     package Ada.Numerics is
        pragma Pure(Numerics);
        Argument_Error : exception;
        Pi : constant :=
               3.14159_26535_89793_23846_26433_83279_50288_41971_69399_37511;
        PI  : constant := Pi;
        e  : constant :=
               2.71828_18284_59045_23536_02874_71352_66249_77572_47093_69996;
     end Ada.Numerics;

4
The Argument_Error exception is raised by a subprogram in a child unit
of Numerics to signal that one or more of the actual subprogram
parameters are outside the domain of the corresponding mathematical
function.

                     _Implementation Permissions_

5
The implementation may specify the values of Pi and e to a larger number
of significant digits.

* Menu:

* A.5.1 ::    Elementary Functions
* A.5.2 ::    Random Number Generation
* A.5.3 ::    Attributes of Floating Point Types
* A.5.4 ::    Attributes of Fixed Point Types


File: arm2012.info,  Node: A.5.1,  Next: A.5.2,  Up: A.5

A.5.1 Elementary Functions
--------------------------

1
Implementation-defined approximations to the mathematical functions
known as the "elementary functions" are provided by the subprograms in
Numerics.Generic_Elementary_Functions.  Nongeneric equivalents of this
generic package for each of the predefined floating point types are also
provided as children of Numerics.

                          _Static Semantics_

2
The generic library package Numerics.Generic_Elementary_Functions has
the following declaration:

3
     generic
        type Float_Type is digits <>;

     package Ada.Numerics.Generic_Elementary_Functions is
        pragma Pure(Generic_Elementary_Functions);

4
        function Sqrt    (X           : Float_Type'Base) return Float_Type'Base;
        function Log     (X           : Float_Type'Base) return Float_Type'Base;
        function Log     (X, Base     : Float_Type'Base) return Float_Type'Base;
        function Exp     (X           : Float_Type'Base) return Float_Type'Base;
        function "**"    (Left, Right : Float_Type'Base) return Float_Type'Base;

5
        function Sin     (X           : Float_Type'Base) return Float_Type'Base;
        function Sin     (X, Cycle    : Float_Type'Base) return Float_Type'Base;
        function Cos     (X           : Float_Type'Base) return Float_Type'Base;
        function Cos     (X, Cycle    : Float_Type'Base) return Float_Type'Base;
        function Tan     (X           : Float_Type'Base) return Float_Type'Base;
        function Tan     (X, Cycle    : Float_Type'Base) return Float_Type'Base;
        function Cot     (X           : Float_Type'Base) return Float_Type'Base;
        function Cot     (X, Cycle    : Float_Type'Base) return Float_Type'Base;

6
        function Arcsin  (X           : Float_Type'Base) return Float_Type'Base;
        function Arcsin  (X, Cycle    : Float_Type'Base) return Float_Type'Base;
        function Arccos  (X           : Float_Type'Base) return Float_Type'Base;
        function Arccos  (X, Cycle    : Float_Type'Base) return Float_Type'Base;
        function Arctan  (Y           : Float_Type'Base;
                          X           : Float_Type'Base := 1.0)
                                                         return Float_Type'Base;
        function Arctan  (Y           : Float_Type'Base;
                          X           : Float_Type'Base := 1.0;
                          Cycle       : Float_Type'Base) return Float_Type'Base;
        function Arccot  (X           : Float_Type'Base;
                          Y           : Float_Type'Base := 1.0)
                                                         return Float_Type'Base;
        function Arccot  (X           : Float_Type'Base;
                          Y           : Float_Type'Base := 1.0;
                          Cycle       : Float_Type'Base) return Float_Type'Base;

7
        function Sinh    (X           : Float_Type'Base) return Float_Type'Base;
        function Cosh    (X           : Float_Type'Base) return Float_Type'Base;
        function Tanh    (X           : Float_Type'Base) return Float_Type'Base;
        function Coth    (X           : Float_Type'Base) return Float_Type'Base;
        function Arcsinh (X           : Float_Type'Base) return Float_Type'Base;
        function Arccosh (X           : Float_Type'Base) return Float_Type'Base;
        function Arctanh (X           : Float_Type'Base) return Float_Type'Base;
        function Arccoth (X           : Float_Type'Base) return Float_Type'Base;

8
     end Ada.Numerics.Generic_Elementary_Functions;

9/1
The library package Numerics.Elementary_Functions is declared pure and
defines the same subprograms as Numerics.Generic_Elementary_Functions,
except that the predefined type Float is systematically substituted for
Float_Type'Base throughout.  Nongeneric equivalents of
Numerics.Generic_Elementary_Functions for each of the other predefined
floating point types are defined similarly, with the names
Numerics.Short_Elementary_Functions, Numerics.Long_Elementary_Functions,
etc.

10
The functions have their usual mathematical meanings.  When the Base
parameter is specified, the Log function computes the logarithm to the
given base; otherwise, it computes the natural logarithm.  When the
Cycle parameter is specified, the parameter X of the forward
trigonometric functions (Sin, Cos, Tan, and Cot) and the results of the
inverse trigonometric functions (Arcsin, Arccos, Arctan, and Arccot) are
measured in units such that a full cycle of revolution has the given
value; otherwise, they are measured in radians.

11
The computed results of the mathematically multivalued functions are
rendered single-valued by the following conventions, which are meant to
imply the principal branch:

12
   * The results of the Sqrt and Arccosh functions and that of the
     exponentiation operator are nonnegative.

13
   * The result of the Arcsin function is in the quadrant containing the
     point (1.0, x), where x is the value of the parameter X. This
     quadrant is I or IV; thus, the range of the Arcsin function is
     approximately -PI/2.0 to PI/2.0 (-Cycle/4.0 to Cycle/4.0, if the
     parameter Cycle is specified).

14
   * The result of the Arccos function is in the quadrant containing the
     point (x, 1.0), where x is the value of the parameter X. This
     quadrant is I or II; thus, the Arccos function ranges from 0.0 to
     approximately PI (Cycle/2.0, if the parameter Cycle is specified).

15
   * The results of the Arctan and Arccot functions are in the quadrant
     containing the point (x, y), where x and y are the values of the
     parameters X and Y, respectively.  This may be any quadrant (I
     through IV) when the parameter X (resp., Y) of Arctan (resp.,
     Arccot) is specified, but it is restricted to quadrants I and IV
     (resp., I and II) when that parameter is omitted.  Thus, the range
     when that parameter is specified is approximately -PI to PI
     (-Cycle/2.0 to Cycle/2.0, if the parameter Cycle is specified);
     when omitted, the range of Arctan (resp., Arccot) is that of Arcsin
     (resp., Arccos), as given above.  When the point (x, y) lies on the
     negative x-axis, the result approximates

16
        * PI (resp., -PI) when the sign of the parameter Y is positive
          (resp., negative), if Float_Type'Signed_Zeros is True;

17
        * PI, if Float_Type'Signed_Zeros is False.

18
(In the case of the inverse trigonometric functions, in which a result
lying on or near one of the axes may not be exactly representable, the
approximation inherent in computing the result may place it in an
adjacent quadrant, close to but on the wrong side of the axis.)

                          _Dynamic Semantics_

19
The exception Numerics.Argument_Error is raised, signaling a parameter
value outside the domain of the corresponding mathematical function, in
the following cases:

20
   * by any forward or inverse trigonometric function with specified
     cycle, when the value of the parameter Cycle is zero or negative;

21
   * by the Log function with specified base, when the value of the
     parameter Base is zero, one, or negative;

22
   * by the Sqrt and Log functions, when the value of the parameter X is
     negative;

23
   * by the exponentiation operator, when the value of the left operand
     is negative or when both operands have the value zero;

24
   * by the Arcsin, Arccos, and Arctanh functions, when the absolute
     value of the parameter X exceeds one;

25
   * by the Arctan and Arccot functions, when the parameters X and Y
     both have the value zero;

26
   * by the Arccosh function, when the value of the parameter X is less
     than one; and

27
   * by the Arccoth function, when the absolute value of the parameter X
     is less than one.

28
The exception Constraint_Error is raised, signaling a pole of the
mathematical function (analogous to dividing by zero), in the following
cases, provided that Float_Type'Machine_Overflows is True:

29
   * by the Log, Cot, and Coth functions, when the value of the
     parameter X is zero;

30
   * by the exponentiation operator, when the value of the left operand
     is zero and the value of the exponent is negative;

31
   * by the Tan function with specified cycle, when the value of the
     parameter X is an odd multiple of the quarter cycle;

32
   * by the Cot function with specified cycle, when the value of the
     parameter X is zero or a multiple of the half cycle; and

33
   * by the Arctanh and Arccoth functions, when the absolute value of
     the parameter X is one.

34
Constraint_Error can also be raised when a finite result overflows (see
*note G.2.4::); this may occur for parameter values sufficiently near
poles, and, in the case of some of the functions, for parameter values
with sufficiently large magnitudes.  When Float_Type'Machine_Overflows
is False, the result at poles is unspecified.

35
When one parameter of a function with multiple parameters represents a
pole and another is outside the function's domain, the latter takes
precedence (i.e., Numerics.Argument_Error is raised).

                     _Implementation Requirements_

36
In the implementation of Numerics.Generic_Elementary_Functions, the
range of intermediate values allowed during the calculation of a final
result shall not be affected by any range constraint of the subtype
Float_Type.

37
In the following cases, evaluation of an elementary function shall yield
the prescribed result, provided that the preceding rules do not call for
an exception to be raised:

38
   * When the parameter X has the value zero, the Sqrt, Sin, Arcsin,
     Tan, Sinh, Arcsinh, Tanh, and Arctanh functions yield a result of
     zero, and the Exp, Cos, and Cosh functions yield a result of one.

39
   * When the parameter X has the value one, the Sqrt function yields a
     result of one, and the Log, Arccos, and Arccosh functions yield a
     result of zero.

40
   * When the parameter Y has the value zero and the parameter X has a
     positive value, the Arctan and Arccot functions yield a result of
     zero.

41
   * The results of the Sin, Cos, Tan, and Cot functions with specified
     cycle are exact when the mathematical result is zero; those of the
     first two are also exact when the mathematical result is ± 1.0.

42
   * Exponentiation by a zero exponent yields the value one.
     Exponentiation by a unit exponent yields the value of the left
     operand.  Exponentiation of the value one yields the value one.
     Exponentiation of the value zero yields the value zero.

43
Other accuracy requirements for the elementary functions, which apply
only in implementations conforming to the Numerics Annex, and then only
in the "strict" mode defined there (see *note G.2::), are given in *note
G.2.4::.

44
When Float_Type'Signed_Zeros is True, the sign of a zero result shall be
as follows:

45
   * A prescribed zero result delivered at the origin by one of the odd
     functions (Sin, Arcsin, Sinh, Arcsinh, Tan, Arctan or Arccot as a
     function of Y when X is fixed and positive, Tanh, and Arctanh) has
     the sign of the parameter X (Y, in the case of Arctan or Arccot).

46
   * A prescribed zero result delivered by one of the odd functions away
     from the origin, or by some other elementary function, has an
     implementation-defined sign.

47
   * A zero result that is not a prescribed result (i.e., one that
     results from rounding or underflow) has the correct mathematical
     sign.

                     _Implementation Permissions_

48
The nongeneric equivalent packages may, but need not, be actual
instantiations of the generic package for the appropriate predefined
type.


File: arm2012.info,  Node: A.5.2,  Next: A.5.3,  Prev: A.5.1,  Up: A.5

A.5.2 Random Number Generation
------------------------------

1
Facilities for the generation of pseudo-random floating point numbers
are provided in the package Numerics.Float_Random; the generic package
Numerics.Discrete_Random provides similar facilities for the generation
of pseudo-random integers and pseudo-random values of enumeration types.
For brevity, pseudo-random values of any of these types are called
random numbers.

2
Some of the facilities provided are basic to all applications of random
numbers.  These include a limited private type each of whose objects
serves as the generator of a (possibly distinct) sequence of random
numbers; a function to obtain the "next" random number from a given
sequence of random numbers (that is, from its generator); and
subprograms to initialize or reinitialize a given generator to a
time-dependent state or a state denoted by a single integer.

3
Other facilities are provided specifically for advanced applications.
These include subprograms to save and restore the state of a given
generator; a private type whose objects can be used to hold the saved
state of a generator; and subprograms to obtain a string representation
of a given generator state, or, given such a string representation, the
corresponding state.

                          _Static Semantics_

4
The library package Numerics.Float_Random has the following declaration:

5
     package Ada.Numerics.Float_Random is

6
        -- Basic facilities

7
        type Generator is limited private;

8
        subtype Uniformly_Distributed is Float range 0.0 .. 1.0;
        function Random (Gen : Generator) return Uniformly_Distributed;

9
        procedure Reset (Gen       : in Generator;
                         Initiator : in Integer);
        procedure Reset (Gen       : in Generator);

10
        -- Advanced facilities

11
        type State is private;

12
        procedure Save  (Gen        : in  Generator;
                         To_State   : out State);
        procedure Reset (Gen        : in  Generator;
                         From_State : in  State);

13
        Max_Image_Width : constant := implementation-defined integer value;

14
        function Image (Of_State    : State)  return String;
        function Value (Coded_State : String) return State;

15
     private
        ... -- not specified by the language
     end Ada.Numerics.Float_Random;

15.1/2
The type Generator needs finalization (see *note 7.6::).

16
The generic library package Numerics.Discrete_Random has the following
declaration:

17

     generic
        type Result_Subtype is (<>);
     package Ada.Numerics.Discrete_Random is

18
        -- Basic facilities

19
        type Generator is limited private;

20
        function Random (Gen : Generator) return Result_Subtype;

21
        procedure Reset (Gen       : in Generator;
                         Initiator : in Integer);
        procedure Reset (Gen       : in Generator);

22
        -- Advanced facilities

23
        type State is private;

24
        procedure Save  (Gen        : in  Generator;
                         To_State   : out State);
        procedure Reset (Gen        : in  Generator;
                         From_State : in  State);

25
        Max_Image_Width : constant := implementation-defined integer value;

26
        function Image (Of_State    : State)  return String;
        function Value (Coded_State : String) return State;

27
     private
        ... -- not specified by the language
     end Ada.Numerics.Discrete_Random;

27.1/2
The type Generator needs finalization (see *note 7.6::) in every
instantiation of Numerics.Discrete_Random.

28
An object of the limited private type Generator is associated with a
sequence of random numbers.  Each generator has a hidden (internal)
state, which the operations on generators use to determine the position
in the associated sequence. All generators are implicitly initialized to
an unspecified state that does not vary from one program execution to
another; they may also be explicitly initialized, or reinitialized, to a
time-dependent state, to a previously saved state, or to a state
uniquely denoted by an integer value.

29/3
An object of the private type State can be used to hold the internal
state of a generator.  Such objects are only needed if the application
is designed to save and restore generator states or to examine or
manufacture them.  The implicit initial value of type State corresponds
to the implicit initial value of all generators.

30
The operations on generators affect the state and therefore the future
values of the associated sequence.  The semantics of the operations on
generators and states are defined below.

31
     function Random (Gen : Generator) return Uniformly_Distributed;
     function Random (Gen : Generator) return Result_Subtype;

32
          Obtains the "next" random number from the given generator,
          relative to its current state, according to an
          implementation-defined algorithm.  The result of the function
          in Numerics.Float_Random is delivered as a value of the
          subtype Uniformly_Distributed, which is a subtype of the
          predefined type Float having a range of 0.0 ..  1.0.  The
          result of the function in an instantiation of
          Numerics.Discrete_Random is delivered as a value of the
          generic formal subtype Result_Subtype.

33
     procedure Reset (Gen       : in Generator;
                      Initiator : in Integer);
     procedure Reset (Gen       : in Generator);

34
          Sets the state of the specified generator to one that is an
          unspecified function of the value of the parameter Initiator
          (or to a time-dependent state, if only a generator parameter
          is specified). The latter form of the procedure is known as
          the time-dependent Reset procedure.

35
     procedure Save  (Gen        : in  Generator;
                      To_State   : out State);
     procedure Reset (Gen        : in  Generator;
                      From_State : in  State);

36
          Save obtains the current state of a generator.  Reset gives a
          generator the specified state.  A generator that is reset to a
          state previously obtained by invoking Save is restored to the
          state it had when Save was invoked.

37
     function Image (Of_State    : State)  return String;
     function Value (Coded_State : String) return State;

38
          Image provides a representation of a state coded (in an
          implementation-defined way) as a string whose length is
          bounded by the value of Max_Image_Width.  Value is the inverse
          of Image: Value(Image(S)) = S for each state S that can be
          obtained from a generator by invoking Save.

                          _Dynamic Semantics_

39
Instantiation of Numerics.Discrete_Random with a subtype having a null
range raises Constraint_Error.

40/1
This paragraph was deleted.

                      _Bounded (Run-Time) Errors_

40.1/1
It is a bounded error to invoke Value with a string that is not the
image of any generator state. If the error is detected, Constraint_Error
or Program_Error is raised.  Otherwise, a call to Reset with the
resulting state will produce a generator such that calls to Random with
this generator will produce a sequence of values of the appropriate
subtype, but which might not be random in character.  That is, the
sequence of values might not fulfill the implementation requirements of
this subclause.

                     _Implementation Requirements_

41
A sufficiently long sequence of random numbers obtained by successive
calls to Random is approximately uniformly distributed over the range of
the result subtype.

42
The Random function in an instantiation of Numerics.Discrete_Random is
guaranteed to yield each value in its result subtype in a finite number
of calls, provided that the number of such values does not exceed 2 15.

43
Other performance requirements for the random number generator, which
apply only in implementations conforming to the Numerics Annex, and then
only in the "strict" mode defined there (see *note G.2::), are given in
*note G.2.5::.

                     _Documentation Requirements_

44
No one algorithm for random number generation is best for all
applications.  To enable the user to determine the suitability of the
random number generators for the intended application, the
implementation shall describe the algorithm used and shall give its
period, if known exactly, or a lower bound on the period, if the exact
period is unknown.  Periods that are so long that the periodicity is
unobservable in practice can be described in such terms, without giving
a numerical bound.

45
The implementation also shall document the minimum time interval between
calls to the time-dependent Reset procedure that are guaranteed to
initiate different sequences, and it shall document the nature of the
strings that Value will accept without raising Constraint_Error.

                        _Implementation Advice_

46
Any storage associated with an object of type Generator should be
reclaimed on exit from the scope of the object.

47
If the generator period is sufficiently long in relation to the number
of distinct initiator values, then each possible value of Initiator
passed to Reset should initiate a sequence of random numbers that does
not, in a practical sense, overlap the sequence initiated by any other
value.  If this is not possible, then the mapping between initiator
values and generator states should be a rapidly varying function of the
initiator value.

     NOTES

48
     19  If two or more tasks are to share the same generator, then the
     tasks have to synchronize their access to the generator as for any
     shared variable (see *note 9.10::).

49
     20  Within a given implementation, a repeatable random number
     sequence can be obtained by relying on the implicit initialization
     of generators or by explicitly initializing a generator with a
     repeatable initiator value.  Different sequences of random numbers
     can be obtained from a given generator in different program
     executions by explicitly initializing the generator to a
     time-dependent state.

50
     21  A given implementation of the Random function in
     Numerics.Float_Random may or may not be capable of delivering the
     values 0.0 or 1.0.  Portable applications should assume that these
     values, or values sufficiently close to them to behave
     indistinguishably from them, can occur.  If a sequence of random
     integers from some fixed range is needed, the application should
     use the Random function in an appropriate instantiation of
     Numerics.Discrete_Random, rather than transforming the result of
     the Random function in Numerics.Float_Random.  However, some
     applications with unusual requirements, such as for a sequence of
     random integers each drawn from a different range, will find it
     more convenient to transform the result of the floating point
     Random function.  For M >= 1, the expression

51
             Integer(Float(M) * Random(G)) mod M

52
     transforms the result of Random(G) to an integer uniformly
     distributed over the range 0 ..  M-1; it is valid even if Random
     delivers 0.0 or 1.0.  Each value of the result range is possible,
     provided that M is not too large.  Exponentially distributed
     (floating point) random numbers with mean and standard deviation
     1.0 can be obtained by the transformation

53/2
             -Log(Random(G) + Float'Model_Small)

54
     where Log comes from Numerics.Elementary_Functions (see *note
     A.5.1::); in this expression, the addition of Float'Model_Small
     avoids the exception that would be raised were Log to be given the
     value zero, without affecting the result (in most implementations)
     when Random returns a nonzero value.

                              _Examples_

55
Example of a program that plays a simulated dice game:

56
     with Ada.Numerics.Discrete_Random;
     procedure Dice_Game is
        subtype Die is Integer range 1 .. 6;
        subtype Dice is Integer range 2*Die'First .. 2*Die'Last;
        package Random_Die is new Ada.Numerics.Discrete_Random (Die);
        use Random_Die;
        G : Generator;
        D : Dice;
     begin
        Reset (G);  -- Start the generator in a unique state in each run
        loop
           -- Roll a pair of dice; sum and process the results
           D := Random(G) + Random(G);
           ...
        end loop;
     end Dice_Game;

57
Example of a program that simulates coin tosses:

58
     with Ada.Numerics.Discrete_Random;
     procedure Flip_A_Coin is
        type Coin is (Heads, Tails);
        package Random_Coin is new Ada.Numerics.Discrete_Random (Coin);
        use Random_Coin;
        G : Generator;
     begin
        Reset (G);  -- Start the generator in a unique state in each run
        loop
           -- Toss a coin and process the result
           case Random(G) is
               when Heads =>
                  ...
               when Tails =>
                  ...
           end case;
        ...
        end loop;
     end Flip_A_Coin;

59
Example of a parallel simulation of a physical system, with a separate
generator of event probabilities in each task:

60
     with Ada.Numerics.Float_Random;
     procedure Parallel_Simulation is
        use Ada.Numerics.Float_Random;
        task type Worker is
           entry Initialize_Generator (Initiator : in Integer);
           ...
        end Worker;
        W : array (1 .. 10) of Worker;
        task body Worker is
           G : Generator;
           Probability_Of_Event : Uniformly_Distributed;
        begin
           accept Initialize_Generator (Initiator : in Integer) do
              Reset (G, Initiator);
           end Initialize_Generator;
           loop
              ...
              Probability_Of_Event := Random(G);
              ...
           end loop;
        end Worker;
     begin
        -- Initialize the generators in the Worker tasks to different states
        for I in W'Range loop
           W(I).Initialize_Generator (I);
        end loop;
        ... -- Wait for the Worker tasks to terminate
     end Parallel_Simulation;

     NOTES

61
     22  Notes on the last example: Although each Worker task
     initializes its generator to a different state, those states will
     be the same in every execution of the program.  The generator
     states can be initialized uniquely in each program execution by
     instantiating Ada.Numerics.Discrete_Random for the type Integer in
     the main procedure, resetting the generator obtained from that
     instance to a time-dependent state, and then using random integers
     obtained from that generator to initialize the generators in each
     Worker task.


File: arm2012.info,  Node: A.5.3,  Next: A.5.4,  Prev: A.5.2,  Up: A.5

A.5.3 Attributes of Floating Point Types
----------------------------------------

                          _Static Semantics_

1
The following representation-oriented attributes are defined for every
subtype S of a floating point type T.

2
S'Machine_Radix
               Yields the radix of the hardware representation of the
               type T. The value of this attribute is of the type
               universal_integer.

3
The values of other representation-oriented attributes of a floating
point subtype, and of the "primitive function" attributes of a floating
point subtype described later, are defined in terms of a particular
representation of nonzero values called the canonical form.  The
canonical form (for the type T) is the form
    ± mantissa · T'Machine_Radixexponent
where

4
   * mantissa is a fraction in the number base T'Machine_Radix, the
     first digit of which is nonzero, and

5
   * exponent is an integer.

6
S'Machine_Mantissa
               Yields the largest value of p such that every value
               expressible in the canonical form (for the type T),
               having a p-digit mantissa and an exponent between
               T'Machine_Emin and T'Machine_Emax, is a machine number
               (see *note 3.5.7::) of the type T. This attribute yields
               a value of the type universal_integer.

7
S'Machine_Emin
               Yields the smallest (most negative) value of exponent
               such that every value expressible in the canonical form
               (for the type T), having a mantissa of T'Machine_Mantissa
               digits, is a machine number (see *note 3.5.7::) of the
               type T. This attribute yields a value of the type
               universal_integer.

8
S'Machine_Emax
               Yields the largest (most positive) value of exponent such
               that every value expressible in the canonical form (for
               the type T), having a mantissa of T'Machine_Mantissa
               digits, is a machine number (see *note 3.5.7::) of the
               type T. This attribute yields a value of the type
               universal_integer.

9
S'Denorm
               Yields the value True if every value expressible in the
               form
                   ± mantissa · T'Machine_RadixT'Machine_Emin
               where mantissa is a nonzero T'Machine_Mantissa-digit
               fraction in the number base T'Machine_Radix, the first
               digit of which is zero, is a machine number (see *note
               3.5.7::) of the type T; yields the value False otherwise.
               The value of this attribute is of the predefined type
               Boolean.

10
The values described by the formula in the definition of S'Denorm are
called denormalized numbers. A nonzero machine number that is not a
denormalized number is a normalized number. A normalized number x of a
given type T is said to be represented in canonical form when it is
expressed in the canonical form (for the type T) with a mantissa having
T'Machine_Mantissa digits; the resulting form is the canonical-form
representation of x.

11
S'Machine_Rounds
               Yields the value True if rounding is performed on inexact
               results of every predefined operation that yields a
               result of the type T; yields the value False otherwise.
               The value of this attribute is of the predefined type
               Boolean.

12
S'Machine_Overflows
               Yields the value True if overflow and divide-by-zero are
               detected and reported by raising Constraint_Error for
               every predefined operation that yields a result of the
               type T; yields the value False otherwise.  The value of
               this attribute is of the predefined type Boolean.

13
S'Signed_Zeros
               Yields the value True if the hardware representation for
               the type T has the capability of representing both
               positively and negatively signed zeros, these being
               generated and used by the predefined operations of the
               type T as specified in IEC 559:1989; yields the value
               False otherwise.  The value of this attribute is of the
               predefined type Boolean.

14
For every value x of a floating point type T, the normalized exponent of
x is defined as follows:

15
   * the normalized exponent of zero is (by convention) zero;

16
   * for nonzero x, the normalized exponent of x is the unique integer k
     such that T'Machine_Radixk-1 <= |x| < T'Machine_Radixk.

17
The following primitive function attributes are defined for any subtype
S of a floating point type T.

18
S'Exponent
               S'Exponent denotes a function with the following
               specification:

19
                    function S'Exponent (X : T)
                      return universal_integer

20
               The function yields the normalized exponent of X.

21
S'Fraction
               S'Fraction denotes a function with the following
               specification:

22
                    function S'Fraction (X : T)
                      return T

23
               The function yields the value X · T'Machine_Radix-k,
               where k is the normalized exponent of X. A zero result,
               which can only occur when X is zero, has the sign of X.

24
S'Compose
               S'Compose denotes a function with the following
               specification:

25
                    function S'Compose (Fraction : T;
                                        Exponent : universal_integer)
                      return T

26
               Let v be the value Fraction · T'Machine_RadixExponent-k,
               where k is the normalized exponent of Fraction.  If v is
               a machine number of the type T, or if |v| >=
               T'Model_Small, the function yields v; otherwise, it
               yields either one of the machine numbers of the type T
               adjacent to v. Constraint_Error is optionally raised if v
               is outside the base range of S. A zero result has the
               sign of Fraction when S'Signed_Zeros is True.

27
S'Scaling
               S'Scaling denotes a function with the following
               specification:

28
                    function S'Scaling (X : T;
                                        Adjustment : universal_integer)
                      return T

29
               Let v be the value X · T'Machine_RadixAdjustment.  If v
               is a machine number of the type T, or if |v| >=
               T'Model_Small, the function yields v; otherwise, it
               yields either one of the machine numbers of the type T
               adjacent to v. Constraint_Error is optionally raised if v
               is outside the base range of S. A zero result has the
               sign of X when S'Signed_Zeros is True.

30
S'Floor
               S'Floor denotes a function with the following
               specification:

31
                    function S'Floor (X : T)
                      return T

32
               The function yields the value 'floor(X)', i.e., the
               largest (most positive) integral value less than or equal
               to X. When X is zero, the result has the sign of X; a
               zero result otherwise has a positive sign.

33
S'Ceiling
               S'Ceiling denotes a function with the following
               specification:

34
                    function S'Ceiling (X : T)
                      return T

35
               The function yields the value 'ceiling(X)', i.e., the
               smallest (most negative) integral value greater than or
               equal to X. When X is zero, the result has the sign of X;
               a zero result otherwise has a negative sign when
               S'Signed_Zeros is True.

36
S'Rounding
               S'Rounding denotes a function with the following
               specification:

37
                    function S'Rounding (X : T)
                      return T

38
               The function yields the integral value nearest to X,
               rounding away from zero if X lies exactly halfway between
               two integers.  A zero result has the sign of X when
               S'Signed_Zeros is True.

39
S'Unbiased_Rounding
               S'Unbiased_Rounding denotes a function with the following
               specification:

40
                    function S'Unbiased_Rounding (X : T)
                      return T

41
               The function yields the integral value nearest to X,
               rounding toward the even integer if X lies exactly
               halfway between two integers.  A zero result has the sign
               of X when S'Signed_Zeros is True.

41.1/2
S'Machine_Rounding
               S'Machine_Rounding denotes a function with the following
               specification:

41.2/2
                    function S'Machine_Rounding (X : T)
                      return T

41.3/2
               The function yields the integral value nearest to X. If X
               lies exactly halfway between two integers, one of those
               integers is returned, but which of them is returned is
               unspecified.  A zero result has the sign of X when
               S'Signed_Zeros is True.  This function provides access to
               the rounding behavior which is most efficient on the
               target processor.

42
S'Truncation
               S'Truncation denotes a function with the following
               specification:

43
                    function S'Truncation (X : T)
                      return T

44
               The function yields the value 'ceiling(X)' when X is
               negative, and 'floor(X)' otherwise.  A zero result has
               the sign of X when S'Signed_Zeros is True.

45
S'Remainder
               S'Remainder denotes a function with the following
               specification:

46
                    function S'Remainder (X, Y : T)
                      return T

47
               For nonzero Y, let v be the value X - n · Y, where n is
               the integer nearest to the exact value of X/Y; if |n -
               X/Y| = 1/2, then n is chosen to be even.  If v is a
               machine number of the type T, the function yields v;
               otherwise, it yields zero. Constraint_Error is raised if
               Y is zero.  A zero result has the sign of X when
               S'Signed_Zeros is True.

48
S'Adjacent
               S'Adjacent denotes a function with the following
               specification:

49
                    function S'Adjacent (X, Towards : T)
                      return T

50
               If Towards = X, the function yields X; otherwise, it
               yields the machine number of the type T adjacent to X in
               the direction of Towards, if that machine number exists. 
               If the result would be outside the base range of S,
               Constraint_Error is raised.  When T'Signed_Zeros is True,
               a zero result has the sign of X. When Towards is zero,
               its sign has no bearing on the result.

51
S'Copy_Sign
               S'Copy_Sign denotes a function with the following
               specification:

52
                    function S'Copy_Sign (Value, Sign : T)
                      return T

53
               If the value of Value is nonzero, the function yields a
               result whose magnitude is that of Value and whose sign is
               that of Sign; otherwise, it yields the value zero. 
               Constraint_Error is optionally raised if the result is
               outside the base range of S. A zero result has the sign
               of Sign when S'Signed_Zeros is True.

54
S'Leading_Part
               S'Leading_Part denotes a function with the following
               specification:

55
                    function S'Leading_Part (X : T;
                                             Radix_Digits : universal_integer)
                      return T

56
               Let v be the value T'Machine_Radixk-Radix_Digits, where k
               is the normalized exponent of X. The function yields the
               value

57
                  * 'floor(X/v)' · v, when X is nonnegative and
                    Radix_Digits is positive;

58
                  * 'ceiling(X/v)' · v, when X is negative and
                    Radix_Digits is positive.

59
               Constraint_Error is raised when Radix_Digits is zero or
               negative.  A zero result, which can only occur when X is
               zero, has the sign of X.

60
S'Machine
               S'Machine denotes a function with the following
               specification:

61
                    function S'Machine (X : T)
                      return T

62
               If X is a machine number of the type T, the function
               yields X; otherwise, it yields the value obtained by
               rounding or truncating X to either one of the adjacent
               machine numbers of the type T. Constraint_Error is raised
               if rounding or truncating X to the precision of the
               machine numbers results in a value outside the base range
               of S. A zero result has the sign of X when S'Signed_Zeros
               is True.

63
The following model-oriented attributes are defined for any subtype S of
a floating point type T.

64
S'Model_Mantissa
               If the Numerics Annex is not supported, this attribute
               yields an implementation defined value that is greater
               than or equal to 'ceiling(d · log(10) /
               log(T'Machine_Radix))' + 1, where d is the requested
               decimal precision of T, and less than or equal to the
               value of T'Machine_Mantissa.  See *note G.2.2:: for
               further requirements that apply to implementations
               supporting the Numerics Annex.  The value of this
               attribute is of the type universal_integer.

65
S'Model_Emin
               If the Numerics Annex is not supported, this attribute
               yields an implementation defined value that is greater
               than or equal to the value of T'Machine_Emin.  See *note
               G.2.2:: for further requirements that apply to
               implementations supporting the Numerics Annex.  The value
               of this attribute is of the type universal_integer.

66
S'Model_Epsilon
               Yields the value T'Machine_Radix1 - T'Model_Mantissa.
               The value of this attribute is of the type
               universal_real.

67
S'Model_Small
               Yields the value T'Machine_RadixT'Model_Emin - 1.  The
               value of this attribute is of the type universal_real.

68
S'Model
               S'Model denotes a function with the following
               specification:

69
                    function S'Model (X : T)
                      return T

70
               If the Numerics Annex is not supported, the meaning of
               this attribute is implementation defined; see *note
               G.2.2:: for the definition that applies to
               implementations supporting the Numerics Annex.

71
S'Safe_First
               Yields the lower bound of the safe range (see *note
               3.5.7::) of the type T. If the Numerics Annex is not
               supported, the value of this attribute is implementation
               defined; see *note G.2.2:: for the definition that
               applies to implementations supporting the Numerics Annex.
               The value of this attribute is of the type
               universal_real.

72
S'Safe_Last
               Yields the upper bound of the safe range (see *note
               3.5.7::) of the type T. If the Numerics Annex is not
               supported, the value of this attribute is implementation
               defined; see *note G.2.2:: for the definition that
               applies to implementations supporting the Numerics Annex.
               The value of this attribute is of the type
               universal_real.


File: arm2012.info,  Node: A.5.4,  Prev: A.5.3,  Up: A.5

A.5.4 Attributes of Fixed Point Types
-------------------------------------

                          _Static Semantics_

1
The following representation-oriented attributes are defined for every
subtype S of a fixed point type T.

2
S'Machine_Radix
               Yields the radix of the hardware representation of the
               type T. The value of this attribute is of the type
               universal_integer.

3
S'Machine_Rounds
               Yields the value True if rounding is performed on inexact
               results of every predefined operation that yields a
               result of the type T; yields the value False otherwise.
               The value of this attribute is of the predefined type
               Boolean.

4
S'Machine_Overflows
               Yields the value True if overflow and divide-by-zero are
               detected and reported by raising Constraint_Error for
               every predefined operation that yields a result of the
               type T; yields the value False otherwise.  The value of
               this attribute is of the predefined type Boolean.


File: arm2012.info,  Node: A.6,  Next: A.7,  Prev: A.5,  Up: Annex A

A.6 Input-Output
================

1/2
Input-output is provided through language-defined packages, each of
which is a child of the root package Ada.  The generic packages
Sequential_IO and Direct_IO define input-output operations applicable to
files containing elements of a given type.  The generic package
Storage_IO supports reading from and writing to an in-memory buffer.
Additional operations for text input-output are supplied in the packages
Text_IO, Wide_Text_IO, and Wide_Wide_Text_IO. Heterogeneous input-output
is provided through the child packages Streams.Stream_IO and
Text_IO.Text_Streams (see also *note 13.13::).  The package
IO_Exceptions defines the exceptions needed by the predefined
input-output packages.


File: arm2012.info,  Node: A.7,  Next: A.8,  Prev: A.6,  Up: Annex A

A.7 External Files and File Objects
===================================

                          _Static Semantics_

1
Values input from the external environment of the program, or output to
the external environment, are considered to occupy external files.  An
external file can be anything external to the program that can produce a
value to be read or receive a value to be written.  An external file is
identified by a string (the name).  A second string (the form) gives
further system-dependent characteristics that may be associated with the
file, such as the physical organization or access rights.  The
conventions governing the interpretation of such strings shall be
documented.

2/3
Input and output operations are expressed as operations on objects of
some file type, rather than directly in terms of the external files.  In
the remainder of this clause, the term file is always used to refer to a
file object; the term external file is used otherwise.

3
Input-output for sequential files of values of a single element type is
defined by means of the generic package Sequential_IO. In order to
define sequential input-output for a given element type, an
instantiation of this generic unit, with the given type as actual
parameter, has to be declared.  The resulting package contains the
declaration of a file type (called File_Type) for files of such
elements, as well as the operations applicable to these files, such as
the Open, Read, and Write procedures.

4/2
Input-output for direct access files is likewise defined by a generic
package called Direct_IO. Input-output in human-readable form is defined
by the (nongeneric) packages Text_IO for Character and String data,
Wide_Text_IO for Wide_Character and Wide_String data, and
Wide_Wide_Text_IO for Wide_Wide_Character and Wide_Wide_String data.
Input-output for files containing streams of elements representing
values of possibly different types is defined by means of the
(nongeneric) package Streams.Stream_IO.

5
Before input or output operations can be performed on a file, the file
first has to be associated with an external file.  While such an
association is in effect, the file is said to be open, and otherwise the
file is said to be closed.

6
The language does not define what happens to external files after the
completion of the main program and all the library tasks (in particular,
if corresponding files have not been closed). The effect of input-output
for access types is unspecified.

7
An open file has a current mode, which is a value of one of the
following enumeration types:

8
     type File_Mode is (In_File, Inout_File, Out_File);  --  for Direct_IO

9
          These values correspond respectively to the cases where only
          reading, both reading and writing, or only writing are to be
          performed.

10/2
     type File_Mode is (In_File, Out_File, Append_File);
     --  for Sequential_IO, Text_IO, Wide_Text_IO, Wide_Wide_Text_IO, and Stream_IO

11
          These values correspond respectively to the cases where only
          reading, only writing, or only appending are to be performed.

12
          The mode of a file can be changed.

13/2
Several file management operations are common to Sequential_IO,
Direct_IO, Text_IO, Wide_Text_IO, and Wide_Wide_Text_IO. These
operations are described in subclause *note A.8.2:: for sequential and
direct files.  Any additional effects concerning text input-output are
described in subclause *note A.10.2::.

14/3
The exceptions that can be propagated by the execution of an
input-output subprogram are defined in the package IO_Exceptions; the
situations in which they can be propagated are described following the
description of the subprogram (and in subclause *note A.13::). The
exceptions Storage_Error and Program_Error may be propagated.
(Program_Error can only be propagated due to errors made by the caller
of the subprogram.)  Finally, exceptions can be propagated in certain
implementation-defined situations.

     NOTES

15/2
     23  Each instantiation of the generic packages Sequential_IO and
     Direct_IO declares a different type File_Type.  In the case of
     Text_IO, Wide_Text_IO, Wide_Wide_Text_IO, and Streams.Stream_IO,
     the corresponding type File_Type is unique.

16
     24  A bidirectional device can often be modeled as two sequential
     files associated with the device, one of mode In_File, and one of
     mode Out_File.  An implementation may restrict the number of files
     that may be associated with a given external file.


File: arm2012.info,  Node: A.8,  Next: A.9,  Prev: A.7,  Up: Annex A

A.8 Sequential and Direct Files
===============================

                          _Static Semantics_

1/2
Two kinds of access to external files are defined in this subclause:
sequential access and direct access.  The corresponding file types and
the associated operations are provided by the generic packages
Sequential_IO and Direct_IO. A file object to be used for sequential
access is called a sequential file, and one to be used for direct access
is called a direct file.  Access to stream files is described in *note
A.12.1::.

2
For sequential access, the file is viewed as a sequence of values that
are transferred in the order of their appearance (as produced by the
program or by the external environment).  When the file is opened with
mode In_File or Out_File, transfer starts respectively from or to the
beginning of the file.  When the file is opened with mode Append_File,
transfer to the file starts after the last element of the file.

3
For direct access, the file is viewed as a set of elements occupying
consecutive positions in linear order; a value can be transferred to or
from an element of the file at any selected position.  The position of
an element is specified by its index, which is a number, greater than
zero, of the implementation-defined integer type Count.  The first
element, if any, has index one; the index of the last element, if any,
is called the current size; the current size is zero if there are no
elements.  The current size is a property of the external file.

4
An open direct file has a current index, which is the index that will be
used by the next read or write operation.  When a direct file is opened,
the current index is set to one.  The current index of a direct file is
a property of a file object, not of an external file.

* Menu:

* A.8.1 ::    The Generic Package Sequential_IO
* A.8.2 ::    File Management
* A.8.3 ::    Sequential Input-Output Operations
* A.8.4 ::    The Generic Package Direct_IO
* A.8.5 ::    Direct Input-Output Operations


File: arm2012.info,  Node: A.8.1,  Next: A.8.2,  Up: A.8

A.8.1 The Generic Package Sequential_IO
---------------------------------------

                          _Static Semantics_

1
The generic library package Sequential_IO has the following declaration:

2
     with Ada.IO_Exceptions;
     generic
        type Element_Type(<>) is private;
     package Ada.Sequential_IO is

3
        type File_Type is limited private;

4
        type File_Mode is (In_File, Out_File, Append_File);

5
        -- File management

6
        procedure Create(File : in out File_Type;
                         Mode : in File_Mode := Out_File;
                         Name : in String := "";
                         Form : in String := "");

7
        procedure Open  (File : in out File_Type;
                         Mode : in File_Mode;
                         Name : in String;
                         Form : in String := "");

8
        procedure Close (File : in out File_Type);
        procedure Delete(File : in out File_Type);
        procedure Reset (File : in out File_Type; Mode : in File_Mode);
        procedure Reset (File : in out File_Type);

9
        function Mode   (File : in File_Type) return File_Mode;
        function Name   (File : in File_Type) return String;
        function Form   (File : in File_Type) return String;

10
        function Is_Open(File : in File_Type) return Boolean;

10.1/4
        procedure Flush (File : in File_Type);

11
        -- Input and output operations

12
        procedure Read  (File : in File_Type; Item : out Element_Type);
        procedure Write (File : in File_Type; Item : in Element_Type);

13
        function End_Of_File(File : in File_Type) return Boolean;

14
        -- Exceptions

15
        Status_Error : exception renames IO_Exceptions.Status_Error;
        Mode_Error   : exception renames IO_Exceptions.Mode_Error;
        Name_Error   : exception renames IO_Exceptions.Name_Error;
        Use_Error    : exception renames IO_Exceptions.Use_Error;
        Device_Error : exception renames IO_Exceptions.Device_Error;
        End_Error    : exception renames IO_Exceptions.End_Error;
        Data_Error   : exception renames IO_Exceptions.Data_Error;

16
     private
        ... -- not specified by the language
     end Ada.Sequential_IO;

17/2
The type File_Type needs finalization (see *note 7.6::) in every
instantiation of Sequential_IO.


File: arm2012.info,  Node: A.8.2,  Next: A.8.3,  Prev: A.8.1,  Up: A.8

A.8.2 File Management
---------------------

                          _Static Semantics_

1
The procedures and functions described in this subclause provide for the
control of external files; their declarations are repeated in each of
the packages for sequential, direct, text, and stream input-output.  For
text input-output, the procedures Create, Open, and Reset have
additional effects described in subclause *note A.10.2::.

2
     procedure Create(File : in out File_Type;
                      Mode : in File_Mode := default_mode;
                      Name : in String := "";
                      Form : in String := "");

3/2
          Establishes a new external file, with the given name and form,
          and associates this external file with the given file.  The
          given file is left open.  The current mode of the given file
          is set to the given access mode.  The default access mode is
          the mode Out_File for sequential, stream, and text
          input-output; it is the mode Inout_File for direct
          input-output.  For direct access, the size of the created file
          is implementation defined.

4
          A null string for Name specifies an external file that is not
          accessible after the completion of the main program (a
          temporary file).  A null string for Form specifies the use of
          the default options of the implementation for the external
          file.

5
          The exception Status_Error is propagated if the given file is
          already open.  The exception Name_Error is propagated if the
          string given as Name does not allow the identification of an
          external file.  The exception Use_Error is propagated if, for
          the specified mode, the external environment does not support
          creation of an external file with the given name (in the
          absence of Name_Error) and form.

6
     procedure Open(File : in out File_Type;
                    Mode : in File_Mode;
                    Name : in String;
                    Form : in String := "");

7
          Associates the given file with an existing external file
          having the given name and form, and sets the current mode of
          the given file to the given mode.  The given file is left
          open.

8
          The exception Status_Error is propagated if the given file is
          already open.  The exception Name_Error is propagated if the
          string given as Name does not allow the identification of an
          external file; in particular, this exception is propagated if
          no external file with the given name exists.  The exception
          Use_Error is propagated if, for the specified mode, the
          external environment does not support opening for an external
          file with the given name (in the absence of Name_Error) and
          form.

9
     procedure Close(File : in out File_Type);

10
          Severs the association between the given file and its
          associated external file.  The given file is left closed.  In
          addition, for sequential files, if the file being closed has
          mode Out_File or Append_File, then the last element written
          since the most recent open or reset is the last element that
          can be read from the file.  If no elements have been written
          and the file mode is Out_File, then the closed file is empty.
          If no elements have been written and the file mode is
          Append_File, then the closed file is unchanged.

11
          The exception Status_Error is propagated if the given file is
          not open.

12
     procedure Delete(File : in out File_Type);

13
          Deletes the external file associated with the given file.  The
          given file is closed, and the external file ceases to exist.

14
          The exception Status_Error is propagated if the given file is
          not open.  The exception Use_Error is propagated if deletion
          of the external file is not supported by the external
          environment.

15
     procedure Reset(File : in out File_Type; Mode : in File_Mode);
     procedure Reset(File : in out File_Type);

16/2
          Resets the given file so that reading from its elements can be
          restarted from the beginning of the external file (for modes
          In_File and Inout_File), and so that writing to its elements
          can be restarted at the beginning of the external file (for
          modes Out_File and Inout_File) or after the last element of
          the external file (for mode Append_File).  In particular, for
          direct access this means that the current index is set to one.
          If a Mode parameter is supplied, the current mode of the given
          file is set to the given mode.  In addition, for sequential
          files, if the given file has mode Out_File or Append_File when
          Reset is called, the last element written since the most
          recent open or reset is the last element that can be read from
          the external file.  If no elements have been written and the
          file mode is Out_File, the reset file is empty.  If no
          elements have been written and the file mode is Append_File,
          then the reset file is unchanged.

17
          The exception Status_Error is propagated if the file is not
          open.  The exception Use_Error is propagated if the external
          environment does not support resetting for the external file
          and, also, if the external environment does not support
          resetting to the specified mode for the external file.

18
     function Mode(File : in File_Type) return File_Mode;

19
          Returns the current mode of the given file.

20
          The exception Status_Error is propagated if the file is not
          open.

21
     function Name(File : in File_Type) return String;

22/2
          Returns a string which uniquely identifies the external file
          currently associated with the given file (and may thus be used
          in an Open operation).

23
          The exception Status_Error is propagated if the given file is
          not open.  The exception Use_Error is propagated if the
          associated external file is a temporary file that cannot be
          opened by any name.

24
     function Form(File : in File_Type) return String;

25
          Returns the form string for the external file currently
          associated with the given file.  If an external environment
          allows alternative specifications of the form (for example,
          abbreviations using default options), the string returned by
          the function should correspond to a full specification (that
          is, it should indicate explicitly all options selected,
          including default options).

26
          The exception Status_Error is propagated if the given file is
          not open.

27
     function Is_Open(File : in File_Type) return Boolean;

28/3
          Returns True if the file is open (that is, if it is associated
          with an external file); otherwise, returns False.

28.1/4
     procedure Flush(File : in File_Type);

28.2/4
          The Flush procedure synchronizes the external file with the
          internal file (by flushing any internal buffers) without
          closing the file.  For a direct file, the current index is
          unchanged; for a stream file (see *note A.12.1::), the current
          position is unchanged.

28.3/4
          The exception Status_Error is propagated if the file is not
          open.  The exception Mode_Error is propagated if the mode of
          the file is In_File.

                     _Implementation Permissions_

29
An implementation may propagate Name_Error or Use_Error if an attempt is
made to use an I/O feature that cannot be supported by the
implementation due to limitations in the external environment.  Any such
restriction should be documented.


File: arm2012.info,  Node: A.8.3,  Next: A.8.4,  Prev: A.8.2,  Up: A.8

A.8.3 Sequential Input-Output Operations
----------------------------------------

                          _Static Semantics_

1
The operations available for sequential input and output are described
in this subclause.  The exception Status_Error is propagated if any of
these operations is attempted for a file that is not open.

2
     procedure Read(File : in File_Type; Item : out Element_Type);

3
          Operates on a file of mode In_File.  Reads an element from the
          given file, and returns the value of this element in the Item
          parameter.

4
          The exception Mode_Error is propagated if the mode is not
          In_File.  The exception End_Error is propagated if no more
          elements can be read from the given file.  The exception
          Data_Error can be propagated if the element read cannot be
          interpreted as a value of the subtype Element_Type (see *note
          A.13::, "*note A.13:: Exceptions in Input-Output").

5
     procedure Write(File : in File_Type; Item : in Element_Type);

6
          Operates on a file of mode Out_File or Append_File.  Writes
          the value of Item to the given file.

7
          The exception Mode_Error is propagated if the mode is not
          Out_File or Append_File.  The exception Use_Error is
          propagated if the capacity of the external file is exceeded.

8
     function End_Of_File(File : in File_Type) return Boolean;

9/3
          Operates on a file of mode In_File.  Returns True if no more
          elements can be read from the given file; otherwise, returns
          False.

10
          The exception Mode_Error is propagated if the mode is not
          In_File.


File: arm2012.info,  Node: A.8.4,  Next: A.8.5,  Prev: A.8.3,  Up: A.8

A.8.4 The Generic Package Direct_IO
-----------------------------------

                          _Static Semantics_

1
The generic library package Direct_IO has the following declaration:

2
     with Ada.IO_Exceptions;
     generic
        type Element_Type is private;
     package Ada.Direct_IO is

3
        type File_Type is limited private;

4
        type File_Mode is (In_File, Inout_File, Out_File);
        type Count     is range 0 .. implementation-defined;
        subtype Positive_Count is Count range 1 .. Count'Last;

5
        -- File management

6
        procedure Create(File : in out File_Type;
                         Mode : in File_Mode := Inout_File;
                         Name : in String := "";
                         Form : in String := "");

7
        procedure Open  (File : in out File_Type;
                         Mode : in File_Mode;
                         Name : in String;
                         Form : in String := "");

8
        procedure Close (File : in out File_Type);
        procedure Delete(File : in out File_Type);
        procedure Reset (File : in out File_Type; Mode : in File_Mode);
        procedure Reset (File : in out File_Type);

9
        function Mode   (File : in File_Type) return File_Mode;
        function Name   (File : in File_Type) return String;
        function Form   (File : in File_Type) return String;

10
        function Is_Open(File : in File_Type) return Boolean;

10.1/4
        procedure Flush (File : in File_Type);

11
        -- Input and output operations

12
        procedure Read (File : in File_Type; Item : out Element_Type;
                                             From : in Positive_Count);
        procedure Read (File : in File_Type; Item : out Element_Type);

13
        procedure Write(File : in File_Type; Item : in  Element_Type;
                                             To   : in Positive_Count);
        procedure Write(File : in File_Type; Item : in Element_Type);

14
        procedure Set_Index(File : in File_Type; To : in Positive_Count);

15
        function Index(File : in File_Type) return Positive_Count;
        function Size (File : in File_Type) return Count;

16
        function End_Of_File(File : in File_Type) return Boolean;

17
        -- Exceptions

18
        Status_Error : exception renames IO_Exceptions.Status_Error;
        Mode_Error   : exception renames IO_Exceptions.Mode_Error;
        Name_Error   : exception renames IO_Exceptions.Name_Error;
        Use_Error    : exception renames IO_Exceptions.Use_Error;
        Device_Error : exception renames IO_Exceptions.Device_Error;
        End_Error    : exception renames IO_Exceptions.End_Error;
        Data_Error   : exception renames IO_Exceptions.Data_Error;

19
     private
        ... -- not specified by the language
     end Ada.Direct_IO;

20/2
The type File_Type needs finalization (see *note 7.6::) in every
instantiation of Direct_IO.


File: arm2012.info,  Node: A.8.5,  Prev: A.8.4,  Up: A.8

A.8.5 Direct Input-Output Operations
------------------------------------

                          _Static Semantics_

1
The operations available for direct input and output are described in
this subclause.  The exception Status_Error is propagated if any of
these operations is attempted for a file that is not open.

2
     procedure Read(File : in File_Type; Item : out Element_Type;
                                         From : in  Positive_Count);
     procedure Read(File : in File_Type; Item : out Element_Type);

3
          Operates on a file of mode In_File or Inout_File.  In the case
          of the first form, sets the current index of the given file to
          the index value given by the parameter From.  Then (for both
          forms) returns, in the parameter Item, the value of the
          element whose position in the given file is specified by the
          current index of the file; finally, increases the current
          index by one.

4
          The exception Mode_Error is propagated if the mode of the
          given file is Out_File.  The exception End_Error is propagated
          if the index to be used exceeds the size of the external file.
          The exception Data_Error can be propagated if the element read
          cannot be interpreted as a value of the subtype Element_Type
          (see *note A.13::).

5
     procedure Write(File : in File_Type; Item : in Element_Type;
                                          To   : in Positive_Count);
     procedure Write(File : in File_Type; Item : in Element_Type);

6
          Operates on a file of mode Inout_File or Out_File.  In the
          case of the first form, sets the index of the given file to
          the index value given by the parameter To.  Then (for both
          forms) gives the value of the parameter Item to the element
          whose position in the given file is specified by the current
          index of the file; finally, increases the current index by
          one.

7
          The exception Mode_Error is propagated if the mode of the
          given file is In_File.  The exception Use_Error is propagated
          if the capacity of the external file is exceeded.

8
     procedure Set_Index(File : in File_Type; To : in Positive_Count);

9
          Operates on a file of any mode.  Sets the current index of the
          given file to the given index value (which may exceed the
          current size of the file).

10
     function Index(File : in File_Type) return Positive_Count;

11
          Operates on a file of any mode.  Returns the current index of
          the given file.

12
     function Size(File : in File_Type) return Count;

13
          Operates on a file of any mode.  Returns the current size of
          the external file that is associated with the given file.

14
     function End_Of_File(File : in File_Type) return Boolean;

15/3
          Operates on a file of mode In_File or Inout_File.  Returns
          True if the current index exceeds the size of the external
          file; otherwise, returns False.

16
          The exception Mode_Error is propagated if the mode of the
          given file is Out_File.

     NOTES

17
     25  Append_File mode is not supported for the generic package
     Direct_IO.


File: arm2012.info,  Node: A.9,  Next: A.10,  Prev: A.8,  Up: Annex A

A.9 The Generic Package Storage_IO
==================================

1
The generic package Storage_IO provides for reading from and writing to
an in-memory buffer.  This generic package supports the construction of
user-defined input-output packages.

                          _Static Semantics_

2
The generic library package Storage_IO has the following declaration:

3
     with Ada.IO_Exceptions;
     with System.Storage_Elements;
     generic
        type Element_Type is private;
     package Ada.Storage_IO is
        pragma Preelaborate(Storage_IO);

4
        Buffer_Size : constant System.Storage_Elements.Storage_Count :=
           implementation-defined;
        subtype Buffer_Type is
           System.Storage_Elements.Storage_Array(1..Buffer_Size);

5
        -- Input and output operations

6
        procedure Read (Buffer : in  Buffer_Type; Item : out Element_Type);

7
        procedure Write(Buffer : out Buffer_Type; Item : in  Element_Type);

8
        -- Exceptions

9
        Data_Error   : exception renames IO_Exceptions.Data_Error;
     end Ada.Storage_IO;

10
In each instance, the constant Buffer_Size has a value that is the size
(in storage elements) of the buffer required to represent the content of
an object of subtype Element_Type, including any implicit levels of
indirection used by the implementation.  The Read and Write procedures
of Storage_IO correspond to the Read and Write procedures of Direct_IO
(see *note A.8.4::), but with the content of the Item parameter being
read from or written into the specified Buffer, rather than an external
file.

     NOTES

11
     26  A buffer used for Storage_IO holds only one element at a time;
     an external file used for Direct_IO holds a sequence of elements.


File: arm2012.info,  Node: A.10,  Next: A.11,  Prev: A.9,  Up: Annex A

A.10 Text Input-Output
======================

                          _Static Semantics_

1/3
This subclause describes the package Text_IO, which provides facilities
for input and output in human-readable form.  Each file is read or
written sequentially, as a sequence of characters grouped into lines,
and as a sequence of lines grouped into pages.  The specification of the
package is given below in subclause *note A.10.1::.

2/3
The facilities for file management given above, in subclauses *note
A.8.2:: and *note A.8.3::, are available for text input-output.  In
place of Read and Write, however, there are procedures Get and Put that
input values of suitable types from text files, and output values to
them.  These values are provided to the Put procedures, and returned by
the Get procedures, in a parameter Item.  Several overloaded procedures
of these names exist, for different types of Item.  These Get procedures
analyze the input sequences of characters based on lexical elements (see
Clause *note 2::) and return the corresponding values; the Put
procedures output the given values as appropriate lexical elements.
Procedures Get and Put are also available that input and output
individual characters treated as character values rather than as lexical
elements.  Related to character input are procedures to look ahead at
the next character without reading it, and to read a character
"immediately" without waiting for an end-of-line to signal availability.

3
In addition to the procedures Get and Put for numeric and enumeration
types of Item that operate on text files, analogous procedures are
provided that read from and write to a parameter of type String.  These
procedures perform the same analysis and composition of character
sequences as their counterparts which have a file parameter.

4
For all Get and Put procedures that operate on text files, and for many
other subprograms, there are forms with and without a file parameter.
Each such Get procedure operates on an input file, and each such Put
procedure operates on an output file.  If no file is specified, a
default input file or a default output file is used.

5
At the beginning of program execution the default input and output files
are the so-called standard input file and standard output file.  These
files are open, have respectively the current modes In_File and
Out_File, and are associated with two implementation-defined external
files.  Procedures are provided to change the current default input file
and the current default output file.

6
At the beginning of program execution a default file for
program-dependent error-related text output is the so-called standard
error file.  This file is open, has the current mode Out_File, and is
associated with an implementation-defined external file.  A procedure is
provided to change the current default error file.

7
From a logical point of view, a text file is a sequence of pages, a page
is a sequence of lines, and a line is a sequence of characters; the end
of a line is marked by a line terminator; the end of a page is marked by
the combination of a line terminator immediately followed by a page
terminator; and the end of a file is marked by the combination of a line
terminator immediately followed by a page terminator and then a file
terminator.  Terminators are generated during output; either by calls of
procedures provided expressly for that purpose; or implicitly as part of
other operations, for example, when a bounded line length, a bounded
page length, or both, have been specified for a file.

8
The actual nature of terminators is not defined by the language and
hence depends on the implementation.  Although terminators are
recognized or generated by certain of the procedures that follow, they
are not necessarily implemented as characters or as sequences of
characters.  Whether they are characters (and if so which ones) in any
particular implementation need not concern a user who neither explicitly
outputs nor explicitly inputs control characters.  The effect of input
(Get) or output (Put) of control characters (other than horizontal
tabulation) is not specified by the language. 

9
The characters of a line are numbered, starting from one; the number of
a character is called its column number.  For a line terminator, a
column number is also defined: it is one more than the number of
characters in the line.  The lines of a page, and the pages of a file,
are similarly numbered.  The current column number is the column number
of the next character or line terminator to be transferred.  The current
line number is the number of the current line.  The current page number
is the number of the current page.  These numbers are values of the
subtype Positive_Count of the type Count (by convention, the value zero
of the type Count is used to indicate special conditions).

10
     type Count is range 0 .. implementation-defined;
     subtype Positive_Count is Count range 1 .. Count'Last;

11
For an output file or an append file, a maximum line length can be
specified and a maximum page length can be specified.  If a value to be
output cannot fit on the current line, for a specified maximum line
length, then a new line is automatically started before the value is
output; if, further, this new line cannot fit on the current page, for a
specified maximum page length, then a new page is automatically started
before the value is output.  Functions are provided to determine the
maximum line length and the maximum page length.  When a file is opened
with mode Out_File or Append_File, both values are zero: by convention,
this means that the line lengths and page lengths are unbounded.
(Consequently, output consists of a single line if the subprograms for
explicit control of line and page structure are not used.)  The constant
Unbounded is provided for this purpose.

* Menu:

* A.10.1 ::   The Package Text_IO
* A.10.2 ::   Text File Management
* A.10.3 ::   Default Input, Output, and Error Files
* A.10.4 ::   Specification of Line and Page Lengths
* A.10.5 ::   Operations on Columns, Lines, and Pages
* A.10.6 ::   Get and Put Procedures
* A.10.7 ::   Input-Output of Characters and Strings
* A.10.8 ::   Input-Output for Integer Types
* A.10.9 ::   Input-Output for Real Types
* A.10.10 ::  Input-Output for Enumeration Types
* A.10.11 ::  Input-Output for Bounded Strings
* A.10.12 ::  Input-Output for Unbounded Strings


File: arm2012.info,  Node: A.10.1,  Next: A.10.2,  Up: A.10

A.10.1 The Package Text_IO
--------------------------

                          _Static Semantics_

1
The library package Text_IO has the following declaration:

2
     with Ada.IO_Exceptions;
     package Ada.Text_IO is

3
        type File_Type is limited private;

4
        type File_Mode is (In_File, Out_File, Append_File);

5
        type Count is range 0 .. implementation-defined;
        subtype Positive_Count is Count range 1 .. Count'Last;
        Unbounded : constant Count := 0; -- line and page length

6
        subtype Field       is Integer range 0 .. implementation-defined;
        subtype Number_Base is Integer range 2 .. 16;

7
        type Type_Set is (Lower_Case, Upper_Case);

8
        -- File Management

9
        procedure Create (File : in out File_Type;
                          Mode : in File_Mode := Out_File;
                          Name : in String    := "";
                          Form : in String    := "");

10
        procedure Open   (File : in out File_Type;
                          Mode : in File_Mode;
                          Name : in String;
                          Form : in String := "");

11
        procedure Close  (File : in out File_Type);
        procedure Delete (File : in out File_Type);
        procedure Reset  (File : in out File_Type; Mode : in File_Mode);
        procedure Reset  (File : in out File_Type);

12
        function  Mode   (File : in File_Type) return File_Mode;
        function  Name   (File : in File_Type) return String;
        function  Form   (File : in File_Type) return String;

13
        function  Is_Open(File : in File_Type) return Boolean;

14
        -- Control of default input and output files

15
        procedure Set_Input (File : in File_Type);
        procedure Set_Output(File : in File_Type);
        procedure Set_Error (File : in File_Type);

16
        function Standard_Input  return File_Type;
        function Standard_Output return File_Type;
        function Standard_Error  return File_Type;

17
        function Current_Input   return File_Type;
        function Current_Output  return File_Type;
        function Current_Error   return File_Type;

18
        type File_Access is access constant File_Type;

19
        function Standard_Input  return File_Access;
        function Standard_Output return File_Access;
        function Standard_Error  return File_Access;

20
        function Current_Input   return File_Access;
        function Current_Output  return File_Access;
        function Current_Error   return File_Access;

21/1
     --Buffer control
        procedure Flush (File : in File_Type);
        procedure Flush;

22
        -- Specification of line and page lengths

23
        procedure Set_Line_Length(File : in File_Type; To : in Count);
        procedure Set_Line_Length(To   : in Count);

24
        procedure Set_Page_Length(File : in File_Type; To : in Count);
        procedure Set_Page_Length(To   : in Count);

25
        function  Line_Length(File : in File_Type) return Count;
        function  Line_Length return Count;

26
        function  Page_Length(File : in File_Type) return Count;
        function  Page_Length return Count;

27
        -- Column, Line, and Page Control

28
        procedure New_Line   (File    : in File_Type;
                              Spacing : in Positive_Count := 1);
        procedure New_Line   (Spacing : in Positive_Count := 1);

29
        procedure Skip_Line  (File    : in File_Type;
                              Spacing : in Positive_Count := 1);
        procedure Skip_Line  (Spacing : in Positive_Count := 1);

30
        function  End_Of_Line(File : in File_Type) return Boolean;
        function  End_Of_Line return Boolean;

31
        procedure New_Page   (File : in File_Type);
        procedure New_Page;

32
        procedure Skip_Page  (File : in File_Type);
        procedure Skip_Page;

33
        function  End_Of_Page(File : in File_Type) return Boolean;
        function  End_Of_Page return Boolean;

34
        function  End_Of_File(File : in File_Type) return Boolean;
        function  End_Of_File return Boolean;

35
        procedure Set_Col (File : in File_Type; To : in Positive_Count);
        procedure Set_Col (To   : in Positive_Count);

36
        procedure Set_Line(File : in File_Type; To : in Positive_Count);
        procedure Set_Line(To   : in Positive_Count);

37
        function Col (File : in File_Type) return Positive_Count;
        function Col  return Positive_Count;

38
        function Line(File : in File_Type) return Positive_Count;
        function Line return Positive_Count;

39
        function Page(File : in File_Type) return Positive_Count;
        function Page return Positive_Count;

40
        -- Character Input-Output

41
        procedure Get(File : in  File_Type; Item : out Character);
        procedure Get(Item : out Character);

42
        procedure Put(File : in  File_Type; Item : in Character);
        procedure Put(Item : in  Character);

43
        procedure Look_Ahead (File        : in  File_Type;
                              Item        : out Character;
                              End_Of_Line : out Boolean);
        procedure Look_Ahead (Item        : out Character;
                              End_Of_Line : out Boolean);

44
        procedure Get_Immediate(File      : in  File_Type;
                                Item      : out Character);
        procedure Get_Immediate(Item      : out Character);

45
        procedure Get_Immediate(File      : in  File_Type;
                                Item      : out Character;
                                Available : out Boolean);
        procedure Get_Immediate(Item      : out Character;
                                Available : out Boolean);

46
        -- String Input-Output

47
        procedure Get(File : in  File_Type; Item : out String);
        procedure Get(Item : out String);

48
        procedure Put(File : in  File_Type; Item : in String);
        procedure Put(Item : in  String);

49
        procedure Get_Line(File : in  File_Type;
                           Item : out String;
                           Last : out Natural);
        procedure Get_Line(Item : out String; Last : out Natural);

49.1/2
        function Get_Line(File : in  File_Type) return String;
        function Get_Line return String;

50
        procedure Put_Line(File : in  File_Type; Item : in String);
        procedure Put_Line(Item : in  String);

51
     -- Generic packages for Input-Output of Integer Types

52
        generic
           type Num is range <>;
        package Integer_IO is

53
           Default_Width : Field := Num'Width;
           Default_Base  : Number_Base := 10;

54
           procedure Get(File  : in  File_Type;
                         Item  : out Num;
                         Width : in Field := 0);
           procedure Get(Item  : out Num;
                         Width : in  Field := 0);

55
           procedure Put(File  : in File_Type;
                         Item  : in Num;
                         Width : in Field := Default_Width;
                         Base  : in Number_Base := Default_Base);
           procedure Put(Item  : in Num;
                         Width : in Field := Default_Width;
                         Base  : in Number_Base := Default_Base);
           procedure Get(From : in  String;
                         Item : out Num;
                         Last : out Positive);
           procedure Put(To   : out String;
                         Item : in Num;
                         Base : in Number_Base := Default_Base);

56
        end Integer_IO;

57
        generic
           type Num is mod <>;
        package Modular_IO is

58
           Default_Width : Field := Num'Width;
           Default_Base  : Number_Base := 10;

59
           procedure Get(File  : in  File_Type;
                         Item  : out Num;
                         Width : in Field := 0);
           procedure Get(Item  : out Num;
                         Width : in  Field := 0);

60
           procedure Put(File  : in File_Type;
                         Item  : in Num;
                         Width : in Field := Default_Width;
                         Base  : in Number_Base := Default_Base);
           procedure Put(Item  : in Num;
                         Width : in Field := Default_Width;
                         Base  : in Number_Base := Default_Base);
           procedure Get(From : in  String;
                         Item : out Num;
                         Last : out Positive);
           procedure Put(To   : out String;
                         Item : in Num;
                         Base : in Number_Base := Default_Base);

61
        end Modular_IO;

62
        -- Generic packages for Input-Output of Real Types

63
        generic
           type Num is digits <>;
        package Float_IO is

64
           Default_Fore : Field := 2;
           Default_Aft  : Field := Num'Digits-1;
           Default_Exp  : Field := 3;

65
           procedure Get(File  : in  File_Type;
                         Item  : out Num;
                         Width : in  Field := 0);
           procedure Get(Item  : out Num;
                         Width : in  Field := 0);

66
           procedure Put(File : in File_Type;
                         Item : in Num;
                         Fore : in Field := Default_Fore;
                         Aft  : in Field := Default_Aft;
                         Exp  : in Field := Default_Exp);
           procedure Put(Item : in Num;
                         Fore : in Field := Default_Fore;
                         Aft  : in Field := Default_Aft;
                         Exp  : in Field := Default_Exp);

67
           procedure Get(From : in String;
                         Item : out Num;
                         Last : out Positive);
           procedure Put(To   : out String;
                         Item : in Num;
                         Aft  : in Field := Default_Aft;
                         Exp  : in Field := Default_Exp);
        end Float_IO;

68
        generic
           type Num is delta <>;
        package Fixed_IO is

69
           Default_Fore : Field := Num'Fore;
           Default_Aft  : Field := Num'Aft;
           Default_Exp  : Field := 0;

70
           procedure Get(File  : in  File_Type;
                         Item  : out Num;
                         Width : in  Field := 0);
           procedure Get(Item  : out Num;
                         Width : in  Field := 0);

71
           procedure Put(File : in File_Type;
                         Item : in Num;
                         Fore : in Field := Default_Fore;
                         Aft  : in Field := Default_Aft;
                         Exp  : in Field := Default_Exp);
           procedure Put(Item : in Num;
                         Fore : in Field := Default_Fore;
                         Aft  : in Field := Default_Aft;
                         Exp  : in Field := Default_Exp);

72
           procedure Get(From : in  String;
                         Item : out Num;
                         Last : out Positive);
           procedure Put(To   : out String;
                         Item : in Num;
                         Aft  : in Field := Default_Aft;
                         Exp  : in Field := Default_Exp);
        end Fixed_IO;

73
        generic
           type Num is delta <> digits <>;
        package Decimal_IO is

74
           Default_Fore : Field := Num'Fore;
           Default_Aft  : Field := Num'Aft;
           Default_Exp  : Field := 0;

75
           procedure Get(File  : in  File_Type;
                         Item  : out Num;
                         Width : in  Field := 0);
           procedure Get(Item  : out Num;
                         Width : in  Field := 0);

76
           procedure Put(File : in File_Type;
                         Item : in Num;
                         Fore : in Field := Default_Fore;
                         Aft  : in Field := Default_Aft;
                         Exp  : in Field := Default_Exp);
           procedure Put(Item : in Num;
                         Fore : in Field := Default_Fore;
                         Aft  : in Field := Default_Aft;
                         Exp  : in Field := Default_Exp);

77
           procedure Get(From : in  String;
                         Item : out Num;
                         Last : out Positive);
           procedure Put(To   : out String;
                         Item : in Num;
                         Aft  : in Field := Default_Aft;
                         Exp  : in Field := Default_Exp);
        end Decimal_IO;

78
        -- Generic package for Input-Output of Enumeration Types

79
        generic
           type Enum is (<>);
        package Enumeration_IO is

80
           Default_Width   : Field := 0;
           Default_Setting : Type_Set := Upper_Case;

81
           procedure Get(File : in  File_Type;
                         Item : out Enum);
           procedure Get(Item : out Enum);

82
           procedure Put(File  : in File_Type;
                         Item  : in Enum;
                         Width : in Field    := Default_Width;
                         Set   : in Type_Set := Default_Setting);
           procedure Put(Item  : in Enum;
                         Width : in Field    := Default_Width;
                         Set   : in Type_Set := Default_Setting);

83
           procedure Get(From : in  String;
                         Item : out Enum;
                         Last : out Positive);
           procedure Put(To   : out String;
                         Item : in  Enum;
                         Set  : in  Type_Set := Default_Setting);
        end Enumeration_IO;

84
     -- Exceptions

85
        Status_Error : exception renames IO_Exceptions.Status_Error;
        Mode_Error   : exception renames IO_Exceptions.Mode_Error;
        Name_Error   : exception renames IO_Exceptions.Name_Error;
        Use_Error    : exception renames IO_Exceptions.Use_Error;
        Device_Error : exception renames IO_Exceptions.Device_Error;
        End_Error    : exception renames IO_Exceptions.End_Error;
        Data_Error   : exception renames IO_Exceptions.Data_Error;
        Layout_Error : exception renames IO_Exceptions.Layout_Error;
     private
        ... -- not specified by the language
     end Ada.Text_IO;

86/2
The type File_Type needs finalization (see *note 7.6::).


File: arm2012.info,  Node: A.10.2,  Next: A.10.3,  Prev: A.10.1,  Up: A.10

A.10.2 Text File Management
---------------------------

                          _Static Semantics_

1
The only allowed file modes for text files are the modes In_File,
Out_File, and Append_File.  The subprograms given in subclause *note
A.8.2:: for the control of external files, and the function End_Of_File
given in subclause *note A.8.3:: for sequential input-output, are also
available for text files.  There is also a version of End_Of_File that
refers to the current default input file.  For text files, the
procedures have the following additional effects:

2
   * For the procedures Create and Open: After a file with mode Out_File
     or Append_File is opened, the page length and line length are
     unbounded (both have the conventional value zero).  After a file
     (of any mode) is opened, the current column, current line, and
     current page numbers are set to one.  If the mode is Append_File,
     it is implementation defined whether a page terminator will
     separate preexisting text in the file from the new text to be
     written.

3
   * For the procedure Close: If the file has the current mode Out_File
     or Append_File, has the effect of calling New_Page, unless the
     current page is already terminated; then outputs a file terminator.

4
   * For the procedure Reset: If the file has the current mode Out_File
     or Append_File, has the effect of calling New_Page, unless the
     current page is already terminated; then outputs a file terminator.
     The current column, line, and page numbers are set to one, and the
     line and page lengths to Unbounded.  If the new mode is
     Append_File, it is implementation defined whether a page terminator
     will separate preexisting text in the file from the new text to be
     written.

5
The exception Mode_Error is propagated by the procedure Reset upon an
attempt to change the mode of a file that is the current default input
file, the current default output file, or the current default error
file.

     NOTES

6
     27  An implementation can define the Form parameter of Create and
     Open to control effects including the following:

7
        * the interpretation of line and column numbers for an
          interactive file, and

8
        * the interpretation of text formats in a file created by a
          foreign program.


File: arm2012.info,  Node: A.10.3,  Next: A.10.4,  Prev: A.10.2,  Up: A.10

A.10.3 Default Input, Output, and Error Files
---------------------------------------------

                          _Static Semantics_

1
The following subprograms provide for the control of the particular
default files that are used when a file parameter is omitted from a Get,
Put, or other operation of text input-output described below, or when
application-dependent error-related text is to be output.

2
     procedure Set_Input(File : in File_Type);

3
          Operates on a file of mode In_File.  Sets the current default
          input file to File.

4
          The exception Status_Error is propagated if the given file is
          not open.  The exception Mode_Error is propagated if the mode
          of the given file is not In_File.

5
     procedure Set_Output(File : in File_Type);
     procedure Set_Error (File : in File_Type);

6
          Each operates on a file of mode Out_File or Append_File.
          Set_Output sets the current default output file to File.
          Set_Error sets the current default error file to File.  The
          exception Status_Error is propagated if the given file is not
          open.  The exception Mode_Error is propagated if the mode of
          the given file is not Out_File or Append_File.

7
     function Standard_Input return File_Type;
     function Standard_Input return File_Access;

8
          Returns the standard input file (see *note A.10::), or an
          access value designating the standard input file,
          respectively.

9
     function Standard_Output return File_Type;
     function Standard_Output return File_Access;

10
          Returns the standard output file (see *note A.10::) or an
          access value designating the standard output file,
          respectively.

11
     function Standard_Error return File_Type;
     function Standard_Error return File_Access;

12/1
          Returns the standard error file (see *note A.10::), or an
          access value designating the standard error file,
          respectively.

13
The Form strings implicitly associated with the opening of
Standard_Input, Standard_Output, and Standard_Error at the start of
program execution are implementation defined.

14
     function Current_Input return File_Type;
     function Current_Input return File_Access;

15
          Returns the current default input file, or an access value
          designating the current default input file, respectively.

16
     function Current_Output return File_Type;
     function Current_Output return File_Access;

17
          Returns the current default output file, or an access value
          designating the current default output file, respectively.

18
     function Current_Error return File_Type;
     function Current_Error return File_Access;

19
          Returns the current default error file, or an access value
          designating the current default error file, respectively.

20/1
     procedure Flush (File : in File_Type);
     procedure Flush;

21/4
          The effect of Flush is the same as the corresponding
          subprogram in Sequential_IO (see *note A.8.2::).  If File is
          not explicitly specified, Current_Output is used.

                         _Erroneous Execution_

22/1
The execution of a program is erroneous if it invokes an operation on a
current default input, default output, or default error file, and if the
corresponding file object is closed or no longer exists.

23/1
This paragraph was deleted.

     NOTES

24
     28  The standard input, standard output, and standard error files
     cannot be opened, closed, reset, or deleted, because the parameter
     File of the corresponding procedures has the mode in out.

25
     29  The standard input, standard output, and standard error files
     are different file objects, but not necessarily different external
     files.


File: arm2012.info,  Node: A.10.4,  Next: A.10.5,  Prev: A.10.3,  Up: A.10

A.10.4 Specification of Line and Page Lengths
---------------------------------------------

                          _Static Semantics_

1
The subprograms described in this subclause are concerned with the line
and page structure of a file of mode Out_File or Append_File.  They
operate either on the file given as the first parameter, or, in the
absence of such a file parameter, on the current default output file.
They provide for output of text with a specified maximum line length or
page length.  In these cases, line and page terminators are output
implicitly and automatically when needed.  When line and page lengths
are unbounded (that is, when they have the conventional value zero), as
in the case of a newly opened file, new lines and new pages are only
started when explicitly called for.

2
In all cases, the exception Status_Error is propagated if the file to be
used is not open; the exception Mode_Error is propagated if the mode of
the file is not Out_File or Append_File.

3
     procedure Set_Line_Length(File : in File_Type; To : in Count);
     procedure Set_Line_Length(To   : in Count);

4
          Sets the maximum line length of the specified output or append
          file to the number of characters specified by To.  The value
          zero for To specifies an unbounded line length.

5
          The exception Use_Error is propagated if the specified line
          length is inappropriate for the associated external file.

6
     procedure Set_Page_Length(File : in File_Type; To : in Count);
     procedure Set_Page_Length(To   : in Count);

7
          Sets the maximum page length of the specified output or append
          file to the number of lines specified by To.  The value zero
          for To specifies an unbounded page length.

8
          The exception Use_Error is propagated if the specified page
          length is inappropriate for the associated external file.

9
     function Line_Length(File : in File_Type) return Count;
     function Line_Length return Count;

10
          Returns the maximum line length currently set for the
          specified output or append file, or zero if the line length is
          unbounded.

11
     function Page_Length(File : in File_Type) return Count;
     function Page_Length return Count;

12
          Returns the maximum page length currently set for the
          specified output or append file, or zero if the page length is
          unbounded.


File: arm2012.info,  Node: A.10.5,  Next: A.10.6,  Prev: A.10.4,  Up: A.10

A.10.5 Operations on Columns, Lines, and Pages
----------------------------------------------

                          _Static Semantics_

1
The subprograms described in this subclause provide for explicit control
of line and page structure; they operate either on the file given as the
first parameter, or, in the absence of such a file parameter, on the
appropriate (input or output) current default file.  The exception
Status_Error is propagated by any of these subprograms if the file to be
used is not open.

2
     procedure New_Line(File : in File_Type; Spacing : in Positive_Count := 1);
     procedure New_Line(Spacing : in Positive_Count := 1);

3
          Operates on a file of mode Out_File or Append_File.

4
          For a Spacing of one: Outputs a line terminator and sets the
          current column number to one.  Then increments the current
          line number by one, except in the case that the current line
          number is already greater than or equal to the maximum page
          length, for a bounded page length; in that case a page
          terminator is output, the current page number is incremented
          by one, and the current line number is set to one.

5
          For a Spacing greater than one, the above actions are
          performed Spacing times.

6
          The exception Mode_Error is propagated if the mode is not
          Out_File or Append_File.

7
     procedure Skip_Line(File  : in File_Type; Spacing : in Positive_Count := 1);
     procedure Skip_Line(Spacing : in Positive_Count := 1);

8
          Operates on a file of mode In_File.

9
          For a Spacing of one: Reads and discards all characters until
          a line terminator has been read, and then sets the current
          column number to one.  If the line terminator is not
          immediately followed by a page terminator, the current line
          number is incremented by one.  Otherwise, if the line
          terminator is immediately followed by a page terminator, then
          the page terminator is skipped, the current page number is
          incremented by one, and the current line number is set to one.

10
          For a Spacing greater than one, the above actions are
          performed Spacing times.

11
          The exception Mode_Error is propagated if the mode is not
          In_File.  The exception End_Error is propagated if an attempt
          is made to read a file terminator.

12
     function End_Of_Line(File : in File_Type) return Boolean;
     function End_Of_Line return Boolean;

13/3
          Operates on a file of mode In_File.  Returns True if a line
          terminator or a file terminator is next; otherwise, returns
          False.

14
          The exception Mode_Error is propagated if the mode is not
          In_File.

15
     procedure New_Page(File : in File_Type);
     procedure New_Page;

16
          Operates on a file of mode Out_File or Append_File.  Outputs a
          line terminator if the current line is not terminated, or if
          the current page is empty (that is, if the current column and
          line numbers are both equal to one).  Then outputs a page
          terminator, which terminates the current page.  Adds one to
          the current page number and sets the current column and line
          numbers to one.

17
          The exception Mode_Error is propagated if the mode is not
          Out_File or Append_File.

18
     procedure Skip_Page(File : in File_Type);
     procedure Skip_Page;

19
          Operates on a file of mode In_File.  Reads and discards all
          characters and line terminators until a page terminator has
          been read.  Then adds one to the current page number, and sets
          the current column and line numbers to one.

20
          The exception Mode_Error is propagated if the mode is not
          In_File.  The exception End_Error is propagated if an attempt
          is made to read a file terminator.

21
     function End_Of_Page(File : in File_Type) return Boolean;
     function End_Of_Page return Boolean;

22/3
          Operates on a file of mode In_File.  Returns True if the
          combination of a line terminator and a page terminator is
          next, or if a file terminator is next; otherwise, returns
          False.

23
          The exception Mode_Error is propagated if the mode is not
          In_File.

24
     function End_Of_File(File : in File_Type) return Boolean;
     function End_Of_File return Boolean;

25/3
          Operates on a file of mode In_File.  Returns True if a file
          terminator is next, or if the combination of a line, a page,
          and a file terminator is next; otherwise, returns False.

26
          The exception Mode_Error is propagated if the mode is not
          In_File.

27
The following subprograms provide for the control of the current
position of reading or writing in a file.  In all cases, the default
file is the current output file.

28
     procedure Set_Col(File : in File_Type; To : in Positive_Count);
     procedure Set_Col(To   : in Positive_Count);

29
          If the file mode is Out_File or Append_File:

30
             * If the value specified by To is greater than the current
               column number, outputs spaces, adding one to the current
               column number after each space, until the current column
               number equals the specified value.  If the value
               specified by To is equal to the current column number,
               there is no effect.  If the value specified by To is less
               than the current column number, has the effect of calling
               New_Line (with a spacing of one), then outputs (To - 1)
               spaces, and sets the current column number to the
               specified value.

31
             * The exception Layout_Error is propagated if the value
               specified by To exceeds Line_Length when the line length
               is bounded (that is, when it does not have the
               conventional value zero).

32
          If the file mode is In_File:

33
             * Reads (and discards) individual characters, line
               terminators, and page terminators, until the next
               character to be read has a column number that equals the
               value specified by To; there is no effect if the current
               column number already equals this value.  Each transfer
               of a character or terminator maintains the current
               column, line, and page numbers in the same way as a Get
               procedure (see *note A.10.6::).  (Short lines will be
               skipped until a line is reached that has a character at
               the specified column position.)

34
             * The exception End_Error is propagated if an attempt is
               made to read a file terminator.

35
     procedure Set_Line(File : in File_Type; To : in Positive_Count);
     procedure Set_Line(To   : in Positive_Count);

36
          If the file mode is Out_File or Append_File:

37/3
             * If the value specified by To is greater than the current
               line number, has the effect of repeatedly calling
               New_Line (with a spacing of one), until the current line
               number equals the specified value.  If the value
               specified by To is equal to the current line number,
               there is no effect.  If the value specified by To is less
               than the current line number, has the effect of calling
               New_Page followed, if To is greater than 1, by a call of
               New_Line with a spacing equal to (To - 1).

38
             * The exception Layout_Error is propagated if the value
               specified by To exceeds Page_Length when the page length
               is bounded (that is, when it does not have the
               conventional value zero).

39
          If the mode is In_File:

40
             * Has the effect of repeatedly calling Skip_Line (with a
               spacing of one), until the current line number equals the
               value specified by To; there is no effect if the current
               line number already equals this value.  (Short pages will
               be skipped until a page is reached that has a line at the
               specified line position.)

41
             * The exception End_Error is propagated if an attempt is
               made to read a file terminator.

42
     function Col(File : in File_Type) return Positive_Count;
     function Col return Positive_Count;

43
          Returns the current column number.

44
          The exception Layout_Error is propagated if this number
          exceeds Count'Last.

45
     function Line(File : in File_Type) return Positive_Count;
     function Line return Positive_Count;

46
          Returns the current line number.

47
          The exception Layout_Error is propagated if this number
          exceeds Count'Last.

48
     function Page(File : in File_Type) return Positive_Count;
     function Page return Positive_Count;

49
          Returns the current page number.

50
          The exception Layout_Error is propagated if this number
          exceeds Count'Last.

51
The column number, line number, or page number are allowed to exceed
Count'Last (as a consequence of the input or output of sufficiently many
characters, lines, or pages).  These events do not cause any exception
to be propagated.  However, a call of Col, Line, or Page propagates the
exception Layout_Error if the corresponding number exceeds Count'Last.

     NOTES

52
     30  A page terminator is always skipped whenever the preceding line
     terminator is skipped.  An implementation may represent the
     combination of these terminators by a single character, provided
     that it is properly recognized on input.


File: arm2012.info,  Node: A.10.6,  Next: A.10.7,  Prev: A.10.5,  Up: A.10

A.10.6 Get and Put Procedures
-----------------------------

                          _Static Semantics_

1
The procedures Get and Put for items of the type Character, String,
numeric types, and enumeration types are described in subsequent
subclauses.  Features of these procedures that are common to most of
these types are described in this subclause.  The Get and Put procedures
for items of type Character and String deal with individual character
values; the Get and Put procedures for numeric and enumeration types
treat the items as lexical elements.

2
All procedures Get and Put have forms with a file parameter, written
first.  Where this parameter is omitted, the appropriate (input or
output) current default file is understood to be specified.  Each
procedure Get operates on a file of mode In_File.  Each procedure Put
operates on a file of mode Out_File or Append_File.

3
All procedures Get and Put maintain the current column, line, and page
numbers of the specified file: the effect of each of these procedures
upon these numbers is the result of the effects of individual transfers
of characters and of individual output or skipping of terminators.  Each
transfer of a character adds one to the current column number.  Each
output of a line terminator sets the current column number to one and
adds one to the current line number.  Each output of a page terminator
sets the current column and line numbers to one and adds one to the
current page number.  For input, each skipping of a line terminator sets
the current column number to one and adds one to the current line
number; each skipping of a page terminator sets the current column and
line numbers to one and adds one to the current page number.  Similar
considerations apply to the procedures Get_Line, Put_Line, and Set_Col.

4
Several Get and Put procedures, for numeric and enumeration types, have
format parameters which specify field lengths; these parameters are of
the nonnegative subtype Field of the type Integer.

5/2
Input-output of enumeration values uses the syntax of the corresponding
lexical elements.  Any Get procedure for an enumeration type begins by
skipping any leading blanks, or line or page terminators.  A blank is
defined as a space or a horizontal tabulation character.  Next,
characters are input only so long as the sequence input is an initial
sequence of an identifier or of a character literal (in particular,
input ceases when a line terminator is encountered).  The character or
line terminator that causes input to cease remains available for
subsequent input.

6
For a numeric type, the Get procedures have a format parameter called
Width.  If the value given for this parameter is zero, the Get procedure
proceeds in the same manner as for enumeration types, but using the
syntax of numeric literals instead of that of enumeration literals.  If
a nonzero value is given, then exactly Width characters are input, or
the characters up to a line terminator, whichever comes first; any
skipped leading blanks are included in the count.  The syntax used for
numeric literals is an extended syntax that allows a leading sign (but
no intervening blanks, or line or page terminators) and that also allows
(for real types) an integer literal as well as forms that have digits
only before the point or only after the point.

7
Any Put procedure, for an item of a numeric or an enumeration type,
outputs the value of the item as a numeric literal, identifier, or
character literal, as appropriate.  This is preceded by leading spaces
if required by the format parameters Width or Fore (as described in
later subclauses), and then a minus sign for a negative value; for an
enumeration type, the spaces follow instead of leading.  The format
given for a Put procedure is overridden if it is insufficiently wide, by
using the minimum needed width.

8
Two further cases arise for Put procedures for numeric and enumeration
types, if the line length of the specified output file is bounded (that
is, if it does not have the conventional value zero).  If the number of
characters to be output does not exceed the maximum line length, but is
such that they cannot fit on the current line, starting from the current
column, then (in effect) New_Line is called (with a spacing of one)
before output of the item.  Otherwise, if the number of characters
exceeds the maximum line length, then the exception Layout_Error is
propagated and nothing is output.

9
The exception Status_Error is propagated by any of the procedures Get,
Get_Line, Put, and Put_Line if the file to be used is not open.  The
exception Mode_Error is propagated by the procedures Get and Get_Line if
the mode of the file to be used is not In_File; and by the procedures
Put and Put_Line, if the mode is not Out_File or Append_File.

10
The exception End_Error is propagated by a Get procedure if an attempt
is made to skip a file terminator.  The exception Data_Error is
propagated by a Get procedure if the sequence finally input is not a
lexical element corresponding to the type, in particular if no
characters were input; for this test, leading blanks are ignored; for an
item of a numeric type, when a sign is input, this rule applies to the
succeeding numeric literal.  The exception Layout_Error is propagated by
a Put procedure that outputs to a parameter of type String, if the
length of the actual string is insufficient for the output of the item.

                              _Examples_

11
In the examples, here and in subclauses *note A.10.8:: and *note
A.10.9::, the string quotes and the lower case letter b are not
transferred: they are shown only to reveal the layout and spaces.

12
     N : Integer;
        ...
     Get(N);

13
     --     Characters at input    Sequence input    Value of N

     --     bb-12535b    -12535    -12535
     --     bb12_535e1b    12_535e1    125350
     --     bb12_535e;    12_535e    (none) Data_Error raised

14
Example of overridden width parameter:

15
     Put(Item => -23, Width => 2);  --  "-23"


File: arm2012.info,  Node: A.10.7,  Next: A.10.8,  Prev: A.10.6,  Up: A.10

A.10.7 Input-Output of Characters and Strings
---------------------------------------------

                          _Static Semantics_

1
For an item of type Character the following procedures are provided:

2
     procedure Get(File : in File_Type; Item : out Character);
     procedure Get(Item : out Character);

3
          After skipping any line terminators and any page terminators,
          reads the next character from the specified input file and
          returns the value of this character in the out parameter Item.

4
          The exception End_Error is propagated if an attempt is made to
          skip a file terminator.

5
     procedure Put(File : in File_Type; Item : in Character);
     procedure Put(Item : in Character);

6
          If the line length of the specified output file is bounded
          (that is, does not have the conventional value zero), and the
          current column number exceeds it, has the effect of calling
          New_Line with a spacing of one.  Then, or otherwise, outputs
          the given character to the file.

7
     procedure Look_Ahead (File        : in  File_Type;
                           Item        : out Character;
                           End_Of_Line : out Boolean);
     procedure Look_Ahead (Item        : out Character;
                           End_Of_Line : out Boolean);

8/3
          Status_Error is propagated if the file is not open.
          Mode_Error is propagated if the mode of the file is not
          In_File.  Sets End_Of_Line to True if at end of line,
          including if at end of page or at end of file; in each of
          these cases the value of Item is not specified. Otherwise,
          End_Of_Line is set to False and Item is set to the next
          character (without consuming it) from the file.

9
     procedure Get_Immediate(File : in  File_Type;
                             Item : out Character);
     procedure Get_Immediate(Item : out Character);

10/3
          Reads the next character, either control or graphic, from the
          specified File or the default input file.  Status_Error is
          propagated if the file is not open.  Mode_Error is propagated
          if the mode of the file is not In_File.  End_Error is
          propagated if at the end of the file.  The current column,
          line and page numbers for the file are not affected.

11
     procedure Get_Immediate(File      : in  File_Type;
                             Item      : out Character;
                             Available : out Boolean);
     procedure Get_Immediate(Item      : out Character;
                             Available : out Boolean);

12/3
          If a character, either control or graphic, is available from
          the specified File or the default input file, then the
          character is read; Available is True and Item contains the
          value of this character.  If a character is not available,
          then Available is False and the value of Item is not
          specified. Status_Error is propagated if the file is not open.
          Mode_Error is propagated if the mode of the file is not
          In_File.  End_Error is propagated if at the end of the file.
          The current column, line and page numbers for the file are not
          affected.

13/2
For an item of type String the following subprograms are provided:

14
     procedure Get(File : in File_Type; Item : out String);
     procedure Get(Item : out String);

15
          Determines the length of the given string and attempts that
          number of Get operations for successive characters of the
          string (in particular, no operation is performed if the string
          is null).

16
     procedure Put(File : in File_Type; Item : in String);
     procedure Put(Item : in String);

17
          Determines the length of the given string and attempts that
          number of Put operations for successive characters of the
          string (in particular, no operation is performed if the string
          is null).

17.1/2
     function Get_Line(File : in File_Type) return String;
     function Get_Line return String;

17.2/2
          Returns a result string constructed by reading successive
          characters from the specified input file, and assigning them
          to successive characters of the result string.  The result
          string has a lower bound of 1 and an upper bound of the number
          of characters read.  Reading stops when the end of the line is
          met; Skip_Line is then (in effect) called with a spacing of 1.

17.3/2
          Constraint_Error is raised if the length of the line exceeds
          Positive'Last; in this case, the line number and page number
          are unchanged, and the column number is unspecified but no
          less than it was before the call.  The exception End_Error is
          propagated if an attempt is made to skip a file terminator.

18
     procedure Get_Line(File : in File_Type;
                        Item : out String;
                        Last : out Natural);
     procedure Get_Line(Item : out String;
                        Last : out Natural);

19
          Reads successive characters from the specified input file and
          assigns them to successive characters of the specified string.
          Reading stops if the end of the string is met.  Reading also
          stops if the end of the line is met before meeting the end of
          the string; in this case Skip_Line is (in effect) called with
          a spacing of 1. The values of characters not assigned are not
          specified.

20
          If characters are read, returns in Last the index value such
          that Item(Last) is the last character assigned (the index of
          the first character assigned is Item'First).  If no characters
          are read, returns in Last an index value that is one less than
          Item'First.  The exception End_Error is propagated if an
          attempt is made to skip a file terminator.

21
     procedure Put_Line(File : in File_Type; Item : in String);
     procedure Put_Line(Item : in String);

22
          Calls the procedure Put for the given string, and then the
          procedure New_Line with a spacing of one.

                        _Implementation Advice_

23
The Get_Immediate procedures should be implemented with unbuffered
input.  For a device such as a keyboard, input should be "available" if
a key has already been typed, whereas for a disk file, input should
always be available except at end of file.  For a file associated with a
keyboard-like device, any line-editing features of the underlying
operating system should be disabled during the execution of
Get_Immediate.

     NOTES

24
     31  Get_Immediate can be used to read a single key from the
     keyboard "immediately"; that is, without waiting for an end of
     line.  In a call of Get_Immediate without the parameter Available,
     the caller will wait until a character is available.

25
     32  In a literal string parameter of Put, the enclosing string
     bracket characters are not output.  Each doubled string bracket
     character in the enclosed string is output as a single string
     bracket character, as a consequence of the rule for string literals
     (see *note 2.6::).

26
     33  A string read by Get or written by Put can extend over several
     lines.  An implementation is allowed to assume that certain
     external files do not contain page terminators, in which case
     Get_Line and Skip_Line can return as soon as a line terminator is
     read.


File: arm2012.info,  Node: A.10.8,  Next: A.10.9,  Prev: A.10.7,  Up: A.10

A.10.8 Input-Output for Integer Types
-------------------------------------

                          _Static Semantics_

1
The following procedures are defined in the generic packages Integer_IO
and Modular_IO, which have to be instantiated for the appropriate signed
integer or modular type respectively (indicated by Num in the
specifications).

2
Values are output as decimal or based literals, without low line
characters or exponent, and, for Integer_IO, preceded by a minus sign if
negative.  The format (which includes any leading spaces and minus sign)
can be specified by an optional field width parameter.  Values of widths
of fields in output formats are of the nonnegative integer subtype
Field.  Values of bases are of the integer subtype Number_Base.

3
     subtype Number_Base is Integer range 2 .. 16;

4
The default field width and base to be used by output procedures are
defined by the following variables that are declared in the generic
packages Integer_IO and Modular_IO:

5
     Default_Width : Field := Num'Width;
     Default_Base  : Number_Base := 10;

6
The following procedures are provided:

7
     procedure Get(File : in File_Type; Item : out Num; Width : in Field := 0);
     procedure Get(Item : out Num; Width : in Field := 0);

8
          If the value of the parameter Width is zero, skips any leading
          blanks, line terminators, or page terminators, then reads a
          plus sign if present or (for a signed type only) a minus sign
          if present, then reads the longest possible sequence of
          characters matching the syntax of a numeric literal without a
          point.  If a nonzero value of Width is supplied, then exactly
          Width characters are input, or the characters (possibly none)
          up to a line terminator, whichever comes first; any skipped
          leading blanks are included in the count.

9
          Returns, in the parameter Item, the value of type Num that
          corresponds to the sequence input.

10/3
          The exception Data_Error is propagated if the sequence of
          characters read does not form a legal integer literal or if
          the value obtained is not of the subtype Num.

11
     procedure Put(File  : in File_Type;
                   Item  : in Num;
                   Width : in Field := Default_Width;
                   Base  : in Number_Base := Default_Base);

     procedure Put(Item  : in Num;
                   Width : in Field := Default_Width;
                   Base  : in Number_Base := Default_Base);

12
          Outputs the value of the parameter Item as an integer literal,
          with no low lines, no exponent, and no leading zeros (but a
          single zero for the value zero), and a preceding minus sign
          for a negative value.

13
          If the resulting sequence of characters to be output has fewer
          than Width characters, then leading spaces are first output to
          make up the difference.

14
          Uses the syntax for decimal literal if the parameter Base has
          the value ten (either explicitly or through Default_Base);
          otherwise, uses the syntax for based literal, with any letters
          in upper case.

15
     procedure Get(From : in String; Item : out Num; Last : out Positive);

16
          Reads an integer value from the beginning of the given string,
          following the same rules as the Get procedure that reads an
          integer value from a file, but treating the end of the string
          as a file terminator.  Returns, in the parameter Item, the
          value of type Num that corresponds to the sequence input.
          Returns in Last the index value such that From(Last) is the
          last character read.

17
          The exception Data_Error is propagated if the sequence input
          does not have the required syntax or if the value obtained is
          not of the subtype Num.

18
     procedure Put(To   : out String;
                   Item : in Num;
                   Base : in Number_Base := Default_Base);

19
          Outputs the value of the parameter Item to the given string,
          following the same rule as for output to a file, using the
          length of the given string as the value for Width.

20
Integer_Text_IO is a library package that is a nongeneric equivalent to
Text_IO.Integer_IO for the predefined type Integer:

21
     with Ada.Text_IO;
     package Ada.Integer_Text_IO is new Ada.Text_IO.Integer_IO(Integer);

22
For each predefined signed integer type, a nongeneric equivalent to
Text_IO.Integer_IO is provided, with names such as
Ada.Long_Integer_Text_IO.

                     _Implementation Permissions_

23
The nongeneric equivalent packages may, but need not, be actual
instantiations of the generic package for the appropriate predefined
type.

Paragraphs 24 and 25 were deleted.

                              _Examples_

26/3
     subtype Byte_Int is Integer range -127 .. 127;
     package Int_IO is new Integer_IO(Byte_Int); use Int_IO;
     -- default format used at instantiation,
     -- Default_Width = 4, Default_Base = 10

27
     Put(126);                            -- "b126"
     Put(-126, 7);                        -- "bbb-126"
     Put(126, Width => 13, Base => 2);    -- "bbb2#1111110#"


File: arm2012.info,  Node: A.10.9,  Next: A.10.10,  Prev: A.10.8,  Up: A.10

A.10.9 Input-Output for Real Types
----------------------------------

                          _Static Semantics_

1
The following procedures are defined in the generic packages Float_IO,
Fixed_IO, and Decimal_IO, which have to be instantiated for the
appropriate floating point, ordinary fixed point, or decimal fixed point
type respectively (indicated by Num in the specifications).

2
Values are output as decimal literals without low line characters.  The
format of each value output consists of a Fore field, a decimal point,
an Aft field, and (if a nonzero Exp parameter is supplied) the letter E
and an Exp field.  The two possible formats thus correspond to:

3
     Fore  .  Aft

4
and to:

5
     Fore  .  Aft  E  Exp

6
without any spaces between these fields.  The Fore field may include
leading spaces, and a minus sign for negative values.  The Aft field
includes only decimal digits (possibly with trailing zeros).  The Exp
field includes the sign (plus or minus) and the exponent (possibly with
leading zeros).

7
For floating point types, the default lengths of these fields are
defined by the following variables that are declared in the generic
package Float_IO:

8
     Default_Fore : Field := 2;
     Default_Aft  : Field := Num'Digits-1;
     Default_Exp  : Field := 3;

9
For ordinary or decimal fixed point types, the default lengths of these
fields are defined by the following variables that are declared in the
generic packages Fixed_IO and Decimal_IO, respectively:

10
     Default_Fore : Field := Num'Fore;
     Default_Aft  : Field := Num'Aft;
     Default_Exp  : Field := 0;

11
The following procedures are provided:

12
     procedure Get(File : in File_Type; Item : out Num; Width : in Field := 0);
     procedure Get(Item : out Num; Width : in Field := 0);

13
          If the value of the parameter Width is zero, skips any leading
          blanks, line terminators, or page terminators, then reads the
          longest possible sequence of characters matching the syntax of
          any of the following (see *note 2.4::):

14
             * [+|-]numeric_literal

15
             * [+|-]numeral.[exponent]

16
             * [+|-].numeral[exponent]

17
             * [+|-]base#based_numeral.#[exponent]

18
             * [+|-]base#.based_numeral#[exponent]

19
          If a nonzero value of Width is supplied, then exactly Width
          characters are input, or the characters (possibly none) up to
          a line terminator, whichever comes first; any skipped leading
          blanks are included in the count.

20
          Returns in the parameter Item the value of type Num that
          corresponds to the sequence input, preserving the sign
          (positive if none has been specified) of a zero value if Num
          is a floating point type and Num'Signed_Zeros is True.

21
          The exception Data_Error is propagated if the sequence input
          does not have the required syntax or if the value obtained is
          not of the subtype Num.

22
     procedure Put(File : in File_Type;
                   Item : in Num;
                   Fore : in Field := Default_Fore;
                   Aft  : in Field := Default_Aft;
                   Exp  : in Field := Default_Exp);

     procedure Put(Item : in Num;
                   Fore : in Field := Default_Fore;
                   Aft  : in Field := Default_Aft;
                   Exp  : in Field := Default_Exp);

23
          Outputs the value of the parameter Item as a decimal literal
          with the format defined by Fore, Aft and Exp.  If the value is
          negative, or if Num is a floating point type where
          Num'Signed_Zeros is True and the value is a negatively signed
          zero, then a minus sign is included in the integer part.  If
          Exp has the value zero, then the integer part to be output has
          as many digits as are needed to represent the integer part of
          the value of Item, overriding Fore if necessary, or consists
          of the digit zero if the value of Item has no integer part.

24
          If Exp has a value greater than zero, then the integer part to
          be output has a single digit, which is nonzero except for the
          value 0.0 of Item.

25
          In both cases, however, if the integer part to be output has
          fewer than Fore characters, including any minus sign, then
          leading spaces are first output to make up the difference.
          The number of digits of the fractional part is given by Aft,
          or is one if Aft equals zero.  The value is rounded; a value
          of exactly one half in the last place is rounded away from
          zero.

26
          If Exp has the value zero, there is no exponent part.  If Exp
          has a value greater than zero, then the exponent part to be
          output has as many digits as are needed to represent the
          exponent part of the value of Item (for which a single digit
          integer part is used), and includes an initial sign (plus or
          minus).  If the exponent part to be output has fewer than Exp
          characters, including the sign, then leading zeros precede the
          digits, to make up the difference.  For the value 0.0 of Item,
          the exponent has the value zero.

27
     procedure Get(From : in String; Item : out Num; Last : out Positive);

28
          Reads a real value from the beginning of the given string,
          following the same rule as the Get procedure that reads a real
          value from a file, but treating the end of the string as a
          file terminator.  Returns, in the parameter Item, the value of
          type Num that corresponds to the sequence input.  Returns in
          Last the index value such that From(Last) is the last
          character read.

29
          The exception Data_Error is propagated if the sequence input
          does not have the required syntax, or if the value obtained is
          not of the subtype Num.

30
     procedure Put(To   : out String;
                   Item : in Num;
                   Aft  : in Field := Default_Aft;
                   Exp  : in Field := Default_Exp);

31
          Outputs the value of the parameter Item to the given string,
          following the same rule as for output to a file, using a value
          for Fore such that the sequence of characters output exactly
          fills the string, including any leading spaces.

32
Float_Text_IO is a library package that is a nongeneric equivalent to
Text_IO.Float_IO for the predefined type Float:

33
     with Ada.Text_IO;
     package Ada.Float_Text_IO is new Ada.Text_IO.Float_IO(Float);

34
For each predefined floating point type, a nongeneric equivalent to
Text_IO.Float_IO is provided, with names such as Ada.Long_Float_Text_IO.

                     _Implementation Permissions_

35
An implementation may extend Get and Put for floating point types to
support special values such as infinities and NaNs.

36
The implementation of Put need not produce an output value with greater
accuracy than is supported for the base subtype.  The additional
accuracy, if any, of the value produced by Put when the number of
requested digits in the integer and fractional parts exceeds the
required accuracy is implementation defined.

37
The nongeneric equivalent packages may, but need not, be actual
instantiations of the generic package for the appropriate predefined
type.

     NOTES

38
     34  For an item with a positive value, if output to a string
     exactly fills the string without leading spaces, then output of the
     corresponding negative value will propagate Layout_Error.

39
     35  The rules for the Value attribute (see *note 3.5::) and the
     rules for Get are based on the same set of formats.

                              _Examples_

40/1
     This paragraph was deleted.

41
     package Real_IO is new Float_IO(Real); use Real_IO;
     -- default format used at instantiation, Default_Exp = 3

42
     X : Real := -123.4567;  --  digits 8      (see *note 3.5.7::)

43
     Put(X);  -- default format    "-1.2345670E+02"
     Put(X, Fore => 5, Aft => 3, Exp => 2);    -- "bbb-1.235E+2"
     Put(X, 5, 3, 0);                -- "b-123.457"


File: arm2012.info,  Node: A.10.10,  Next: A.10.11,  Prev: A.10.9,  Up: A.10

A.10.10 Input-Output for Enumeration Types
------------------------------------------

                          _Static Semantics_

1
The following procedures are defined in the generic package
Enumeration_IO, which has to be instantiated for the appropriate
enumeration type (indicated by Enum in the specification).

2
Values are output using either upper or lower case letters for
identifiers.  This is specified by the parameter Set, which is of the
enumeration type Type_Set.

3
     type Type_Set is (Lower_Case, Upper_Case);

4
The format (which includes any trailing spaces) can be specified by an
optional field width parameter.  The default field width and letter case
are defined by the following variables that are declared in the generic
package Enumeration_IO:

5
     Default_Width   : Field := 0;
     Default_Setting : Type_Set := Upper_Case;

6
The following procedures are provided:

7
     procedure Get(File : in File_Type; Item : out Enum);
     procedure Get(Item : out Enum);

8
          After skipping any leading blanks, line terminators, or page
          terminators, reads an identifier according to the syntax of
          this lexical element (lower and upper case being considered
          equivalent), or a character literal according to the syntax of
          this lexical element (including the apostrophes).  Returns, in
          the parameter Item, the value of type Enum that corresponds to
          the sequence input.

9
          The exception Data_Error is propagated if the sequence input
          does not have the required syntax, or if the identifier or
          character literal does not correspond to a value of the
          subtype Enum.

10
     procedure Put(File  : in File_Type;
                   Item  : in Enum;
                   Width : in Field := Default_Width;
                   Set   : in Type_Set := Default_Setting);

     procedure Put(Item  : in Enum;
                   Width : in Field := Default_Width;
                   Set   : in Type_Set := Default_Setting);

11
          Outputs the value of the parameter Item as an enumeration
          literal (either an identifier or a character literal).  The
          optional parameter Set indicates whether lower case or upper
          case is used for identifiers; it has no effect for character
          literals.  If the sequence of characters produced has fewer
          than Width characters, then trailing spaces are finally output
          to make up the difference.  If Enum is a character type, the
          sequence of characters produced is as for Enum'Image(Item), as
          modified by the Width and Set parameters.

12
     procedure Get(From : in String; Item : out Enum; Last : out Positive);

13
          Reads an enumeration value from the beginning of the given
          string, following the same rule as the Get procedure that
          reads an enumeration value from a file, but treating the end
          of the string as a file terminator.  Returns, in the parameter
          Item, the value of type Enum that corresponds to the sequence
          input.  Returns in Last the index value such that From(Last)
          is the last character read.

14
          The exception Data_Error is propagated if the sequence input
          does not have the required syntax, or if the identifier or
          character literal does not correspond to a value of the
          subtype Enum.

15
     procedure Put(To   : out String;
                   Item : in Enum;
                   Set  : in Type_Set := Default_Setting);

16
          Outputs the value of the parameter Item to the given string,
          following the same rule as for output to a file, using the
          length of the given string as the value for Width.

17/1
Although the specification of the generic package Enumeration_IO would
allow instantiation for an integer type, this is not the intended
purpose of this generic package, and the effect of such instantiations
is not defined by the language.

     NOTES

18
     36  There is a difference between Put defined for characters, and
     for enumeration values.  Thus

19
             Ada.Text_IO.Put('A');  --  outputs the character A

20
             package Char_IO is new Ada.Text_IO.Enumeration_IO(Character);
             Char_IO.Put('A');  --  outputs the character 'A', between apostrophes

21
     37  The type Boolean is an enumeration type, hence Enumeration_IO
     can be instantiated for this type.


File: arm2012.info,  Node: A.10.11,  Next: A.10.12,  Prev: A.10.10,  Up: A.10

A.10.11 Input-Output for Bounded Strings
----------------------------------------

1/2
The package Text_IO.Bounded_IO provides input-output in human-readable
form for Bounded_Strings.

                          _Static Semantics_

2/2
The generic library package Text_IO.Bounded_IO has the following
declaration:

3/2
     with Ada.Strings.Bounded;
     generic
        with package Bounded is
                          new Ada.Strings.Bounded.Generic_Bounded_Length (<>);
     package Ada.Text_IO.Bounded_IO is

4/2
        procedure Put
           (File : in File_Type;
            Item : in Bounded.Bounded_String);

5/2
        procedure Put
           (Item : in Bounded.Bounded_String);

6/2
        procedure Put_Line
           (File : in File_Type;
            Item : in Bounded.Bounded_String);

7/2
        procedure Put_Line
           (Item : in Bounded.Bounded_String);

8/2
        function Get_Line
           (File : in File_Type)
           return Bounded.Bounded_String;

9/2
        function Get_Line
           return Bounded.Bounded_String;

10/2
        procedure Get_Line
           (File : in File_Type; Item : out Bounded.Bounded_String);

11/2
        procedure Get_Line
           (Item : out Bounded.Bounded_String);

12/2
     end Ada.Text_IO.Bounded_IO;

13/2
For an item of type Bounded_String, the following subprograms are
provided:

14/2
     procedure Put
        (File : in File_Type;
         Item : in Bounded.Bounded_String);

15/2
          Equivalent to Text_IO.Put (File, Bounded.To_String(Item));

16/2
     procedure Put
        (Item : in Bounded.Bounded_String);

17/2
          Equivalent to Text_IO.Put (Bounded.To_String(Item));

18/2
     procedure Put_Line
        (File : in File_Type;
         Item : in Bounded.Bounded_String);

19/2
          Equivalent to Text_IO.Put_Line (File,
          Bounded.To_String(Item));

20/2
     procedure Put_Line
        (Item : in Bounded.Bounded_String);

21/2
          Equivalent to Text_IO.Put_Line (Bounded.To_String(Item));

22/2
     function Get_Line
        (File : in File_Type)
        return Bounded.Bounded_String;

23/2
          Returns Bounded.To_Bounded_String(Text_IO.Get_Line(File));

24/2
     function Get_Line
        return Bounded.Bounded_String;

25/2
          Returns Bounded.To_Bounded_String(Text_IO.Get_Line);

26/2
     procedure Get_Line
        (File : in File_Type; Item : out Bounded.Bounded_String);

27/2
          Equivalent to Item := Get_Line (File);

28/2
     procedure Get_Line
        (Item : out Bounded.Bounded_String);

29/2
          Equivalent to Item := Get_Line;


File: arm2012.info,  Node: A.10.12,  Prev: A.10.11,  Up: A.10

A.10.12 Input-Output for Unbounded Strings
------------------------------------------

1/2
The package Text_IO.Unbounded_IO provides input-output in human-readable
form for Unbounded_Strings.

                          _Static Semantics_

2/2
The library package Text_IO.Unbounded_IO has the following declaration:

3/2
     with Ada.Strings.Unbounded;
     package Ada.Text_IO.Unbounded_IO is

4/2
        procedure Put
           (File : in File_Type;
            Item : in Strings.Unbounded.Unbounded_String);

5/2
        procedure Put
           (Item : in Strings.Unbounded.Unbounded_String);

6/2
        procedure Put_Line
           (File : in File_Type;
            Item : in Strings.Unbounded.Unbounded_String);

7/2
        procedure Put_Line
           (Item : in Strings.Unbounded.Unbounded_String);

8/2
        function Get_Line
           (File : in File_Type)
           return Strings.Unbounded.Unbounded_String;

9/2
        function Get_Line
           return Strings.Unbounded.Unbounded_String;

10/2
        procedure Get_Line
           (File : in File_Type; Item : out Strings.Unbounded.Unbounded_String);

11/2
        procedure Get_Line
           (Item : out Strings.Unbounded.Unbounded_String);

12/2
     end Ada.Text_IO.Unbounded_IO;

13/2
For an item of type Unbounded_String, the following subprograms are
provided:

14/2
     procedure Put
        (File : in File_Type;
         Item : in Strings.Unbounded.Unbounded_String);

15/2
          Equivalent to Text_IO.Put (File,
          Strings.Unbounded.To_String(Item));

16/2
     procedure Put
        (Item : in Strings.Unbounded.Unbounded_String);

17/2
          Equivalent to Text_IO.Put (Strings.Unbounded.To_String(Item));

18/2
     procedure Put_Line
        (File : in File_Type;
         Item : in Strings.Unbounded.Unbounded_String);

19/2
          Equivalent to Text_IO.Put_Line (File,
          Strings.Unbounded.To_String(Item));

20/2
     procedure Put_Line
        (Item : in Strings.Unbounded.Unbounded_String);

21/2
          Equivalent to Text_IO.Put_Line
          (Strings.Unbounded.To_String(Item));

22/2
     function Get_Line
        (File : in File_Type)
        return Strings.Unbounded.Unbounded_String;

23/2
          Returns
          Strings.Unbounded.To_Unbounded_String(Text_IO.Get_Line(File));

24/2
     function Get_Line
        return Strings.Unbounded.Unbounded_String;

25/2
          Returns
          Strings.Unbounded.To_Unbounded_String(Text_IO.Get_Line);

26/2
     procedure Get_Line
        (File : in File_Type; Item : out Strings.Unbounded.Unbounded_String);

27/2
          Equivalent to Item := Get_Line (File);

28/2
     procedure Get_Line
        (Item : out Strings.Unbounded.Unbounded_String);

29/2
          Equivalent to Item := Get_Line;


File: arm2012.info,  Node: A.11,  Next: A.12,  Prev: A.10,  Up: Annex A

A.11 Wide Text Input-Output and Wide Wide Text Input-Output
===========================================================

1/2
The packages Wide_Text_IO and Wide_Wide_Text_IO provide facilities for
input and output in human-readable form.  Each file is read or written
sequentially, as a sequence of wide characters (or wide wide characters)
grouped into lines, and as a sequence of lines grouped into pages.

                          _Static Semantics_

2/2
The specification of package Wide_Text_IO is the same as that for
Text_IO, except that in each Get, Look_Ahead, Get_Immediate, Get_Line,
Put, and Put_Line subprogram, any occurrence of Character is replaced by
Wide_Character, and any occurrence of String is replaced by Wide_String.
Nongeneric equivalents of Wide_Text_IO.Integer_IO and
Wide_Text_IO.Float_IO are provided (as for Text_IO) for each predefined
numeric type, with names such as Ada.Integer_Wide_Text_IO,
Ada.Long_Integer_Wide_Text_IO, Ada.Float_Wide_Text_IO,
Ada.Long_Float_Wide_Text_IO.

3/2
The specification of package Wide_Wide_Text_IO is the same as that for
Text_IO, except that in each Get, Look_Ahead, Get_Immediate, Get_Line,
Put, and Put_Line subprogram, any occurrence of Character is replaced by
Wide_Wide_Character, and any occurrence of String is replaced by
Wide_Wide_String. Nongeneric equivalents of Wide_Wide_Text_IO.Integer_IO
and Wide_Wide_Text_IO.Float_IO are provided (as for Text_IO) for each
predefined numeric type, with names such as
Ada.Integer_Wide_Wide_Text_IO, Ada.Long_Integer_Wide_Wide_Text_IO,
Ada.Float_Wide_Wide_Text_IO, Ada.Long_Float_Wide_Wide_Text_IO.

4/3
The specification of package Wide_Text_IO.Wide_Bounded_IO is the same as
that for Text_IO.Bounded_IO, except that any occurrence of
Bounded_String is replaced by Bounded_Wide_String, and any occurrence of
package Bounded is replaced by Wide_Bounded.  The specification of
package Wide_Wide_Text_IO.Wide_Wide_Bounded_IO is the same as that for
Text_IO.Bounded_IO, except that any occurrence of Bounded_String is
replaced by Bounded_Wide_Wide_String, and any occurrence of package
Bounded is replaced by Wide_Wide_Bounded.

5/3
The specification of package Wide_Text_IO.Wide_Unbounded_IO is the same
as that for Text_IO.Unbounded_IO, except that any occurrence of
Unbounded_String is replaced by Unbounded_Wide_String, and any
occurrence of package Unbounded is replaced by Wide_Unbounded.  The
specification of package Wide_Wide_Text_IO.Wide_Wide_Unbounded_IO is the
same as that for Text_IO.Unbounded_IO, except that any occurrence of
Unbounded_String is replaced by Unbounded_Wide_Wide_String, and any
occurrence of package Unbounded is replaced by Wide_Wide_Unbounded.


File: arm2012.info,  Node: A.12,  Next: A.13,  Prev: A.11,  Up: Annex A

A.12 Stream Input-Output
========================

1/2
The packages Streams.Stream_IO, Text_IO.Text_Streams,
Wide_Text_IO.Text_Streams, and Wide_Wide_Text_IO.Text_Streams provide
stream-oriented operations on files.

* Menu:

* A.12.1 ::   The Package Streams.Stream_IO
* A.12.2 ::   The Package Text_IO.Text_Streams
* A.12.3 ::   The Package Wide_Text_IO.Text_Streams
* A.12.4 ::   The Package Wide_Wide_Text_IO.Text_Streams


File: arm2012.info,  Node: A.12.1,  Next: A.12.2,  Up: A.12

A.12.1 The Package Streams.Stream_IO
------------------------------------

1
The subprograms in the child package Streams.Stream_IO provide control
over stream files.  Access to a stream file is either sequential, via a
call on Read or Write to transfer an array of stream elements, or
positional (if supported by the implementation for the given file), by
specifying a relative index for an element.  Since a stream file can be
converted to a Stream_Access value, calling stream-oriented attribute
subprograms of different element types with the same Stream_Access value
provides heterogeneous input-output.  See *note 13.13:: for a general
discussion of streams.

                          _Static Semantics_

1.1/1
The elements of a stream file are stream elements.  If positioning is
supported for the specified external file, a current index and current
size are maintained for the file as described in *note A.8::.  If
positioning is not supported, a current index is not maintained, and the
current size is implementation defined.

2
The library package Streams.Stream_IO has the following declaration:

3/3
     with Ada.IO_Exceptions;
     package Ada.Streams.Stream_IO is
         pragma Preelaborate(Stream_IO);

4
         type Stream_Access is access all Root_Stream_Type'Class;

5/4
         type File_Type is limited private;
         pragma Preelaborable_Initialization(File_Type);

6
         type File_Mode is (In_File, Out_File, Append_File);

7
         type    Count          is range 0 .. implementation-defined;
         subtype Positive_Count is Count range 1 .. Count'Last;
           -- Index into file, in stream elements.

8
         procedure Create (File : in out File_Type;
                           Mode : in File_Mode := Out_File;
                           Name : in String    := "";
                           Form : in String    := "");

9
         procedure Open (File : in out File_Type;
                         Mode : in File_Mode;
                         Name : in String;
                         Form : in String := "");

10
         procedure Close  (File : in out File_Type);
         procedure Delete (File : in out File_Type);
         procedure Reset  (File : in out File_Type; Mode : in File_Mode);
         procedure Reset  (File : in out File_Type);

11
         function Mode (File : in File_Type) return File_Mode;
         function Name (File : in File_Type) return String;
         function Form (File : in File_Type) return String;

12
         function Is_Open     (File : in File_Type) return Boolean;
         function End_Of_File (File : in File_Type) return Boolean;

13
         function Stream (File : in File_Type) return Stream_Access;
             -- Return stream access for use with T'Input and T'Output

14/1
     This paragraph was deleted.

15
         -- Read array of stream elements from file
         procedure Read (File : in  File_Type;
                         Item : out Stream_Element_Array;
                         Last : out Stream_Element_Offset;
                         From : in  Positive_Count);

16
         procedure Read (File : in  File_Type;
                         Item : out Stream_Element_Array;
                         Last : out Stream_Element_Offset);

17/1
     This paragraph was deleted.

18
         -- Write array of stream elements into file
         procedure Write (File : in File_Type;
                          Item : in Stream_Element_Array;
                          To   : in Positive_Count);

19
         procedure Write (File : in File_Type;
                          Item : in Stream_Element_Array);

20/1
     This paragraph was deleted.

21
         -- Operations on position within file

22
         procedure Set_Index(File : in File_Type; To : in Positive_Count);

23
         function Index(File : in File_Type) return Positive_Count;
         function Size (File : in File_Type) return Count;

24
         procedure Set_Mode(File : in out File_Type; Mode : in File_Mode);

25/1
         procedure Flush(File : in File_Type);

26
         -- exceptions
         Status_Error : exception renames IO_Exceptions.Status_Error;
         Mode_Error   : exception renames IO_Exceptions.Mode_Error;
         Name_Error   : exception renames IO_Exceptions.Name_Error;
         Use_Error    : exception renames IO_Exceptions.Use_Error;
         Device_Error : exception renames IO_Exceptions.Device_Error;
         End_Error    : exception renames IO_Exceptions.End_Error;
         Data_Error   : exception renames IO_Exceptions.Data_Error;

27
     private
        ... -- not specified by the language
     end Ada.Streams.Stream_IO;

27.1/2
The type File_Type needs finalization (see *note 7.6::).

28/4
The subprograms given in subclause *note A.8.2:: for the control of
external files (Create, Open, Close, Delete, Reset, Mode, Name, Form,
Is_Open, and Flush) are available for stream files.

28.1/2
The End_Of_File function:

28.2/2
   * Propagates Mode_Error if the mode of the file is not In_File;

28.3/3
   * If positioning is supported for the given external file, the
     function returns True if the current index exceeds the size of the
     external file; otherwise, it returns False;

28.4/3
   * If positioning is not supported for the given external file, the
     function returns True if no more elements can be read from the
     given file; otherwise, it returns False.

28.5/2
The Set_Mode procedure sets the mode of the file.  If the new mode is
Append_File, the file is positioned to its end; otherwise, the position
in the file is unchanged.

28.6/4
This paragraph was deleted.

29/1
The Stream function returns a Stream_Access result from a File_Type
object, thus allowing the stream-oriented attributes Read, Write, Input,
and Output to be used on the same file for multiple types.  Stream
propagates Status_Error if File is not open.

30/2
The procedures Read and Write are equivalent to the corresponding
operations in the package Streams.  Read propagates Mode_Error if the
mode of File is not In_File.  Write propagates Mode_Error if the mode of
File is not Out_File or Append_File.  The Read procedure with a
Positive_Count parameter starts reading at the specified index.  The
Write procedure with a Positive_Count parameter starts writing at the
specified index.  For a file that supports positioning, Read without a
Positive_Count parameter starts reading at the current index, and Write
without a Positive_Count parameter starts writing at the current index.

30.1/1
The Size function returns the current size of the file.

31/1
The Index function returns the current index.

32
The Set_Index procedure sets the current index to the specified value.

32.1/1
If positioning is supported for the external file, the current index is
maintained as follows:

32.2/1
   * For Open and Create, if the Mode parameter is Append_File, the
     current index is set to the current size of the file plus one;
     otherwise, the current index is set to one.

32.3/1
   * For Reset, if the Mode parameter is Append_File, or no Mode
     parameter is given and the current mode is Append_File, the current
     index is set to the current size of the file plus one; otherwise,
     the current index is set to one.

32.4/1
   * For Set_Mode, if the new mode is Append_File, the current index is
     set to current size plus one; otherwise, the current index is
     unchanged.

32.5/1
   * For Read and Write without a Positive_Count parameter, the current
     index is incremented by the number of stream elements read or
     written.

32.6/1
   * For Read and Write with a Positive_Count parameter, the value of
     the current index is set to the value of the Positive_Count
     parameter plus the number of stream elements read or written.

33
If positioning is not supported for the given file, then a call of Index
or Set_Index propagates Use_Error.  Similarly, a call of Read or Write
with a Positive_Count parameter propagates Use_Error.

Paragraphs 34 through 36 were deleted.

                         _Erroneous Execution_

36.1/1
If the File_Type object passed to the Stream function is later closed or
finalized, and the stream-oriented attributes are subsequently called
(explicitly or implicitly) on the Stream_Access value returned by
Stream, execution is erroneous.  This rule applies even if the File_Type
object was opened again after it had been closed.


File: arm2012.info,  Node: A.12.2,  Next: A.12.3,  Prev: A.12.1,  Up: A.12

A.12.2 The Package Text_IO.Text_Streams
---------------------------------------

1
The package Text_IO.Text_Streams provides a function for treating a text
file as a stream.

                          _Static Semantics_

2
The library package Text_IO.Text_Streams has the following declaration:

3
     with Ada.Streams;
     package Ada.Text_IO.Text_Streams is
        type Stream_Access is access all Streams.Root_Stream_Type'Class;

4
        function Stream (File : in File_Type) return Stream_Access;
     end Ada.Text_IO.Text_Streams;

5
The Stream function has the same effect as the corresponding function in
Streams.Stream_IO.

     NOTES

6
     38  The ability to obtain a stream for a text file allows
     Current_Input, Current_Output, and Current_Error to be processed
     with the functionality of streams, including the mixing of text and
     binary input-output, and the mixing of binary input-output for
     different types.

7
     39  Performing operations on the stream associated with a text file
     does not affect the column, line, or page counts.


File: arm2012.info,  Node: A.12.3,  Next: A.12.4,  Prev: A.12.2,  Up: A.12

A.12.3 The Package Wide_Text_IO.Text_Streams
--------------------------------------------

1
The package Wide_Text_IO.Text_Streams provides a function for treating a
wide text file as a stream.

                          _Static Semantics_

2
The library package Wide_Text_IO.Text_Streams has the following
declaration:

3
     with Ada.Streams;
     package Ada.Wide_Text_IO.Text_Streams is
        type Stream_Access is access all Streams.Root_Stream_Type'Class;

4
        function Stream (File : in File_Type) return Stream_Access;
     end Ada.Wide_Text_IO.Text_Streams;

5
The Stream function has the same effect as the corresponding function in
Streams.Stream_IO.


File: arm2012.info,  Node: A.12.4,  Prev: A.12.3,  Up: A.12

A.12.4 The Package Wide_Wide_Text_IO.Text_Streams
-------------------------------------------------

1/2
The package Wide_Wide_Text_IO.Text_Streams provides a function for
treating a wide wide text file as a stream.

                          _Static Semantics_

2/2
The library package Wide_Wide_Text_IO.Text_Streams has the following
declaration:

3/2
     with Ada.Streams;
     package Ada.Wide_Wide_Text_IO.Text_Streams is
        type Stream_Access is access all Streams.Root_Stream_Type'Class;

4/2
        function Stream (File : in File_Type) return Stream_Access;
     end Ada.Wide_Wide_Text_IO.Text_Streams;

5/2
The Stream function has the same effect as the corresponding function in
Streams.Stream_IO.


File: arm2012.info,  Node: A.13,  Next: A.14,  Prev: A.12,  Up: Annex A

A.13 Exceptions in Input-Output
===============================

1
The package IO_Exceptions defines the exceptions needed by the
predefined input-output packages.

                          _Static Semantics_

2
The library package IO_Exceptions has the following declaration:

3
     package Ada.IO_Exceptions is
        pragma Pure(IO_Exceptions);

4
        Status_Error : exception;
        Mode_Error   : exception;
        Name_Error   : exception;
        Use_Error    : exception;
        Device_Error : exception;
        End_Error    : exception;
        Data_Error   : exception;
        Layout_Error : exception;

5
     end Ada.IO_Exceptions;

6
If more than one error condition exists, the corresponding exception
that appears earliest in the following list is the one that is
propagated.

7
The exception Status_Error is propagated by an attempt to operate upon a
file that is not open, and by an attempt to open a file that is already
open.

8
The exception Mode_Error is propagated by an attempt to read from, or
test for the end of, a file whose current mode is Out_File or
Append_File, and also by an attempt to write to a file whose current
mode is In_File.  In the case of Text_IO, the exception Mode_Error is
also propagated by specifying a file whose current mode is Out_File or
Append_File in a call of Set_Input, Skip_Line, End_Of_Line, Skip_Page,
or End_Of_Page; and by specifying a file whose current mode is In_File
in a call of Set_Output, Set_Line_Length, Set_Page_Length, Line_Length,
Page_Length, New_Line, or New_Page.

9
The exception Name_Error is propagated by a call of Create or Open if
the string given for the parameter Name does not allow the
identification of an external file.  For example, this exception is
propagated if the string is improper, or, alternatively, if either none
or more than one external file corresponds to the string.

10
The exception Use_Error is propagated if an operation is attempted that
is not possible for reasons that depend on characteristics of the
external file.  For example, this exception is propagated by the
procedure Create, among other circumstances, if the given mode is
Out_File but the form specifies an input only device, if the parameter
Form specifies invalid access rights, or if an external file with the
given name already exists and overwriting is not allowed.

11
The exception Device_Error is propagated if an input-output operation
cannot be completed because of a malfunction of the underlying system.

12
The exception End_Error is propagated by an attempt to skip (read past)
the end of a file.

13
The exception Data_Error can be propagated by the procedure Read (or by
the Read attribute) if the element read cannot be interpreted as a value
of the required subtype.  This exception is also propagated by a
procedure Get (defined in the package Text_IO) if the input character
sequence fails to satisfy the required syntax, or if the value input
does not belong to the range of the required subtype.

14
The exception Layout_Error is propagated (in text input-output) by Col,
Line, or Page if the value returned exceeds Count'Last.  The exception
Layout_Error is also propagated on output by an attempt to set column or
line numbers in excess of specified maximum line or page lengths,
respectively (excluding the unbounded cases).  It is also propagated by
an attempt to Put too many characters to a string.

14.1/3
These exceptions are also propagated by various other language-defined
packages and operations, see the definition of those entities for other
reasons that these exceptions are propagated.

                     _Documentation Requirements_

15
The implementation shall document the conditions under which Name_Error,
Use_Error and Device_Error are propagated.

                     _Implementation Permissions_

16
If the associated check is too complex, an implementation need not
propagate Data_Error as part of a procedure Read (or the Read attribute)
if the value read cannot be interpreted as a value of the required
subtype.

                         _Erroneous Execution_

17
If the element read by the procedure Read (or by the Read attribute)
cannot be interpreted as a value of the required subtype, but this is
not detected and Data_Error is not propagated, then the resulting value
can be abnormal, and subsequent references to the value can lead to
erroneous execution, as explained in *note 13.9.1::. 


File: arm2012.info,  Node: A.14,  Next: A.15,  Prev: A.13,  Up: Annex A

A.14 File Sharing
=================

                          _Dynamic Semantics_

1
It is not specified by the language whether the same external file can
be associated with more than one file object.  If such sharing is
supported by the implementation, the following effects are defined:

2
   * Operations on one text file object do not affect the column, line,
     and page numbers of any other file object.

3/1
   * This paragraph was deleted.

4
   * For direct and stream files, the current index is a property of
     each file object; an operation on one file object does not affect
     the current index of any other file object.

5
   * For direct and stream files, the current size of the file is a
     property of the external file.

6
All other effects are identical.


File: arm2012.info,  Node: A.15,  Next: A.16,  Prev: A.14,  Up: Annex A

A.15 The Package Command_Line
=============================

1
The package Command_Line allows a program to obtain the values of its
arguments and to set the exit status code to be returned on normal
termination.

                          _Static Semantics_

2
The library package Ada.Command_Line has the following declaration:

3
     package Ada.Command_Line is
       pragma Preelaborate(Command_Line);

4
       function Argument_Count return Natural;

5
       function Argument (Number : in Positive) return String;

6
       function Command_Name return String;

7
       type Exit_Status is implementation-defined integer type;

8
       Success : constant Exit_Status;
       Failure : constant Exit_Status;

9
       procedure Set_Exit_Status (Code : in Exit_Status);

10
     private
       ... -- not specified by the language
     end Ada.Command_Line;


11
     function Argument_Count return Natural;

12/3
          If the external execution environment supports passing
          arguments to a program, then Argument_Count returns the number
          of arguments passed to the program invoking the function.
          Otherwise, it returns 0.  The meaning of "number of arguments"
          is implementation defined.

13
     function Argument (Number : in Positive) return String;

14
          If the external execution environment supports passing
          arguments to a program, then Argument returns an
          implementation-defined value corresponding to the argument at
          relative position Number. If Number is outside the range
          1..Argument_Count, then Constraint_Error is propagated.

15
     function Command_Name return String;

16/3
          If the external execution environment supports passing
          arguments to a program, then Command_Name returns an
          implementation-defined value corresponding to the name of the
          command invoking the program; otherwise, Command_Name returns
          the null string.

16.1/1
     type Exit_Status is implementation-defined integer type;

17
          The type Exit_Status represents the range of exit status
          values supported by the external execution environment.  The
          constants Success and Failure correspond to success and
          failure, respectively.

18
     procedure Set_Exit_Status (Code : in Exit_Status);

19
          If the external execution environment supports returning an
          exit status from a program, then Set_Exit_Status sets Code as
          the status.  Normal termination of a program returns as the
          exit status the value most recently set by Set_Exit_Status,
          or, if no such value has been set, then the value Success.  If
          a program terminates abnormally, the status set by
          Set_Exit_Status is ignored, and an implementation-defined exit
          status value is set.

20
          If the external execution environment does not support
          returning an exit value from a program, then Set_Exit_Status
          does nothing.

                     _Implementation Permissions_

21
An alternative declaration is allowed for package Command_Line if
different functionality is appropriate for the external execution
environment.

     NOTES

22
     40  Argument_Count, Argument, and Command_Name correspond to the C
     language's argc, argv[n] (for n>0) and argv[0], respectively.


File: arm2012.info,  Node: A.16,  Next: A.17,  Prev: A.15,  Up: Annex A

A.16 The Package Directories
============================

1/2
The package Directories provides operations for manipulating files and
directories, and their names.

                          _Static Semantics_

2/2
The library package Directories has the following declaration:

3/2
     with Ada.IO_Exceptions;
     with Ada.Calendar;
     package Ada.Directories is

4/2
        -- Directory and file operations:

5/2
        function Current_Directory return String;

6/2
        procedure Set_Directory (Directory : in String);

7/2
        procedure Create_Directory (New_Directory : in String;
                                    Form          : in String := "");

8/2
        procedure Delete_Directory (Directory : in String);

9/2
        procedure Create_Path (New_Directory : in String;
                               Form          : in String := "");

10/2
        procedure Delete_Tree (Directory : in String);

11/2
        procedure Delete_File (Name : in String);

12/2
        procedure Rename (Old_Name, New_Name : in String);

13/2
        procedure Copy_File (Source_Name,
                             Target_Name : in String;
                             Form        : in String := "");

14/2
        -- File and directory name operations:

15/2
        function Full_Name (Name : in String) return String;

16/2
        function Simple_Name (Name : in String) return String;

17/2
        function Containing_Directory (Name : in String) return String;

18/2
        function Extension (Name : in String) return String;

19/2
        function Base_Name (Name : in String) return String;

20/2
        function Compose (Containing_Directory : in String := "";
                          Name                 : in String;
                          Extension            : in String := "") return String;

20.1/3
        type Name_Case_Kind is
           (Unknown, Case_Sensitive, Case_Insensitive, Case_Preserving);

20.2/3
        function Name_Case_Equivalence (Name : in String) return Name_Case_Kind;

21/2
        -- File and directory queries:

22/2
        type File_Kind is (Directory, Ordinary_File, Special_File);

23/2
        type File_Size is range 0 .. implementation-defined;

24/2
        function Exists (Name : in String) return Boolean;

25/2
        function Kind (Name : in String) return File_Kind;

26/2
        function Size (Name : in String) return File_Size;

27/2
        function Modification_Time (Name : in String) return Ada.Calendar.Time;

28/2
        -- Directory searching:

29/2
        type Directory_Entry_Type is limited private;

30/2
        type Filter_Type is array (File_Kind) of Boolean;

31/2
        type Search_Type is limited private;

32/2
        procedure Start_Search (Search    : in out Search_Type;
                                Directory : in String;
                                Pattern   : in String;
                                Filter    : in Filter_Type := (others => True));

33/2
        procedure End_Search (Search : in out Search_Type);

34/2
        function More_Entries (Search : in Search_Type) return Boolean;

35/2
        procedure Get_Next_Entry (Search : in out Search_Type;
                                  Directory_Entry : out Directory_Entry_Type);

36/2
        procedure Search (
           Directory : in String;
           Pattern   : in String;
           Filter    : in Filter_Type := (others => True);
           Process   : not null access procedure (
               Directory_Entry : in Directory_Entry_Type));

37/2
        -- Operations on Directory Entries:

38/2
        function Simple_Name (Directory_Entry : in Directory_Entry_Type)
            return String;

39/2
        function Full_Name (Directory_Entry : in Directory_Entry_Type)
            return String;

40/2
        function Kind (Directory_Entry : in Directory_Entry_Type)
            return File_Kind;

41/2
        function Size (Directory_Entry : in Directory_Entry_Type)
            return File_Size;

42/2
        function Modification_Time (Directory_Entry : in Directory_Entry_Type)
            return Ada.Calendar.Time;

43/2
        Status_Error : exception renames Ada.IO_Exceptions.Status_Error;
        Name_Error   : exception renames Ada.IO_Exceptions.Name_Error;
        Use_Error    : exception renames Ada.IO_Exceptions.Use_Error;
        Device_Error : exception renames Ada.IO_Exceptions.Device_Error;

44/3
     private
         ... -- not specified by the language
     end Ada.Directories;

45/2
External files may be classified as directories, special files, or
ordinary files.  A directory is an external file that is a container for
files on the target system.  A special file is an external file that
cannot be created or read by a predefined Ada input-output package.
External files that are not special files or directories are called
ordinary files. 

46/2
A file name is a string identifying an external file.  Similarly, a
directory name is a string identifying a directory.  The interpretation
of file names and directory names is implementation-defined. 

47/2
The full name of an external file is a full specification of the name of
the file.  If the external environment allows alternative specifications
of the name (for example, abbreviations), the full name should not use
such alternatives.  A full name typically will include the names of all
of the directories that contain the item.  The simple name of an
external file is the name of the item, not including any containing
directory names.  Unless otherwise specified, a file name or directory
name parameter in a call to a predefined Ada input-output subprogram can
be a full name, a simple name, or any other form of name supported by
the implementation. 

48/2
The default directory is the directory that is used if a directory or
file name is not a full name (that is, when the name does not fully
identify all of the containing directories). 

49/2
A directory entry is a single item in a directory, identifying a single
external file (including directories and special files). 

50/2
For each function that returns a string, the lower bound of the returned
value is 1.

51/2
The following file and directory operations are provided:

52/2
     function Current_Directory return String;

53/2
          Returns the full directory name for the current default
          directory.  The name returned shall be suitable for a future
          call to Set_Directory.  The exception Use_Error is propagated
          if a default directory is not supported by the external
          environment.

54/2
     procedure Set_Directory (Directory : in String);

55/2
          Sets the current default directory.  The exception Name_Error
          is propagated if the string given as Directory does not
          identify an existing directory.  The exception Use_Error is
          propagated if the external environment does not support making
          Directory (in the absence of Name_Error) a default directory.

56/2
     procedure Create_Directory (New_Directory : in String;
                                 Form          : in String := "");

57/2
          Creates a directory with name New_Directory.  The Form
          parameter can be used to give system-dependent characteristics
          of the directory; the interpretation of the Form parameter is
          implementation-defined.  A null string for Form specifies the
          use of the default options of the implementation of the new
          directory.  The exception Name_Error is propagated if the
          string given as New_Directory does not allow the
          identification of a directory.  The exception Use_Error is
          propagated if the external environment does not support the
          creation of a directory with the given name (in the absence of
          Name_Error) and form.

58/2
     procedure Delete_Directory (Directory : in String);

59/3
          Deletes an existing empty directory with name Directory.  The
          exception Name_Error is propagated if the string given as
          Directory does not identify an existing directory.  The
          exception Use_Error is propagated if the directory is not
          empty or the external environment does not support the
          deletion of the directory with the given name (in the absence
          of Name_Error).

60/2
     procedure Create_Path (New_Directory : in String;
                            Form          : in String := "");

61/3
          Creates zero or more directories with name New_Directory.
          Each nonexistent directory named by New_Directory is created.
          For example, on a typical Unix system, Create_Path
          ("/usr/me/my"); would create directory "me" in directory
          "usr", then create directory "my" in directory "me".  The Form
          parameter can be used to give system-dependent characteristics
          of the directory; the interpretation of the Form parameter is
          implementation-defined.  A null string for Form specifies the
          use of the default options of the implementation of the new
          directory.  The exception Name_Error is propagated if the
          string given as New_Directory does not allow the
          identification of any directory.  The exception Use_Error is
          propagated if the external environment does not support the
          creation of any directories with the given name (in the
          absence of Name_Error) and form.  If Use_Error is propagated,
          it is unspecified whether a portion of the directory path is
          created.

62/2
     procedure Delete_Tree (Directory : in String);

63/2
          Deletes an existing directory with name Directory.  The
          directory and all of its contents (possibly including other
          directories) are deleted.  The exception Name_Error is
          propagated if the string given as Directory does not identify
          an existing directory.  The exception Use_Error is propagated
          if the external environment does not support the deletion of
          the directory or some portion of its contents with the given
          name (in the absence of Name_Error).  If Use_Error is
          propagated, it is unspecified whether a portion of the
          contents of the directory is deleted.

64/2
     procedure Delete_File (Name : in String);

65/2
          Deletes an existing ordinary or special file with name Name.
          The exception Name_Error is propagated if the string given as
          Name does not identify an existing ordinary or special
          external file.  The exception Use_Error is propagated if the
          external environment does not support the deletion of the file
          with the given name (in the absence of Name_Error).

66/2
     procedure Rename (Old_Name, New_Name : in String);

67/3
          Renames an existing external file (including directories) with
          name Old_Name to New_Name.  The exception Name_Error is
          propagated if the string given as Old_Name does not identify
          an existing external file or if the string given as New_Name
          does not allow the identification of an external file.  The
          exception Use_Error is propagated if the external environment
          does not support the renaming of the file with the given name
          (in the absence of Name_Error).  In particular, Use_Error is
          propagated if a file or directory already exists with name
          New_Name.

68/3
     procedure Copy_File (Source_Name,
                          Target_Name : in String;
                          Form        : in String := "");

69/3
          Copies the contents of the existing external file with name
          Source_Name to an external file with name Target_Name.  The
          resulting external file is a duplicate of the source external
          file.  The Form parameter can be used to give system-dependent
          characteristics of the resulting external file; the
          interpretation of the Form parameter is
          implementation-defined.  Exception Name_Error is propagated if
          the string given as Source_Name does not identify an existing
          external ordinary or special file, or if the string given as
          Target_Name does not allow the identification of an external
          file.  The exception Use_Error is propagated if the external
          environment does not support creating the file with the name
          given by Target_Name and form given by Form, or copying of the
          file with the name given by Source_Name (in the absence of
          Name_Error).  If Use_Error is propagated, it is unspecified
          whether a portion of the file is copied.

70/2
The following file and directory name operations are provided:

71/2
     function Full_Name (Name : in String) return String;

72/2
          Returns the full name corresponding to the file name specified
          by Name.  The exception Name_Error is propagated if the string
          given as Name does not allow the identification of an external
          file (including directories and special files).

73/2
     function Simple_Name (Name : in String) return String;

74/2
          Returns the simple name portion of the file name specified by
          Name.  The exception Name_Error is propagated if the string
          given as Name does not allow the identification of an external
          file (including directories and special files).

75/2
     function Containing_Directory (Name : in String) return String;

76/2
          Returns the name of the containing directory of the external
          file (including directories) identified by Name.  (If more
          than one directory can contain Name, the directory name
          returned is implementation-defined.)  The exception Name_Error
          is propagated if the string given as Name does not allow the
          identification of an external file.  The exception Use_Error
          is propagated if the external file does not have a containing
          directory.

77/2
     function Extension (Name : in String) return String;

78/2
          Returns the extension name corresponding to Name.  The
          extension name is a portion of a simple name (not including
          any separator characters), typically used to identify the file
          class.  If the external environment does not have extension
          names, then the null string is returned.  The exception
          Name_Error is propagated if the string given as Name does not
          allow the identification of an external file.

79/2
     function Base_Name (Name : in String) return String;

80/2
          Returns the base name corresponding to Name.  The base name is
          the remainder of a simple name after removing any extension
          and extension separators.  The exception Name_Error is
          propagated if the string given as Name does not allow the
          identification of an external file (including directories and
          special files).

81/2
     function Compose (Containing_Directory : in String := "";
                       Name                 : in String;
                       Extension            : in String := "") return String;

82/3
          Returns the name of the external file with the specified
          Containing_Directory, Name, and Extension.  If Extension is
          the null string, then Name is interpreted as a simple name;
          otherwise, Name is interpreted as a base name.  The exception
          Name_Error is propagated if the string given as
          Containing_Directory is not null and does not allow the
          identification of a directory, or if the string given as
          Extension is not null and is not a possible extension, or if
          the string given as Name is not a possible simple name (if
          Extension is null) or base name (if Extension is nonnull).

82.1/3
     function Name_Case_Equivalence (Name : in String) return Name_Case_Kind;

82.2/3
          Returns the file name equivalence rule for the directory
          containing Name.  Raises Name_Error if Name is not a full
          name.  Returns Case_Sensitive if file names that differ only
          in the case of letters are considered different names.  If
          file names that differ only in the case of letters are
          considered the same name, then Case_Preserving is returned if
          names have the case of the file name used when a file is
          created; and Case_Insensitive is returned otherwise.  Returns
          Unknown if the file name equivalence is not known.

83/2
The following file and directory queries and types are provided:

84/2
     type File_Kind is (Directory, Ordinary_File, Special_File);

85/2
          The type File_Kind represents the kind of file represented by
          an external file or directory.

86/2
     type File_Size is range 0 .. implementation-defined;

87/2
          The type File_Size represents the size of an external file.

88/2
     function Exists (Name : in String) return Boolean;

89/2
          Returns True if an external file represented by Name exists,
          and False otherwise.  The exception Name_Error is propagated
          if the string given as Name does not allow the identification
          of an external file (including directories and special files).

90/2
     function Kind (Name : in String) return File_Kind;

91/2
          Returns the kind of external file represented by Name.  The
          exception Name_Error is propagated if the string given as Name
          does not allow the identification of an existing external
          file.

92/2
     function Size (Name : in String) return File_Size;

93/2
          Returns the size of the external file represented by Name.
          The size of an external file is the number of stream elements
          contained in the file.  If the external file is not an
          ordinary file, the result is implementation-defined.  The
          exception Name_Error is propagated if the string given as Name
          does not allow the identification of an existing external
          file.  The exception Constraint_Error is propagated if the
          file size is not a value of type File_Size.

94/2
     function Modification_Time (Name : in String) return Ada.Calendar.Time;

95/2
          Returns the time that the external file represented by Name
          was most recently modified.  If the external file is not an
          ordinary file, the result is implementation-defined.  The
          exception Name_Error is propagated if the string given as Name
          does not allow the identification of an existing external
          file.  The exception Use_Error is propagated if the external
          environment does not support reading the modification time of
          the file with the name given by Name (in the absence of
          Name_Error).

96/2
The following directory searching operations and types are provided:

97/2
     type Directory_Entry_Type is limited private;

98/2
          The type Directory_Entry_Type represents a single item in a
          directory.  These items can only be created by the
          Get_Next_Entry procedure in this package.  Information about
          the item can be obtained from the functions declared in this
          package.  A default-initialized object of this type is
          invalid; objects returned from Get_Next_Entry are valid.

99/2
     type Filter_Type is array (File_Kind) of Boolean;

100/2
          The type Filter_Type specifies which directory entries are
          provided from a search operation.  If the Directory component
          is True, directory entries representing directories are
          provided.  If the Ordinary_File component is True, directory
          entries representing ordinary files are provided.  If the
          Special_File component is True, directory entries representing
          special files are provided.

101/2
     type Search_Type is limited private;

102/2
          The type Search_Type contains the state of a directory search.
          A default-initialized Search_Type object has no entries
          available (function More_Entries returns False).  Type
          Search_Type needs finalization (see *note 7.6::).

103/2
     procedure Start_Search (Search    : in out Search_Type;
                             Directory : in String;
                             Pattern   : in String;
                             Filter    : in Filter_Type := (others => True));

104/3
          Starts a search in the directory named by Directory for
          entries matching Pattern and Filter.  Pattern represents a
          pattern for matching file names.  If Pattern is the null
          string, all items in the directory are matched; otherwise, the
          interpretation of Pattern is implementation-defined.  Only
          items that match Filter will be returned.  After a successful
          call on Start_Search, the object Search may have entries
          available, but it may have no entries available if no files or
          directories match Pattern and Filter.  The exception
          Name_Error is propagated if the string given by Directory does
          not identify an existing directory, or if Pattern does not
          allow the identification of any possible external file or
          directory.  The exception Use_Error is propagated if the
          external environment does not support the searching of the
          directory with the given name (in the absence of Name_Error).
          When Start_Search propagates Name_Error or Use_Error, the
          object Search will have no entries available.

105/2
     procedure End_Search (Search : in out Search_Type);

106/2
          Ends the search represented by Search.  After a successful
          call on End_Search, the object Search will have no entries
          available.

107/2
     function More_Entries (Search : in Search_Type) return Boolean;

108/2
          Returns True if more entries are available to be returned by a
          call to Get_Next_Entry for the specified search object, and
          False otherwise.

109/2
     procedure Get_Next_Entry (Search : in out Search_Type;
                               Directory_Entry : out Directory_Entry_Type);

110/3
          Returns the next Directory_Entry for the search described by
          Search that matches the pattern and filter.  If no further
          matches are available, Status_Error is raised.  It is
          implementation-defined as to whether the results returned by
          this subprogram are altered if the contents of the directory
          are altered while the Search object is valid (for example, by
          another program).  The exception Use_Error is propagated if
          the external environment does not support continued searching
          of the directory represented by Search.

111/2
     procedure Search (
         Directory : in String;
         Pattern   : in String;
         Filter    : in Filter_Type := (others => True);
         Process   : not null access procedure (
             Directory_Entry : in Directory_Entry_Type));

112/3
          Searches in the directory named by Directory for entries
          matching Pattern and Filter.  The subprogram designated by
          Process is called with each matching entry in turn.  Pattern
          represents a pattern for matching file names.  If Pattern is
          the null string, all items in the directory are matched;
          otherwise, the interpretation of Pattern is
          implementation-defined.  Only items that match Filter will be
          returned.  The exception Name_Error is propagated if the
          string given by Directory does not identify an existing
          directory, or if Pattern does not allow the identification of
          any possible external file or directory.  The exception
          Use_Error is propagated if the external environment does not
          support the searching of the directory with the given name (in
          the absence of Name_Error).

113/2
     function Simple_Name (Directory_Entry : in Directory_Entry_Type)
          return String;

114/2
          Returns the simple external name of the external file
          (including directories) represented by Directory_Entry.  The
          format of the name returned is implementation-defined.  The
          exception Status_Error is propagated if Directory_Entry is
          invalid.

115/2
     function Full_Name (Directory_Entry : in Directory_Entry_Type)
          return String;

116/2
          Returns the full external name of the external file (including
          directories) represented by Directory_Entry.  The format of
          the name returned is implementation-defined.  The exception
          Status_Error is propagated if Directory_Entry is invalid.

117/2
     function Kind (Directory_Entry : in Directory_Entry_Type)
          return File_Kind;

118/2
          Returns the kind of external file represented by
          Directory_Entry.  The exception Status_Error is propagated if
          Directory_Entry is invalid.

119/2
     function Size (Directory_Entry : in Directory_Entry_Type)
          return File_Size;

120/2
          Returns the size of the external file represented by
          Directory_Entry.  The size of an external file is the number
          of stream elements contained in the file.  If the external
          file represented by Directory_Entry is not an ordinary file,
          the result is implementation-defined.  The exception
          Status_Error is propagated if Directory_Entry is invalid.  The
          exception Constraint_Error is propagated if the file size is
          not a value of type File_Size.

121/2
     function Modification_Time (Directory_Entry : in Directory_Entry_Type)
          return Ada.Calendar.Time;

122/2
          Returns the time that the external file represented by
          Directory_Entry was most recently modified.  If the external
          file represented by Directory_Entry is not an ordinary file,
          the result is implementation-defined.  The exception
          Status_Error is propagated if Directory_Entry is invalid.  The
          exception Use_Error is propagated if the external environment
          does not support reading the modification time of the file
          represented by Directory_Entry.

                     _Implementation Requirements_

123/2
For Copy_File, if Source_Name identifies an existing external ordinary
file created by a predefined Ada input-output package, and Target_Name
and Form can be used in the Create operation of that input-output
package with mode Out_File without raising an exception, then Copy_File
shall not propagate Use_Error.

                        _Implementation Advice_

124/2
If other information about a file (such as the owner or creation date)
is available in a directory entry, the implementation should provide
functions in a child package Directories.Information to retrieve it.

125/3
Start_Search and Search should raise Name_Error if Pattern is malformed,
but not if it could represent a file in the directory but does not
actually do so.

126/2
Rename should be supported at least when both New_Name and Old_Name are
simple names and New_Name does not identify an existing external file.

     NOTES

127/2
     41  The operations Containing_Directory, Full_Name, Simple_Name,
     Base_Name, Extension, and Compose operate on file names, not
     external files.  The files identified by these operations do not
     need to exist.  Name_Error is raised only if the file name is
     malformed and cannot possibly identify a file.  Of these
     operations, only the result of Full_Name depends on the current
     default directory; the result of the others depends only on their
     parameters.

128/2
     42  Using access types, values of Search_Type and
     Directory_Entry_Type can be saved and queried later.  However,
     another task or application can modify or delete the file
     represented by a Directory_Entry_Type value or the directory
     represented by a Search_Type value; such a value can only give the
     information valid at the time it is created.  Therefore, long-term
     storage of these values is not recommended.

129/2
     43  If the target system does not support directories inside of
     directories, then Kind will never return Directory and
     Containing_Directory will always raise Use_Error.

130/2
     44  If the target system does not support creation or deletion of
     directories, then Create_Directory, Create_Path, Delete_Directory,
     and Delete_Tree will always propagate Use_Error.

131/2
     45  To move a file or directory to a different location, use
     Rename.  Most target systems will allow renaming of files from one
     directory to another.  If the target file or directory might
     already exist, it should be deleted first.

* Menu:

* A.16.1 ::   The Package Directories.Hierarchical_File_Names


File: arm2012.info,  Node: A.16.1,  Up: A.16

A.16.1 The Package Directories.Hierarchical_File_Names
------------------------------------------------------

1/3
The library package Directories.Hierarchical_File_Names is an optional
package providing operations for file name construction and
decomposition for targets with hierarchical file naming.

                          _Static Semantics_

2/3
If provided, the library package Directories.Hierarchical_File_Names has
the following declaration:

3/3
     package Ada.Directories.Hierarchical_File_Names is

4/3
        function Is_Simple_Name (Name : in String) return Boolean;

5/3
        function Is_Root_Directory_Name (Name : in String) return Boolean;

6/3
        function Is_Parent_Directory_Name (Name : in String) return Boolean;

7/3
        function Is_Current_Directory_Name (Name : in String) return Boolean;

8/3
        function Is_Full_Name (Name : in String) return Boolean;

9/3
        function Is_Relative_Name (Name : in String) return Boolean;

10/3
        function Simple_Name (Name : in String) return String
           renames Ada.Directories.Simple_Name;

11/3
        function Containing_Directory (Name : in String) return String
           renames Ada.Directories.Containing_Directory;

12/3
        function Initial_Directory (Name : in String) return String;

13/3
        function Relative_Name (Name : in String) return String;

14/3
        function Compose (Directory      : in String := "";
                          Relative_Name  : in String;
                          Extension      : in String := "") return String;

15/3
     end Ada.Directories.Hierarchical_File_Names;

16/3
In addition to the operations provided in package
Directories.Hierarchical_File_Names, the operations in package
Directories can be used with hierarchical file names.  In particular,
functions Full_Name, Base_Name, and Extension provide additional
capabilities for hierarchical file names.

17/3
     function Is_Simple_Name (Name : in String) return Boolean;

18/3
          Returns True if Name is a simple name, and returns False
          otherwise.

19/3
     function Is_Root_Directory_Name (Name : in String) return Boolean;

20/3
          Returns True if Name is syntactically a root (a directory that
          cannot be decomposed further), and returns False otherwise.

21/3
     function Is_Parent_Directory_Name (Name : in String) return Boolean;

22/3
          Returns True if Name can be used to indicate symbolically the
          parent directory of any directory, and returns False
          otherwise.

23/3
     function Is_Current_Directory_Name (Name : in String) return Boolean;

24/3
          Returns True if Name can be used to indicate symbolically the
          directory itself for any directory, and returns False
          otherwise.

25/3
     function Is_Full_Name (Name : in String) return Boolean;

26/3
          Returns True if the leftmost directory part of Name is a root,
          and returns False otherwise.

27/3
     function Is_Relative_Name (Name : in String) return Boolean;

28/3
          Returns True if Name allows the identification of an external
          file (including directories and special files) but is not a
          full name, and returns False otherwise.

29/3
     function Initial_Directory (Name : in String) return String;

30/3
          Returns the leftmost directory part in Name.  That is, it
          returns a root directory name (for a full name), or one of a
          parent directory name, a current directory name, or a simple
          name (for a relative name).  The exception Name_Error is
          propagated if the string given as Name does not allow the
          identification of an external file (including directories and
          special files).

31/3
     function Relative_Name (Name : in String) return String;

32/3
          Returns the entire file name except the Initial_Directory
          portion.  The exception Name_Error is propagated if the string
          given as Name does not allow the identification of an external
          file (including directories and special files), or if Name has
          a single part (this includes if any of Is_Simple_Name,
          Is_Root_Directory_Name, Is_Parent_Directory_Name, or
          Is_Current_Directory_Name are True).

33/3
     function Compose (Directory      : in String := "";
                       Relative_Name  : in String;
                       Extension      : in String := "") return String;

34/3
          Returns the name of the external file with the specified
          Directory, Relative_Name, and Extension.  The exception
          Name_Error is propagated if the string given as Directory is
          not the null string and does not allow the identification of a
          directory, or if Is_Relative_Name (Relative_Name) is False, or
          if the string given as Extension is not the null string and is
          not a possible extension, or if Extension is not the null
          string and Simple_Name (Relative_Name) is not a base name.

35/3
          The result of Compose is a full name if Is_Full_Name
          (Directory) is True; result is a relative name otherwise.

                        _Implementation Advice_

36/3
Directories.Hierarchical_File_Names should be provided for systems with
hierarchical file naming, and should not be provided on other systems.

     NOTES

37/3
     46  These operations operate on file names, not external files.
     The files identified by these operations do not need to exist.
     Name_Error is raised only as specified or if the file name is
     malformed and cannot possibly identify a file.  The result of these
     operations depends only on their parameters.

38/3
     47  Containing_Directory raises Use_Error if Name does not have a
     containing directory, including when any of Is_Simple_Name,
     Is_Root_Directory_Name, Is_Parent_Directory_Name, or
     Is_Current_Directory_Name are True.


File: arm2012.info,  Node: A.17,  Next: A.18,  Prev: A.16,  Up: Annex A

A.17 The Package Environment_Variables
======================================

1/2
The package Environment_Variables allows a program to read or modify
environment variables.  Environment variables are name-value pairs,
where both the name and value are strings.  The definition of what
constitutes an environment variable, and the meaning of the name and
value, are implementation defined.

                          _Static Semantics_

2/2
The library package Environment_Variables has the following declaration:

3/2
     package Ada.Environment_Variables is
        pragma Preelaborate(Environment_Variables);

4/2
        function Value (Name : in String) return String;

4.1/3
        function Value (Name : in String; Default : in String) return String;

5/2
        function Exists (Name : in String) return Boolean;

6/2
        procedure Set (Name : in String; Value : in String);

7/2
        procedure Clear (Name : in String);
        procedure Clear;

8/3
        procedure Iterate
           (Process : not null access procedure (Name, Value : in String));

9/2
     end Ada.Environment_Variables;

10/2
     function Value (Name : in String) return String;

11/2
          If the external execution environment supports environment
          variables, then Value returns the value of the environment
          variable with the given name.  If no environment variable with
          the given name exists, then Constraint_Error is propagated.
          If the execution environment does not support environment
          variables, then Program_Error is propagated.

11.1/3
     function Value (Name : in String; Default : in String) return String;

11.2/3
          If the external execution environment supports environment
          variables and an environment variable with the given name
          currently exists, then Value returns its value; otherwise, it
          returns Default.

12/2
     function Exists (Name : in String) return Boolean;

13/3
          If the external execution environment supports environment
          variables and an environment variable with the given name
          currently exists, then Exists returns True; otherwise, it
          returns False.

14/2
     procedure Set (Name : in String; Value : in String);

15/3
          If the external execution environment supports environment
          variables, then Set first clears any existing environment
          variable with the given name, and then defines a single new
          environment variable with the given name and value.
          Otherwise, Program_Error is propagated.

16/2
          If implementation-defined circumstances prohibit the
          definition of an environment variable with the given name and
          value, then Constraint_Error is propagated.

17/2
          It is implementation defined whether there exist values for
          which the call Set(Name, Value) has the same effect as Clear
          (Name).

18/2
     procedure Clear (Name : in String);

19/3
          If the external execution environment supports environment
          variables, then Clear deletes all existing environment
          variables with the given name.  Otherwise, Program_Error is
          propagated.

20/2
     procedure Clear;

21/3
          If the external execution environment supports environment
          variables, then Clear deletes all existing environment
          variables.  Otherwise, Program_Error is propagated.

22/3
     procedure Iterate
        (Process : not null access procedure (Name, Value : in String));

23/3
          If the external execution environment supports environment
          variables, then Iterate calls the subprogram designated by
          Process for each existing environment variable, passing the
          name and value of that environment variable.  Otherwise,
          Program_Error is propagated.

24/2
          If several environment variables exist that have the same
          name, Process is called once for each such variable.

                      _Bounded (Run-Time) Errors_

25/2
It is a bounded error to call Value if more than one environment
variable exists with the given name; the possible outcomes are that:

26/2
   * one of the values is returned, and that same value is returned in
     subsequent calls in the absence of changes to the environment; or

27/2
   * Program_Error is propagated.

                         _Erroneous Execution_

28/2
Making calls to the procedures Set or Clear concurrently with calls to
any subprogram of package Environment_Variables, or to any instantiation
of Iterate, results in erroneous execution.

29/2
Making calls to the procedures Set or Clear in the actual subprogram
corresponding to the Process parameter of Iterate results in erroneous
execution.

                     _Documentation Requirements_

30/2
An implementation shall document how the operations of this package
behave if environment variables are changed by external mechanisms (for
instance, calling operating system services).

                     _Implementation Permissions_

31/2
An implementation running on a system that does not support environment
variables is permitted to define the operations of package
Environment_Variables with the semantics corresponding to the case where
the external execution environment does support environment variables.
In this case, it shall provide a mechanism to initialize a nonempty set
of environment variables prior to the execution of a partition.

                        _Implementation Advice_

32/2
If the execution environment supports subprocesses, the currently
defined environment variables should be used to initialize the
environment variables of a subprocess.

33/2
Changes to the environment variables made outside the control of this
package should be reflected immediately in the effect of the operations
of this package.  Changes to the environment variables made using this
package should be reflected immediately in the external execution
environment.  This package should not perform any buffering of the
environment variables.


File: arm2012.info,  Node: A.18,  Next: A.19,  Prev: A.17,  Up: Annex A

A.18 Containers
===============

1/2
This clause presents the specifications of the package Containers and
several child packages, which provide facilities for storing collections
of elements.

2/2
A variety of sequence and associative containers are provided.  Each
container includes a cursor type.  A cursor is a reference to an element
within a container.  Many operations on cursors are common to all of the
containers.  A cursor referencing an element in a container is
considered to be overlapping with the container object itself. 

3/2
Within this clause we provide Implementation Advice for the desired
average or worst case time complexity of certain operations on a
container.  This advice is expressed using the Landau symbol O(X).
Presuming f is some function of a length parameter N and t(N) is the
time the operation takes (on average or worst case, as specified) for
the length N, a complexity of O(f(N)) means that there exists a finite A
such that for any N, t(N)/f(N) < A. 

4/2
If the advice suggests that the complexity should be less than O(f(N)),
then for any arbitrarily small positive real D, there should exist a
positive integer M such that for all N > M, t(N)/f(N) < D.

5/3
When a formal function is used to provide an ordering for a container,
it is generally required to define a strict weak ordering.  A function
"<" defines a strict weak ordering if it is irreflexive, asymmetric,
transitive, and in addition, if x < y for any values x and y, then for
all other values z, (x < z) or (z < y).

                          _Static Semantics_

6/4
Certain subprograms declared within instances of some of the generic
packages presented in this clause are said to perform indefinite
insertion.  These subprograms are those corresponding (in the sense of
the copying described in subclause *note 12.3::) to subprograms that
have formal parameters of a generic formal indefinite type and that are
identified as performing indefinite insertion in the subclause defining
the generic package.

7/4
If a subprogram performs indefinite insertion, then certain run-time
checks are performed as part of a call to the subprogram; if any of
these checks fail, then the resulting exception is propagated to the
caller and the container is not modified by the call.  These checks are
performed for each parameter corresponding (in the sense of the copying
described in *note 12.3::) to a parameter in the corresponding generic
whose type is a generic formal indefinite type.  The checks performed
for a given parameter are those checks explicitly specified in subclause
*note 4.8:: that would be performed as part of the evaluation of an
initialized allocator whose access type is declared immediately within
the instance, where:

8/4
   * the value of the qualified_expression is that of the parameter; and

9/4
   * the designated subtype of the access type is the subtype of the
     parameter; and

10/4
   * finalization of the collection of the access type has started if
     and only if the finalization of the instance has started.

* Menu:

* A.18.1 ::   The Package Containers
* A.18.2 ::   The Generic Package Containers.Vectors
* A.18.3 ::   The Generic Package Containers.Doubly_Linked_Lists
* A.18.4 ::   Maps
* A.18.5 ::   The Generic Package Containers.Hashed_Maps
* A.18.6 ::   The Generic Package Containers.Ordered_Maps
* A.18.7 ::   Sets
* A.18.8 ::   The Generic Package Containers.Hashed_Sets
* A.18.9 ::   The Generic Package Containers.Ordered_Sets
* A.18.10 ::  The Generic Package Containers.Multiway_Trees
* A.18.11 ::  The Generic Package Containers.Indefinite_Vectors
* A.18.12 ::  The Generic Package Containers.Indefinite_Doubly_Linked_Lists
* A.18.13 ::  The Generic Package Containers.Indefinite_Hashed_Maps
* A.18.14 ::  The Generic Package Containers.Indefinite_Ordered_Maps
* A.18.15 ::  The Generic Package Containers.Indefinite_Hashed_Sets
* A.18.16 ::  The Generic Package Containers.Indefinite_Ordered_Sets
* A.18.17 ::  The Generic Package Containers.Indefinite_Multiway_Trees
* A.18.18 ::  The Generic Package Containers.Indefinite_Holders
* A.18.19 ::  The Generic Package Containers.Bounded_Vectors
* A.18.20 ::  The Generic Package Containers.Bounded_Doubly_Linked_Lists
* A.18.21 ::  The Generic Package Containers.Bounded_Hashed_Maps
* A.18.22 ::  The Generic Package Containers.Bounded_Ordered_Maps
* A.18.23 ::  The Generic Package Containers.Bounded_Hashed_Sets
* A.18.24 ::  The Generic Package Containers.Bounded_Ordered_Sets
* A.18.25 ::  The Generic Package Containers.Bounded_Multiway_Trees
* A.18.26 ::  Array Sorting
* A.18.27 ::  The Generic Package Containers.Synchronized_Queue_Interfaces
* A.18.28 ::  The Generic Package Containers.Unbounded_Synchronized_Queues
* A.18.29 ::  The Generic Package Containers.Bounded_Synchronized_Queues
* A.18.30 ::  The Generic Package Containers.Unbounded_Priority_Queues
* A.18.31 ::  The Generic Package Containers.Bounded_Priority_Queues
* A.18.32 ::  Example of Container Use


File: arm2012.info,  Node: A.18.1,  Next: A.18.2,  Up: A.18

A.18.1 The Package Containers
-----------------------------

1/2
The package Containers is the root of the containers subsystem.

                          _Static Semantics_

2/2
The library package Containers has the following declaration:

3/2
     package Ada.Containers is
        pragma Pure(Containers);

4/2
        type Hash_Type is mod implementation-defined;

5/2
        type Count_Type is range 0 .. implementation-defined;

5.1/3
        Capacity_Error : exception;

6/2
     end Ada.Containers;

7/2
Hash_Type represents the range of the result of a hash function.
Count_Type represents the (potential or actual) number of elements of a
container.

7.1/3
Capacity_Error is raised when the capacity of a container is exceeded.

                        _Implementation Advice_

8/2
Hash_Type'Modulus should be at least 2**32.  Count_Type'Last should be
at least 2**31-1.


File: arm2012.info,  Node: A.18.2,  Next: A.18.3,  Prev: A.18.1,  Up: A.18

A.18.2 The Generic Package Containers.Vectors
---------------------------------------------

1/2
The language-defined generic package Containers.Vectors provides private
types Vector and Cursor, and a set of operations for each type.  A
vector container allows insertion and deletion at any position, but it
is specifically optimized for insertion and deletion at the high end
(the end with the higher index) of the container.  A vector container
also provides random access to its elements. 

2/2
A vector container behaves conceptually as an array that expands as
necessary as items are inserted.  The length of a vector is the number
of elements that the vector contains.  The capacity of a vector is the
maximum number of elements that can be inserted into the vector prior to
it being automatically expanded.

3/2
Elements in a vector container can be referred to by an index value of a
generic formal type.  The first element of a vector always has its index
value equal to the lower bound of the formal type.

4/2
A vector container may contain empty elements.  Empty elements do not
have a specified value.

                          _Static Semantics_

5/2
The generic library package Containers.Vectors has the following
declaration:

6/3
     with Ada.Iterator_Interfaces;
     generic
        type Index_Type is range <>;
        type Element_Type is private;
        with function "=" (Left, Right : Element_Type)
           return Boolean is <>;
     package Ada.Containers.Vectors is
        pragma Preelaborate(Vectors);
        pragma Remote_Types(Vectors);

7/2
        subtype Extended_Index is
           Index_Type'Base range
              Index_Type'First-1 ..
              Index_Type'Min (Index_Type'Base'Last - 1, Index_Type'Last) + 1;
        No_Index : constant Extended_Index := Extended_Index'First;

8/3
        type Vector is tagged private
           with Constant_Indexing => Constant_Reference,
                Variable_Indexing => Reference,
                Default_Iterator  => Iterate,
                Iterator_Element  => Element_Type;
        pragma Preelaborable_Initialization(Vector);

9/2
        type Cursor is private;
        pragma Preelaborable_Initialization(Cursor);

10/2
        Empty_Vector : constant Vector;

11/2
        No_Element : constant Cursor;

11.1/3
        function Has_Element (Position : Cursor) return Boolean;

11.2/3
        package Vector_Iterator_Interfaces is new
            Ada.Iterator_Interfaces (Cursor, Has_Element);

12/2
        function "=" (Left, Right : Vector) return Boolean;

13/2
        function To_Vector (Length : Count_Type) return Vector;

14/2
        function To_Vector
          (New_Item : Element_Type;
           Length   : Count_Type) return Vector;

15/2
        function "&" (Left, Right : Vector) return Vector;

16/2
        function "&" (Left  : Vector;
                      Right : Element_Type) return Vector;

17/2
        function "&" (Left  : Element_Type;
                      Right : Vector) return Vector;

18/2
        function "&" (Left, Right  : Element_Type) return Vector;

19/2
        function Capacity (Container : Vector) return Count_Type;

20/2
        procedure Reserve_Capacity (Container : in out Vector;
                                    Capacity  : in     Count_Type);

21/2
        function Length (Container : Vector) return Count_Type;

22/2
        procedure Set_Length (Container : in out Vector;
                              Length    : in     Count_Type);

23/2
        function Is_Empty (Container : Vector) return Boolean;

24/2
        procedure Clear (Container : in out Vector);

25/2
        function To_Cursor (Container : Vector;
                            Index     : Extended_Index) return Cursor;

26/2
        function To_Index (Position  : Cursor) return Extended_Index;

27/2
        function Element (Container : Vector;
                          Index     : Index_Type)
           return Element_Type;

28/2
        function Element (Position : Cursor) return Element_Type;

29/2
        procedure Replace_Element (Container : in out Vector;
                                   Index     : in     Index_Type;
                                   New_Item  : in     Element_Type);

30/2
        procedure Replace_Element (Container : in out Vector;
                                   Position  : in     Cursor;
                                   New_item  : in     Element_Type);

31/2
        procedure Query_Element
          (Container : in Vector;
           Index     : in Index_Type;
           Process   : not null access procedure (Element : in Element_Type));

32/2
        procedure Query_Element
          (Position : in Cursor;
           Process  : not null access procedure (Element : in Element_Type));

33/2
        procedure Update_Element
          (Container : in out Vector;
           Index     : in     Index_Type;
           Process   : not null access procedure
                           (Element : in out Element_Type));

34/2
        procedure Update_Element
          (Container : in out Vector;
           Position  : in     Cursor;
           Process   : not null access procedure
                           (Element : in out Element_Type));

34.1/3
        type Constant_Reference_Type
              (Element : not null access constant Element_Type) is private
           with Implicit_Dereference => Element;

34.2/3
        type Reference_Type (Element : not null access Element_Type) is private
           with Implicit_Dereference => Element;

34.3/3
        function Constant_Reference (Container : aliased in Vector;
                                     Index     : in Index_Type)
           return Constant_Reference_Type;

34.4/3
        function Reference (Container : aliased in out Vector;
                            Index     : in Index_Type)
           return Reference_Type;

34.5/3
        function Constant_Reference (Container : aliased in Vector;
                                     Position  : in Cursor)
           return Constant_Reference_Type;

34.6/3
        function Reference (Container : aliased in out Vector;
                            Position  : in Cursor)
           return Reference_Type;

34.7/3
        procedure Assign (Target : in out Vector; Source : in Vector);

34.8/3
        function Copy (Source : Vector; Capacity : Count_Type := 0)
           return Vector;

35/2
        procedure Move (Target : in out Vector;
                        Source : in out Vector);

36/2
        procedure Insert (Container : in out Vector;
                          Before    : in     Extended_Index;
                          New_Item  : in     Vector);

37/2
        procedure Insert (Container : in out Vector;
                          Before    : in     Cursor;
                          New_Item  : in     Vector);

38/2
        procedure Insert (Container : in out Vector;
                          Before    : in     Cursor;
                          New_Item  : in     Vector;
                          Position  :    out Cursor);

39/2
        procedure Insert (Container : in out Vector;
                          Before    : in     Extended_Index;
                          New_Item  : in     Element_Type;
                          Count     : in     Count_Type := 1);

40/2
        procedure Insert (Container : in out Vector;
                          Before    : in     Cursor;
                          New_Item  : in     Element_Type;
                          Count     : in     Count_Type := 1);

41/2
        procedure Insert (Container : in out Vector;
                          Before    : in     Cursor;
                          New_Item  : in     Element_Type;
                          Position  :    out Cursor;
                          Count     : in     Count_Type := 1);

42/2
        procedure Insert (Container : in out Vector;
                          Before    : in     Extended_Index;
                          Count     : in     Count_Type := 1);

43/2
        procedure Insert (Container : in out Vector;
                          Before    : in     Cursor;
                          Position  :    out Cursor;
                          Count     : in     Count_Type := 1);

44/2
        procedure Prepend (Container : in out Vector;
                           New_Item  : in     Vector);

45/2
        procedure Prepend (Container : in out Vector;
                           New_Item  : in     Element_Type;
                           Count     : in     Count_Type := 1);

46/2
        procedure Append (Container : in out Vector;
                          New_Item  : in     Vector);

47/2
        procedure Append (Container : in out Vector;
                          New_Item  : in     Element_Type;
                          Count     : in     Count_Type := 1);

48/2
        procedure Insert_Space (Container : in out Vector;
                                Before    : in     Extended_Index;
                                Count     : in     Count_Type := 1);

49/2
        procedure Insert_Space (Container : in out Vector;
                                Before    : in     Cursor;
                                Position  :    out Cursor;
                                Count     : in     Count_Type := 1);

50/2
        procedure Delete (Container : in out Vector;
                          Index     : in     Extended_Index;
                          Count     : in     Count_Type := 1);

51/2
        procedure Delete (Container : in out Vector;
                          Position  : in out Cursor;
                          Count     : in     Count_Type := 1);

52/2
        procedure Delete_First (Container : in out Vector;
                                Count     : in     Count_Type := 1);

53/2
        procedure Delete_Last (Container : in out Vector;
                               Count     : in     Count_Type := 1);

54/2
        procedure Reverse_Elements (Container : in out Vector);

55/2
        procedure Swap (Container : in out Vector;
                        I, J      : in     Index_Type);

56/2
        procedure Swap (Container : in out Vector;
                        I, J      : in     Cursor);

57/2
        function First_Index (Container : Vector) return Index_Type;

58/2
        function First (Container : Vector) return Cursor;

59/2
        function First_Element (Container : Vector)
           return Element_Type;

60/2
        function Last_Index (Container : Vector) return Extended_Index;

61/2
        function Last (Container : Vector) return Cursor;

62/2
        function Last_Element (Container : Vector)
           return Element_Type;

63/2
        function Next (Position : Cursor) return Cursor;

64/2
        procedure Next (Position : in out Cursor);

65/2
        function Previous (Position : Cursor) return Cursor;

66/2
        procedure Previous (Position : in out Cursor);

67/2
        function Find_Index (Container : Vector;
                             Item      : Element_Type;
                             Index     : Index_Type := Index_Type'First)
           return Extended_Index;

68/2
        function Find (Container : Vector;
                       Item      : Element_Type;
                       Position  : Cursor := No_Element)
           return Cursor;

69/2
        function Reverse_Find_Index (Container : Vector;
                                     Item      : Element_Type;
                                     Index     : Index_Type := Index_Type'Last)
           return Extended_Index;

70/2
        function Reverse_Find (Container : Vector;
                               Item      : Element_Type;
                               Position  : Cursor := No_Element)
           return Cursor;

71/2
        function Contains (Container : Vector;
                           Item      : Element_Type) return Boolean;

72/3
     This paragraph was deleted.

73/2
        procedure  Iterate
          (Container : in Vector;
           Process   : not null access procedure (Position : in Cursor));

74/2
        procedure Reverse_Iterate
          (Container : in Vector;
           Process   : not null access procedure (Position : in Cursor));

74.1/3
        function Iterate (Container : in Vector)
           return Vector_Iterator_Interfaces.Reversible_Iterator'Class;

74.2/3
        function Iterate (Container : in Vector; Start : in Cursor)
           return Vector_Iterator_Interfaces.Reversible_Iterator'Class;

75/2
        generic
           with function "<" (Left, Right : Element_Type)
              return Boolean is <>;
        package Generic_Sorting is

76/2
           function Is_Sorted (Container : Vector) return Boolean;

77/2
           procedure Sort (Container : in out Vector);

78/2
           procedure Merge (Target  : in out Vector;
                            Source  : in out Vector);

79/2
        end Generic_Sorting;

80/2
     private

81/2
        ... -- not specified by the language

82/2
     end Ada.Containers.Vectors;

83/2
The actual function for the generic formal function "=" on Element_Type
values is expected to define a reflexive and symmetric relationship and
return the same result value each time it is called with a particular
pair of values.  If it behaves in some other manner, the functions
defined to use it return an unspecified value.  The exact arguments and
number of calls of this generic formal function by the functions defined
to use it are unspecified.

84/2
The type Vector is used to represent vectors.  The type Vector needs
finalization (see *note 7.6::).

85/2
Empty_Vector represents the empty vector object.  It has a length of 0.
If an object of type Vector is not otherwise initialized, it is
initialized to the same value as Empty_Vector.

86/2
No_Element represents a cursor that designates no element.  If an object
of type Cursor is not otherwise initialized, it is initialized to the
same value as No_Element.

87/2
The predefined "=" operator for type Cursor returns True if both cursors
are No_Element, or designate the same element in the same container.

88/2
Execution of the default implementation of the Input, Output, Read, or
Write attribute of type Cursor raises Program_Error.

88.1/3
Vector'Write for a Vector object V writes Length(V) elements of the
vector to the stream.  It also may write additional information about
the vector.

88.2/3
Vector'Read reads the representation of a vector from the stream, and
assigns to Item a vector with the same length and elements as was
written by Vector'Write.

89/2
No_Index represents a position that does not correspond to any element.
The subtype Extended_Index includes the indices covered by Index_Type
plus the value No_Index and, if it exists, the successor to the
Index_Type'Last.

89.1/3
If an operation attempts to modify the vector such that the position of
the last element would be greater than Index_Type'Last, then the
operation propagates Constraint_Error.

90/2
Some operations of this generic package have access-to-subprogram
parameters.  To ensure such operations are well-defined, they guard
against certain actions by the designated subprogram.  In particular,
some operations check for "tampering with cursors" of a container
because they depend on the set of elements of the container remaining
constant, and others check for "tampering with elements" of a container
because they depend on elements of the container not being replaced.

91/2
A subprogram is said to tamper with cursors of a vector object V if:

92/2
   * it inserts or deletes elements of V, that is, it calls the Insert,
     Insert_Space, Clear, Delete, or Set_Length procedures with V as a
     parameter; or

93/2
   * it finalizes V; or

93.1/3
   * it calls the Assign procedure with V as the Target parameter; or

94/2
   * it calls the Move procedure with V as a parameter.

95/2
A subprogram is said to tamper with elements of a vector object V if:

96/2
   * it tampers with cursors of V; or

97/2
   * it replaces one or more elements of V, that is, it calls the
     Replace_Element, Reverse_Elements, or Swap procedures or the Sort
     or Merge procedures of an instance of Generic_Sorting with V as a
     parameter.

97.1/4
When tampering with cursors is prohibited for a particular vector object
V, Program_Error is propagated by a call of any language-defined
subprogram that is defined to tamper with the cursors of V, leaving V
unmodified.  Similarly, when tampering with elements is prohibited for a
particular vector object V, Program_Error is propagated by a call of any
language-defined subprogram that is defined to tamper with the elements
of V (or tamper with the cursors of V), leaving V unmodified.  These
checks are made before any other defined behavior of the body of the
language-defined subprogram.

97.2/3
     function Has_Element (Position : Cursor) return Boolean;

97.3/3
          Returns True if Position designates an element, and returns
          False otherwise.

98/2
     function "=" (Left, Right : Vector) return Boolean;

99/3
          If Left and Right denote the same vector object, then the
          function returns True.  If Left and Right have different
          lengths, then the function returns False.  Otherwise, it
          compares each element in Left to the corresponding element in
          Right using the generic formal equality operator.  If any such
          comparison returns False, the function returns False;
          otherwise, it returns True.  Any exception raised during
          evaluation of element equality is propagated.

100/2
     function To_Vector (Length : Count_Type) return Vector;

101/2
          Returns a vector with a length of Length, filled with empty
          elements.

102/2
     function To_Vector
       (New_Item : Element_Type;
        Length   : Count_Type) return Vector;

103/2
          Returns a vector with a length of Length, filled with elements
          initialized to the value New_Item.

104/2
     function "&" (Left, Right : Vector) return Vector;

105/2
          Returns a vector comprising the elements of Left followed by
          the elements of Right.

106/2
     function "&" (Left  : Vector;
                   Right : Element_Type) return Vector;

107/2
          Returns a vector comprising the elements of Left followed by
          the element Right.

108/2
     function "&" (Left  : Element_Type;
                   Right : Vector) return Vector;

109/2
          Returns a vector comprising the element Left followed by the
          elements of Right.

110/2
     function "&" (Left, Right  : Element_Type) return Vector;

111/2
          Returns a vector comprising the element Left followed by the
          element Right.

112/2
     function Capacity (Container : Vector) return Count_Type;

113/2
          Returns the capacity of Container.

114/2
     procedure Reserve_Capacity (Container : in out Vector;
                                 Capacity  : in     Count_Type);

115/3
          If the capacity of Container is already greater than or equal
          to Capacity, then Reserve_Capacity has no effect.  Otherwise,
          Reserve_Capacity allocates additional storage as necessary to
          ensure that the length of the resulting vector can become at
          least the value Capacity without requiring an additional call
          to Reserve_Capacity, and is large enough to hold the current
          length of Container.  Reserve_Capacity then, as necessary,
          moves elements into the new storage and deallocates any
          storage no longer needed.  Any exception raised during
          allocation is propagated and Container is not modified.

116/2
     function Length (Container : Vector) return Count_Type;

117/2
          Returns the number of elements in Container.

118/2
     procedure Set_Length (Container : in out Vector;
                           Length    : in     Count_Type);

119/3
          If Length is larger than the capacity of Container, Set_Length
          calls Reserve_Capacity (Container, Length), then sets the
          length of the Container to Length.  If Length is greater than
          the original length of Container, empty elements are added to
          Container; otherwise, elements are removed from Container.

120/2
     function Is_Empty (Container : Vector) return Boolean;

121/2
          Equivalent to Length (Container) = 0.

122/2
     procedure Clear (Container : in out Vector);

123/2
          Removes all the elements from Container.  The capacity of
          Container does not change.

124/2
     function To_Cursor (Container : Vector;
                         Index     : Extended_Index) return Cursor;

125/2
          If Index is not in the range First_Index (Container) ..
          Last_Index (Container), then No_Element is returned.
          Otherwise, a cursor designating the element at position Index
          in Container is returned.

126/2
     function To_Index (Position  : Cursor) return Extended_Index;

127/2
          If Position is No_Element, No_Index is returned.  Otherwise,
          the index (within its containing vector) of the element
          designated by Position is returned.

128/2
     function Element (Container : Vector;
                       Index     : Index_Type)
        return Element_Type;

129/2
          If Index is not in the range First_Index (Container) ..
          Last_Index (Container), then Constraint_Error is propagated.
          Otherwise, Element returns the element at position Index.

130/2
     function Element (Position  : Cursor) return Element_Type;

131/2
          If Position equals No_Element, then Constraint_Error is
          propagated.  Otherwise, Element returns the element designated
          by Position.

132/2
     procedure Replace_Element (Container : in out Vector;
                                Index     : in     Index_Type;
                                New_Item  : in     Element_Type);

133/3
          If Index is not in the range First_Index (Container) ..
          Last_Index (Container), then Constraint_Error is propagated.
          Otherwise, Replace_Element assigns the value New_Item to the
          element at position Index.  Any exception raised during the
          assignment is propagated.  The element at position Index is
          not an empty element after successful call to Replace_Element.

134/2
     procedure Replace_Element (Container : in out Vector;
                                Position  : in     Cursor;
                                New_Item  : in     Element_Type);

135/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Replace_Element assigns New_Item to the element designated by
          Position.  Any exception raised during the assignment is
          propagated.  The element at Position is not an empty element
          after successful call to Replace_Element.

136/2
     procedure Query_Element
       (Container : in Vector;
        Index     : in Index_Type;
        Process   : not null access procedure (Element : in Element_Type));

137/3
          If Index is not in the range First_Index (Container) ..
          Last_Index (Container), then Constraint_Error is propagated.
          Otherwise, Query_Element calls Process.all with the element at
          position Index as the argument.  Tampering with the elements
          of Container is prohibited during the execution of the call on
          Process.all.  Any exception raised by Process.all is
          propagated.

138/2
     procedure Query_Element
       (Position : in Cursor;
        Process  : not null access procedure (Element : in Element_Type));

139/3
          If Position equals No_Element, then Constraint_Error is
          propagated.  Otherwise, Query_Element calls Process.all with
          the element designated by Position as the argument.  Tampering
          with the elements of the vector that contains the element
          designated by Position is prohibited during the execution of
          the call on Process.all.  Any exception raised by Process.all
          is propagated.

140/2
     procedure Update_Element
       (Container : in out Vector;
        Index     : in     Index_Type;
        Process   : not null access procedure (Element : in out Element_Type));

141/3
          If Index is not in the range First_Index (Container) ..
          Last_Index (Container), then Constraint_Error is propagated.
          Otherwise, Update_Element calls Process.all with the element
          at position Index as the argument.  Tampering with the
          elements of Container is prohibited during the execution of
          the call on Process.all.  Any exception raised by Process.all
          is propagated.

142/2
          If Element_Type is unconstrained and definite, then the actual
          Element parameter of Process.all shall be unconstrained.

143/2
          The element at position Index is not an empty element after
          successful completion of this operation.

144/2
     procedure Update_Element
       (Container : in out Vector;
        Position  : in     Cursor;
        Process   : not null access procedure (Element : in out Element_Type));

145/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Update_Element calls Process.all with the element designated
          by Position as the argument.  Tampering with the elements of
          Container is prohibited during the execution of the call on
          Process.all.  Any exception raised by Process.all is
          propagated.

146/2
          If Element_Type is unconstrained and definite, then the actual
          Element parameter of Process.all shall be unconstrained.

147/2
          The element designated by Position is not an empty element
          after successful completion of this operation.

147.1/3
     type Constant_Reference_Type
           (Element : not null access constant Element_Type) is private
        with Implicit_Dereference => Element;

147.2/3
     type Reference_Type (Element : not null access Element_Type) is private
        with Implicit_Dereference => Element;

147.3/3
          The types Constant_Reference_Type and Reference_Type need
          finalization.

147.4/3
          The default initialization of an object of type
          Constant_Reference_Type or Reference_Type propagates
          Program_Error.

147.5/3
     function Constant_Reference (Container : aliased in Vector;
                                  Index     : in Index_Type)
        return Constant_Reference_Type;

147.6/3
          This function (combined with the Constant_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read access to an individual element of a vector given an
          index value.

147.7/3
          If Index is not in the range First_Index (Container) ..
          Last_Index (Container), then Constraint_Error is propagated.
          Otherwise, Constant_Reference returns an object whose
          discriminant is an access value that designates the element at
          position Index.  Tampering with the elements of Container is
          prohibited while the object returned by Constant_Reference
          exists and has not been finalized.

147.8/3
     function Reference (Container : aliased in out Vector;
                         Index     : in Index_Type)
        return Reference_Type;

147.9/3
          This function (combined with the Variable_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read and write access to an individual element of a
          vector given an index value.

147.10/3
          If Index is not in the range First_Index (Container) ..
          Last_Index (Container), then Constraint_Error is propagated.
          Otherwise, Reference returns an object whose discriminant is
          an access value that designates the element at position Index.
          Tampering with the elements of Container is prohibited while
          the object returned by Reference exists and has not been
          finalized.

147.11/3
          The element at position Index is not an empty element after
          successful completion of this operation.

147.12/3
     function Constant_Reference (Container : aliased in Vector;
                                  Position  : in Cursor)
        return Constant_Reference_Type;

147.13/3
          This function (combined with the Constant_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read access to an individual element of a vector given a
          cursor.

147.14/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Constant_Reference returns an object whose discriminant is an
          access value that designates the element designated by
          Position.  Tampering with the elements of Container is
          prohibited while the object returned by Constant_Reference
          exists and has not been finalized.

147.15/3
     function Reference (Container : aliased in out Vector;
                         Position  : in Cursor)
        return Reference_Type;

147.16/3
          This function (combined with the Variable_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read and write access to an individual element of a
          vector given a cursor.

147.17/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Reference returns an object whose discriminant is an access
          value that designates the element designated by Position.
          Tampering with the elements of Container is prohibited while
          the object returned by Reference exists and has not been
          finalized.

147.18/3
          The element designated by Position is not an empty element
          after successful completion of this operation.

147.19/3
     procedure Assign (Target : in out Vector; Source : in Vector);

147.20/3
          If Target denotes the same object as Source, the operation has
          no effect.  If the length of Source is greater than the
          capacity of Target, Reserve_Capacity (Target, Length (Source))
          is called.  The elements of Source are then copied to Target
          as for an assignment_statement assigning Source to Target
          (this includes setting the length of Target to be that of
          Source).

147.21/3
     function Copy (Source : Vector; Capacity : Count_Type := 0)
        return Vector;

147.22/3
          Returns a vector whose elements are initialized from the
          corresponding elements of Source.  If Capacity is 0, then the
          vector capacity is the length of Source; if Capacity is equal
          to or greater than the length of Source, the vector capacity
          is at least the specified value.  Otherwise, the operation
          propagates Capacity_Error.

148/2
     procedure Move (Target : in out Vector;
                     Source : in out Vector);

149/3
          If Target denotes the same object as Source, then the
          operation has no effect.  Otherwise, Move first calls
          Reserve_Capacity (Target, Length (Source)) and then Clear
          (Target); then, each element from Source is removed from
          Source and inserted into Target in the original order.  The
          length of Source is 0 after a successful call to Move.

150/2
     procedure Insert (Container : in out Vector;
                       Before    : in     Extended_Index;
                       New_Item  : in     Vector);

151/3
          If Before is not in the range First_Index (Container) ..
          Last_Index (Container) + 1, then Constraint_Error is
          propagated.  If Length(New_Item) is 0, then Insert does
          nothing.  Otherwise, it computes the new length NL as the sum
          of the current length and Length (New_Item); if the value of
          Last appropriate for length NL would be greater than
          Index_Type'Last, then Constraint_Error is propagated.

152/2
          If the current vector capacity is less than NL,
          Reserve_Capacity (Container, NL) is called to increase the
          vector capacity.  Then Insert slides the elements in the range
          Before ..  Last_Index (Container) up by Length(New_Item)
          positions, and then copies the elements of New_Item to the
          positions starting at Before.  Any exception raised during the
          copying is propagated.

153/2
     procedure Insert (Container : in out Vector;
                       Before    : in     Cursor;
                       New_Item  : in     Vector);

154/3
          If Before is not No_Element, and does not designate an element
          in Container, then Program_Error is propagated.  Otherwise, if
          Length(New_Item) is 0, then Insert does nothing.  If Before is
          No_Element, then the call is equivalent to Insert (Container,
          Last_Index (Container) + 1, New_Item); otherwise, the call is
          equivalent to Insert (Container, To_Index (Before), New_Item);

155/2
     procedure Insert (Container : in out Vector;
                       Before    : in     Cursor;
                       New_Item  : in     Vector;
                       Position  :    out Cursor);

156/2
          If Before is not No_Element, and does not designate an element
          in Container, then Program_Error is propagated.  If Before
          equals No_Element, then let T be Last_Index (Container) + 1;
          otherwise, let T be To_Index (Before).  Insert (Container, T,
          New_Item) is called, and then Position is set to To_Cursor
          (Container, T).

157/2
     procedure Insert (Container : in out Vector;
                       Before    : in     Extended_Index;
                       New_Item  : in     Element_Type;
                       Count     : in     Count_Type := 1);

158/2
          Equivalent to Insert (Container, Before, To_Vector (New_Item,
          Count));

159/2
     procedure Insert (Container : in out Vector;
                       Before    : in     Cursor;
                       New_Item  : in     Element_Type;
                       Count     : in     Count_Type := 1);

160/2
          Equivalent to Insert (Container, Before, To_Vector (New_Item,
          Count));

161/2
     procedure Insert (Container : in out Vector;
                       Before    : in     Cursor;
                       New_Item  : in     Element_Type;
                       Position  :    out Cursor;
                       Count     : in     Count_Type := 1);

162/2
          Equivalent to Insert (Container, Before, To_Vector (New_Item,
          Count), Position);

163/2
     procedure Insert (Container : in out Vector;
                       Before    : in     Extended_Index;
                       Count     : in     Count_Type := 1);

164/3
          If Before is not in the range First_Index (Container) ..
          Last_Index (Container) + 1, then Constraint_Error is
          propagated.  If Count is 0, then Insert does nothing.
          Otherwise, it computes the new length NL as the sum of the
          current length and Count; if the value of Last appropriate for
          length NL would be greater than Index_Type'Last, then
          Constraint_Error is propagated.

165/2
          If the current vector capacity is less than NL,
          Reserve_Capacity (Container, NL) is called to increase the
          vector capacity.  Then Insert slides the elements in the range
          Before ..  Last_Index (Container) up by Count positions, and
          then inserts elements that are initialized by default (see
          *note 3.3.1::) in the positions starting at Before.

166/2
     procedure Insert (Container : in out Vector;
                       Before    : in     Cursor;
                       Position  :    out Cursor;
                       Count     : in     Count_Type := 1);

167/2
          If Before is not No_Element, and does not designate an element
          in Container, then Program_Error is propagated.  If Before
          equals No_Element, then let T be Last_Index (Container) + 1;
          otherwise, let T be To_Index (Before).  Insert (Container, T,
          Count) is called, and then Position is set to To_Cursor
          (Container, T).

168/4
     procedure Prepend (Container : in out Vector;
                        New_Item  : in     Vector);

169/2
          Equivalent to Insert (Container, First_Index (Container),
          New_Item).

170/2
     procedure Prepend (Container : in out Vector;
                        New_Item  : in     Element_Type;
                        Count     : in     Count_Type := 1);

171/2
          Equivalent to Insert (Container, First_Index (Container),
          New_Item, Count).

172/2
     procedure Append (Container : in out Vector;
                       New_Item  : in     Vector);

173/2
          Equivalent to Insert (Container, Last_Index (Container) + 1,
          New_Item).

174/2
     procedure Append (Container : in out Vector;
                       New_Item  : in     Element_Type;
                       Count     : in     Count_Type := 1);

175/2
          Equivalent to Insert (Container, Last_Index (Container) + 1,
          New_Item, Count).

176/2
     procedure Insert_Space (Container : in out Vector;
                             Before    : in     Extended_Index;
                             Count     : in     Count_Type := 1);

177/3
          If Before is not in the range First_Index (Container) ..
          Last_Index (Container) + 1, then Constraint_Error is
          propagated.  If Count is 0, then Insert_Space does nothing.
          Otherwise, it computes the new length NL as the sum of the
          current length and Count; if the value of Last appropriate for
          length NL would be greater than Index_Type'Last, then
          Constraint_Error is propagated.

178/2
          If the current vector capacity is less than NL,
          Reserve_Capacity (Container, NL) is called to increase the
          vector capacity.  Then Insert_Space slides the elements in the
          range Before ..  Last_Index (Container) up by Count positions,
          and then inserts empty elements in the positions starting at
          Before.

179/2
     procedure Insert_Space (Container : in out Vector;
                             Before    : in     Cursor;
                             Position  :    out Cursor;
                             Count     : in     Count_Type := 1);

180/2
          If Before is not No_Element, and does not designate an element
          in Container, then Program_Error is propagated.  If Before
          equals No_Element, then let T be Last_Index (Container) + 1;
          otherwise, let T be To_Index (Before).  Insert_Space
          (Container, T, Count) is called, and then Position is set to
          To_Cursor (Container, T).

181/2
     procedure Delete (Container : in out Vector;
                       Index     : in     Extended_Index;
                       Count     : in     Count_Type := 1);

182/3
          If Index is not in the range First_Index (Container) ..
          Last_Index (Container) + 1, then Constraint_Error is
          propagated.  If Count is 0, Delete has no effect.  Otherwise,
          Delete slides the elements (if any) starting at position Index
          + Count down to Index.  Any exception raised during element
          assignment is propagated.

183/2
     procedure Delete (Container : in out Vector;
                       Position  : in out Cursor;
                       Count     : in     Count_Type := 1);

184/2
          If Position equals No_Element, then Constraint_Error is
          propagated.  If Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Delete (Container, To_Index (Position), Count) is called, and
          then Position is set to No_Element.

185/2
     procedure Delete_First (Container : in out Vector;
                             Count     : in     Count_Type := 1);

186/2
          Equivalent to Delete (Container, First_Index (Container),
          Count).

187/2
     procedure Delete_Last (Container : in out Vector;
                            Count     : in     Count_Type := 1);

188/3
          If Length (Container) <= Count, then Delete_Last is equivalent
          to Clear (Container).  Otherwise, it is equivalent to Delete
          (Container, Index_Type'Val(Index_Type'Pos(Last_Index
          (Container)) - Count + 1), Count).

189/2
     procedure Reverse_Elements (Container : in out Vector);

190/2
          Reorders the elements of Container in reverse order.

191/2
     procedure Swap (Container : in out Vector;
                     I, J      : in     Index_Type);

192/2
          If either I or J is not in the range First_Index (Container)
          ..  Last_Index (Container), then Constraint_Error is
          propagated.  Otherwise, Swap exchanges the values of the
          elements at positions I and J.

193/2
     procedure Swap (Container : in out Vector;
                     I, J      : in     Cursor);

194/2
          If either I or J is No_Element, then Constraint_Error is
          propagated.  If either I or J do not designate an element in
          Container, then Program_Error is propagated.  Otherwise, Swap
          exchanges the values of the elements designated by I and J.

195/2
     function First_Index (Container : Vector) return Index_Type;

196/2
          Returns the value Index_Type'First.

197/2
     function First (Container : Vector) return Cursor;

198/2
          If Container is empty, First returns No_Element.  Otherwise,
          it returns a cursor that designates the first element in
          Container.

199/2
     function First_Element (Container : Vector) return Element_Type;

200/2
          Equivalent to Element (Container, First_Index (Container)).

201/2
     function Last_Index (Container : Vector) return Extended_Index;

202/2
          If Container is empty, Last_Index returns No_Index.
          Otherwise, it returns the position of the last element in
          Container.

203/2
     function Last (Container : Vector) return Cursor;

204/2
          If Container is empty, Last returns No_Element.  Otherwise, it
          returns a cursor that designates the last element in
          Container.

205/2
     function Last_Element (Container : Vector) return Element_Type;

206/2
          Equivalent to Element (Container, Last_Index (Container)).

207/2
     function Next (Position : Cursor) return Cursor;

208/2
          If Position equals No_Element or designates the last element
          of the container, then Next returns the value No_Element.
          Otherwise, it returns a cursor that designates the element
          with index To_Index (Position) + 1 in the same vector as
          Position.

209/2
     procedure Next (Position : in out Cursor);

210/2
          Equivalent to Position := Next (Position).

211/2
     function Previous (Position : Cursor) return Cursor;

212/2
          If Position equals No_Element or designates the first element
          of the container, then Previous returns the value No_Element.
          Otherwise, it returns a cursor that designates the element
          with index To_Index (Position) - 1 in the same vector as
          Position.

213/2
     procedure Previous (Position : in out Cursor);

214/2
          Equivalent to Position := Previous (Position).

215/2
     function Find_Index (Container : Vector;
                          Item      : Element_Type;
                          Index     : Index_Type := Index_Type'First)
        return Extended_Index;

216/2
          Searches the elements of Container for an element equal to
          Item (using the generic formal equality operator).  The search
          starts at position Index and proceeds towards Last_Index
          (Container).  If no equal element is found, then Find_Index
          returns No_Index.  Otherwise, it returns the index of the
          first equal element encountered.

217/2
     function Find (Container : Vector;
                    Item      : Element_Type;
                    Position  : Cursor := No_Element)
        return Cursor;

218/3
          If Position is not No_Element, and does not designate an
          element in Container, then Program_Error is propagated.
          Otherwise, Find searches the elements of Container for an
          element equal to Item (using the generic formal equality
          operator).  The search starts at the first element if Position
          equals No_Element, and at the element designated by Position
          otherwise.  It proceeds towards the last element of Container.
          If no equal element is found, then Find returns No_Element.
          Otherwise, it returns a cursor designating the first equal
          element encountered.

219/2
     function Reverse_Find_Index (Container : Vector;
                                  Item      : Element_Type;
                                  Index     : Index_Type := Index_Type'Last)
        return Extended_Index;

220/2
          Searches the elements of Container for an element equal to
          Item (using the generic formal equality operator).  The search
          starts at position Index or, if Index is greater than
          Last_Index (Container), at position Last_Index (Container).
          It proceeds towards First_Index (Container).  If no equal
          element is found, then Reverse_Find_Index returns No_Index.
          Otherwise, it returns the index of the first equal element
          encountered.

221/2
     function Reverse_Find (Container : Vector;
                            Item      : Element_Type;
                            Position  : Cursor := No_Element)
        return Cursor;

222/3
          If Position is not No_Element, and does not designate an
          element in Container, then Program_Error is propagated.
          Otherwise, Reverse_Find searches the elements of Container for
          an element equal to Item (using the generic formal equality
          operator).  The search starts at the last element if Position
          equals No_Element, and at the element designated by Position
          otherwise.  It proceeds towards the first element of
          Container.  If no equal element is found, then Reverse_Find
          returns No_Element.  Otherwise, it returns a cursor
          designating the first equal element encountered.

223/2
     function Contains (Container : Vector;
                        Item      : Element_Type) return Boolean;

224/2
          Equivalent to Has_Element (Find (Container, Item)).

          Paragraphs 225 and 226 were moved above.

227/2
     procedure Iterate
       (Container : in Vector;
        Process   : not null access procedure (Position : in Cursor));

228/3
          Invokes Process.all with a cursor that designates each element
          in Container, in index order.  Tampering with the cursors of
          Container is prohibited during the execution of a call on
          Process.all.  Any exception raised by Process.all is
          propagated.

229/2
     procedure Reverse_Iterate
       (Container : in Vector;
        Process   : not null access procedure (Position : in Cursor));

230/3
          Iterates over the elements in Container as per procedure
          Iterate, except that elements are traversed in reverse index
          order.

230.1/3
     function Iterate (Container : in Vector)
        return Vector_Iterator_Interfaces.Reversible_Iterator'Class;

230.2/3
          Iterate returns a reversible iterator object (see *note
          5.5.1::) that will generate a value for a loop parameter (see
          *note 5.5.2::) designating each node in Container, starting
          with the first node and moving the cursor as per the Next
          function when used as a forward iterator, and starting with
          the last node and moving the cursor as per the Previous
          function when used as a reverse iterator.  Tampering with the
          cursors of Container is prohibited while the iterator object
          exists (in particular, in the sequence_of_statements of the
          loop_statement whose iterator_specification denotes this
          object).  The iterator object needs finalization.

230.3/3
     function Iterate (Container : in Vector; Start : in Cursor)
        return Vector_Iterator_Interfaces.Reversible_Iterator'Class;

230.4/3
          If Start is not No_Element and does not designate an item in
          Container, then Program_Error is propagated.  If Start is
          No_Element, then Constraint_Error is propagated.  Otherwise,
          Iterate returns a reversible iterator object (see *note
          5.5.1::) that will generate a value for a loop parameter (see
          *note 5.5.2::) designating each node in Container, starting
          with the node designated by Start and moving the cursor as per
          the Next function when used as a forward iterator, or moving
          the cursor as per the Previous function when used as a reverse
          iterator.  Tampering with the cursors of Container is
          prohibited while the iterator object exists (in particular, in
          the sequence_of_statements of the loop_statement whose
          iterator_specification denotes this object).  The iterator
          object needs finalization.

231/3
The actual function for the generic formal function "<" of
Generic_Sorting is expected to return the same value each time it is
called with a particular pair of element values.  It should define a
strict weak ordering relationship (see *note A.18::); it should not
modify Container.  If the actual for "<" behaves in some other manner,
the behavior of the subprograms of Generic_Sorting are unspecified.  The
number of times the subprograms of Generic_Sorting call "<" is
unspecified.

232/2
     function Is_Sorted (Container : Vector) return Boolean;

233/2
          Returns True if the elements are sorted smallest first as
          determined by the generic formal "<" operator; otherwise,
          Is_Sorted returns False.  Any exception raised during
          evaluation of "<" is propagated.

234/2
     procedure Sort (Container : in out Vector);

235/2
          Reorders the elements of Container such that the elements are
          sorted smallest first as determined by the generic formal "<"
          operator provided.  Any exception raised during evaluation of
          "<" is propagated.

236/2
     procedure Merge (Target  : in out Vector;
                      Source  : in out Vector);

237/3
          If Source is empty, then Merge does nothing.  If Source and
          Target are the same nonempty container object, then
          Program_Error is propagated.  Otherwise, Merge removes
          elements from Source and inserts them into Target; afterwards,
          Target contains the union of the elements that were initially
          in Source and Target; Source is left empty.  If Target and
          Source are initially sorted smallest first, then Target is
          ordered smallest first as determined by the generic formal "<"
          operator; otherwise, the order of elements in Target is
          unspecified.  Any exception raised during evaluation of "<" is
          propagated.

                      _Bounded (Run-Time) Errors_

238/3
Reading the value of an empty element by calling Element, Query_Element,
Update_Element, Constant_Reference, Reference, Swap, Is_Sorted, Sort,
Merge, "=", Find, or Reverse_Find is a bounded error.  The
implementation may treat the element as having any normal value (see
*note 13.9.1::) of the element type, or raise Constraint_Error or
Program_Error before modifying the vector.

239/2
Calling Merge in an instance of Generic_Sorting with either Source or
Target not ordered smallest first using the provided generic formal "<"
operator is a bounded error.  Either Program_Error is raised after
Target is updated as described for Merge, or the operation works as
defined.

239.1/3
It is a bounded error for the actual function associated with a generic
formal subprogram, when called as part of an operation of this package,
to tamper with elements of any Vector parameter of the operation.
Either Program_Error is raised, or the operation works as defined on the
value of the Vector either prior to, or subsequent to, some or all of
the modifications to the Vector.

239.2/3
It is a bounded error to call any subprogram declared in the visible
part of Containers.Vectors when the associated container has been
finalized.  If the operation takes Container as an in out parameter,
then it raises Constraint_Error or Program_Error.  Otherwise, the
operation either proceeds as it would for an empty container, or it
raises Constraint_Error or Program_Error.

240/2
A Cursor value is ambiguous if any of the following have occurred since
it was created:

241/2
   * Insert, Insert_Space, or Delete has been called on the vector that
     contains the element the cursor designates with an index value (or
     a cursor designating an element at such an index value) less than
     or equal to the index value of the element designated by the
     cursor; or

242/2
   * The vector that contains the element it designates has been passed
     to the Sort or Merge procedures of an instance of Generic_Sorting,
     or to the Reverse_Elements procedure.

243/2
It is a bounded error to call any subprogram other than "=" or
Has_Element declared in Containers.Vectors with an ambiguous (but not
invalid, see below) cursor parameter.  Possible results are:

244/2
   * The cursor may be treated as if it were No_Element;

245/2
   * The cursor may designate some element in the vector (but not
     necessarily the element that it originally designated);

246/2
   * Constraint_Error may be raised; or

247/2
   * Program_Error may be raised.

                         _Erroneous Execution_

248/2
A Cursor value is invalid if any of the following have occurred since it
was created: 

249/2
   * The vector that contains the element it designates has been
     finalized;

249.1/3
   * The vector that contains the element it designates has been used as
     the Target of a call to Assign, or as the target of an
     assignment_statement;

250/2
   * The vector that contains the element it designates has been used as
     the Source or Target of a call to Move; or

251/3
   * The element it designates has been deleted or removed from the
     vector that previously contained the element.

252/2
The result of "=" or Has_Element is unspecified if it is called with an
invalid cursor parameter.  Execution is erroneous if any other
subprogram declared in Containers.Vectors is called with an invalid
cursor parameter.

252.1/3
Execution is erroneous if the vector associated with the result of a
call to Reference or Constant_Reference is finalized before the result
object returned by the call to Reference or Constant_Reference is
finalized.

                     _Implementation Requirements_

253/2
No storage associated with a vector object shall be lost upon assignment
or scope exit.

254/3
The execution of an assignment_statement for a vector shall have the
effect of copying the elements from the source vector object to the
target vector object and changing the length of the target object to
that of the source object.

                        _Implementation Advice_

255/2
Containers.Vectors should be implemented similarly to an array.  In
particular, if the length of a vector is N, then

256/2
   * the worst-case time complexity of Element should be O(log N);

257/2
   * the worst-case time complexity of Append with Count=1 when N is
     less than the capacity of the vector should be O(log N); and

258/2
   * the worst-case time complexity of Prepend with Count=1 and
     Delete_First with Count=1 should be O(N log N).

259/2
The worst-case time complexity of a call on procedure Sort of an
instance of Containers.Vectors.Generic_Sorting should be O(N**2), and
the average time complexity should be better than O(N**2).

260/2
Containers.Vectors.Generic_Sorting.Sort and
Containers.Vectors.Generic_Sorting.Merge should minimize copying of
elements.

261/2
Move should not copy elements, and should minimize copying of internal
data structures.

262/2
If an exception is propagated from a vector operation, no storage should
be lost, nor any elements removed from a vector unless specified by the
operation.

     NOTES

263/2
     48  All elements of a vector occupy locations in the internal
     array.  If a sparse container is required, a Hashed_Map should be
     used rather than a vector.

264/2
     49  If Index_Type'Base'First = Index_Type'First an instance of
     Ada.Containers.Vectors will raise Constraint_Error.  A value below
     Index_Type'First is required so that an empty vector has a
     meaningful value of Last_Index.


File: arm2012.info,  Node: A.18.3,  Next: A.18.4,  Prev: A.18.2,  Up: A.18

A.18.3 The Generic Package Containers.Doubly_Linked_Lists
---------------------------------------------------------

1/2
The language-defined generic package Containers.Doubly_Linked_Lists
provides private types List and Cursor, and a set of operations for each
type.  A list container is optimized for insertion and deletion at any
position. 

2/2
A doubly-linked list container object manages a linked list of internal
nodes, each of which contains an element and pointers to the next
(successor) and previous (predecessor) internal nodes.  A cursor
designates a particular node within a list (and by extension the element
contained in that node).  A cursor keeps designating the same node (and
element) as long as the node is part of the container, even if the node
is moved in the container.

3/2
The length of a list is the number of elements it contains.

                          _Static Semantics_

4/2
The generic library package Containers.Doubly_Linked_Lists has the
following declaration:

5/3
     with Ada.Iterator_Interfaces;
     generic
        type Element_Type is private;
        with function "=" (Left, Right : Element_Type)
           return Boolean is <>;
     package Ada.Containers.Doubly_Linked_Lists is
        pragma Preelaborate(Doubly_Linked_Lists);
        pragma Remote_Types(Doubly_Linked_Lists);

6/3
        type List is tagged private
           with Constant_Indexing => Constant_Reference,
                Variable_Indexing => Reference,
                Default_Iterator  => Iterate,
                Iterator_Element  => Element_Type;
        pragma Preelaborable_Initialization(List);

7/2
        type Cursor is private;
        pragma Preelaborable_Initialization(Cursor);

8/2
        Empty_List : constant List;

9/2
        No_Element : constant Cursor;

9.1/3
        function Has_Element (Position : Cursor) return Boolean;

9.2/3
        package List_Iterator_Interfaces is new
            Ada.Iterator_Interfaces (Cursor, Has_Element);

10/2
        function "=" (Left, Right : List) return Boolean;

11/2
        function Length (Container : List) return Count_Type;

12/2
        function Is_Empty (Container : List) return Boolean;

13/2
        procedure Clear (Container : in out List);

14/2
        function Element (Position : Cursor)
           return Element_Type;

15/2
        procedure Replace_Element (Container : in out List;
                                   Position  : in     Cursor;
                                   New_Item  : in     Element_Type);

16/2
        procedure Query_Element
          (Position : in Cursor;
           Process  : not null access procedure (Element : in Element_Type));

17/2
        procedure Update_Element
          (Container : in out List;
           Position  : in     Cursor;
           Process   : not null access procedure
                           (Element : in out Element_Type));

17.1/3
        type Constant_Reference_Type
              (Element : not null access constant Element_Type) is private
           with Implicit_Dereference => Element;

17.2/3
        type Reference_Type (Element : not null access Element_Type) is private
           with Implicit_Dereference => Element;

17.3/3
        function Constant_Reference (Container : aliased in List;
                                     Position  : in Cursor)
           return Constant_Reference_Type;

17.4/3
        function Reference (Container : aliased in out List;
                            Position  : in Cursor)
           return Reference_Type;

17.5/3
        procedure Assign (Target : in out List; Source : in List);

17.6/3
        function Copy (Source : List) return List;

18/2
        procedure Move (Target : in out List;
                        Source : in out List);

19/2
        procedure Insert (Container : in out List;
                          Before    : in     Cursor;
                          New_Item  : in     Element_Type;
                          Count     : in     Count_Type := 1);

20/2
        procedure Insert (Container : in out List;
                          Before    : in     Cursor;
                          New_Item  : in     Element_Type;
                          Position  :    out Cursor;
                          Count     : in     Count_Type := 1);

21/2
        procedure Insert (Container : in out List;
                          Before    : in     Cursor;
                          Position  :    out Cursor;
                          Count     : in     Count_Type := 1);

22/2
        procedure Prepend (Container : in out List;
                           New_Item  : in     Element_Type;
                           Count     : in     Count_Type := 1);

23/2
        procedure Append (Container : in out List;
                          New_Item  : in     Element_Type;
                          Count     : in     Count_Type := 1);

24/2
        procedure Delete (Container : in out List;
                          Position  : in out Cursor;
                          Count     : in     Count_Type := 1);

25/2
        procedure Delete_First (Container : in out List;
                                Count     : in     Count_Type := 1);

26/2
        procedure Delete_Last (Container : in out List;
                               Count     : in     Count_Type := 1);

27/2
        procedure Reverse_Elements (Container : in out List);

28/2
        procedure Swap (Container : in out List;
                        I, J      : in     Cursor);

29/2
        procedure Swap_Links (Container : in out List;
                              I, J      : in     Cursor);

30/2
        procedure Splice (Target   : in out List;
                          Before   : in     Cursor;
                          Source   : in out List);

31/2
        procedure Splice (Target   : in out List;
                          Before   : in     Cursor;
                          Source   : in out List;
                          Position : in out Cursor);

32/2
        procedure Splice (Container: in out List;
                          Before   : in     Cursor;
                          Position : in     Cursor);

33/2
        function First (Container : List) return Cursor;

34/2
        function First_Element (Container : List)
           return Element_Type;

35/2
        function Last (Container : List) return Cursor;

36/2
        function Last_Element (Container : List)
           return Element_Type;

37/2
        function Next (Position : Cursor) return Cursor;

38/2
        function Previous (Position : Cursor) return Cursor;

39/2
        procedure Next (Position : in out Cursor);

40/2
        procedure Previous (Position : in out Cursor);

41/2
        function Find (Container : List;
                       Item      : Element_Type;
                       Position  : Cursor := No_Element)
           return Cursor;

42/2
        function Reverse_Find (Container : List;
                               Item      : Element_Type;
                               Position  : Cursor := No_Element)
           return Cursor;

43/2
        function Contains (Container : List;
                           Item      : Element_Type) return Boolean;

44/3
     This paragraph was deleted.

45/2
        procedure Iterate
          (Container : in List;
           Process   : not null access procedure (Position : in Cursor));

46/2
        procedure Reverse_Iterate
          (Container : in List;
           Process   : not null access procedure (Position : in Cursor));

46.1/3
        function Iterate (Container : in List)
           return List_Iterator_Interfaces.Reversible_Iterator'Class;

46.2/3
        function Iterate (Container : in List; Start : in Cursor)
           return List_Iterator_Interfaces.Reversible_Iterator'Class;

47/2
        generic
           with function "<" (Left, Right : Element_Type)
              return Boolean is <>;
        package Generic_Sorting is

48/2
           function Is_Sorted (Container : List) return Boolean;

49/2
           procedure Sort (Container : in out List);

50/2
           procedure Merge (Target  : in out List;
                            Source  : in out List);

51/2
        end Generic_Sorting;

52/2
     private

53/2
        ... -- not specified by the language

54/2
     end Ada.Containers.Doubly_Linked_Lists;

55/2
The actual function for the generic formal function "=" on Element_Type
values is expected to define a reflexive and symmetric relationship and
return the same result value each time it is called with a particular
pair of values.  If it behaves in some other manner, the functions Find,
Reverse_Find, and "=" on list values return an unspecified value.  The
exact arguments and number of calls of this generic formal function by
the functions Find, Reverse_Find, and "=" on list values are
unspecified.

56/2
The type List is used to represent lists.  The type List needs
finalization (see *note 7.6::).

57/2
Empty_List represents the empty List object.  It has a length of 0.  If
an object of type List is not otherwise initialized, it is initialized
to the same value as Empty_List.

58/2
No_Element represents a cursor that designates no element.  If an object
of type Cursor is not otherwise initialized, it is initialized to the
same value as No_Element.

59/2
The predefined "=" operator for type Cursor returns True if both cursors
are No_Element, or designate the same element in the same container.

60/2
Execution of the default implementation of the Input, Output, Read, or
Write attribute of type Cursor raises Program_Error.

60.1/3
List'Write for a List object L writes Length(L) elements of the list to
the stream.  It also may write additional information about the list.

60.2/3
List'Read reads the representation of a list from the stream, and
assigns to Item a list with the same length and elements as was written
by List'Write.

61/2
Some operations of this generic package have access-to-subprogram
parameters.  To ensure such operations are well-defined, they guard
against certain actions by the designated subprogram.  In particular,
some operations check for "tampering with cursors" of a container
because they depend on the set of elements of the container remaining
constant, and others check for "tampering with elements" of a container
because they depend on elements of the container not being replaced.

62/2
A subprogram is said to tamper with cursors of a list object L if:

63/2
   * it inserts or deletes elements of L, that is, it calls the Insert,
     Clear, Delete, or Delete_Last procedures with L as a parameter; or

64/2
   * it reorders the elements of L, that is, it calls the Splice,
     Swap_Links, or Reverse_Elements procedures or the Sort or Merge
     procedures of an instance of Generic_Sorting with L as a parameter;
     or

65/2
   * it finalizes L; or

65.1/3
   * it calls the Assign procedure with L as the Target parameter; or

66/2
   * it calls the Move procedure with L as a parameter.

67/2
A subprogram is said to tamper with elements of a list object L if:

68/2
   * it tampers with cursors of L; or

69/2
   * it replaces one or more elements of L, that is, it calls the
     Replace_Element or Swap procedures with L as a parameter.

69.1/4
When tampering with cursors is prohibited for a particular list object
L, Program_Error is propagated by a call of any language-defined
subprogram that is defined to tamper with the cursors of L, leaving L
unmodified.  Similarly, when tampering with elements is prohibited for a
particular list object L, Program_Error is propagated by a call of any
language-defined subprogram that is defined to tamper with the elements
of L (or tamper with the cursors of L), leaving L unmodified.  These
checks are made before any other defined behavior of the body of the
language-defined subprogram.

69.2/3
     function Has_Element (Position : Cursor) return Boolean;

69.3/3
          Returns True if Position designates an element, and returns
          False otherwise.

70/2
     function "=" (Left, Right : List) return Boolean;

71/3
          If Left and Right denote the same list object, then the
          function returns True.  If Left and Right have different
          lengths, then the function returns False.  Otherwise, it
          compares each element in Left to the corresponding element in
          Right using the generic formal equality operator.  If any such
          comparison returns False, the function returns False;
          otherwise, it returns True.  Any exception raised during
          evaluation of element equality is propagated.

72/2
     function Length (Container : List) return Count_Type;

73/2
          Returns the number of elements in Container.

74/2
     function Is_Empty (Container : List) return Boolean;

75/2
          Equivalent to Length (Container) = 0.

76/2
     procedure Clear (Container : in out List);

77/2
          Removes all the elements from Container.

78/2
     function Element (Position : Cursor) return Element_Type;

79/2
          If Position equals No_Element, then Constraint_Error is
          propagated.  Otherwise, Element returns the element designated
          by Position.

80/2
     procedure Replace_Element (Container : in out List;
                                Position  : in     Cursor;
                                New_Item  : in     Element_Type);

81/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Replace_Element assigns the value New_Item to the element
          designated by Position.

82/2
     procedure Query_Element
       (Position : in Cursor;
        Process  : not null access procedure (Element : in Element_Type));

83/3
          If Position equals No_Element, then Constraint_Error is
          propagated.  Otherwise, Query_Element calls Process.all with
          the element designated by Position as the argument.  Tampering
          with the elements of the list that contains the element
          designated by Position is prohibited during the execution of
          the call on Process.all.  Any exception raised by Process.all
          is propagated.

84/2
     procedure Update_Element
       (Container : in out List;
        Position  : in     Cursor;
        Process   : not null access procedure (Element : in out Element_Type));

85/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Update_Element calls Process.all with the element designated
          by Position as the argument.  Tampering with the elements of
          Container is prohibited during the execution of the call on
          Process.all.  Any exception raised by Process.all is
          propagated.

86/2
          If Element_Type is unconstrained and definite, then the actual
          Element parameter of Process.all shall be unconstrained.

86.1/3
     type Constant_Reference_Type
           (Element : not null access constant Element_Type) is private
        with Implicit_Dereference => Element;

86.2/3
     type Reference_Type (Element : not null access Element_Type) is private
        with Implicit_Dereference => Element;

86.3/3
          The types Constant_Reference_Type and Reference_Type need
          finalization.

86.4/3
          The default initialization of an object of type
          Constant_Reference_Type or Reference_Type propagates
          Program_Error.

86.5/3
     function Constant_Reference (Container : aliased in List;
                                  Position  : in Cursor)
        return Constant_Reference_Type;

86.6/3
          This function (combined with the Constant_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read access to an individual element of a list given a
          cursor.

86.7/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Constant_Reference returns an object whose discriminant is an
          access value that designates the element designated by
          Position.  Tampering with the elements of Container is
          prohibited while the object returned by Constant_Reference
          exists and has not been finalized.

86.8/3
     function Reference (Container : aliased in out List;
                         Position  : in Cursor)
        return Reference_Type;

86.9/3
          This function (combined with the Variable_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read and write access to an individual element of a list
          given a cursor.

86.10/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Reference returns an object whose discriminant is an access
          value that designates the element designated by Position.
          Tampering with the elements of Container is prohibited while
          the object returned by Reference exists and has not been
          finalized.

86.11/3
     procedure Assign (Target : in out List; Source : in List);

86.12/3
          If Target denotes the same object as Source, the operation has
          no effect.  Otherwise, the elements of Source are copied to
          Target as for an assignment_statement assigning Source to
          Target.

86.13/3
     function Copy (Source : List) return List;

86.14/3
          Returns a list whose elements match the elements of Source.

87/2
     procedure Move (Target : in out List;
                     Source : in out List);

88/3
          If Target denotes the same object as Source, then the
          operation has no effect.  Otherwise, the operation is
          equivalent to Assign (Target, Source) followed by Clear
          (Source).

89/2
     procedure Insert (Container : in out List;
                       Before    : in     Cursor;
                       New_Item  : in     Element_Type;
                       Count     : in     Count_Type := 1);

90/2
          If Before is not No_Element, and does not designate an element
          in Container, then Program_Error is propagated.  Otherwise,
          Insert inserts Count copies of New_Item prior to the element
          designated by Before.  If Before equals No_Element, the new
          elements are inserted after the last node (if any).  Any
          exception raised during allocation of internal storage is
          propagated, and Container is not modified.

91/2
     procedure Insert (Container : in out List;
                       Before    : in     Cursor;
                       New_Item  : in     Element_Type;
                       Position  :    out Cursor;
                       Count     : in     Count_Type := 1);

92/3
          If Before is not No_Element, and does not designate an element
          in Container, then Program_Error is propagated.  Otherwise,
          Insert allocates Count copies of New_Item, and inserts them
          prior to the element designated by Before.  If Before equals
          No_Element, the new elements are inserted after the last
          element (if any).  Position designates the first
          newly-inserted element, or if Count equals 0, then Position is
          assigned the value of Before.  Any exception raised during
          allocation of internal storage is propagated, and Container is
          not modified.

93/2
     procedure Insert (Container : in out List;
                       Before    : in     Cursor;
                       Position  :    out Cursor;
                       Count     : in     Count_Type := 1);

94/3
          If Before is not No_Element, and does not designate an element
          in Container, then Program_Error is propagated.  Otherwise,
          Insert inserts Count new elements prior to the element
          designated by Before.  If Before equals No_Element, the new
          elements are inserted after the last node (if any).  The new
          elements are initialized by default (see *note 3.3.1::).
          Position designates the first newly-inserted element, or if
          Count equals 0, then Position is assigned the value of Before.
          Any exception raised during allocation of internal storage is
          propagated, and Container is not modified.

95/2
     procedure Prepend (Container : in out List;
                        New_Item  : in     Element_Type;
                        Count     : in     Count_Type := 1);

96/2
          Equivalent to Insert (Container, First (Container), New_Item,
          Count).

97/2
     procedure Append (Container : in out List;
                       New_Item  : in     Element_Type;
                       Count     : in     Count_Type := 1);

98/2
          Equivalent to Insert (Container, No_Element, New_Item, Count).

99/2
     procedure Delete (Container : in out List;
                       Position  : in out Cursor;
                       Count     : in     Count_Type := 1);

100/3
          If Position equals No_Element, then Constraint_Error is
          propagated.  If Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Delete removes (from Container) Count elements starting at the
          element designated by Position (or all of the elements
          starting at Position if there are fewer than Count elements
          starting at Position).  Finally, Position is set to
          No_Element.

101/2
     procedure Delete_First (Container : in out List;
                             Count     : in     Count_Type := 1);

102/3
          If Length (Container) <= Count, then Delete_First is
          equivalent to Clear (Container).  Otherwise, it removes the
          first Count nodes from Container.

103/2
     procedure Delete_Last (Container : in out List;
                            Count     : in     Count_Type := 1);

104/3
          If Length (Container) <= Count, then Delete_Last is equivalent
          to Clear (Container).  Otherwise, it removes the last Count
          nodes from Container.

105/2
     procedure Reverse_Elements (Container : in out List);

106/2
          Reorders the elements of Container in reverse order.

107/2
     procedure Swap (Container : in out List;
                     I, J      : in     Cursor);

108/2
          If either I or J is No_Element, then Constraint_Error is
          propagated.  If either I or J do not designate an element in
          Container, then Program_Error is propagated.  Otherwise, Swap
          exchanges the values of the elements designated by I and J.

109/2
     procedure Swap_Links (Container : in out List;
                           I, J      : in     Cursor);

110/2
          If either I or J is No_Element, then Constraint_Error is
          propagated.  If either I or J do not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Swap_Links exchanges the nodes designated by I and J.

111/2
     procedure Splice (Target   : in out List;
                       Before   : in     Cursor;
                       Source   : in out List);

112/2
          If Before is not No_Element, and does not designate an element
          in Target, then Program_Error is propagated.  Otherwise, if
          Source denotes the same object as Target, the operation has no
          effect.  Otherwise, Splice reorders elements such that they
          are removed from Source and moved to Target, immediately prior
          to Before.  If Before equals No_Element, the nodes of Source
          are spliced after the last node of Target.  The length of
          Target is incremented by the number of nodes in Source, and
          the length of Source is set to 0.

113/2
     procedure Splice (Target   : in out List;
                       Before   : in     Cursor;
                       Source   : in out List;
                       Position : in out Cursor);

114/3
          If Position is No_Element, then Constraint_Error is
          propagated.  If Before does not equal No_Element, and does not
          designate an element in Target, then Program_Error is
          propagated.  If Position does not equal No_Element, and does
          not designate a node in Source, then Program_Error is
          propagated.  If Source denotes the same object as Target, then
          there is no effect if Position equals Before, else the element
          designated by Position is moved immediately prior to Before,
          or, if Before equals No_Element, after the last element.  In
          both cases, Position and the length of Target are unchanged.
          Otherwise, the element designated by Position is removed from
          Source and moved to Target, immediately prior to Before, or,
          if Before equals No_Element, after the last element of Target.
          The length of Target is incremented, the length of Source is
          decremented, and Position is updated to represent an element
          in Target.

115/2
     procedure Splice (Container: in out List;
                       Before   : in     Cursor;
                       Position : in     Cursor);

116/3
          If Position is No_Element, then Constraint_Error is
          propagated.  If Before does not equal No_Element, and does not
          designate an element in Container, then Program_Error is
          propagated.  If Position does not equal No_Element, and does
          not designate a node in Container, then Program_Error is
          propagated.  If Position equals Before there is no effect.
          Otherwise, the element designated by Position is moved
          immediately prior to Before, or, if Before equals No_Element,
          after the last element.  The length of Container is unchanged.

117/2
     function First (Container : List) return Cursor;

118/3
          If Container is empty, First returns the value No_Element.
          Otherwise, it returns a cursor that designates the first node
          in Container.

119/2
     function First_Element (Container : List) return Element_Type;

120/2
          Equivalent to Element (First (Container)).

121/2
     function Last (Container : List) return Cursor;

122/3
          If Container is empty, Last returns the value No_Element.
          Otherwise, it returns a cursor that designates the last node
          in Container.

123/2
     function Last_Element (Container : List) return Element_Type;

124/2
          Equivalent to Element (Last (Container)).

125/2
     function Next (Position : Cursor) return Cursor;

126/2
          If Position equals No_Element or designates the last element
          of the container, then Next returns the value No_Element.
          Otherwise, it returns a cursor that designates the successor
          of the element designated by Position.

127/2
     function Previous (Position : Cursor) return Cursor;

128/2
          If Position equals No_Element or designates the first element
          of the container, then Previous returns the value No_Element.
          Otherwise, it returns a cursor that designates the predecessor
          of the element designated by Position.

129/2
     procedure Next (Position : in out Cursor);

130/2
          Equivalent to Position := Next (Position).

131/2
     procedure Previous (Position : in out Cursor);

132/2
          Equivalent to Position := Previous (Position).

133/2
     function Find (Container : List;
                    Item      : Element_Type;
                    Position  : Cursor := No_Element)
       return Cursor;

134/2
          If Position is not No_Element, and does not designate an
          element in Container, then Program_Error is propagated.  Find
          searches the elements of Container for an element equal to
          Item (using the generic formal equality operator).  The search
          starts at the element designated by Position, or at the first
          element if Position equals No_Element.  It proceeds towards
          Last (Container).  If no equal element is found, then Find
          returns No_Element.  Otherwise, it returns a cursor
          designating the first equal element encountered.

135/2
     function Reverse_Find (Container : List;
                            Item      : Element_Type;
                            Position  : Cursor := No_Element)
        return Cursor;

136/2
          If Position is not No_Element, and does not designate an
          element in Container, then Program_Error is propagated.  Find
          searches the elements of Container for an element equal to
          Item (using the generic formal equality operator).  The search
          starts at the element designated by Position, or at the last
          element if Position equals No_Element.  It proceeds towards
          First (Container).  If no equal element is found, then
          Reverse_Find returns No_Element.  Otherwise, it returns a
          cursor designating the first equal element encountered.

137/2
     function Contains (Container : List;
                        Item      : Element_Type) return Boolean;

138/2
          Equivalent to Find (Container, Item) /= No_Element.

          Paragraphs 139 and 140 were moved above.

141/2
     procedure Iterate
       (Container : in List;
        Process   : not null access procedure (Position : in Cursor));

142/3
          Iterate calls Process.all with a cursor that designates each
          node in Container, starting with the first node and moving the
          cursor as per the Next function.  Tampering with the cursors
          of Container is prohibited during the execution of a call on
          Process.all.  Any exception raised by Process.all is
          propagated.

143/2
     procedure Reverse_Iterate
       (Container : in List;
        Process   : not null access procedure (Position : in Cursor));

144/3
          Iterates over the nodes in Container as per procedure Iterate,
          except that elements are traversed in reverse order, starting
          with the last node and moving the cursor as per the Previous
          function.

144.1/3
     function Iterate (Container : in List)
        return List_Iterator_Interfaces.Reversible_Iterator'Class;

144.2/3
          Iterate returns a reversible iterator object (see *note
          5.5.1::) that will generate a value for a loop parameter (see
          *note 5.5.2::) designating each node in Container, starting
          with the first node and moving the cursor as per the Next
          function when used as a forward iterator, and starting with
          the last node and moving the cursor as per the Previous
          function when used as a reverse iterator.  Tampering with the
          cursors of Container is prohibited while the iterator object
          exists (in particular, in the sequence_of_statements of the
          loop_statement whose iterator_specification denotes this
          object).  The iterator object needs finalization.

144.3/3
     function Iterate (Container : in List; Start : in Cursor)
        return List_Iterator_Interfaces.Reversible_Iterator'Class;

144.4/3
          If Start is not No_Element and does not designate an item in
          Container, then Program_Error is propagated.  If Start is
          No_Element, then Constraint_Error is propagated.  Otherwise,
          Iterate returns a reversible iterator object (see *note
          5.5.1::) that will generate a value for a loop parameter (see
          *note 5.5.2::) designating each node in Container, starting
          with the node designated by Start and moving the cursor as per
          the Next function when used as a forward iterator, or moving
          the cursor as per the Previous function when used as a reverse
          iterator.  Tampering with the cursors of Container is
          prohibited while the iterator object exists (in particular, in
          the sequence_of_statements of the loop_statement whose
          iterator_specification denotes this object).  The iterator
          object needs finalization.

145/3
The actual function for the generic formal function "<" of
Generic_Sorting is expected to return the same value each time it is
called with a particular pair of element values.  It should define a
strict weak ordering relationship (see *note A.18::); it should not
modify Container.  If the actual for "<" behaves in some other manner,
the behavior of the subprograms of Generic_Sorting are unspecified.  The
number of times the subprograms of Generic_Sorting call "<" is
unspecified.

146/2
     function Is_Sorted (Container : List) return Boolean;

147/2
          Returns True if the elements are sorted smallest first as
          determined by the generic formal "<" operator; otherwise,
          Is_Sorted returns False.  Any exception raised during
          evaluation of "<" is propagated.

148/2
     procedure Sort (Container : in out List);

149/2
          Reorders the nodes of Container such that the elements are
          sorted smallest first as determined by the generic formal "<"
          operator provided.  The sort is stable.  Any exception raised
          during evaluation of "<" is propagated.

150/2
     procedure Merge (Target  : in out List;
                      Source  : in out List);

151/3
          If Source is empty, then Merge does nothing.  If Source and
          Target are the same nonempty container object, then
          Program_Error is propagated.  Otherwise, Merge removes
          elements from Source and inserts them into Target; afterwards,
          Target contains the union of the elements that were initially
          in Source and Target; Source is left empty.  If Target and
          Source are initially sorted smallest first, then Target is
          ordered smallest first as determined by the generic formal "<"
          operator; otherwise, the order of elements in Target is
          unspecified.  Any exception raised during evaluation of "<" is
          propagated.

                      _Bounded (Run-Time) Errors_

152/2
Calling Merge in an instance of Generic_Sorting with either Source or
Target not ordered smallest first using the provided generic formal "<"
operator is a bounded error.  Either Program_Error is raised after
Target is updated as described for Merge, or the operation works as
defined.

152.1/3
It is a bounded error for the actual function associated with a generic
formal subprogram, when called as part of an operation of this package,
to tamper with elements of any List parameter of the operation.  Either
Program_Error is raised, or the operation works as defined on the value
of the List either prior to, or subsequent to, some or all of the
modifications to the List.

152.2/3
It is a bounded error to call any subprogram declared in the visible
part of Containers.Doubly_Linked_Lists when the associated container has
been finalized.  If the operation takes Container as an in out
parameter, then it raises Constraint_Error or Program_Error.  Otherwise,
the operation either proceeds as it would for an empty container, or it
raises Constraint_Error or Program_Error.

                         _Erroneous Execution_

153/2
A Cursor value is invalid if any of the following have occurred since it
was created: 

154/2
   * The list that contains the element it designates has been
     finalized;

154.1/3
   * The list that contains the element it designates has been used as
     the Target of a call to Assign, or as the target of an
     assignment_statement;

155/2
   * The list that contains the element it designates has been used as
     the Source or Target of a call to Move; or

156/3
   * The element it designates has been removed from the list that
     previously contained the element.

157/2
The result of "=" or Has_Element is unspecified if it is called with an
invalid cursor parameter.  Execution is erroneous if any other
subprogram declared in Containers.Doubly_Linked_Lists is called with an
invalid cursor parameter. 

157.1/3
Execution is erroneous if the list associated with the result of a call
to Reference or Constant_Reference is finalized before the result object
returned by the call to Reference or Constant_Reference is finalized.

                     _Implementation Requirements_

158/2
No storage associated with a doubly-linked List object shall be lost
upon assignment or scope exit.

159/3
The execution of an assignment_statement for a list shall have the
effect of copying the elements from the source list object to the target
list object and changing the length of the target object to that of the
source object.

                        _Implementation Advice_

160/2
Containers.Doubly_Linked_Lists should be implemented similarly to a
linked list.  In particular, if N is the length of a list, then the
worst-case time complexity of Element, Insert with Count=1, and Delete
with Count=1 should be O(log N).

161/2
The worst-case time complexity of a call on procedure Sort of an
instance of Containers.Doubly_Linked_Lists.Generic_Sorting should be
O(N**2), and the average time complexity should be better than O(N**2).

162/2
Move should not copy elements, and should minimize copying of internal
data structures.

163/2
If an exception is propagated from a list operation, no storage should
be lost, nor any elements removed from a list unless specified by the
operation.

     NOTES

164/2
     50  Sorting a list never copies elements, and is a stable sort
     (equal elements remain in the original order).  This is different
     than sorting an array or vector, which may need to copy elements,
     and is probably not a stable sort.


File: arm2012.info,  Node: A.18.4,  Next: A.18.5,  Prev: A.18.3,  Up: A.18

A.18.4 Maps
-----------

1/2
The language-defined generic packages Containers.Hashed_Maps and
Containers.Ordered_Maps provide private types Map and Cursor, and a set
of operations for each type.  A map container allows an arbitrary type
to be used as a key to find the element associated with that key.  A
hashed map uses a hash function to organize the keys, while an ordered
map orders the keys per a specified relation. 

2/3
This subclause describes the declarations that are common to both kinds
of maps.  See *note A.18.5:: for a description of the semantics specific
to Containers.Hashed_Maps and *note A.18.6:: for a description of the
semantics specific to Containers.Ordered_Maps.

                          _Static Semantics_

3/2
The actual function for the generic formal function "=" on Element_Type
values is expected to define a reflexive and symmetric relationship and
return the same result value each time it is called with a particular
pair of values.  If it behaves in some other manner, the function "=" on
map values returns an unspecified value.  The exact arguments and number
of calls of this generic formal function by the function "=" on map
values are unspecified.

4/2
The type Map is used to represent maps.  The type Map needs finalization
(see *note 7.6::).

5/2
A map contains pairs of keys and elements, called nodes.  Map cursors
designate nodes, but also can be thought of as designating an element
(the element contained in the node) for consistency with the other
containers.  There exists an equivalence relation on keys, whose
definition is different for hashed maps and ordered maps.  A map never
contains two or more nodes with equivalent keys.  The length of a map is
the number of nodes it contains.

6/2
Each nonempty map has two particular nodes called the first node and the
last node (which may be the same).  Each node except for the last node
has a successor node.  If there are no other intervening operations,
starting with the first node and repeatedly going to the successor node
will visit each node in the map exactly once until the last node is
reached.  The exact definition of these terms is different for hashed
maps and ordered maps.

7/2
Some operations of these generic packages have access-to-subprogram
parameters.  To ensure such operations are well-defined, they guard
against certain actions by the designated subprogram.  In particular,
some operations check for "tampering with cursors" of a container
because they depend on the set of elements of the container remaining
constant, and others check for "tampering with elements" of a container
because they depend on elements of the container not being replaced.

8/2
A subprogram is said to tamper with cursors of a map object M if:

9/2
   * it inserts or deletes elements of M, that is, it calls the Insert,
     Include, Clear, Delete, or Exclude procedures with M as a
     parameter; or

10/2
   * it finalizes M; or

10.1/3
   * it calls the Assign procedure with M as the Target parameter; or

11/2
   * it calls the Move procedure with M as a parameter; or

12/2
   * it calls one of the operations defined to tamper with the cursors
     of M.

13/2
A subprogram is said to tamper with elements of a map object M if:

14/2
   * it tampers with cursors of M; or

15/2
   * it replaces one or more elements of M, that is, it calls the
     Replace or Replace_Element procedures with M as a parameter.

15.1/4
When tampering with cursors is prohibited for a particular map object M,
Program_Error is propagated by a call of any language-defined subprogram
that is defined to tamper with the cursors of M, leaving M unmodified.
Similarly, when tampering with elements is prohibited for a particular
map object M, Program_Error is propagated by a call of any
language-defined subprogram that is defined to tamper with the elements
of M (or tamper with the cursors of M), leaving M unmodified.  These
checks are made before any other defined behavior of the body of the
language-defined subprogram.

16/2
Empty_Map represents the empty Map object.  It has a length of 0.  If an
object of type Map is not otherwise initialized, it is initialized to
the same value as Empty_Map.

17/2
No_Element represents a cursor that designates no node.  If an object of
type Cursor is not otherwise initialized, it is initialized to the same
value as No_Element.

18/2
The predefined "=" operator for type Cursor returns True if both cursors
are No_Element, or designate the same element in the same container.

19/2
Execution of the default implementation of the Input, Output, Read, or
Write attribute of type Cursor raises Program_Error.

19.1/3
Map'Write for a Map object M writes Length(M) elements of the map to the
stream.  It also may write additional information about the map.

19.2/3
Map'Read reads the representation of a map from the stream, and assigns
to Item a map with the same length and elements as was written by
Map'Write.

19.3/3
     function Has_Element (Position : Cursor) return Boolean;

19.4/3
          Returns True if Position designates an element, and returns
          False otherwise.

20/2
     function "=" (Left, Right : Map) return Boolean;

21/2
          If Left and Right denote the same map object, then the
          function returns True.  If Left and Right have different
          lengths, then the function returns False.  Otherwise, for each
          key K in Left, the function returns False if:

22/2
             * a key equivalent to K is not present in Right; or

23/2
             * the element associated with K in Left is not equal to the
               element associated with K in Right (using the generic
               formal equality operator for elements).

24/2
          If the function has not returned a result after checking all
          of the keys, it returns True.  Any exception raised during
          evaluation of key equivalence or element equality is
          propagated.

25/2
     function Length (Container : Map) return Count_Type;

26/2
          Returns the number of nodes in Container.

27/2
     function Is_Empty (Container : Map) return Boolean;

28/2
          Equivalent to Length (Container) = 0.

29/2
     procedure Clear (Container : in out Map);

30/2
          Removes all the nodes from Container.

31/2
     function Key (Position : Cursor) return Key_Type;

32/2
          If Position equals No_Element, then Constraint_Error is
          propagated.  Otherwise, Key returns the key component of the
          node designated by Position.

33/2
     function Element (Position : Cursor) return Element_Type;

34/2
          If Position equals No_Element, then Constraint_Error is
          propagated.  Otherwise, Element returns the element component
          of the node designated by Position.

35/2
     procedure Replace_Element (Container : in out Map;
                                Position  : in     Cursor;
                                New_Item  : in     Element_Type);

36/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Replace_Element assigns New_Item to the element of the node
          designated by Position.

37/2
     procedure Query_Element
       (Position : in Cursor;
        Process  : not null access procedure (Key     : in Key_Type;
                                              Element : in Element_Type));

38/3
          If Position equals No_Element, then Constraint_Error is
          propagated.  Otherwise, Query_Element calls Process.all with
          the key and element from the node designated by Position as
          the arguments.  Tampering with the elements of the map that
          contains the element designated by Position is prohibited
          during the execution of the call on Process.all.  Any
          exception raised by Process.all is propagated.

39/2
     procedure Update_Element
       (Container : in out Map;
        Position  : in     Cursor;
        Process   : not null access procedure (Key     : in     Key_Type;
                                               Element : in out Element_Type));

40/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Update_Element calls Process.all with the key and element from
          the node designated by Position as the arguments.  Tampering
          with the elements of Container is prohibited during the
          execution of the call on Process.all.  Any exception raised by
          Process.all is propagated.

41/2
          If Element_Type is unconstrained and definite, then the actual
          Element parameter of Process.all shall be unconstrained.

41.1/3
     type Constant_Reference_Type
           (Element : not null access constant Element_Type) is private
        with Implicit_Dereference => Element;

41.2/3
     type Reference_Type (Element : not null access Element_Type) is private
        with Implicit_Dereference => Element;

41.3/3
          The types Constant_Reference_Type and Reference_Type need
          finalization.

41.4/3
          The default initialization of an object of type
          Constant_Reference_Type or Reference_Type propagates
          Program_Error.

41.5/3
     function Constant_Reference (Container : aliased in Map;
                                  Position  : in Cursor)
        return Constant_Reference_Type;

41.6/3
          This function (combined with the Constant_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read access to an individual element of a map given a
          cursor.

41.7/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Constant_Reference returns an object whose discriminant is an
          access value that designates the element designated by
          Position.  Tampering with the elements of Container is
          prohibited while the object returned by Constant_Reference
          exists and has not been finalized.

41.8/3
     function Reference (Container : aliased in out Map;
                         Position  : in Cursor)
        return Reference_Type;

41.9/3
          This function (combined with the Variable_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read and write access to an individual element of a map
          given a cursor.

41.10/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Reference returns an object whose discriminant is an access
          value that designates the element designated by Position.
          Tampering with the elements of Container is prohibited while
          the object returned by Reference exists and has not been
          finalized.

41.11/3
     function Constant_Reference (Container : aliased in Map;
                                  Key       : in Key_Type)
        return Constant_Reference_Type;

41.12/3
          This function (combined with the Constant_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read access to an individual element of a map given a key
          value.

41.13/3
          Equivalent to Constant_Reference (Container, Find (Container,
          Key)).

41.14/3
     function Reference (Container : aliased in out Map;
                         Key       : in Key_Type)
        return Reference_Type;

41.15/3
          This function (combined with the Variable_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read and write access to an individual element of a map
          given a key value.

41.16/3
          Equivalent to Reference (Container, Find (Container, Key)).

41.17/3
     procedure Assign (Target : in out Map; Source : in Map);

41.18/3
          If Target denotes the same object as Source, the operation has
          no effect.  Otherwise, the key/element pairs of Source are
          copied to Target as for an assignment_statement assigning
          Source to Target.

42/2
     procedure Move (Target : in out Map;
                     Source : in out Map);

43/3
          If Target denotes the same object as Source, then the
          operation has no effect.  Otherwise, the operation is
          equivalent to Assign (Target, Source) followed by Clear
          (Source).

44/2
     procedure Insert (Container : in out Map;
                       Key       : in     Key_Type;
                       New_Item  : in     Element_Type;
                       Position  :    out Cursor;
                       Inserted  :    out Boolean);

45/2
          Insert checks if a node with a key equivalent to Key is
          already present in Container.  If a match is found, Inserted
          is set to False and Position designates the element with the
          matching key.  Otherwise, Insert allocates a new node,
          initializes it to Key and New_Item, and adds it to Container;
          Inserted is set to True and Position designates the
          newly-inserted node.  Any exception raised during allocation
          is propagated and Container is not modified.

46/2
     procedure Insert (Container : in out Map;
                       Key       : in     Key_Type;
                       Position  :    out Cursor;
                       Inserted  :    out Boolean);

47/2
          Insert inserts Key into Container as per the five-parameter
          Insert, with the difference that an element initialized by
          default (see *note 3.3.1::) is inserted.

48/2
     procedure Insert (Container : in out Map;
                       Key       : in     Key_Type;
                       New_Item  : in     Element_Type);

49/2
          Insert inserts Key and New_Item into Container as per the
          five-parameter Insert, with the difference that if a node with
          a key equivalent to Key is already in the map, then
          Constraint_Error is propagated.

50/2
     procedure Include (Container : in out Map;
                        Key       : in     Key_Type;
                        New_Item  : in     Element_Type);

51/2
          Include inserts Key and New_Item into Container as per the
          five-parameter Insert, with the difference that if a node with
          a key equivalent to Key is already in the map, then this
          operation assigns Key and New_Item to the matching node.  Any
          exception raised during assignment is propagated.

52/2
     procedure Replace (Container : in out Map;
                        Key       : in     Key_Type;
                        New_Item  : in     Element_Type);

53/2
          Replace checks if a node with a key equivalent to Key is
          present in Container.  If a match is found, Replace assigns
          Key and New_Item to the matching node; otherwise,
          Constraint_Error is propagated.

54/2
     procedure Exclude (Container : in out Map;
                        Key       : in     Key_Type);

55/2
          Exclude checks if a node with a key equivalent to Key is
          present in Container.  If a match is found, Exclude removes
          the node from the map.

56/2
     procedure Delete (Container : in out Map;
                       Key       : in     Key_Type);

57/2
          Delete checks if a node with a key equivalent to Key is
          present in Container.  If a match is found, Delete removes the
          node from the map; otherwise, Constraint_Error is propagated.

58/2
     procedure Delete (Container : in out Map;
                       Position  : in out Cursor);

59/2
          If Position equals No_Element, then Constraint_Error is
          propagated.  If Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Delete removes the node designated by Position from the map.
          Position is set to No_Element on return.

60/2
     function First (Container : Map) return Cursor;

61/2
          If Length (Container) = 0, then First returns No_Element.
          Otherwise, First returns a cursor that designates the first
          node in Container.

62/2
     function Next (Position  : Cursor) return Cursor;

63/2
          Returns a cursor that designates the successor of the node
          designated by Position.  If Position designates the last node,
          then No_Element is returned.  If Position equals No_Element,
          then No_Element is returned.

64/2
     procedure Next (Position  : in out Cursor);

65/2
          Equivalent to Position := Next (Position).

66/2
     function Find (Container : Map;
                    Key       : Key_Type) return Cursor;

67/2
          If Length (Container) equals 0, then Find returns No_Element.
          Otherwise, Find checks if a node with a key equivalent to Key
          is present in Container.  If a match is found, a cursor
          designating the matching node is returned; otherwise,
          No_Element is returned.

68/2
     function Element (Container : Map;
                       Key       : Key_Type) return Element_Type;

69/2
          Equivalent to Element (Find (Container, Key)).

70/2
     function Contains (Container : Map;
                        Key       : Key_Type) return Boolean;

71/2
          Equivalent to Find (Container, Key) /= No_Element.

          Paragraphs 72 and 73 were moved above.

74/2
     procedure Iterate
       (Container : in Map;
        Process   : not null access procedure (Position : in Cursor));

75/3
          Iterate calls Process.all with a cursor that designates each
          node in Container, starting with the first node and moving the
          cursor according to the successor relation.  Tampering with
          the cursors of Container is prohibited during the execution of
          a call on Process.all.  Any exception raised by Process.all is
          propagated.

                      _Bounded (Run-Time) Errors_

75.1/3
It is a bounded error for the actual function associated with a generic
formal subprogram, when called as part of an operation of a map package,
to tamper with elements of any map parameter of the operation.  Either
Program_Error is raised, or the operation works as defined on the value
of the map either prior to, or subsequent to, some or all of the
modifications to the map.

75.2/3
It is a bounded error to call any subprogram declared in the visible
part of a map package when the associated container has been finalized.
If the operation takes Container as an in out parameter, then it raises
Constraint_Error or Program_Error.  Otherwise, the operation either
proceeds as it would for an empty container, or it raises
Constraint_Error or Program_Error.

                         _Erroneous Execution_

76/2
A Cursor value is invalid if any of the following have occurred since it
was created: 

77/2
   * The map that contains the node it designates has been finalized;

77.1/3
   * The map that contains the node it designates has been used as the
     Target of a call to Assign, or as the target of an
     assignment_statement;

78/2
   * The map that contains the node it designates has been used as the
     Source or Target of a call to Move; or

79/3
   * The node it designates has been removed from the map that
     previously contained the node.

80/2
The result of "=" or Has_Element is unspecified if these functions are
called with an invalid cursor parameter.  Execution is erroneous if any
other subprogram declared in Containers.Hashed_Maps or
Containers.Ordered_Maps is called with an invalid cursor parameter.

80.1/3
Execution is erroneous if the map associated with the result of a call
to Reference or Constant_Reference is finalized before the result object
returned by the call to Reference or Constant_Reference is finalized.

                     _Implementation Requirements_

81/2
No storage associated with a Map object shall be lost upon assignment or
scope exit.

82/3
The execution of an assignment_statement for a map shall have the effect
of copying the elements from the source map object to the target map
object and changing the length of the target object to that of the
source object.

                        _Implementation Advice_

83/2
Move should not copy elements, and should minimize copying of internal
data structures.

84/2
If an exception is propagated from a map operation, no storage should be
lost, nor any elements removed from a map unless specified by the
operation.


File: arm2012.info,  Node: A.18.5,  Next: A.18.6,  Prev: A.18.4,  Up: A.18

A.18.5 The Generic Package Containers.Hashed_Maps
-------------------------------------------------

                          _Static Semantics_

1/2
The generic library package Containers.Hashed_Maps has the following
declaration:

2/3
     with Ada.Iterator_Interfaces;
     generic
        type Key_Type is private;
        type Element_Type is private;
        with function Hash (Key : Key_Type) return Hash_Type;
        with function Equivalent_Keys (Left, Right : Key_Type)
           return Boolean;
        with function "=" (Left, Right : Element_Type)
           return Boolean is <>;
     package Ada.Containers.Hashed_Maps is
        pragma Preelaborate(Hashed_Maps);
        pragma Remote_Types(Hashed_Maps);

3/3
        type Map is tagged private
           with Constant_Indexing => Constant_Reference,
                Variable_Indexing => Reference,
                Default_Iterator  => Iterate,
                Iterator_Element  => Element_Type;
        pragma Preelaborable_Initialization(Map);

4/2
        type Cursor is private;
        pragma Preelaborable_Initialization(Cursor);

5/2
        Empty_Map : constant Map;

6/2
        No_Element : constant Cursor;

6.1/3
        function Has_Element (Position : Cursor) return Boolean;

6.2/3
        package Map_Iterator_Interfaces is new
            Ada.Iterator_Interfaces (Cursor, Has_Element);

7/2
        function "=" (Left, Right : Map) return Boolean;

8/2
        function Capacity (Container : Map) return Count_Type;

9/2
        procedure Reserve_Capacity (Container : in out Map;
                                    Capacity  : in     Count_Type);

10/2
        function Length (Container : Map) return Count_Type;

11/2
        function Is_Empty (Container : Map) return Boolean;

12/2
        procedure Clear (Container : in out Map);

13/2
        function Key (Position : Cursor) return Key_Type;

14/2
        function Element (Position : Cursor) return Element_Type;

15/2
        procedure Replace_Element (Container : in out Map;
                                   Position  : in     Cursor;
                                   New_Item  : in     Element_Type);

16/2
        procedure Query_Element
          (Position : in Cursor;
           Process  : not null access procedure (Key     : in Key_Type;
                                                 Element : in Element_Type));

17/2
        procedure Update_Element
          (Container : in out Map;
           Position  : in     Cursor;
           Process   : not null access procedure
                           (Key     : in     Key_Type;
                            Element : in out Element_Type));

17.1/3
        type Constant_Reference_Type
              (Element : not null access constant Element_Type) is private
           with Implicit_Dereference => Element;

17.2/3
        type Reference_Type (Element : not null access Element_Type) is private
           with Implicit_Dereference => Element;

17.3/3
        function Constant_Reference (Container : aliased in Map;
                                     Position  : in Cursor)
           return Constant_Reference_Type;

17.4/3
        function Reference (Container : aliased in out Map;
                            Position  : in Cursor)
           return Reference_Type;

17.5/3
        function Constant_Reference (Container : aliased in Map;
                                     Key       : in Key_Type)
           return Constant_Reference_Type;

17.6/3
        function Reference (Container : aliased in out Map;
                            Key       : in Key_Type)
           return Reference_Type;

17.7/3
        procedure Assign (Target : in out Map; Source : in Map);

17.8/3
        function Copy (Source : Map; Capacity : Count_Type := 0) return Map;

18/2
        procedure Move (Target : in out Map;
                        Source : in out Map);

19/2
        procedure Insert (Container : in out Map;
                          Key       : in     Key_Type;
                          New_Item  : in     Element_Type;
                          Position  :    out Cursor;
                          Inserted  :    out Boolean);

20/2
        procedure Insert (Container : in out Map;
                          Key       : in     Key_Type;
                          Position  :    out Cursor;
                          Inserted  :    out Boolean);

21/2
        procedure Insert (Container : in out Map;
                          Key       : in     Key_Type;
                          New_Item  : in     Element_Type);

22/2
        procedure Include (Container : in out Map;
                           Key       : in     Key_Type;
                           New_Item  : in     Element_Type);

23/2
        procedure Replace (Container : in out Map;
                           Key       : in     Key_Type;
                           New_Item  : in     Element_Type);

24/2
        procedure Exclude (Container : in out Map;
                           Key       : in     Key_Type);

25/2
        procedure Delete (Container : in out Map;
                          Key       : in     Key_Type);

26/2
        procedure Delete (Container : in out Map;
                          Position  : in out Cursor);

27/2
        function First (Container : Map)
           return Cursor;

28/2
        function Next (Position  : Cursor) return Cursor;

29/2
        procedure Next (Position  : in out Cursor);

30/2
        function Find (Container : Map;
                       Key       : Key_Type)
           return Cursor;

31/2
        function Element (Container : Map;
                          Key       : Key_Type)
           return Element_Type;

32/2
        function Contains (Container : Map;
                           Key       : Key_Type) return Boolean;

33/3
     This paragraph was deleted.

34/2
        function Equivalent_Keys (Left, Right : Cursor)
           return Boolean;

35/2
        function Equivalent_Keys (Left  : Cursor;
                                  Right : Key_Type)
           return Boolean;

36/2
        function Equivalent_Keys (Left  : Key_Type;
                                  Right : Cursor)
           return Boolean;

37/2
        procedure Iterate
          (Container : in Map;
           Process   : not null access procedure (Position : in Cursor));

37.1/3
        function Iterate (Container : in Map)
           return Map_Iterator_Interfaces.Forward_Iterator'Class;

38/2
     private

39/2
        ... -- not specified by the language

40/2
     end Ada.Containers.Hashed_Maps;

41/2
An object of type Map contains an expandable hash table, which is used
to provide direct access to nodes.  The capacity of an object of type
Map is the maximum number of nodes that can be inserted into the hash
table prior to it being automatically expanded.

42/2
Two keys K1 and K2 are defined to be equivalent if Equivalent_Keys (K1,
K2) returns True.

43/2
The actual function for the generic formal function Hash is expected to
return the same value each time it is called with a particular key
value.  For any two equivalent key values, the actual for Hash is
expected to return the same value.  If the actual for Hash behaves in
some other manner, the behavior of this package is unspecified.  Which
subprograms of this package call Hash, and how many times they call it,
is unspecified.

44/2
The actual function for the generic formal function Equivalent_Keys on
Key_Type values is expected to return the same value each time it is
called with a particular pair of key values.  It should define an
equivalence relationship, that is, be reflexive, symmetric, and
transitive.  If the actual for Equivalent_Keys behaves in some other
manner, the behavior of this package is unspecified.  Which subprograms
of this package call Equivalent_Keys, and how many times they call it,
is unspecified.

45/2
If the value of a key stored in a node of a map is changed other than by
an operation in this package such that at least one of Hash or
Equivalent_Keys give different results, the behavior of this package is
unspecified.

46/2
Which nodes are the first node and the last node of a map, and which
node is the successor of a given node, are unspecified, other than the
general semantics described in *note A.18.4::.

47/2
     function Capacity (Container : Map) return Count_Type;

48/2
          Returns the capacity of Container.

49/2
     procedure Reserve_Capacity (Container : in out Map;
                                 Capacity  : in     Count_Type);

50/2
          Reserve_Capacity allocates a new hash table such that the
          length of the resulting map can become at least the value
          Capacity without requiring an additional call to
          Reserve_Capacity, and is large enough to hold the current
          length of Container.  Reserve_Capacity then rehashes the nodes
          in Container onto the new hash table.  It replaces the old
          hash table with the new hash table, and then deallocates the
          old hash table.  Any exception raised during allocation is
          propagated and Container is not modified.

51/2
          Reserve_Capacity tampers with the cursors of Container.

52/2
     procedure Clear (Container : in out Map);

53/2
          In addition to the semantics described in *note A.18.4::,
          Clear does not affect the capacity of Container.

53.1/3
     procedure Assign (Target : in out Map; Source : in Map);

53.2/3
          In addition to the semantics described in *note A.18.4::, if
          the length of Source is greater than the capacity of Target,
          Reserve_Capacity (Target, Length (Source)) is called before
          assigning any elements.

53.3/3
     function Copy (Source : Map; Capacity : Count_Type := 0) return Map;

53.4/3
          Returns a map whose keys and elements are initialized from the
          keys and elements of Source.  If Capacity is 0, then the map
          capacity is the length of Source; if Capacity is equal to or
          greater than the length of Source, the map capacity is at
          least the specified value.  Otherwise, the operation
          propagates Capacity_Error.

54/2
     procedure Insert (Container : in out Map;
                       Key       : in     Key_Type;
                       New_Item  : in     Element_Type;
                       Position  :    out Cursor;
                       Inserted  :    out Boolean);

55/2
          In addition to the semantics described in *note A.18.4::, if
          Length (Container) equals Capacity (Container), then Insert
          first calls Reserve_Capacity to increase the capacity of
          Container to some larger value.

56/2
     function Equivalent_Keys (Left, Right : Cursor)
           return Boolean;

57/2
          Equivalent to Equivalent_Keys (Key (Left), Key (Right)).

58/2
     function Equivalent_Keys (Left  : Cursor;
                               Right : Key_Type) return Boolean;

59/2
          Equivalent to Equivalent_Keys (Key (Left), Right).

60/2
     function Equivalent_Keys (Left  : Key_Type;
                               Right : Cursor) return Boolean;

61/2
          Equivalent to Equivalent_Keys (Left, Key (Right)).

61.1/3
     function Iterate (Container : in Map)
        return Map_Iterator_Interfaces.Forward_Iterator'Class;

61.2/3
          Iterate returns an iterator object (see *note 5.5.1::) that
          will generate a value for a loop parameter (see *note 5.5.2::)
          designating each node in Container, starting with the first
          node and moving the cursor according to the successor
          relation.  Tampering with the cursors of Container is
          prohibited while the iterator object exists (in particular, in
          the sequence_of_statements of the loop_statement whose
          iterator_specification denotes this object).  The iterator
          object needs finalization.

                        _Implementation Advice_

62/2
If N is the length of a map, the average time complexity of the
subprograms Element, Insert, Include, Replace, Delete, Exclude and Find
that take a key parameter should be O(log N). The average time
complexity of the subprograms that take a cursor parameter should be
O(1).  The average time complexity of Reserve_Capacity should be O(N).


File: arm2012.info,  Node: A.18.6,  Next: A.18.7,  Prev: A.18.5,  Up: A.18

A.18.6 The Generic Package Containers.Ordered_Maps
--------------------------------------------------

                          _Static Semantics_

1/2
The generic library package Containers.Ordered_Maps has the following
declaration:

2/3
     with Ada.Iterator_Interfaces;
     generic
        type Key_Type is private;
        type Element_Type is private;
        with function "<" (Left, Right : Key_Type) return Boolean is <>;
        with function "=" (Left, Right : Element_Type) return Boolean is <>;
     package Ada.Containers.Ordered_Maps is
        pragma Preelaborate(Ordered_Maps);
        pragma Remote_Types(Ordered_Maps);

3/2
        function Equivalent_Keys (Left, Right : Key_Type) return Boolean;

4/3
        type Map is tagged private
           with Constant_Indexing => Constant_Reference,
                Variable_Indexing => Reference,
                Default_Iterator  => Iterate,
                Iterator_Element  => Element_Type;
        pragma Preelaborable_Initialization(Map);

5/2
        type Cursor is private;
        pragma Preelaborable_Initialization(Cursor);

6/2
        Empty_Map : constant Map;

7/2
        No_Element : constant Cursor;

7.1/3
        function Has_Element (Position : Cursor) return Boolean;

7.2/3
        package Map_Iterator_Interfaces is new
            Ada.Iterator_Interfaces (Cursor, Has_Element);

8/2
        function "=" (Left, Right : Map) return Boolean;

9/2
        function Length (Container : Map) return Count_Type;

10/2
        function Is_Empty (Container : Map) return Boolean;

11/2
        procedure Clear (Container : in out Map);

12/2
        function Key (Position : Cursor) return Key_Type;

13/2
        function Element (Position : Cursor) return Element_Type;

14/2
        procedure Replace_Element (Container : in out Map;
                                   Position  : in     Cursor;
                                   New_Item  : in     Element_Type);

15/2
        procedure Query_Element
          (Position : in Cursor;
           Process  : not null access procedure (Key     : in Key_Type;
                                                 Element : in Element_Type));

16/2
        procedure Update_Element
          (Container : in out Map;
           Position  : in     Cursor;
           Process   : not null access procedure
                           (Key     : in     Key_Type;
                            Element : in out Element_Type));

16.1/3
        type Constant_Reference_Type
              (Element : not null access constant Element_Type) is private
           with Implicit_Dereference => Element;

16.2/3
        type Reference_Type (Element : not null access Element_Type) is private
           with Implicit_Dereference => Element;

16.3/3
        function Constant_Reference (Container : aliased in Map;
                                     Position  : in Cursor)
           return Constant_Reference_Type;

16.4/3
        function Reference (Container : aliased in out Map;
                            Position  : in Cursor)
           return Reference_Type;

16.5/3
        function Constant_Reference (Container : aliased in Map;
                                     Key       : in Key_Type)
           return Constant_Reference_Type;

16.6/3
        function Reference (Container : aliased in out Map;
                            Key       : in Key_Type)
           return Reference_Type;

16.7/3
        procedure Assign (Target : in out Map; Source : in Map);

16.8/3
        function Copy (Source : Map) return Map;

17/2
        procedure Move (Target : in out Map;
                        Source : in out Map);

18/2
        procedure Insert (Container : in out Map;
                          Key       : in     Key_Type;
                          New_Item  : in     Element_Type;
                          Position  :    out Cursor;
                          Inserted  :    out Boolean);

19/2
        procedure Insert (Container : in out Map;
                          Key       : in     Key_Type;
                          Position  :    out Cursor;
                          Inserted  :    out Boolean);

20/2
        procedure Insert (Container : in out Map;
                          Key       : in     Key_Type;
                          New_Item  : in     Element_Type);

21/2
        procedure Include (Container : in out Map;
                           Key       : in     Key_Type;
                           New_Item  : in     Element_Type);

22/2
        procedure Replace (Container : in out Map;
                           Key       : in     Key_Type;
                           New_Item  : in     Element_Type);

23/2
        procedure Exclude (Container : in out Map;
                           Key       : in     Key_Type);

24/2
        procedure Delete (Container : in out Map;
                          Key       : in     Key_Type);

25/2
        procedure Delete (Container : in out Map;
                          Position  : in out Cursor);

26/2
        procedure Delete_First (Container : in out Map);

27/2
        procedure Delete_Last (Container : in out Map);

28/2
        function First (Container : Map) return Cursor;

29/2
        function First_Element (Container : Map) return Element_Type;

30/2
        function First_Key (Container : Map) return Key_Type;

31/2
        function Last (Container : Map) return Cursor;

32/2
        function Last_Element (Container : Map) return Element_Type;

33/2
        function Last_Key (Container : Map) return Key_Type;

34/2
        function Next (Position : Cursor) return Cursor;

35/2
        procedure Next (Position : in out Cursor);

36/2
        function Previous (Position : Cursor) return Cursor;

37/2
        procedure Previous (Position : in out Cursor);

38/2
        function Find (Container : Map;
                       Key       : Key_Type) return Cursor;

39/2
        function Element (Container : Map;
                          Key       : Key_Type) return Element_Type;

40/2
        function Floor (Container : Map;
                        Key       : Key_Type) return Cursor;

41/2
        function Ceiling (Container : Map;
                          Key       : Key_Type) return Cursor;

42/2
        function Contains (Container : Map;
                           Key       : Key_Type) return Boolean;

43/3
     This paragraph was deleted.

44/2
        function "<" (Left, Right : Cursor) return Boolean;

45/2
        function ">" (Left, Right : Cursor) return Boolean;

46/2
        function "<" (Left : Cursor; Right : Key_Type) return Boolean;

47/2
        function ">" (Left : Cursor; Right : Key_Type) return Boolean;

48/2
        function "<" (Left : Key_Type; Right : Cursor) return Boolean;

49/2
        function ">" (Left : Key_Type; Right : Cursor) return Boolean;

50/2
        procedure Iterate
          (Container : in Map;
           Process   : not null access procedure (Position : in Cursor));

51/2
        procedure Reverse_Iterate
          (Container : in Map;
           Process   : not null access procedure (Position : in Cursor));

51.1/3
        function Iterate (Container : in Map)
           return Map_Iterator_Interfaces.Reversible_Iterator'Class;

51.2/3
        function Iterate (Container : in Map; Start : in Cursor)
           return Map_Iterator_Interfaces.Reversible_Iterator'Class;

52/2
     private

53/2
        ... -- not specified by the language

54/2
     end Ada.Containers.Ordered_Maps;

55/2
Two keys K1 and K2 are equivalent if both K1 < K2 and K2 < K1 return
False, using the generic formal "<" operator for keys.  Function
Equivalent_Keys returns True if Left and Right are equivalent, and False
otherwise.

56/3
The actual function for the generic formal function "<" on Key_Type
values is expected to return the same value each time it is called with
a particular pair of key values.  It should define a strict weak
ordering relationship (see *note A.18::).  If the actual for "<" behaves
in some other manner, the behavior of this package is unspecified.
Which subprograms of this package call "<" and how many times they call
it, is unspecified.

57/2
If the value of a key stored in a map is changed other than by an
operation in this package such that at least one of "<" or "=" give
different results, the behavior of this package is unspecified.

58/3
The first node of a nonempty map is the one whose key is less than the
key of all the other nodes in the map.  The last node of a nonempty map
is the one whose key is greater than the key of all the other elements
in the map.  The successor of a node is the node with the smallest key
that is larger than the key of the given node.  The predecessor of a
node is the node with the largest key that is smaller than the key of
the given node.  All comparisons are done using the generic formal "<"
operator for keys.

58.1/3
     function Copy (Source : Map) return Map;

58.2/3
          Returns a map whose keys and elements are initialized from the
          corresponding keys and elements of Source.

59/2
     procedure Delete_First (Container : in out Map);

60/3
          If Container is empty, Delete_First has no effect.  Otherwise,
          the node designated by First (Container) is removed from
          Container.  Delete_First tampers with the cursors of
          Container.

61/2
     procedure Delete_Last (Container : in out Map);

62/3
          If Container is empty, Delete_Last has no effect.  Otherwise,
          the node designated by Last (Container) is removed from
          Container.  Delete_Last tampers with the cursors of Container.

63/2
     function First_Element (Container : Map) return Element_Type;

64/2
          Equivalent to Element (First (Container)).

65/2
     function First_Key (Container : Map) return Key_Type;

66/2
          Equivalent to Key (First (Container)).

67/2
     function Last (Container : Map) return Cursor;

68/2
          Returns a cursor that designates the last node in Container.
          If Container is empty, returns No_Element.

69/2
     function Last_Element (Container : Map) return Element_Type;

70/2
          Equivalent to Element (Last (Container)).

71/2
     function Last_Key (Container : Map) return Key_Type;

72/2
          Equivalent to Key (Last (Container)).

73/2
     function Previous (Position : Cursor) return Cursor;

74/3
          If Position equals No_Element, then Previous returns
          No_Element.  Otherwise, Previous returns a cursor designating
          the predecessor node of the one designated by Position.  If
          Position designates the first element, then Previous returns
          No_Element.

75/2
     procedure Previous (Position : in out Cursor);

76/2
          Equivalent to Position := Previous (Position).

77/2
     function Floor (Container : Map;
                     Key       : Key_Type) return Cursor;

78/3
          Floor searches for the last node whose key is not greater than
          Key, using the generic formal "<" operator for keys.  If such
          a node is found, a cursor that designates it is returned.
          Otherwise, No_Element is returned.

79/2
     function Ceiling (Container : Map;
                       Key       : Key_Type) return Cursor;

80/3
          Ceiling searches for the first node whose key is not less than
          Key, using the generic formal "<" operator for keys.  If such
          a node is found, a cursor that designates it is returned.
          Otherwise, No_Element is returned.

81/2
     function "<" (Left, Right : Cursor) return Boolean;

82/2
          Equivalent to Key (Left) < Key (Right).

83/2
     function ">" (Left, Right : Cursor) return Boolean;

84/2
          Equivalent to Key (Right) < Key (Left).

85/2
     function "<" (Left : Cursor; Right : Key_Type) return Boolean;

86/2
          Equivalent to Key (Left) < Right.

87/2
     function ">" (Left : Cursor; Right : Key_Type) return Boolean;

88/2
          Equivalent to Right < Key (Left).

89/2
     function "<" (Left : Key_Type; Right : Cursor) return Boolean;

90/2
          Equivalent to Left < Key (Right).

91/2
     function ">" (Left : Key_Type; Right : Cursor) return Boolean;

92/2
          Equivalent to Key (Right) < Left.

93/2
     procedure Reverse_Iterate
       (Container : in Map;
        Process   : not null access procedure (Position : in Cursor));

94/3
          Iterates over the nodes in Container as per procedure Iterate,
          with the difference that the nodes are traversed in
          predecessor order, starting with the last node.

94.1/3
     function Iterate (Container : in Map)
        return Map_Iterator_Interfaces.Reversible_Iterator'Class;

94.2/3
          Iterate returns a reversible iterator object (see *note
          5.5.1::) that will generate a value for a loop parameter (see
          *note 5.5.2::) designating each node in Container, starting
          with the first node and moving the cursor according to the
          successor relation when used as a forward iterator, and
          starting with the last node and moving the cursor according to
          the predecessor relation when used as a reverse iterator.
          Tampering with the cursors of Container is prohibited while
          the iterator object exists (in particular, in the
          sequence_of_statements of the loop_statement whose
          iterator_specification denotes this object).  The iterator
          object needs finalization.

94.3/3
     function Iterate (Container : in Map; Start : in Cursor)
        return Map_Iterator_Interfaces.Reversible_Iterator'Class;

94.4/3
          If Start is not No_Element and does not designate an item in
          Container, then Program_Error is propagated.  If Start is
          No_Element, then Constraint_Error is propagated.  Otherwise,
          Iterate returns a reversible iterator object (see *note
          5.5.1::) that will generate a value for a loop parameter (see
          *note 5.5.2::) designating each node in Container, starting
          with the node designated by Start and moving the cursor
          according to the successor relation when used as a forward
          iterator, or moving the cursor according to the predecessor
          relation when used as a reverse iterator.  Tampering with the
          cursors of Container is prohibited while the iterator object
          exists (in particular, in the sequence_of_statements of the
          loop_statement whose iterator_specification denotes this
          object).  The iterator object needs finalization.

                        _Implementation Advice_

95/2
If N is the length of a map, then the worst-case time complexity of the
Element, Insert, Include, Replace, Delete, Exclude and Find operations
that take a key parameter should be O((log N)**2) or better.  The
worst-case time complexity of the subprograms that take a cursor
parameter should be O(1).


File: arm2012.info,  Node: A.18.7,  Next: A.18.8,  Prev: A.18.6,  Up: A.18

A.18.7 Sets
-----------

1/2
The language-defined generic packages Containers.Hashed_Sets and
Containers.Ordered_Sets provide private types Set and Cursor, and a set
of operations for each type.  A set container allows elements of an
arbitrary type to be stored without duplication.  A hashed set uses a
hash function to organize elements, while an ordered set orders its
element per a specified relation. 

2/3
This subclause describes the declarations that are common to both kinds
of sets.  See *note A.18.8:: for a description of the semantics specific
to Containers.Hashed_Sets and *note A.18.9:: for a description of the
semantics specific to Containers.Ordered_Sets.

                          _Static Semantics_

3/2
The actual function for the generic formal function "=" on Element_Type
values is expected to define a reflexive and symmetric relationship and
return the same result value each time it is called with a particular
pair of values.  If it behaves in some other manner, the function "=" on
set values returns an unspecified value.  The exact arguments and number
of calls of this generic formal function by the function "=" on set
values are unspecified.

4/2
The type Set is used to represent sets.  The type Set needs finalization
(see *note 7.6::).

5/2
A set contains elements.  Set cursors designate elements.  There exists
an equivalence relation on elements, whose definition is different for
hashed sets and ordered sets.  A set never contains two or more
equivalent elements.  The length of a set is the number of elements it
contains.

6/2
Each nonempty set has two particular elements called the first element
and the last element (which may be the same).  Each element except for
the last element has a successor element.  If there are no other
intervening operations, starting with the first element and repeatedly
going to the successor element will visit each element in the set
exactly once until the last element is reached.  The exact definition of
these terms is different for hashed sets and ordered sets.

7/2
Some operations of these generic packages have access-to-subprogram
parameters.  To ensure such operations are well-defined, they guard
against certain actions by the designated subprogram.  In particular,
some operations check for "tampering with cursors" of a container
because they depend on the set of elements of the container remaining
constant, and others check for "tampering with elements" of a container
because they depend on elements of the container not being replaced.

8/2
A subprogram is said to tamper with cursors of a set object S if:

9/2
   * it inserts or deletes elements of S, that is, it calls the Insert,
     Include, Clear, Delete, Exclude, or Replace_Element procedures with
     S as a parameter; or

10/2
   * it finalizes S; or

10.1/3
   * it calls the Assign procedure with S as the Target parameter; or

11/2
   * it calls the Move procedure with S as a parameter; or

12/2
   * it calls one of the operations defined to tamper with cursors of S.

13/2
A subprogram is said to tamper with elements of a set object S if:

14/2
   * it tampers with cursors of S.

14.1/4
When tampering with cursors is prohibited for a particular set object S,
Program_Error is propagated by a call of any language-defined subprogram
that is defined to tamper with the cursors of S, leaving S unmodified.
Similarly, when tampering with elements is prohibited for a particular
set object S, Program_Error is propagated by a call of any
language-defined subprogram that is defined to tamper with the elements
of S (or tamper with the cursors of S), leaving S unmodified.  These
checks are made before any other defined behavior of the body of the
language-defined subprogram.

15/2
Empty_Set represents the empty Set object.  It has a length of 0.  If an
object of type Set is not otherwise initialized, it is initialized to
the same value as Empty_Set.

16/2
No_Element represents a cursor that designates no element.  If an object
of type Cursor is not otherwise initialized, it is initialized to the
same value as No_Element.

17/2
The predefined "=" operator for type Cursor returns True if both cursors
are No_Element, or designate the same element in the same container.

18/2
Execution of the default implementation of the Input, Output, Read, or
Write attribute of type Cursor raises Program_Error.

18.1/3
Set'Write for a Set object S writes Length(S) elements of the set to the
stream.  It also may write additional information about the set.

18.2/3
Set'Read reads the representation of a set from the stream, and assigns
to Item a set with the same length and elements as was written by
Set'Write.

18.3/3
     function Has_Element (Position : Cursor) return Boolean;

18.4/3
          Returns True if Position designates an element, and returns
          False otherwise.

19/2
     function "=" (Left, Right : Set) return Boolean;

20/2
          If Left and Right denote the same set object, then the
          function returns True.  If Left and Right have different
          lengths, then the function returns False.  Otherwise, for each
          element E in Left, the function returns False if an element
          equal to E (using the generic formal equality operator) is not
          present in Right.  If the function has not returned a result
          after checking all of the elements, it returns True.  Any
          exception raised during evaluation of element equality is
          propagated.

21/2
     function Equivalent_Sets (Left, Right : Set) return Boolean;

22/2
          If Left and Right denote the same set object, then the
          function returns True.  If Left and Right have different
          lengths, then the function returns False.  Otherwise, for each
          element E in Left, the function returns False if an element
          equivalent to E is not present in Right.  If the function has
          not returned a result after checking all of the elements, it
          returns True.  Any exception raised during evaluation of
          element equivalence is propagated.

23/2
     function To_Set (New_Item : Element_Type) return Set;

24/2
          Returns a set containing the single element New_Item.

25/2
     function Length (Container : Set) return Count_Type;

26/2
          Returns the number of elements in Container.

27/2
     function Is_Empty (Container : Set) return Boolean;

28/2
          Equivalent to Length (Container) = 0.

29/2
     procedure Clear (Container : in out Set);

30/2
          Removes all the elements from Container.

31/2
     function Element (Position : Cursor) return Element_Type;

32/2
          If Position equals No_Element, then Constraint_Error is
          propagated.  Otherwise, Element returns the element designated
          by Position.

33/2
     procedure Replace_Element (Container : in out Set;
                                Position  : in     Cursor;
                                New_Item  : in     Element_Type);

34/2
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  If an element
          equivalent to New_Item is already present in Container at a
          position other than Position, Program_Error is propagated.
          Otherwise, Replace_Element assigns New_Item to the element
          designated by Position.  Any exception raised by the
          assignment is propagated.

35/2
     procedure Query_Element
       (Position : in Cursor;
        Process  : not null access procedure (Element : in Element_Type));

36/3
          If Position equals No_Element, then Constraint_Error is
          propagated.  Otherwise, Query_Element calls Process.all with
          the element designated by Position as the argument.  Tampering
          with the elements of the set that contains the element
          designated by Position is prohibited during the execution of
          the call on Process.all.  Any exception raised by Process.all
          is propagated.

36.1/3
     type Constant_Reference_Type
           (Element : not null access constant Element_Type) is private
        with Implicit_Dereference => Element;

36.2/3
          The type Constant_Reference_Type needs finalization.

36.3/3
          The default initialization of an object of type
          Constant_Reference_Type propagates Program_Error.

36.4/3
     function Constant_Reference (Container : aliased in Set;
                                  Position  : in Cursor)
        return Constant_Reference_Type;

36.5/3
          This function (combined with the Constant_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read access to an individual element of a set given a
          cursor.

36.6/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Constant_Reference returns an object whose discriminant is an
          access value that designates the element designated by
          Position.  Tampering with the elements of Container is
          prohibited while the object returned by Constant_Reference
          exists and has not been finalized.

36.7/3
     procedure Assign (Target : in out Set; Source : in Set);

36.8/3
          If Target denotes the same object as Source, the operation has
          no effect.  Otherwise, the elements of Source are copied to
          Target as for an assignment_statement assigning Source to
          Target.

37/2
     procedure Move (Target : in out Set;
                     Source : in out Set);

38/3
          If Target denotes the same object as Source, then the
          operation has no effect.  Otherwise, the operation is
          equivalent to Assign (Target, Source) followed by Clear
          (Source).

39/2
     procedure Insert (Container : in out Set;
                       New_Item  : in     Element_Type;
                       Position  :    out Cursor;
                       Inserted  :    out Boolean);

40/2
          Insert checks if an element equivalent to New_Item is already
          present in Container.  If a match is found, Inserted is set to
          False and Position designates the matching element.
          Otherwise, Insert adds New_Item to Container; Inserted is set
          to True and Position designates the newly-inserted element.
          Any exception raised during allocation is propagated and
          Container is not modified.

41/2
     procedure Insert (Container : in out Set;
                       New_Item  : in     Element_Type);

42/2
          Insert inserts New_Item into Container as per the
          four-parameter Insert, with the difference that if an element
          equivalent to New_Item is already in the set, then
          Constraint_Error is propagated.

43/2
     procedure Include (Container : in out Set;
                        New_Item  : in     Element_Type);

44/2
          Include inserts New_Item into Container as per the
          four-parameter Insert, with the difference that if an element
          equivalent to New_Item is already in the set, then it is
          replaced.  Any exception raised during assignment is
          propagated.

45/2
     procedure Replace (Container : in out Set;
                        New_Item  : in     Element_Type);

46/2
          Replace checks if an element equivalent to New_Item is already
          in the set.  If a match is found, that element is replaced
          with New_Item; otherwise, Constraint_Error is propagated.

47/2
     procedure Exclude (Container : in out Set;
                        Item      : in     Element_Type);

48/2
          Exclude checks if an element equivalent to Item is present in
          Container.  If a match is found, Exclude removes the element
          from the set.

49/2
     procedure Delete (Container : in out Set;
                       Item      : in     Element_Type);

50/2
          Delete checks if an element equivalent to Item is present in
          Container.  If a match is found, Delete removes the element
          from the set; otherwise, Constraint_Error is propagated.

51/2
     procedure Delete (Container : in out Set;
                       Position  : in out Cursor);

52/2
          If Position equals No_Element, then Constraint_Error is
          propagated.  If Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Delete removes the element designated by Position from the
          set.  Position is set to No_Element on return.

53/2
     procedure Union (Target : in out Set;
                      Source : in     Set);

54/2
          Union inserts into Target the elements of Source that are not
          equivalent to some element already in Target.

55/2
     function Union (Left, Right : Set) return Set;

56/2
          Returns a set comprising all of the elements of Left, and the
          elements of Right that are not equivalent to some element of
          Left.

57/2
     procedure Intersection (Target : in out Set;
                             Source : in     Set);

58/3
          Intersection deletes from Target the elements of Target that
          are not equivalent to some element of Source.

59/2
     function Intersection (Left, Right : Set) return Set;

60/2
          Returns a set comprising all the elements of Left that are
          equivalent to the some element of Right.

61/2
     procedure Difference (Target : in out Set;
                           Source : in     Set);

62/2
          If Target denotes the same object as Source, then Difference
          clears Target.  Otherwise, it deletes from Target the elements
          that are equivalent to some element of Source.

63/2
     function Difference (Left, Right : Set) return Set;

64/2
          Returns a set comprising the elements of Left that are not
          equivalent to some element of Right.

65/2
     procedure Symmetric_Difference (Target : in out Set;
                                     Source : in     Set);

66/2
          If Target denotes the same object as Source, then
          Symmetric_Difference clears Target.  Otherwise, it deletes
          from Target the elements that are equivalent to some element
          of Source, and inserts into Target the elements of Source that
          are not equivalent to some element of Target.

67/2
     function Symmetric_Difference (Left, Right : Set) return Set;

68/2
          Returns a set comprising the elements of Left that are not
          equivalent to some element of Right, and the elements of Right
          that are not equivalent to some element of Left.

69/2
     function Overlap (Left, Right : Set) return Boolean;

70/3
          If an element of Left is equivalent to some element of Right,
          then Overlap returns True.  Otherwise, it returns False.

71/2
     function Is_Subset (Subset : Set;
                         Of_Set : Set) return Boolean;

72/3
          If an element of Subset is not equivalent to some element of
          Of_Set, then Is_Subset returns False.  Otherwise, it returns
          True.

73/2
     function First (Container : Set) return Cursor;

74/2
          If Length (Container) = 0, then First returns No_Element.
          Otherwise, First returns a cursor that designates the first
          element in Container.

75/2
     function Next (Position  : Cursor) return Cursor;

76/2
          Returns a cursor that designates the successor of the element
          designated by Position.  If Position designates the last
          element, then No_Element is returned.  If Position equals
          No_Element, then No_Element is returned.

77/2
     procedure Next (Position  : in out Cursor);

78/2
          Equivalent to Position := Next (Position).

79/3
          This paragraph was deleted.

80/2
     function Find (Container : Set;
                    Item      : Element_Type) return Cursor;

81/2
          If Length (Container) equals 0, then Find returns No_Element.
          Otherwise, Find checks if an element equivalent to Item is
          present in Container.  If a match is found, a cursor
          designating the matching element is returned; otherwise,
          No_Element is returned.

82/2
     function Contains (Container : Set;
                        Item      : Element_Type) return Boolean;

82.1/3
          Equivalent to Find (Container, Item) /= No_Element.

          Paragraphs 83 and 84 were moved above.

85/2
     procedure Iterate
       (Container : in Set;
        Process   : not null access procedure (Position : in Cursor));

86/3
          Iterate calls Process.all with a cursor that designates each
          element in Container, starting with the first element and
          moving the cursor according to the successor relation.
          Tampering with the cursors of Container is prohibited during
          the execution of a call on Process.all.  Any exception raised
          by Process.all is propagated.

87/2
Both Containers.Hashed_Set and Containers.Ordered_Set declare a nested
generic package Generic_Keys, which provides operations that allow set
manipulation in terms of a key (typically, a portion of an element)
instead of a complete element.  The formal function Key of Generic_Keys
extracts a key value from an element.  It is expected to return the same
value each time it is called with a particular element.  The behavior of
Generic_Keys is unspecified if Key behaves in some other manner.

88/2
A key is expected to unambiguously determine a single equivalence class
for elements.  The behavior of Generic_Keys is unspecified if the formal
parameters of this package behave in some other manner.

89/2
     function Key (Position : Cursor) return Key_Type;

90/2
          Equivalent to Key (Element (Position)).

91/2
The subprograms in package Generic_Keys named Contains, Find, Element,
Delete, and Exclude, are equivalent to the corresponding subprograms in
the parent package, with the difference that the Key parameter is used
to locate an element in the set.

92/2
     procedure Replace (Container : in out Set;
                        Key       : in     Key_Type;
                        New_Item  : in     Element_Type);

93/2
          Equivalent to Replace_Element (Container, Find (Container,
          Key), New_Item).

94/2
     procedure Update_Element_Preserving_Key
       (Container : in out Set;
        Position  : in     Cursor;
        Process   : not null access procedure
                                      (Element : in out Element_Type));

95/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Update_Element_Preserving_Key uses Key to save the key value K
          of the element designated by Position.
          Update_Element_Preserving_Key then calls Process.all with that
          element as the argument.  Tampering with the elements of
          Container is prohibited during the execution of the call on
          Process.all.  Any exception raised by Process.all is
          propagated.  After Process.all returns,
          Update_Element_Preserving_Key checks if K determines the same
          equivalence class as that for the new element; if not, the
          element is removed from the set and Program_Error is
          propagated.

96/2
          If Element_Type is unconstrained and definite, then the actual
          Element parameter of Process.all shall be unconstrained.

96.1/3
     type Reference_Type (Element : not null access Element_Type) is private
        with Implicit_Dereference => Element;

96.2/3
          The type Reference_Type needs finalization.

96.3/3
          The default initialization of an object of type Reference_Type
          propagates Program_Error.

96.4/3
     function Reference_Preserving_Key (Container : aliased in out Set;
                                        Position  : in Cursor)
        return Reference_Type;

96.5/3
          This function (combined with the Implicit_Dereference aspect)
          provides a convenient way to gain read and write access to an
          individual element of a set given a cursor.

96.6/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Reference_Preserving_Key uses Key to save the key value K;
          then returns an object whose discriminant is an access value
          that designates the element designated by Position.  Tampering
          with the elements of Container is prohibited while the object
          returned by Reference_Preserving_Key exists and has not been
          finalized.  When the object returned by
          Reference_Preserving_Key is finalized, a check is made if K
          determines the same equivalence class as that for the new
          element; if not, the element is removed from the set and
          Program_Error is propagated.

96.7/3
     function Constant_Reference (Container : aliased in Set;
                                  Key       : in Key_Type)
        return Constant_Reference_Type;

96.8/3
          This function (combined with the Implicit_Dereference aspect)
          provides a convenient way to gain read access to an individual
          element of a set given a key value.

96.9/3
          Equivalent to Constant_Reference (Container, Find (Container,
          Key)).

96.10/3
     function Reference_Preserving_Key (Container : aliased in out Set;
                                        Key       : in Key_Type)
        return Reference_Type;

96.11/3
          This function (combined with the Implicit_Dereference aspect)
          provides a convenient way to gain read and write access to an
          individual element of a set given a key value.

96.12/3
          Equivalent to Reference_Preserving_Key (Container, Find
          (Container, Key)).

                      _Bounded (Run-Time) Errors_

96.13/3
It is a bounded error for the actual function associated with a generic
formal subprogram, when called as part of an operation of a set package,
to tamper with elements of any set parameter of the operation.  Either
Program_Error is raised, or the operation works as defined on the value
of the set either prior to, or subsequent to, some or all of the
modifications to the set.

96.14/3
It is a bounded error to call any subprogram declared in the visible
part of a set package when the associated container has been finalized.
If the operation takes Container as an in out parameter, then it raises
Constraint_Error or Program_Error.  Otherwise, the operation either
proceeds as it would for an empty container, or it raises
Constraint_Error or Program_Error.

                         _Erroneous Execution_

97/2
A Cursor value is invalid if any of the following have occurred since it
was created: 

98/2
   * The set that contains the element it designates has been finalized;

98.1/3
   * The set that contains the element it designates has been used as
     the Target of a call to Assign, or as the target of an
     assignment_statement;

99/2
   * The set that contains the element it designates has been used as
     the Source or Target of a call to Move; or

100/3
   * The element it designates has been removed from the set that
     previously contained the element.

101/2
The result of "=" or Has_Element is unspecified if these functions are
called with an invalid cursor parameter.  Execution is erroneous if any
other subprogram declared in Containers.Hashed_Sets or
Containers.Ordered_Sets is called with an invalid cursor parameter.

101.1/3
Execution is erroneous if the set associated with the result of a call
to Reference or Constant_Reference is finalized before the result object
returned by the call to Reference or Constant_Reference is finalized.

                     _Implementation Requirements_

102/2
No storage associated with a Set object shall be lost upon assignment or
scope exit.

103/3
The execution of an assignment_statement for a set shall have the effect
of copying the elements from the source set object to the target set
object and changing the length of the target object to that of the
source object.

                        _Implementation Advice_

104/2
Move should not copy elements, and should minimize copying of internal
data structures.

105/2
If an exception is propagated from a set operation, no storage should be
lost, nor any elements removed from a set unless specified by the
operation.


File: arm2012.info,  Node: A.18.8,  Next: A.18.9,  Prev: A.18.7,  Up: A.18

A.18.8 The Generic Package Containers.Hashed_Sets
-------------------------------------------------

                          _Static Semantics_

1/2
The generic library package Containers.Hashed_Sets has the following
declaration:

2/3
     with Ada.Iterator_Interfaces;
     generic
        type Element_Type is private;
        with function Hash (Element : Element_Type) return Hash_Type;
        with function Equivalent_Elements (Left, Right : Element_Type)
                      return Boolean;
        with function "=" (Left, Right : Element_Type) return Boolean is <>;
     package Ada.Containers.Hashed_Sets is
        pragma Preelaborate(Hashed_Sets);
        pragma Remote_Types(Hashed_Sets);

3/3
        type Set is tagged private
           with Constant_Indexing => Constant_Reference,
                Default_Iterator  => Iterate,
                Iterator_Element  => Element_Type;
        pragma Preelaborable_Initialization(Set);

4/2
        type Cursor is private;
        pragma Preelaborable_Initialization(Cursor);

5/2
        Empty_Set : constant Set;

6/2
        No_Element : constant Cursor;

6.1/3
        function Has_Element (Position : Cursor) return Boolean;

6.2/3
        package Set_Iterator_Interfaces is new
            Ada.Iterator_Interfaces (Cursor, Has_Element);

7/2
        function "=" (Left, Right : Set) return Boolean;

8/2
        function Equivalent_Sets (Left, Right : Set) return Boolean;

9/2
        function To_Set (New_Item : Element_Type) return Set;

10/2
        function Capacity (Container : Set) return Count_Type;

11/2
        procedure Reserve_Capacity (Container : in out Set;
                                    Capacity  : in     Count_Type);

12/2
        function Length (Container : Set) return Count_Type;

13/2
        function Is_Empty (Container : Set) return Boolean;

14/2
        procedure Clear (Container : in out Set);

15/2
        function Element (Position : Cursor) return Element_Type;

16/2
        procedure Replace_Element (Container : in out Set;
                                   Position  : in     Cursor;
                                   New_Item  : in     Element_Type);

17/2
        procedure Query_Element
          (Position : in Cursor;
           Process  : not null access procedure (Element : in Element_Type));

17.1/3
        type Constant_Reference_Type
              (Element : not null access constant Element_Type) is private
           with Implicit_Dereference => Element;

17.2/3
        function Constant_Reference (Container : aliased in Set;
                                     Position  : in Cursor)
           return Constant_Reference_Type;

17.3/3
        procedure Assign (Target : in out Set; Source : in Set);

17.4/3
        function Copy (Source : Set; Capacity : Count_Type := 0) return Set;

18/2
        procedure Move (Target : in out Set;
                        Source : in out Set);

19/2
        procedure Insert (Container : in out Set;
                          New_Item  : in     Element_Type;
                          Position  :    out Cursor;
                          Inserted  :    out Boolean);

20/2
        procedure Insert (Container : in out Set;
                          New_Item  : in     Element_Type);

21/2
        procedure Include (Container : in out Set;
                           New_Item  : in     Element_Type);

22/2
        procedure Replace (Container : in out Set;
                           New_Item  : in     Element_Type);

23/2
        procedure Exclude (Container : in out Set;
                           Item      : in     Element_Type);

24/2
        procedure Delete (Container : in out Set;
                          Item      : in     Element_Type);

25/2
        procedure Delete (Container : in out Set;
                          Position  : in out Cursor);

26/2
        procedure Union (Target : in out Set;
                         Source : in     Set);

27/2
        function Union (Left, Right : Set) return Set;

28/2
        function "or" (Left, Right : Set) return Set renames Union;

29/2
        procedure Intersection (Target : in out Set;
                                Source : in     Set);

30/2
        function Intersection (Left, Right : Set) return Set;

31/2
        function "and" (Left, Right : Set) return Set renames Intersection;

32/2
        procedure Difference (Target : in out Set;
                              Source : in     Set);

33/2
        function Difference (Left, Right : Set) return Set;

34/2
        function "-" (Left, Right : Set) return Set renames Difference;

35/2
        procedure Symmetric_Difference (Target : in out Set;
                                        Source : in     Set);

36/2
        function Symmetric_Difference (Left, Right : Set) return Set;

37/2
        function "xor" (Left, Right : Set) return Set
          renames Symmetric_Difference;

38/2
        function Overlap (Left, Right : Set) return Boolean;

39/2
        function Is_Subset (Subset : Set;
                            Of_Set : Set) return Boolean;

40/2
        function First (Container : Set) return Cursor;

41/2
        function Next (Position : Cursor) return Cursor;

42/2
        procedure Next (Position : in out Cursor);

43/2
        function Find (Container : Set;
                       Item      : Element_Type) return Cursor;

44/2
        function Contains (Container : Set;
                           Item      : Element_Type) return Boolean;

45/3
     This paragraph was deleted.

46/2
        function Equivalent_Elements (Left, Right : Cursor)
          return Boolean;

47/2
        function Equivalent_Elements (Left  : Cursor;
                                      Right : Element_Type)
          return Boolean;

48/2
        function Equivalent_Elements (Left  : Element_Type;
                                      Right : Cursor)
          return Boolean;

49/2
        procedure Iterate
          (Container : in Set;
           Process   : not null access procedure (Position : in Cursor));

49.1/3
        function Iterate (Container : in Set)
           return Set_Iterator_Interfaces.Forward_Iterator'Class;

50/2
        generic
           type Key_Type (<>) is private;
           with function Key (Element : Element_Type) return Key_Type;
           with function Hash (Key : Key_Type) return Hash_Type;
           with function Equivalent_Keys (Left, Right : Key_Type)
                                          return Boolean;
        package Generic_Keys is

51/2
           function Key (Position : Cursor) return Key_Type;

52/2
           function Element (Container : Set;
                             Key       : Key_Type)
             return Element_Type;

53/2
           procedure Replace (Container : in out Set;
                              Key       : in     Key_Type;
                              New_Item  : in     Element_Type);

54/2
           procedure Exclude (Container : in out Set;
                              Key       : in     Key_Type);

55/2
           procedure Delete (Container : in out Set;
                             Key       : in     Key_Type);

56/2
           function Find (Container : Set;
                          Key       : Key_Type)
              return Cursor;

57/2
           function Contains (Container : Set;
                              Key       : Key_Type)
              return Boolean;

58/2
           procedure Update_Element_Preserving_Key
             (Container : in out Set;
              Position  : in     Cursor;
              Process   : not null access procedure
                              (Element : in out Element_Type));

58.1/3
           type Reference_Type
                 (Element : not null access Element_Type) is private
              with Implicit_Dereference => Element;

58.2/3
           function Reference_Preserving_Key (Container : aliased in out Set;
                                              Position  : in Cursor)
              return Reference_Type;

58.3/3
           function Constant_Reference (Container : aliased in Set;
                                        Key       : in Key_Type)
              return Constant_Reference_Type;

58.4/3
           function Reference_Preserving_Key (Container : aliased in out Set;
                                              Key       : in Key_Type)
              return Reference_Type;

59/2
        end Generic_Keys;

60/2
     private

61/2
        ... -- not specified by the language

62/2
     end Ada.Containers.Hashed_Sets;

63/2
An object of type Set contains an expandable hash table, which is used
to provide direct access to elements.  The capacity of an object of type
Set is the maximum number of elements that can be inserted into the hash
table prior to it being automatically expanded.

64/2
Two elements E1 and E2 are defined to be equivalent if
Equivalent_Elements (E1, E2) returns True.

65/2
The actual function for the generic formal function Hash is expected to
return the same value each time it is called with a particular element
value.  For any two equivalent elements, the actual for Hash is expected
to return the same value.  If the actual for Hash behaves in some other
manner, the behavior of this package is unspecified.  Which subprograms
of this package call Hash, and how many times they call it, is
unspecified.

66/2
The actual function for the generic formal function Equivalent_Elements
is expected to return the same value each time it is called with a
particular pair of Element values.  It should define an equivalence
relationship, that is, be reflexive, symmetric, and transitive.  If the
actual for Equivalent_Elements behaves in some other manner, the
behavior of this package is unspecified.  Which subprograms of this
package call Equivalent_Elements, and how many times they call it, is
unspecified.

66.1/3
If the actual function for the generic formal function "=" returns True
for any pair of nonequivalent elements, then the behavior of the
container function "=" is unspecified.

67/2
If the value of an element stored in a set is changed other than by an
operation in this package such that at least one of Hash or
Equivalent_Elements give different results, the behavior of this package
is unspecified.

68/2
Which elements are the first element and the last element of a set, and
which element is the successor of a given element, are unspecified,
other than the general semantics described in *note A.18.7::.

69/2
     function Capacity (Container : Set) return Count_Type;

70/2
          Returns the capacity of Container.

71/2
     procedure Reserve_Capacity (Container : in out Set;
                                 Capacity  : in     Count_Type);

72/2
          Reserve_Capacity allocates a new hash table such that the
          length of the resulting set can become at least the value
          Capacity without requiring an additional call to
          Reserve_Capacity, and is large enough to hold the current
          length of Container.  Reserve_Capacity then rehashes the
          elements in Container onto the new hash table.  It replaces
          the old hash table with the new hash table, and then
          deallocates the old hash table.  Any exception raised during
          allocation is propagated and Container is not modified.

73/2
          Reserve_Capacity tampers with the cursors of Container.

74/2
     procedure Clear (Container : in out Set);

75/2
          In addition to the semantics described in *note A.18.7::,
          Clear does not affect the capacity of Container.

75.1/3
     procedure Assign (Target : in out Set; Source : in Set);

75.2/3
          In addition to the semantics described in *note A.18.7::, if
          the length of Source is greater than the capacity of Target,
          Reserve_Capacity (Target, Length (Source)) is called before
          assigning any elements.

75.3/3
     function Copy (Source : Set; Capacity : Count_Type := 0) return Set;

75.4/3
          Returns a set whose elements are initialized from the elements
          of Source.  If Capacity is 0, then the set capacity is the
          length of Source; if Capacity is equal to or greater than the
          length of Source, the set capacity is at least the specified
          value.  Otherwise, the operation propagates Capacity_Error.

76/2
     procedure Insert (Container : in out Set;
                       New_Item  : in     Element_Type;
                       Position  :    out Cursor;
                       Inserted  :    out Boolean);

77/2
          In addition to the semantics described in *note A.18.7::, if
          Length (Container) equals Capacity (Container), then Insert
          first calls Reserve_Capacity to increase the capacity of
          Container to some larger value.

78/2
     function First (Container : Set) return Cursor;

79/2
          If Length (Container) = 0, then First returns No_Element.
          Otherwise, First returns a cursor that designates the first
          hashed element in Container.

80/2
     function Equivalent_Elements (Left, Right : Cursor)
           return Boolean;

81/2
          Equivalent to Equivalent_Elements (Element (Left), Element
          (Right)).

82/2
     function Equivalent_Elements (Left  : Cursor;
                                   Right : Element_Type) return Boolean;

83/2
          Equivalent to Equivalent_Elements (Element (Left), Right).

84/2
     function Equivalent_Elements (Left  : Element_Type;
                                   Right : Cursor) return Boolean;

85/2
          Equivalent to Equivalent_Elements (Left, Element (Right)).

85.1/3
     function Iterate (Container : in Set)
        return Set_Iterator_Interfaces.Forward_Iterator'Class;

85.2/3
          Iterate returns an iterator object (see *note 5.5.1::) that
          will generate a value for a loop parameter (see *note 5.5.2::)
          designating each element in Container, starting with the first
          element and moving the cursor according to the successor
          relation.  Tampering with the cursors of Container is
          prohibited while the iterator object exists (in particular, in
          the sequence_of_statements of the loop_statement whose
          iterator_specification denotes this object).  The iterator
          object needs finalization.

86/2
For any element E, the actual function for the generic formal function
Generic_Keys.Hash is expected to be such that Hash (E) =
Generic_Keys.Hash (Key (E)). If the actuals for Key or Generic_Keys.Hash
behave in some other manner, the behavior of Generic_Keys is
unspecified.  Which subprograms of Generic_Keys call Generic_Keys.Hash,
and how many times they call it, is unspecified.

87/2
For any two elements E1 and E2, the boolean values Equivalent_Elements
(E1, E2) and Equivalent_Keys (Key (E1), Key (E2)) are expected to be
equal.  If the actuals for Key or Equivalent_Keys behave in some other
manner, the behavior of Generic_Keys is unspecified.  Which subprograms
of Generic_Keys call Equivalent_Keys, and how many times they call it,
is unspecified.

                        _Implementation Advice_

88/2
If N is the length of a set, the average time complexity of the
subprograms Insert, Include, Replace, Delete, Exclude and Find that take
an element parameter should be O(log N). The average time complexity of
the subprograms that take a cursor parameter should be O(1).  The
average time complexity of Reserve_Capacity should be O(N).


File: arm2012.info,  Node: A.18.9,  Next: A.18.10,  Prev: A.18.8,  Up: A.18

A.18.9 The Generic Package Containers.Ordered_Sets
--------------------------------------------------

                          _Static Semantics_

1/2
The generic library package Containers.Ordered_Sets has the following
declaration:

2/3
     with Ada.Iterator_Interfaces;
     generic
        type Element_Type is private;
        with function "<" (Left, Right : Element_Type) return Boolean is <>;
        with function "=" (Left, Right : Element_Type) return Boolean is <>;
     package Ada.Containers.Ordered_Sets is
        pragma Preelaborate(Ordered_Sets);
        pragma Remote_Types(Ordered_Sets);

3/2
        function Equivalent_Elements (Left, Right : Element_Type) return Boolean;

4/3
        type Set is tagged private
           with Constant_Indexing => Constant_Reference,
                Default_Iterator  => Iterate,
                Iterator_Element  => Element_Type;
        pragma Preelaborable_Initialization(Set);

5/2
        type Cursor is private;
        pragma Preelaborable_Initialization(Cursor);

6/2
        Empty_Set : constant Set;

7/2
        No_Element : constant Cursor;

7.1/3
        function Has_Element (Position : Cursor) return Boolean;

7.2/3
        package Set_Iterator_Interfaces is new
            Ada.Iterator_Interfaces (Cursor, Has_Element);

8/2
        function "=" (Left, Right : Set) return Boolean;

9/2
        function Equivalent_Sets (Left, Right : Set) return Boolean;

10/2
        function To_Set (New_Item : Element_Type) return Set;

11/2
        function Length (Container : Set) return Count_Type;

12/2
        function Is_Empty (Container : Set) return Boolean;

13/2
        procedure Clear (Container : in out Set);

14/2
        function Element (Position : Cursor) return Element_Type;

15/2
        procedure Replace_Element (Container : in out Set;
                                   Position  : in     Cursor;
                                   New_Item  : in     Element_Type);

16/2
        procedure Query_Element
          (Position : in Cursor;
           Process  : not null access procedure (Element : in Element_Type));

16.1/3
        type Constant_Reference_Type
              (Element : not null access constant Element_Type) is private
           with Implicit_Dereference => Element;

16.2/3
        function Constant_Reference (Container : aliased in Set;
                                     Position  : in Cursor)
           return Constant_Reference_Type;

16.3/3
        procedure Assign (Target : in out Set; Source : in Set);

16.4/3
        function Copy (Source : Set) return Set;

17/2
        procedure Move (Target : in out Set;
                        Source : in out Set);

18/2
        procedure Insert (Container : in out Set;
                          New_Item  : in     Element_Type;
                          Position  :    out Cursor;
                          Inserted  :    out Boolean);

19/2
        procedure Insert (Container : in out Set;
                          New_Item  : in     Element_Type);

20/2
        procedure Include (Container : in out Set;
                           New_Item  : in     Element_Type);

21/2
        procedure Replace (Container : in out Set;
                           New_Item  : in     Element_Type);

22/2
        procedure Exclude (Container : in out Set;
                           Item      : in     Element_Type);

23/2
        procedure Delete (Container : in out Set;
                          Item      : in     Element_Type);

24/2
        procedure Delete (Container : in out Set;
                          Position  : in out Cursor);

25/2
        procedure Delete_First (Container : in out Set);

26/2
        procedure Delete_Last (Container : in out Set);

27/2
        procedure Union (Target : in out Set;
                         Source : in     Set);

28/2
        function Union (Left, Right : Set) return Set;

29/2
        function "or" (Left, Right : Set) return Set renames Union;

30/2
        procedure Intersection (Target : in out Set;
                                Source : in     Set);

31/2
        function Intersection (Left, Right : Set) return Set;

32/2
        function "and" (Left, Right : Set) return Set renames Intersection;

33/2
        procedure Difference (Target : in out Set;
                              Source : in     Set);

34/2
        function Difference (Left, Right : Set) return Set;

35/2
        function "-" (Left, Right : Set) return Set renames Difference;

36/2
        procedure Symmetric_Difference (Target : in out Set;
                                        Source : in     Set);

37/2
        function Symmetric_Difference (Left, Right : Set) return Set;

38/2
        function "xor" (Left, Right : Set) return Set renames
           Symmetric_Difference;

39/2
        function Overlap (Left, Right : Set) return Boolean;

40/2
        function Is_Subset (Subset : Set;
                            Of_Set : Set) return Boolean;

41/2
        function First (Container : Set) return Cursor;

42/2
        function First_Element (Container : Set) return Element_Type;

43/2
        function Last (Container : Set) return Cursor;

44/2
        function Last_Element (Container : Set) return Element_Type;

45/2
        function Next (Position : Cursor) return Cursor;

46/2
        procedure Next (Position : in out Cursor);

47/2
        function Previous (Position : Cursor) return Cursor;

48/2
        procedure Previous (Position : in out Cursor);

49/2
        function Find (Container : Set;
                       Item      : Element_Type)
           return Cursor;

50/2
        function Floor (Container : Set;
                        Item      : Element_Type)
           return Cursor;

51/2
        function Ceiling (Container : Set;
                          Item      : Element_Type)
           return Cursor;

52/2
        function Contains (Container : Set;
                           Item      : Element_Type) return Boolean;

53/3
     This paragraph was deleted.

54/2
        function "<" (Left, Right : Cursor) return Boolean;

55/2
        function ">" (Left, Right : Cursor) return Boolean;

56/2
        function "<" (Left : Cursor; Right : Element_Type)
           return Boolean;

57/2
        function ">" (Left : Cursor; Right : Element_Type)
           return Boolean;

58/2
        function "<" (Left : Element_Type; Right : Cursor)
           return Boolean;

59/2
        function ">" (Left : Element_Type; Right : Cursor)
           return Boolean;

60/2
        procedure Iterate
          (Container : in Set;
           Process   : not null access procedure (Position : in Cursor));

61/2
        procedure Reverse_Iterate
          (Container : in Set;
           Process   : not null access procedure (Position : in Cursor));

61.1/3
        function Iterate (Container : in Set)
           return Set_Iterator_Interfaces.Reversible_Iterator'Class;

61.2/3
        function Iterate (Container : in Set; Start : in Cursor)
           return Set_Iterator_Interfaces.Reversible_Iterator'Class;

62/2
        generic
           type Key_Type (<>) is private;
           with function Key (Element : Element_Type) return Key_Type;
           with function "<" (Left, Right : Key_Type)
              return Boolean is <>;
        package Generic_Keys is

63/2
            function Equivalent_Keys (Left, Right : Key_Type)
               return Boolean;

64/2
            function Key (Position : Cursor) return Key_Type;

65/2
            function Element (Container : Set;
                              Key       : Key_Type)
               return Element_Type;

66/2
            procedure Replace (Container : in out Set;
                               Key       : in     Key_Type;
                               New_Item  : in     Element_Type);

67/2
            procedure Exclude (Container : in out Set;
                               Key       : in     Key_Type);

68/2
            procedure Delete (Container : in out Set;
                              Key       : in     Key_Type);

69/2
            function Find (Container : Set;
                           Key       : Key_Type)
               return Cursor;

70/2
            function Floor (Container : Set;
                            Key       : Key_Type)
               return Cursor;

71/2
            function Ceiling (Container : Set;
                              Key       : Key_Type)
               return Cursor;

72/2
            function Contains (Container : Set;
                               Key       : Key_Type) return Boolean;

73/2
            procedure Update_Element_Preserving_Key
              (Container : in out Set;
               Position  : in     Cursor;
               Process   : not null access procedure
                               (Element : in out Element_Type));

73.1/3
           type Reference_Type
                 (Element : not null access Element_Type) is private
              with Implicit_Dereference => Element;

73.2/3
           function Reference_Preserving_Key (Container : aliased in out Set;
                                              Position  : in Cursor)
              return Reference_Type;

73.3/3
           function Constant_Reference (Container : aliased in Set;
                                        Key       : in Key_Type)
              return Constant_Reference_Type;

73.4/3
           function Reference_Preserving_Key (Container : aliased in out Set;
                                              Key       : in Key_Type)
              return Reference_Type;

74/2
        end Generic_Keys;

75/2
     private

76/2
        ... -- not specified by the language

77/2
     end Ada.Containers.Ordered_Sets;

78/2
Two elements E1 and E2 are equivalent if both E1 < E2 and E2 < E1 return
False, using the generic formal "<" operator for elements.  Function
Equivalent_Elements returns True if Left and Right are equivalent, and
False otherwise.

79/3
The actual function for the generic formal function "<" on Element_Type
values is expected to return the same value each time it is called with
a particular pair of key values.  It should define a strict weak
ordering relationship (see *note A.18::).  If the actual for "<" behaves
in some other manner, the behavior of this package is unspecified.
Which subprograms of this package call "<" and how many times they call
it, is unspecified.

79.1/3
If the actual function for the generic formal function "=" returns True
for any pair of nonequivalent elements, then the behavior of the
container function "=" is unspecified.

80/2
If the value of an element stored in a set is changed other than by an
operation in this package such that at least one of "<" or "=" give
different results, the behavior of this package is unspecified.

81/3
The first element of a nonempty set is the one which is less than all
the other elements in the set.  The last element of a nonempty set is
the one which is greater than all the other elements in the set.  The
successor of an element is the smallest element that is larger than the
given element.  The predecessor of an element is the largest element
that is smaller than the given element.  All comparisons are done using
the generic formal "<" operator for elements.

81.1/3
     function Copy (Source : Set) return Set;

81.2/3
          Returns a set whose elements are initialized from the
          corresponding elements of Source.

82/2
     procedure Delete_First (Container : in out Set);

83/3
          If Container is empty, Delete_First has no effect.  Otherwise,
          the element designated by First (Container) is removed from
          Container.  Delete_First tampers with the cursors of
          Container.

84/2
     procedure Delete_Last (Container : in out Set);

85/3
          If Container is empty, Delete_Last has no effect.  Otherwise,
          the element designated by Last (Container) is removed from
          Container.  Delete_Last tampers with the cursors of Container.

86/2
     function First_Element (Container : Set) return Element_Type;

87/2
          Equivalent to Element (First (Container)).

88/2
     function Last (Container : Set) return Cursor;

89/2
          Returns a cursor that designates the last element in
          Container.  If Container is empty, returns No_Element.

90/2
     function Last_Element (Container : Set) return Element_Type;

91/2
          Equivalent to Element (Last (Container)).

92/2
     function Previous (Position : Cursor) return Cursor;

93/3
          If Position equals No_Element, then Previous returns
          No_Element.  Otherwise, Previous returns a cursor designating
          the predecessor element of the one designated by Position.  If
          Position designates the first element, then Previous returns
          No_Element.

94/2
     procedure Previous (Position : in out Cursor);

95/2
          Equivalent to Position := Previous (Position).

96/2
     function Floor (Container : Set;
                     Item      : Element_Type) return Cursor;

97/3
          Floor searches for the last element which is not greater than
          Item.  If such an element is found, a cursor that designates
          it is returned.  Otherwise, No_Element is returned.

98/2
     function Ceiling (Container : Set;
                       Item      : Element_Type) return Cursor;

99/3
          Ceiling searches for the first element which is not less than
          Item.  If such an element is found, a cursor that designates
          it is returned.  Otherwise, No_Element is returned.

100/2
     function "<" (Left, Right : Cursor) return Boolean;

101/2
          Equivalent to Element (Left) < Element (Right).

102/2
     function ">" (Left, Right : Cursor) return Boolean;

103/2
          Equivalent to Element (Right) < Element (Left).

104/2
     function "<" (Left : Cursor; Right : Element_Type) return Boolean;

105/2
          Equivalent to Element (Left) < Right.

106/2
     function ">" (Left : Cursor; Right : Element_Type) return Boolean;

107/2
          Equivalent to Right < Element (Left).

108/2
     function "<" (Left : Element_Type; Right : Cursor) return Boolean;

109/2
          Equivalent to Left < Element (Right).

110/2
     function ">" (Left : Element_Type; Right : Cursor) return Boolean;

111/2
          Equivalent to Element (Right) < Left.

112/2
     procedure Reverse_Iterate
        (Container : in Set;
         Process   : not null access procedure (Position : in Cursor));

113/3
          Iterates over the elements in Container as per procedure
          Iterate, with the difference that the elements are traversed
          in predecessor order, starting with the last element.

113.1/3
     function Iterate (Container : in Set)
        return Set_Iterator_Interfaces.Reversible_Iterator'Class;

113.2/3
          Iterate returns a reversible iterator object (see *note
          5.5.1::) that will generate a value for a loop parameter (see
          *note 5.5.2::) designating each element in Container, starting
          with the first element and moving the cursor according to the
          successor relation when used as a forward iterator, and
          starting with the last element and moving the cursor according
          to the predecessor relation when used as a reverse iterator.
          Tampering with the cursors of Container is prohibited while
          the iterator object exists (in particular, in the
          sequence_of_statements of the loop_statement whose
          iterator_specification denotes this object).  The iterator
          object needs finalization.

113.3/3
     function Iterate (Container : in Set; Start : in Cursor)
        return Set_Iterator_Interfaces.Reversible_Iterator'Class;

113.4/3
          If Start is not No_Element and does not designate an item in
          Container, then Program_Error is propagated.  If Start is
          No_Element, then Constraint_Error is propagated.  Otherwise,
          Iterate returns a reversible iterator object (see *note
          5.5.1::) that will generate a value for a loop parameter (see
          *note 5.5.2::) designating each element in Container, starting
          with the element designated by Start and moving the cursor
          according to the successor relation when used as a forward
          iterator, or moving the cursor according to the predecessor
          relation when used as a reverse iterator.  Tampering with the
          cursors of Container is prohibited while the iterator object
          exists (in particular, in the sequence_of_statements of the
          loop_statement whose iterator_specification denotes this
          object).  The iterator object needs finalization.

114/2
For any two elements E1 and E2, the boolean values (E1 < E2) and
(Key(E1) < Key(E2)) are expected to be equal.  If the actuals for Key or
Generic_Keys."<" behave in some other manner, the behavior of this
package is unspecified.  Which subprograms of this package call Key and
Generic_Keys."<", and how many times the functions are called, is
unspecified.

115/2
In addition to the semantics described in *note A.18.7::, the
subprograms in package Generic_Keys named Floor and Ceiling, are
equivalent to the corresponding subprograms in the parent package, with
the difference that the Key subprogram parameter is compared to elements
in the container using the Key and "<" generic formal functions.  The
function named Equivalent_Keys in package Generic_Keys returns True if
both Left < Right and Right < Left return False using the generic formal
"<" operator, and returns True otherwise.

                        _Implementation Advice_

116/2
If N is the length of a set, then the worst-case time complexity of the
Insert, Include, Replace, Delete, Exclude and Find operations that take
an element parameter should be O((log N)**2) or better.  The worst-case
time complexity of the subprograms that take a cursor parameter should
be O(1).


File: arm2012.info,  Node: A.18.10,  Next: A.18.11,  Prev: A.18.9,  Up: A.18

A.18.10 The Generic Package Containers.Multiway_Trees
-----------------------------------------------------

1/3
The language-defined generic package Containers.Multiway_Trees provides
private types Tree and Cursor, and a set of operations for each type.  A
multiway tree container is well-suited to represent nested structures.

2/4
A multiway tree container object manages a tree of nodes, consisting of
a root node and a set of internal nodes; each internal node contains an
element and pointers to the parent, first child, last child, next
(successor) sibling, and previous (predecessor) sibling internal nodes.
A cursor designates a particular node within a tree (and by extension
the element contained in that node, if any).  A cursor keeps designating
the same node (and element) as long as the node is part of the
container, even if the node is moved within the container.

3/4
A subtree is a particular node (which roots the subtree) and all of its
child nodes (including all of the children of the child nodes,
recursively). The root node is always present and has neither an
associated element value nor any parent node; it has pointers to its
first child and its last child, if any.  The root node provides a place
to add nodes to an otherwise empty tree and represents the base of the
tree.

4/3
A node that has no children is called a leaf node.  The ancestors of a
node are the node itself, its parent node, the parent of the parent
node, and so on until a node with no parent is reached.  Similarly, the
descendants of a node are the node itself, its child nodes, the children
of each child node, and so on.

5/3
The nodes of a subtree can be visited in several different orders.  For
a depth-first order, after visiting a node, the nodes of its child list
are each visited in depth-first order, with each child node visited in
natural order (first child to last child).

                          _Static Semantics_

6/3
The generic library package Containers.Multiway_Trees has the following
declaration:

7/3
     with Ada.Iterator_Interfaces;
     generic
        type Element_Type is private;
        with function "=" (Left, Right : Element_Type) return Boolean is <>;
     package Ada.Containers.Multiway_Trees is
        pragma Preelaborate(Multiway_Trees);
        pragma Remote_Types(Multiway_Trees);

8/3
        type Tree is tagged private
           with Constant_Indexing => Constant_Reference,
                Variable_Indexing => Reference,
                Default_Iterator  => Iterate,
                Iterator_Element  => Element_Type;
        pragma Preelaborable_Initialization(Tree);

9/3
        type Cursor is private;
        pragma Preelaborable_Initialization(Cursor);

10/3
        Empty_Tree : constant Tree;

11/3
        No_Element : constant Cursor;

12/3
        function Has_Element (Position : Cursor) return Boolean;

13/3
        package Tree_Iterator_Interfaces is new
           Ada.Iterator_Interfaces (Cursor, Has_Element);

14/3
        function Equal_Subtree (Left_Position : Cursor;
                                Right_Position: Cursor) return Boolean;

15/3
        function "=" (Left, Right : Tree) return Boolean;

16/3
        function Is_Empty (Container : Tree) return Boolean;

17/3
        function Node_Count (Container : Tree) return Count_Type;

18/3
        function Subtree_Node_Count (Position : Cursor) return Count_Type;

19/3
        function Depth (Position : Cursor) return Count_Type;

20/3
        function Is_Root (Position : Cursor) return Boolean;

21/3
        function Is_Leaf (Position : Cursor) return Boolean;

22/3
        function Root (Container : Tree) return Cursor;

23/3
        procedure Clear (Container : in out Tree);

24/3
        function Element (Position : Cursor) return Element_Type;

25/3
        procedure Replace_Element (Container : in out Tree;
                                   Position  : in     Cursor;
                                   New_Item  : in     Element_Type);

26/3
        procedure Query_Element
          (Position : in Cursor;
           Process  : not null access procedure (Element : in Element_Type));

27/3
        procedure Update_Element
          (Container : in out Tree;
           Position  : in     Cursor;
           Process   : not null access procedure
                           (Element : in out Element_Type));

28/3
        type Constant_Reference_Type
              (Element : not null access constant Element_Type) is private
           with Implicit_Dereference => Element;

29/3
        type Reference_Type (Element : not null access Element_Type) is private
           with Implicit_Dereference => Element;

30/3
        function Constant_Reference (Container : aliased in Tree;
                                     Position  : in Cursor)
           return Constant_Reference_Type;

31/3
        function Reference (Container : aliased in out Tree;
                            Position  : in Cursor)
           return Reference_Type;

32/3
        procedure Assign (Target : in out Tree; Source : in Tree);

33/3
        function Copy (Source : Tree) return Tree;

34/3
        procedure Move (Target : in out Tree;
                        Source : in out Tree);

35/3
        procedure Delete_Leaf (Container : in out Tree;
                               Position  : in out Cursor);

36/3
        procedure Delete_Subtree (Container : in out Tree;
                                  Position  : in out Cursor);

37/3
        procedure Swap (Container : in out Tree;
                        I, J      : in     Cursor);

38/3
        function Find (Container : Tree;
                       Item      : Element_Type)
           return Cursor;

39/3
        function Find_In_Subtree (Position : Cursor;
                                  Item     : Element_Type)
           return Cursor;

40/3
        function Ancestor_Find (Position : Cursor;
                                Item     : Element_Type)
           return Cursor;

41/3
        function Contains (Container : Tree;
                           Item      : Element_Type) return Boolean;

42/3
        procedure Iterate
          (Container : in Tree;
           Process   : not null access procedure (Position : in Cursor));

43/3
        procedure Iterate_Subtree
          (Position  : in Cursor;
           Process   : not null access procedure (Position : in Cursor));

44/3
        function Iterate (Container : in Tree)
           return Tree_Iterator_Interfaces.Forward_Iterator'Class;

45/3
        function Iterate_Subtree (Position : in Cursor)
           return Tree_Iterator_Interfaces.Forward_Iterator'Class;

46/3
        function Child_Count (Parent : Cursor) return Count_Type;

47/3
        function Child_Depth (Parent, Child : Cursor) return Count_Type;

48/3
        procedure Insert_Child (Container : in out Tree;
                                Parent    : in     Cursor;
                                Before    : in     Cursor;
                                New_Item  : in     Element_Type;
                                Count     : in     Count_Type := 1);

49/3
        procedure Insert_Child (Container : in out Tree;
                                Parent    : in     Cursor;
                                Before    : in     Cursor;
                                New_Item  : in     Element_Type;
                                Position  :    out Cursor;
                                Count     : in     Count_Type := 1);

50/3
        procedure Insert_Child (Container : in out Tree;
                                Parent    : in     Cursor;
                                Before    : in     Cursor;
                                Position  :    out Cursor;
                                Count     : in     Count_Type := 1);

51/3
        procedure Prepend_Child (Container : in out Tree;
                                 Parent    : in     Cursor;
                                 New_Item  : in     Element_Type;
                                 Count     : in     Count_Type := 1);

52/3
        procedure Append_Child (Container : in out Tree;
                                Parent    : in     Cursor;
                                New_Item  : in     Element_Type;
                                Count     : in     Count_Type := 1);

53/3
        procedure Delete_Children (Container : in out Tree;
                                   Parent    : in     Cursor);

54/3
        procedure Copy_Subtree (Target   : in out Tree;
                                Parent   : in     Cursor;
                                Before   : in     Cursor;
                                Source   : in     Cursor);

55/3
        procedure Splice_Subtree (Target   : in out Tree;
                                  Parent   : in     Cursor;
                                  Before   : in     Cursor;
                                  Source   : in out Tree;
                                  Position : in out Cursor);

56/3
        procedure Splice_Subtree (Container: in out Tree;
                                  Parent   : in     Cursor;
                                  Before   : in     Cursor;
                                  Position : in     Cursor);

57/3
        procedure Splice_Children (Target          : in out Tree;
                                   Target_Parent   : in     Cursor;
                                   Before          : in     Cursor;
                                   Source          : in out Tree;
                                   Source_Parent   : in     Cursor);

58/3
        procedure Splice_Children (Container       : in out Tree;
                                   Target_Parent   : in     Cursor;
                                   Before          : in     Cursor;
                                   Source_Parent   : in     Cursor);

59/3
        function Parent (Position : Cursor) return Cursor;

60/3
        function First_Child (Parent : Cursor) return Cursor;

61/3
        function First_Child_Element (Parent : Cursor) return Element_Type;

62/3
        function Last_Child (Parent : Cursor) return Cursor;

63/3
        function Last_Child_Element (Parent : Cursor) return Element_Type;

64/3
        function Next_Sibling (Position : Cursor) return Cursor;

65/3
        function Previous_Sibling (Position : Cursor) return Cursor;

66/3
        procedure Next_Sibling (Position : in out Cursor);

67/3
        procedure Previous_Sibling (Position : in out Cursor);

68/3
        procedure Iterate_Children
          (Parent  : in Cursor;
           Process : not null access procedure (Position : in Cursor));

69/3
        procedure Reverse_Iterate_Children
          (Parent  : in Cursor;
           Process : not null access procedure (Position : in Cursor));

70/3
        function Iterate_Children (Container : in Tree; Parent : in Cursor)
           return Tree_Iterator_Interfaces.Reversible_Iterator'Class;

71/3
     private
        ... -- not specified by the language
     end Ada.Containers.Multiway_Trees;

72/3
The actual function for the generic formal function "=" on Element_Type
values is expected to define a reflexive and symmetric relationship and
return the same result value each time it is called with a particular
pair of values.  If it behaves in some other manner, the functions Find,
Reverse_Find, Equal_Subtree, and "=" on tree values return an
unspecified value.  The exact arguments and number of calls of this
generic formal function by the functions Find, Reverse_Find,
Equal_Subtree, and "=" on tree values are unspecified.

73/3
The type Tree is used to represent trees.  The type Tree needs
finalization (see *note 7.6::).

74/3
Empty_Tree represents the empty Tree object.  It contains only the root
node (Node_Count (Empty_Tree) returns 1).  If an object of type Tree is
not otherwise initialized, it is initialized to the same value as
Empty_Tree.

75/3
No_Element represents a cursor that designates no element.  If an object
of type Cursor is not otherwise initialized, it is initialized to the
same value as No_Element.

76/3
The predefined "=" operator for type Cursor returns True if both cursors
are No_Element, or designate the same element in the same container.

77/3
Execution of the default implementation of the Input, Output, Read, or
Write attribute of type Cursor raises Program_Error.

78/3
Tree'Write for a Tree object T writes Node_Count(T) - 1 elements of the
tree to the stream.  It also may write additional information about the
tree.

79/3
Tree'Read reads the representation of a tree from the stream, and
assigns to Item a tree with the same elements and structure as was
written by Tree'Write.

80/3
Some operations of this generic package have access-to-subprogram
parameters.  To ensure such operations are well-defined, they guard
against certain actions by the designated subprogram.  In particular,
some operations check for "tampering with cursors" of a container
because they depend on the set of elements of the container remaining
constant, and others check for "tampering with elements" of a container
because they depend on elements of the container not being replaced.

81/3
A subprogram is said to tamper with cursors of a tree object T if:

82/3
   * it inserts or deletes elements of T, that is, it calls the Clear,
     Delete_Leaf, Insert_Child, Delete_Children, Delete_Subtree, or
     Copy_Subtree procedures with T as a parameter; or

83/3
   * it reorders the elements of T, that is, it calls the Splice_Subtree
     or Splice_Children procedures with T as a parameter; or

84/3
   * it finalizes T; or

85/3
   * it calls Assign with T as the Target parameter; or

86/3
   * it calls the Move procedure with T as a parameter.

87/3
A subprogram is said to tamper with elements of a tree object T if:

88/3
   * it tampers with cursors of T; or

89/3
   * it replaces one or more elements of T, that is, it calls the
     Replace_Element or Swap procedures with T as a parameter.

90/4
When tampering with cursors is prohibited for a particular tree object
T, Program_Error is propagated by a call of any language-defined
subprogram that is defined to tamper with the cursors of T, leaving T
unmodified.  Similarly, when tampering with elements is prohibited for a
particular tree object T, Program_Error is propagated by a call of any
language-defined subprogram that is defined to tamper with the elements
of T (or tamper with the cursors of T), leaving T unmodified.  These
checks are made before any other defined behavior of the body of the
language-defined subprogram.

91/3
     function Has_Element (Position : Cursor) return Boolean;

92/3
          Returns True if Position designates an element, and returns
          False otherwise.  In particular, Has_Element returns False if
          the cursor designates a root node or equals No_Element.

93/3
     function Equal_Subtree (Left_Position : Cursor;
                             Right_Position: Cursor) return Boolean;

94/3
          If Left_Position or Right_Position equals No_Element,
          propagates Constraint_Error.  If the number of child nodes of
          the element designated by Left_Position is different from the
          number of child nodes of the element designated by
          Right_Position, the function returns False.  If Left_Position
          designates a root node and Right_Position does not, the
          function returns False.  If Right_Position designates a root
          node and Left_Position does not, the function returns False.
          Unless both cursors designate a root node, the elements are
          compared using the generic formal equality operator.  If the
          result of the element comparison is False, the function
          returns False.  Otherwise, it calls Equal_Subtree on a cursor
          designating each child element of the element designated by
          Left_Position and a cursor designating the corresponding child
          element of the element designated by Right_Position.  If any
          such call returns False, the function returns False;
          otherwise, it returns True.  Any exception raised during the
          evaluation of element equality is propagated.

95/3
     function "=" (Left, Right : Tree) return Boolean;

96/3
          If Left and Right denote the same tree object, then the
          function returns True.  Otherwise, it calls Equal_Subtree with
          cursors designating the root nodes of Left and Right; the
          result is returned.  Any exception raised during the
          evaluation of Equal_Subtree is propagated.

97/3
     function Node_Count (Container : Tree) return Count_Type;

98/3
          Node_Count returns the number of nodes in Container.

99/3
     function Subtree_Node_Count (Position : Cursor) return Count_Type;

100/3
          If Position is No_Element, Subtree_Node_Count returns 0;
          otherwise, Subtree_Node_Count returns the number of nodes in
          the subtree that is rooted by Position.

101/3
     function Is_Empty (Container : Tree) return Boolean;

102/3
          Equivalent to Node_Count (Container) = 1.

103/3
     function Depth (Position : Cursor) return Count_Type;

104/3
          If Position equals No_Element, Depth returns 0; otherwise,
          Depth returns the number of ancestor nodes of the node
          designated by Position (including the node itself).

105/3
     function Is_Root (Position : Cursor) return Boolean;

106/3
          Is_Root returns True if the Position designates the root node
          of some tree; and returns False otherwise.

107/3
     function Is_Leaf (Position : Cursor) return Boolean;

108/3
          Is_Leaf returns True if Position designates a node that does
          not have any child nodes; and returns False otherwise.

109/3
     function Root (Container : Tree) return Cursor;

110/3
          Root returns a cursor that designates the root node of
          Container.

111/3
     procedure Clear (Container : in out Tree);

112/3
          Removes all the elements from Container.

113/3
     function Element (Position : Cursor) return Element_Type;

114/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position designates the root node of a tree,
          then Program_Error is propagated.  Otherwise, Element returns
          the element designated by Position.

115/3
     procedure Replace_Element (Container : in out Tree;
                                Position  : in     Cursor;
                                New_Item  : in     Element_Type);

116/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container (including if it designates the root node), then
          Program_Error is propagated.  Otherwise, Replace_Element
          assigns the value New_Item to the element designated by
          Position.

117/3
     procedure Query_Element
       (Position : in Cursor;
        Process  : not null access procedure (Element : in Element_Type));

118/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position designates the root node of a tree,
          then Program_Error is propagated.  Otherwise, Query_Element
          calls Process.all with the element designated by Position as
          the argument.  Tampering with the elements of the tree that
          contains the element designated by Position is prohibited
          during the execution of the call on Process.all.  Any
          exception raised by Process.all is propagated.

119/3
     procedure Update_Element
       (Container : in out Tree;
        Position  : in     Cursor;
        Process   : not null access procedure
                        (Element : in out Element_Type));

120/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container (including if it designates the root node), then
          Program_Error is propagated.  Otherwise, Update_Element calls
          Process.all with the element designated by Position as the
          argument.  Tampering with the elements of Container is
          prohibited during the execution of the call on Process.all.
          Any exception raised by Process.all is propagated.

121/3
          If Element_Type is unconstrained and definite, then the actual
          Element parameter of Process.all shall be unconstrained.

122/3
     type Constant_Reference_Type
           (Element : not null access constant Element_Type) is private
        with Implicit_Dereference => Element;

123/3
     type Reference_Type (Element : not null access Element_Type) is private
        with Implicit_Dereference => Element;

124/3
          The types Constant_Reference_Type and Reference_Type need
          finalization.

125/3
          The default initialization of an object of type
          Constant_Reference_Type or Reference_Type propagates
          Program_Error.

126/3
     function Constant_Reference (Container : aliased in Tree;
                                  Position  : in Cursor)
        return Constant_Reference_Type;

127/3
          This function (combined with the Constant_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read access to an individual element of a tree given a
          cursor.

128/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Constant_Reference returns an object whose discriminant is an
          access value that designates the element designated by
          Position.  Tampering with the elements of Container is
          prohibited while the object returned by Constant_Reference
          exists and has not been finalized.

129/3
     function Reference (Container : aliased in out Tree;
                         Position  : in Cursor)
        return Reference_Type;

130/3
          This function (combined with the Variable_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read and write access to an individual element of a tree
          given a cursor.

131/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Reference returns an object whose discriminant is an access
          value that designates the element designated by Position.
          Tampering with the elements of Container is prohibited while
          the object returned by Reference exists and has not been
          finalized.

132/3
     procedure Assign (Target : in out Tree; Source : in Tree);

133/3
          If Target denotes the same object as Source, the operation has
          no effect.  Otherwise, the elements of Source are copied to
          Target as for an assignment_statement assigning Source to
          Target.

134/3
     function Copy (Source : Tree) return Tree;

135/3
          Returns a tree with the same structure as Source and whose
          elements are initialized from the corresponding elements of
          Source.

136/3
     procedure Move (Target : in out Tree;
                     Source : in out Tree);

137/3
          If Target denotes the same object as Source, then the
          operation has no effect.  Otherwise, Move first calls Clear
          (Target).  Then, the nodes other than the root node in Source
          are moved to Target (in the same positions).  After Move
          completes, Node_Count (Target) is the number of nodes
          originally in Source, and Node_Count (Source) is 1.

138/3
     procedure Delete_Leaf (Container : in out Tree;
                            Position  : in out Cursor);

139/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container (including if it designates the root node), then
          Program_Error is propagated.  If the element designated by
          position has any child elements, then Constraint_Error is
          propagated.  Otherwise, Delete_Leaf removes (from Container)
          the element designated by Position.  Finally, Position is set
          to No_Element.

140/3
     procedure Delete_Subtree (Container : in out Tree;
                               Position  : in out Cursor);

141/3
          If Position equals No_Element, then Constraint_Error is
          propagated.  If Position does not designate an element in
          Container (including if it designates the root node), then
          Program_Error is propagated.  Otherwise, Delete_Subtree
          removes (from Container) the subtree designated by Position
          (that is, all descendants of the node designated by Position
          including the node itself), and Position is set to No_Element.

142/3
     procedure Swap (Container : in out Tree;
                     I, J      : in     Cursor);

143/3
          If either I or J equals No_Element, then Constraint_Error is
          propagated.  If either I or J do not designate an element in
          Container (including if either designates the root node), then
          Program_Error is propagated.  Otherwise, Swap exchanges the
          values of the elements designated by I and J.

144/3
     function Find (Container : Tree;
                    Item      : Element_Type)
        return Cursor;

145/3
          Find searches the elements of Container for an element equal
          to Item (using the generic formal equality operator).  The
          search starts at the root node.  The search traverses the tree
          in a depth-first order.  If no equal element is found, then
          Find returns No_Element.  Otherwise, it returns a cursor
          designating the first equal element encountered.

146/3
     function Find_In_Subtree (Position : Cursor;
                               Item     : Element_Type)
        return Cursor;

147/3
          If Position equals No_Element, then Constraint_Error is
          propagated.  Find_In_Subtree searches the subtree rooted by
          Position for an element equal to Item (using the generic
          formal equality operator).  The search starts at the element
          designated by Position.  The search traverses the subtree in a
          depth-first order.  If no equal element is found, then Find
          returns No_Element.  Otherwise, it returns a cursor
          designating the first equal element encountered.

148/3
     function Ancestor_Find (Position : Cursor;
                             Item     : Element_Type)
        return Cursor;

149/3
          If Position equals No_Element, then Constraint_Error is
          propagated.  Otherwise, Ancestor_Find searches for an element
          equal to Item (using the generic formal equality operator).
          The search starts at the node designated by Position, and
          checks each ancestor proceeding toward the root of the
          subtree.  If no equal element is found, then Ancestor_Find
          returns No_Element.  Otherwise, it returns a cursor
          designating the first equal element encountered.

150/3
     function Contains (Container : Tree;
                        Item      : Element_Type) return Boolean;

151/3
          Equivalent to Find (Container, Item) /= No_Element.

152/3
     procedure Iterate
       (Container : in Tree;
        Process   : not null access procedure (Position : in Cursor));

153/4
          Iterate calls Process.all with a cursor that designates each
          element in Container, starting from the root node and
          proceeding in a depth-first order.  Tampering with the cursors
          of Container is prohibited during the execution of a call on
          Process.all.  Any exception raised by Process.all is
          propagated.

154/3
     procedure Iterate_Subtree
       (Position  : in Cursor;
        Process   : not null access procedure (Position : in Cursor));

155/4
          If Position equals No_Element, then Constraint_Error is
          propagated.  Otherwise, Iterate_Subtree calls Process.all with
          a cursor that designates each element in the subtree rooted by
          the node designated by Position, starting from the node
          designated by Position and proceeding in a depth-first order.
          Tampering with the cursors of the tree that contains the
          element designated by Position is prohibited during the
          execution of a call on Process.all.  Any exception raised by
          Process.all is propagated.

156/3
     function Iterate (Container : in Tree)
        return Tree_Iterator_Interfaces.Forward_Iterator'Class;

157/4
          Iterate returns an iterator object (see *note 5.5.1::) that
          will generate a value for a loop parameter (see *note 5.5.2::)
          designating each element in Container, starting from the root
          node and proceeding in a depth-first order.  Tampering with
          the cursors of Container is prohibited while the iterator
          object exists (in particular, in the sequence_of_statements of
          the loop_statement whose iterator_specification denotes this
          object).  The iterator object needs finalization.

158/3
     function Iterate_Subtree (Position : in Cursor)
        return Tree_Iterator_Interfaces.Forward_Iterator'Class;

159/4
          If Position equals No_Element, then Constraint_Error is
          propagated.  Otherwise, Iterate_Subtree returns an iterator
          object (see *note 5.5.1::) that will generate a value for a
          loop parameter (see *note 5.5.2::) designating each element in
          the subtree rooted by the node designated by Position,
          starting from the node designated by Position and proceeding
          in a depth-first order.  If Position equals No_Element, then
          Constraint_Error is propagated.  Tampering with the cursors of
          the container that contains the node designated by Position is
          prohibited while the iterator object exists (in particular, in
          the sequence_of_statements of the loop_statement whose
          iterator_specification denotes this object).  The iterator
          object needs finalization.

160/3
     function Child_Count (Parent : Cursor) return Count_Type;

161/3
          Child_Count returns the number of child nodes of the node
          designated by Parent.

162/3
     function Child_Depth (Parent, Child : Cursor) return Count_Type;

163/3
          If Child or Parent is equal to No_Element, then
          Constraint_Error is propagated.  Otherwise, Child_Depth
          returns the number of ancestor nodes of Child (including Child
          itself), up to but not including Parent; Program_Error is
          propagated if Parent is not an ancestor of Child.

164/3
     procedure Insert_Child (Container : in out Tree;
                             Parent    : in     Cursor;
                             Before    : in     Cursor;
                             New_Item  : in     Element_Type;
                             Count     : in     Count_Type := 1);

165/3
          If Parent equals No_Element, then Constraint_Error is
          propagated.  If Parent does not designate a node in Container,
          then Program_Error is propagated.  If Before is not equal to
          No_Element, and does not designate a node in Container, then
          Program_Error is propagated.  If Before is not equal to
          No_Element, and Parent does not designate the parent node of
          the node designated by Before, then Constraint_Error is
          propagated.  Otherwise, Insert_Child allocates Count nodes
          containing copies of New_Item and inserts them as children of
          Parent.  If Parent already has child nodes, then the new nodes
          are inserted prior to the node designated by Before, or, if
          Before equals No_Element, the new nodes are inserted after the
          last existing child node of Parent.  Any exception raised
          during allocation of internal storage is propagated, and
          Container is not modified.

166/3
     procedure Insert_Child (Container : in out Tree;
                             Parent    : in     Cursor;
                             Before    : in     Cursor;
                             New_Item  : in     Element_Type;
                             Position  :    out Cursor;
                             Count     : in     Count_Type := 1);

167/3
          If Parent equals No_Element, then Constraint_Error is
          propagated.  If Parent does not designate a node in Container,
          then Program_Error is propagated.  If Before is not equal to
          No_Element, and does not designate a node in Container, then
          Program_Error is propagated.  If Before is not equal to
          No_Element, and Parent does not designate the parent node of
          the node designated by Before, then Constraint_Error is
          propagated.  Otherwise, Insert_Child allocates Count nodes
          containing copies of New_Item and inserts them as children of
          Parent.  If Parent already has child nodes, then the new nodes
          are inserted prior to the node designated by Before, or, if
          Before equals No_Element, the new nodes are inserted after the
          last existing child node of Parent.  Position designates the
          first newly-inserted node, or if Count equals 0, then Position
          is assigned the value of Before.  Any exception raised during
          allocation of internal storage is propagated, and Container is
          not modified.

168/3
     procedure Insert_Child (Container : in out Tree;
                             Parent    : in     Cursor;
                             Before    : in     Cursor;
                             Position  :    out Cursor;
                             Count     : in     Count_Type := 1);

169/3
          If Parent equals No_Element, then Constraint_Error is
          propagated.  If Parent does not designate a node in Container,
          then Program_Error is propagated.  If Before is not equal to
          No_Element, and does not designate a node in Container, then
          Program_Error is propagated.  If Before is not equal to
          No_Element, and Parent does not designate the parent node of
          the node designated by Before, then Constraint_Error is
          propagated.  Otherwise, Insert_Child allocates Count nodes,
          the elements contained in the new nodes are initialized by
          default (see *note 3.3.1::), and the new nodes are inserted as
          children of Parent.  If Parent already has child nodes, then
          the new nodes are inserted prior to the node designated by
          Before, or, if Before equals No_Element, the new nodes are
          inserted after the last existing child node of Parent.
          Position designates the first newly-inserted node, or if Count
          equals 0, then Position is assigned the value of Before.  Any
          exception raised during allocation of internal storage is
          propagated, and Container is not modified.

170/3
     procedure Prepend_Child (Container : in out Tree;
                              Parent    : in     Cursor;
                              New_Item  : in     Element_Type;
                              Count     : in     Count_Type := 1);

171/3
          Equivalent to Insert_Child (Container, Parent, First_Child
          (Container, Parent), New_Item, Count).

172/3
     procedure Append_Child (Container : in out Tree;
                             Parent    : in     Cursor;
                             New_Item  : in     Element_Type;
                             Count     : in     Count_Type := 1);

173/3
          Equivalent to Insert_Child (Container, Parent, No_Element,
          New_Item, Count).

174/3
     procedure Delete_Children (Container : in out Tree;
                                Parent    : in     Cursor);

175/3
          If Parent equals No_Element, then Constraint_Error is
          propagated.  If Parent does not designate a node in Container,
          Program_Error is propagated.  Otherwise, Delete_Children
          removes (from Container) all of the descendants of Parent
          other than Parent itself.

176/3
     procedure Copy_Subtree (Target   : in out Tree;
                             Parent   : in     Cursor;
                             Before   : in     Cursor;
                             Source   : in     Cursor);

177/3
          If Parent equals No_Element, then Constraint_Error is
          propagated.  If Parent does not designate a node in Target,
          then Program_Error is propagated.  If Before is not equal to
          No_Element, and does not designate a node in Target, then
          Program_Error is propagated.  If Before is not equal to
          No_Element, and Parent does not designate the parent node of
          the node designated by Before, then Constraint_Error is
          propagated.  If Source designates a root node, then
          Constraint_Error is propagated.  If Source is equal to
          No_Element, then the operation has no effect.  Otherwise, the
          subtree rooted by Source (which can be from any tree; it does
          not have to be a subtree of Target) is copied (new nodes are
          allocated to create a new subtree with the same structure as
          the Source subtree, with each element initialized from the
          corresponding element of the Source subtree) and inserted into
          Target as a child of Parent.  If Parent already has child
          nodes, then the new nodes are inserted prior to the node
          designated by Before, or, if Before equals No_Element, the new
          nodes are inserted after the last existing child node of
          Parent.  The parent of the newly created subtree is set to
          Parent, and the overall count of Target is incremented by
          Subtree_Node_Count (Source).  Any exception raised during
          allocation of internal storage is propagated, and Container is
          not modified.

178/3
     procedure Splice_Subtree (Target   : in out Tree;
                               Parent   : in     Cursor;
                               Before   : in     Cursor;
                               Source   : in out Tree;
                               Position : in out Cursor);

179/3
          If Parent equals No_Element, then Constraint_Error is
          propagated.  If Parent does not designate a node in Target,
          then Program_Error is propagated.  If Before is not equal to
          No_Element, and does not designate a node in Target, then
          Program_Error is propagated.  If Before is not equal to
          No_Element, and Parent does not designate the parent node of
          the node designated by Before, then Constraint_Error is
          propagated.  If Position equals No_Element, Constraint_Error
          is propagated.  If Position does not designate a node in
          Source or designates a root node, then Program_Error is
          propagated.  If Source denotes the same object as Target,
          then: if Position equals Before there is no effect; if
          Position designates an ancestor of Parent (including Parent
          itself), Constraint_Error is propagated; otherwise, the
          subtree rooted by the element designated by Position is moved
          to be a child of Parent.  If Parent already has child nodes,
          then the moved nodes are inserted prior to the node designated
          by Before, or, if Before equals No_Element, the moved nodes
          are inserted after the last existing child node of Parent.  In
          each of these cases, Position and the count of Target are
          unchanged, and the parent of the element designated by
          Position is set to Parent.

180/3
          Otherwise (if Source does not denote the same object as
          Target), the subtree designated by Position is removed from
          Source and moved to Target.  The subtree is inserted as a
          child of Parent.  If Parent already has child nodes, then the
          moved nodes are inserted prior to the node designated by
          Before, or, if Before equals No_Element, the moved nodes are
          inserted after the last existing child node of Parent.  In
          each of these cases, the count of Target is incremented by
          Subtree_Node_Count (Position), and the count of Source is
          decremented by Subtree_Node_Count (Position), Position is
          updated to represent an element in Target.

181/3
     procedure Splice_Subtree (Container: in out Tree;
                               Parent   : in     Cursor;
                               Before   : in     Cursor;
                               Position : in     Cursor);

182/3
          If Parent equals No_Element, then Constraint_Error is
          propagated.  If Parent does not designate a node in Container,
          then Program_Error is propagated.  If Before is not equal to
          No_Element, and does not designate a node in Container, then
          Program_Error is propagated.  If Before is not equal to
          No_Element, and Parent does not designate the parent node of
          the node designated by Before, then Constraint_Error is
          propagated.  If Position equals No_Element, Constraint_Error
          is propagated.  If Position does not designate a node in
          Container or designates a root node, then Program_Error is
          propagated.  If Position equals Before, there is no effect.
          If Position designates an ancestor of Parent (including Parent
          itself), Constraint_Error is propagated.  Otherwise, the
          subtree rooted by the element designated by Position is moved
          to be a child of Parent.  If Parent already has child nodes,
          then the moved nodes are inserted prior to the node designated
          by Before, or, if Before equals No_Element, the moved nodes
          are inserted after the last existing child node of Parent.
          The parent of the element designated by Position is set to
          Parent.

183/3
     procedure Splice_Children (Target          : in out Tree;
                                Target_Parent   : in     Cursor;
                                Before          : in     Cursor;
                                Source          : in out Tree;
                                Source_Parent   : in     Cursor);

184/3
          If Target_Parent equals No_Element, then Constraint_Error is
          propagated.  If Target_Parent does not designate a node in
          Target, then Program_Error is propagated.  If Before is not
          equal to No_Element, and does not designate an element in
          Target, then Program_Error is propagated.  If Source_Parent
          equals No_Element, then Constraint_Error is propagated.  If
          Source_Parent does not designate a node in Source, then
          Program_Error is propagated.  If Before is not equal to
          No_Element, and Target_Parent does not designate the parent
          node of the node designated by Before, then Constraint_Error
          is propagated.

185/3
          If Source denotes the same object as Target, then:

186/3
             * if Target_Parent equals Source_Parent there is no effect;
               else

187/3
             * if Source_Parent is an ancestor of Target_Parent other
               than Target_Parent itself, then Constraint_Error is
               propagated; else

188/3
             * the child elements (and the further descendants) of
               Source_Parent are moved to be child elements of
               Target_Parent.  If Target_Parent already has child
               elements, then the moved elements are inserted prior to
               the node designated by Before, or, if Before equals
               No_Element, the moved elements are inserted after the
               last existing child node of Target_Parent.  The parent of
               each moved child element is set to Target_Parent.

189/3
          Otherwise (if Source does not denote the same object as
          Target), the child elements (and the further descendants) of
          Source_Parent are removed from Source and moved to Target.
          The child elements are inserted as children of Target_Parent.
          If Target_Parent already has child elements, then the moved
          elements are inserted prior to the node designated by Before,
          or, if Before equals No_Element, the moved elements are
          inserted after the last existing child node of Target_Parent.
          In each of these cases, the overall count of Target is
          incremented by Subtree_Node_Count (Source_Parent)-1, and the
          overall count of Source is decremented by Subtree_Node_Count
          (Source_Parent)-1.

190/3
     procedure Splice_Children (Container       : in out Tree;
                                Target_Parent   : in     Cursor;
                                Before          : in     Cursor;
                                Source_Parent   : in     Cursor);

191/3
          If Target_Parent equals No_Element, then Constraint_Error is
          propagated.  If Target_Parent does not designate a node in
          Container, then Program_Error is propagated.  If Before is not
          equal to No_Element, and does not designate an element in
          Container, then Program_Error is propagated.  If Source_Parent
          equals No_Element, then Constraint_Error is propagated.  If
          Source_Parent does not designate a node in Container, then
          Program_Error is propagated.  If Before is not equal to
          No_Element, and Target_Parent does not designate the parent
          node of the node designated by Before, then Constraint_Error
          is propagated.  If Target_Parent equals Source_Parent there is
          no effect.  If Source_Parent is an ancestor of Target_Parent
          other than Target_Parent itself, then Constraint_Error is
          propagated.  Otherwise, the child elements (and the further
          descendants) of Source_Parent are moved to be child elements
          of Target_Parent.  If Target_Parent already has child
          elements, then the moved elements are inserted prior to the
          node designated by Before, or, if Before equals No_Element,
          the moved elements are inserted after the last existing child
          node of Target_Parent.  The parent of each moved child element
          is set to Target_Parent.

192/3
     function Parent (Position : Cursor) return Cursor;

193/3
          If Position is equal to No_Element or designates a root node,
          No_Element is returned.  Otherwise, a cursor designating the
          parent node of the node designated by Position is returned.

194/3
     function First_Child (Parent : Cursor) return Cursor;

195/3
          If Parent is equal to No_Element, then Constraint_Error is
          propagated.  Otherwise, First_Child returns a cursor
          designating the first child node of the node designated by
          Parent; if there is no such node, No_Element is returned.

196/3
     function First_Child_Element (Parent : Cursor) return Element_Type;

197/3
          Equivalent to Element (First_Child (Parent)).

198/3
     function Last_Child (Parent : Cursor) return Cursor;

199/3
          If Parent is equal to No_Element, then Constraint_Error is
          propagated.  Otherwise, Last_Child returns a cursor
          designating the last child node of the node designated by
          Parent; if there is no such node, No_Element is returned.

200/3
     function Last_Child_Element (Parent : Cursor) return Element_Type;

201/3
          Equivalent to Element (Last_Child (Parent)).

202/3
     function Next_Sibling (Position : Cursor) return Cursor;

203/3
          If Position equals No_Element or designates the last child
          node of its parent, then Next_Sibling returns the value
          No_Element.  Otherwise, it returns a cursor that designates
          the successor (with the same parent) of the node designated by
          Position.

204/3
     function Previous_Sibling (Position : Cursor) return Cursor;

205/3
          If Position equals No_Element or designates the first child
          node of its parent, then Previous_Sibling returns the value
          No_Element.  Otherwise, it returns a cursor that designates
          the predecessor (with the same parent) of the node designated
          by Position.

206/3
     procedure Next_Sibling (Position : in out Cursor);

207/3
          Equivalent to Position := Next_Sibling (Position);

208/3
     procedure Previous_Sibling (Position : in out Cursor);

209/3
          Equivalent to Position := Previous_Sibling (Position);

210/3
     procedure Iterate_Children
       (Parent  : in Cursor;
        Process : not null access procedure (Position : in Cursor));

211/3
          If Parent equals No_Element, then Constraint_Error is
          propagated.

212/3
          Iterate_Children calls Process.all with a cursor that
          designates each child node of Parent, starting with the first
          child node and moving the cursor as per the Next_Sibling
          function.

213/3
          Tampering with the cursors of the tree containing Parent is
          prohibited during the execution of a call on Process.all.  Any
          exception raised by Process.all is propagated.

214/3
     procedure Reverse_Iterate_Children
       (Parent  : in Cursor;
        Process : not null access procedure (Position : in Cursor));

215/3
          If Parent equals No_Element, then Constraint_Error is
          propagated.

216/3
          Reverse_Iterate_Children calls Process.all with a cursor that
          designates each child node of Parent, starting with the last
          child node and moving the cursor as per the Previous_Sibling
          function.

217/3
          Tampering with the cursors of the tree containing Parent is
          prohibited during the execution of a call on Process.all.  Any
          exception raised by Process.all is propagated.

218/3
     function Iterate_Children (Container : in Tree; Parent : in Cursor)
        return Tree_Iterator_Interfaces.Reversible_Iterator'Class;

219/3
          Iterate_Children returns a reversible iterator object (see
          *note 5.5.1::) that will generate a value for a loop parameter
          (see *note 5.5.2::) designating each child node of Parent.  If
          Parent equals No_Element, then Constraint_Error is propagated.
          If Parent does not designate a node in Container, then
          Program_Error is propagated.  Otherwise, when used as a
          forward iterator, the nodes are designated starting with the
          first child node and moving the cursor as per the function
          Next_Sibling; when used as a reverse iterator, the nodes are
          designated starting with the last child node and moving the
          cursor as per the function Previous_Sibling.  Tampering with
          the cursors of Container is prohibited while the iterator
          object exists (in particular, in the sequence_of_statements of
          the loop_statement whose iterator_specification denotes this
          object).  The iterator object needs finalization.

                      _Bounded (Run-Time) Errors_

220/3
It is a bounded error for the actual function associated with a generic
formal subprogram, when called as part of an operation of this package,
to tamper with elements of any Tree parameter of the operation.  Either
Program_Error is raised, or the operation works as defined on the value
of the Tree either prior to, or subsequent to, some or all of the
modifications to the Tree.

221/3
It is a bounded error to call any subprogram declared in the visible
part of Containers.Multiway_Trees when the associated container has been
finalized.  If the operation takes Container as an in out parameter,
then it raises Constraint_Error or Program_Error.  Otherwise, the
operation either proceeds as it would for an empty container, or it
raises Constraint_Error or Program_Error.

                         _Erroneous Execution_

222/3
A Cursor value is invalid if any of the following have occurred since it
was created: 

223/3
   * The tree that contains the element it designates has been
     finalized;

224/3
   * The tree that contains the element it designates has been used as
     the Source or Target of a call to Move;

225/3
   * The tree that contains the element it designates has been used as
     the Target of a call to Assign or the target of an
     assignment_statement;

226/3
   * The element it designates has been removed from the tree that
     previously contained the element.

227/3
The result of "=" or Has_Element is unspecified if it is called with an
invalid cursor parameter.  Execution is erroneous if any other
subprogram declared in Containers.Multiway_Trees is called with an
invalid cursor parameter.

228/3
Execution is erroneous if the tree associated with the result of a call
to Reference or Constant_Reference is finalized before the result object
returned by the call to Reference or Constant_Reference is finalized.

                     _Implementation Requirements_

229/3
No storage associated with a multiway tree object shall be lost upon
assignment or scope exit.

230/3
The execution of an assignment_statement for a tree shall have the
effect of copying the elements from the source tree object to the target
tree object and changing the node count of the target object to that of
the source object.

                        _Implementation Advice_

231/3
Containers.Multiway_Trees should be implemented similarly to a multiway
tree.  In particular, if N is the overall number of nodes for a
particular tree, then the worst-case time complexity of Element, Parent,
First_Child, Last_Child, Next_Sibling, Previous_Sibling, Insert_Child
with Count=1, and Delete should be O(log N).

232/3
Move should not copy elements, and should minimize copying of internal
data structures.

233/3
If an exception is propagated from a tree operation, no storage should
be lost, nor any elements removed from a tree unless specified by the
operation.


File: arm2012.info,  Node: A.18.11,  Next: A.18.12,  Prev: A.18.10,  Up: A.18

A.18.11 The Generic Package Containers.Indefinite_Vectors
---------------------------------------------------------

1/2
The language-defined generic package Containers.Indefinite_Vectors
provides a private type Vector and a set of operations.  It provides the
same operations as the package Containers.Vectors (see *note A.18.2::),
with the difference that the generic formal Element_Type is indefinite.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Indefinite_Vectors has the same contents and semantics as
Containers.Vectors except:

3/2
   * The generic formal Element_Type is indefinite.

4/2
   * The procedures with the profiles:

5/2
     procedure Insert (Container : in out Vector;
                       Before    : in     Extended_Index;
                       Count     : in     Count_Type := 1);

6/2
     procedure Insert (Container : in out Vector;
                       Before    : in     Cursor;
                       Position  :    out Cursor;
                       Count     : in     Count_Type := 1);

7/2
     are omitted.

8/2
   * The actual Element parameter of access subprogram Process of
     Update_Element may be constrained even if Element_Type is
     unconstrained.

9/4
   * The operations "&", Append, Insert, Prepend, Replace_Element, and
     To_Vector that have a formal parameter of type Element_Type perform
     indefinite insertion (see *note A.18::).


File: arm2012.info,  Node: A.18.12,  Next: A.18.13,  Prev: A.18.11,  Up: A.18

A.18.12 The Generic Package Containers.Indefinite_Doubly_Linked_Lists
---------------------------------------------------------------------

1/2
The language-defined generic package
Containers.Indefinite_Doubly_Linked_Lists provides private types List
and Cursor, and a set of operations for each type.  It provides the same
operations as the package Containers.Doubly_Linked_Lists (see *note
A.18.3::), with the difference that the generic formal Element_Type is
indefinite.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Indefinite_Doubly_Linked_Lists has the same contents and
semantics as Containers.Doubly_Linked_Lists except:

3/2
   * The generic formal Element_Type is indefinite.

4/2
   * The procedure with the profile:

5/2
     procedure Insert (Container : in out List;
                       Before    : in     Cursor;
                       Position  :    out Cursor;
                       Count     : in     Count_Type := 1);

6/2
     is omitted.

7/2
   * The actual Element parameter of access subprogram Process of
     Update_Element may be constrained even if Element_Type is
     unconstrained.

8/4
   * The operations Append, Insert, Prepend, and Replace_Element that
     have a formal parameter of type Element_Type perform indefinite
     insertion (see *note A.18::).


File: arm2012.info,  Node: A.18.13,  Next: A.18.14,  Prev: A.18.12,  Up: A.18

A.18.13 The Generic Package Containers.Indefinite_Hashed_Maps
-------------------------------------------------------------

1/2
The language-defined generic package Containers.Indefinite_Hashed_Maps
provides a map with the same operations as the package
Containers.Hashed_Maps (see *note A.18.5::), with the difference that
the generic formal types Key_Type and Element_Type are indefinite.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Indefinite_Hashed_Maps has the same contents and semantics as
Containers.Hashed_Maps except:

3/2
   * The generic formal Key_Type is indefinite.

4/2
   * The generic formal Element_Type is indefinite.

5/2
   * The procedure with the profile:

6/2
     procedure Insert (Container : in out Map;
                       Key       : in     Key_Type;
                       Position  :    out Cursor;
                       Inserted  :    out Boolean);

7/2
     is omitted.

8/2
   * The actual Element parameter of access subprogram Process of
     Update_Element may be constrained even if Element_Type is
     unconstrained.

9/4
   * The operations Include, Insert, Replace, and Replace_Element that
     have a formal parameter of type Element_Type perform indefinite
     insertion (see *note A.18::).


File: arm2012.info,  Node: A.18.14,  Next: A.18.15,  Prev: A.18.13,  Up: A.18

A.18.14 The Generic Package Containers.Indefinite_Ordered_Maps
--------------------------------------------------------------

1/2
The language-defined generic package Containers.Indefinite_Ordered_Maps
provides a map with the same operations as the package
Containers.Ordered_Maps (see *note A.18.6::), with the difference that
the generic formal types Key_Type and Element_Type are indefinite.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Indefinite_Ordered_Maps has the same contents and semantics
as Containers.Ordered_Maps except:

3/2
   * The generic formal Key_Type is indefinite.

4/2
   * The generic formal Element_Type is indefinite.

5/2
   * The procedure with the profile:

6/2
     procedure Insert (Container : in out Map;
                       Key       : in     Key_Type;
                       Position  :    out Cursor;
                       Inserted  :    out Boolean);

7/2
     is omitted.

8/2
   * The actual Element parameter of access subprogram Process of
     Update_Element may be constrained even if Element_Type is
     unconstrained.

9/4
   * The operations Include, Insert, Replace, and Replace_Element that
     have a formal parameter of type Element_Type perform indefinite
     insertion (see *note A.18::).


File: arm2012.info,  Node: A.18.15,  Next: A.18.16,  Prev: A.18.14,  Up: A.18

A.18.15 The Generic Package Containers.Indefinite_Hashed_Sets
-------------------------------------------------------------

1/2
The language-defined generic package Containers.Indefinite_Hashed_Sets
provides a set with the same operations as the package
Containers.Hashed_Sets (see *note A.18.8::), with the difference that
the generic formal type Element_Type is indefinite.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Indefinite_Hashed_Sets has the same contents and semantics as
Containers.Hashed_Sets except:

3/2
   * The generic formal Element_Type is indefinite.

4/2
   * The actual Element parameter of access subprogram Process of
     Update_Element_Preserving_Key may be constrained even if
     Element_Type is unconstrained.

5/4
   * The operations Include, Insert, Replace, Replace_Element, and
     To_Set that have a formal parameter of type Element_Type perform
     indefinite insertion (see *note A.18::).


File: arm2012.info,  Node: A.18.16,  Next: A.18.17,  Prev: A.18.15,  Up: A.18

A.18.16 The Generic Package Containers.Indefinite_Ordered_Sets
--------------------------------------------------------------

1/2
The language-defined generic package Containers.Indefinite_Ordered_Sets
provides a set with the same operations as the package
Containers.Ordered_Sets (see *note A.18.9::), with the difference that
the generic formal type Element_Type is indefinite.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Indefinite_Ordered_Sets has the same contents and semantics
as Containers.Ordered_Sets except:

3/2
   * The generic formal Element_Type is indefinite.

4/2
   * The actual Element parameter of access subprogram Process of
     Update_Element_Preserving_Key may be constrained even if
     Element_Type is unconstrained.

5/4
   * The operations Include, Insert, Replace, Replace_Element, and
     To_Set that have a formal parameter of type Element_Type perform
     indefinite insertion (see *note A.18::).


File: arm2012.info,  Node: A.18.17,  Next: A.18.18,  Prev: A.18.16,  Up: A.18

A.18.17 The Generic Package Containers.Indefinite_Multiway_Trees
----------------------------------------------------------------

1/3
The language-defined generic package
Containers.Indefinite_Multiway_Trees provides a multiway tree with the
same operations as the package Containers.Multiway_Trees (see *note
A.18.10::), with the difference that the generic formal Element_Type is
indefinite.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Indefinite_Multiway_Trees has the same contents and semantics
as Containers.Multiway_Trees except:

3/3
   * The generic formal Element_Type is indefinite.

4/3
   * The procedure with the profile:

5/3
     procedure Insert_Child (Container : in out Tree;
                             Parent    : in     Cursor;
                             Before    : in     Cursor;
                             Position  :    out Cursor;
                             Count     : in     Count_Type := 1);

6/3
     is omitted.

7/3
   * The actual Element parameter of access subprogram Process of
     Update_Element may be constrained even if Element_Type is
     unconstrained.

8/4
   * The operations Append_Child, Insert_Child, Prepend_Child, and
     Replace_Element that have a formal parameter of type Element_Type
     perform indefinite insertion (see *note A.18::).


File: arm2012.info,  Node: A.18.18,  Next: A.18.19,  Prev: A.18.17,  Up: A.18

A.18.18 The Generic Package Containers.Indefinite_Holders
---------------------------------------------------------

1/3
The language-defined generic package Containers.Indefinite_Holders
provides a private type Holder and a set of operations for that type.  A
holder container holds a single element of an indefinite type.

2/3
A holder container allows the declaration of an object that can be used
like an uninitialized variable or component of an indefinite type.

3/3
A holder container may be empty.  An empty holder does not contain an
element.

                          _Static Semantics_

4/3
The generic library package Containers.Indefinite_Holders has the
following declaration:

5/3
     generic
        type Element_Type (<>) is private;
        with function "=" (Left, Right : Element_Type) return Boolean is <>;
     package Ada.Containers.Indefinite_Holders is
        pragma Preelaborate(Indefinite_Holders);
        pragma Remote_Types(Indefinite_Holders);

6/3
        type Holder is tagged private;
        pragma Preelaborable_Initialization (Holder);

7/3
        Empty_Holder : constant Holder;

8/3
        function "=" (Left, Right : Holder) return Boolean;

9/3
        function To_Holder (New_Item : Element_Type) return Holder;

10/3
        function Is_Empty (Container : Holder) return Boolean;

11/3
        procedure Clear (Container : in out Holder);

12/3
        function Element (Container : Holder) return Element_Type;

13/3
        procedure Replace_Element (Container : in out Holder;
                                   New_Item  : in     Element_Type);

14/3
        procedure Query_Element
       (Container : in Holder;
        Process   : not null access procedure (Element : in Element_Type));

15/3
        procedure Update_Element
       (Container : in out Holder;
        Process   : not null access procedure (Element : in out Element_Type));

16/3
        type Constant_Reference_Type
           (Element : not null access constant Element_Type) is private
        with Implicit_Dereference => Element;

17/3
        type Reference_Type (Element : not null access Element_Type) is private
        with Implicit_Dereference => Element;

18/3
        function Constant_Reference (Container : aliased in Holder)
        return Constant_Reference_Type;

19/3
        function Reference (Container : aliased in out Holder)
        return Reference_Type;

20/3
        procedure Assign (Target : in out Holder; Source : in Holder);

21/3
        function Copy (Source : Holder) return Holder;

22/3
        procedure Move (Target : in out Holder; Source : in out Holder);

23/3
     private

24/3
        ... -- not specified by the language

25/3
     end Ada.Containers.Indefinite_Holders;

26/3
The actual function for the generic formal function "=" on Element_Type
values is expected to define a reflexive and symmetric relationship and
return the same result value each time it is called with a particular
pair of values.  If it behaves in some other manner, the function "=" on
holder values returns an unspecified value.  The exact arguments and
number of calls of this generic formal function by the function "=" on
holder values are unspecified.

27/3
The type Holder is used to represent holder containers.  The type Holder
needs finalization (see *note 7.6::).

28/3
Empty_Holder represents an empty holder object.  If an object of type
Holder is not otherwise initialized, it is initialized to the same value
as Empty_Holder.

29/3
Some operations of this generic package have access-to-subprogram
parameters.  To ensure such operations are well-defined, they guard
against certain actions by the designated subprogram.  In particular,
some operations check for "tampering with the element" of a container
because they depend on the element of the container not being replaced.

30/3
A subprogram is said to tamper with the element of a holder object H if:

31/3
   * It clears the element contained by H, that is, it calls the Clear
     procedure with H as a parameter;

32/3
   * It replaces the element contained by H, that is, it calls the
     Replace_Element procedure with H as a parameter;

33/3
   * It calls the Move procedure with H as a parameter;

34/3
   * It finalizes H.

35/4
When tampering with the element is prohibited for a particular holder
object H, Program_Error is propagated by a call of any language-defined
subprogram that is defined to tamper with the element of H, leaving H
unmodified.  These checks are made before any other defined behavior of
the body of the language-defined subprogram.

36/3
     function "=" (Left, Right : Holder) return Boolean;

37/3
          If Left and Right denote the same holder object, then the
          function returns True.  Otherwise, it compares the element
          contained in Left to the element contained in Right using the
          generic formal equality operator, returning the result of that
          operation.  Any exception raised during the evaluation of
          element equality is propagated.

38/3
     function To_Holder (New_Item : Element_Type) return Holder;

39/4
          Returns a nonempty holder containing an element initialized to
          New_Item.  To_Holder performs indefinite insertion (see *note
          A.18::).

40/3
     function Is_Empty (Container : Holder) return Boolean;

41/3
          Returns True if Container is empty, and False if it contains
          an element.

42/3
     procedure Clear (Container : in out Holder);

43/3
          Removes the element from Container.  Container is empty after
          a successful Clear operation.

44/3
     function Element (Container : Holder) return Element_Type;

45/3
          If Container is empty, Constraint_Error is propagated.
          Otherwise, returns the element stored in Container.

46/3
     procedure Replace_Element (Container : in out Holder;
                                New_Item  : in     Element_Type);

47/4
          Replace_Element assigns the value New_Item into Container,
          replacing any preexisting content of Container;
          Replace_Element performs indefinite insertion (see *note
          A.18::).  Container is not empty after a successful call to
          Replace_Element.

48/3
     procedure Query_Element
       (Container : in Holder;
        Process   : not null access procedure (Element : in Element_Type));

49/3
          If Container is empty, Constraint_Error is propagated.
          Otherwise, Query_Element calls Process.all with the contained
          element as the argument.  Tampering with the element of
          Container is prohibited during the execution of the call on
          Process.all.  Any exception raised by Process.all is
          propagated.

50/3
     procedure Update_Element
       (Container : in out Holder;
        Process   : not null access procedure (Element : in out Element_Type));

51/3
          If Container is empty, Constraint_Error is propagated.
          Otherwise, Update_Element calls Process.all with the contained
          element as the argument.  Tampering with the element of
          Container is prohibited during the execution of the call on
          Process.all.  Any exception raised by Process.all is
          propagated.

52/3
     type Constant_Reference_Type
           (Element : not null access constant Element_Type) is private
        with Implicit_Dereference => Element;

53/3
     type Reference_Type (Element : not null access Element_Type) is private
        with Implicit_Dereference => Element;

54/3
          The types Constant_Reference_Type and Reference_Type need
          finalization.

55/3
          The default initialization of an object of type
          Constant_Reference_Type or Reference_Type propagates
          Program_Error.

56/3
     function Constant_Reference (Container : aliased in Holder)
        return Constant_Reference_Type;

57/3
          This function (combined with the Implicit_Dereference aspect)
          provides a convenient way to gain read access to the contained
          element of a holder container.

58/3
          If Container is empty, Constraint_Error is propagated.
          Otherwise, Constant_Reference returns an object whose
          discriminant is an access value that designates the contained
          element.  Tampering with the elements of Container is
          prohibited while the object returned by Constant_Reference
          exists and has not been finalized.

59/3
     function Reference (Container : aliased in out Holder)
        return Reference_Type;

60/3
          This function (combined with the Implicit_Dereference aspects)
          provides a convenient way to gain read and write access to the
          contained element of a holder container.

61/3
          If Container is empty, Constraint_Error is propagated.
          Otherwise, Reference returns an object whose discriminant is
          an access value that designates the contained element.
          Tampering with the elements of Container is prohibited while
          the object returned by Reference exists and has not been
          finalized.

62/3
     procedure Assign (Target : in out Holder; Source : in Holder);

63/3
          If Target denotes the same object as Source, the operation has
          no effect.  If Source is empty, Clear (Target) is called.
          Otherwise, Replace_Element (Target, Element (Source)) is
          called.

64/3
     function Copy (Source : Holder) return Holder;

65/3
          If Source is empty, returns an empty holder container;
          otherwise, returns To_Holder (Element (Source)).

66/3
     procedure Move (Target : in out Holder; Source : in out Holder);

67/3
          If Target denotes the same object as Source, then the
          operation has no effect.  Otherwise, the element contained by
          Source (if any) is removed from Source and inserted into
          Target, replacing any preexisting content.  Source is empty
          after a successful call to Move.

                      _Bounded (Run-Time) Errors_

68/3
It is a bounded error for the actual function associated with a generic
formal subprogram, when called as part of an operation of this package,
to tamper with the element of any Holder parameter of the operation.
Either Program_Error is raised, or the operation works as defined on the
value of the Holder either prior to, or subsequent to, some or all of
the modifications to the Holder.

69/3
It is a bounded error to call any subprogram declared in the visible
part of Containers.Indefinite_Holders when the associated container has
been finalized.  If the operation takes Container as an in out
parameter, then it raises Constraint_Error or Program_Error.  Otherwise,
the operation either proceeds as it would for an empty container, or it
raises Constraint_Error or Program_Error.

                         _Erroneous Execution_

70/3
Execution is erroneous if the holder container associated with the
result of a call to Reference or Constant_Reference is finalized before
the result object returned by the call to Reference or
Constant_Reference is finalized.

                     _Implementation Requirements_

71/3
No storage associated with a holder object shall be lost upon assignment
or scope exit.

72/3
The execution of an assignment_statement for a holder container shall
have the effect of copying the element (if any) from the source holder
object to the target holder object.

                        _Implementation Advice_

73/3
Move should not copy the element, and should minimize copying of
internal data structures.

74/3
If an exception is propagated from a holder operation, no storage should
be lost, nor should the element be removed from a holder container
unless specified by the operation.


File: arm2012.info,  Node: A.18.19,  Next: A.18.20,  Prev: A.18.18,  Up: A.18

A.18.19 The Generic Package Containers.Bounded_Vectors
------------------------------------------------------

1/3
The language-defined generic package Containers.Bounded_Vectors provides
a private type Vector and a set of operations.  It provides the same
operations as the package Containers.Vectors (see *note A.18.2::), with
the difference that the maximum storage is bounded.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Bounded_Vectors has the same contents and semantics as
Containers.Vectors except:

3/3
   * The pragma Preelaborate is replaced with pragma Pure.

4/3
   * The type Vector is declared with a discriminant that specifies the
     capacity:

5/3
       type Vector (Capacity : Count_Type) is tagged private;

6/3
   * The type Vector needs finalization if and only if type Element_Type
     needs finalization.

7/3
   * In function Copy, if the Capacity parameter is equal to or greater
     than the length of Source, the vector capacity exactly equals the
     value of the Capacity parameter.

8/3
   * The description of Reserve_Capacity is replaced with:

9/3
          If the specified Capacity is larger than the capacity of
          Container, then Reserve_Capacity propagates Capacity_Error.
          Otherwise, the operation has no effect.

                      _Bounded (Run-Time) Errors_

10/3
It is a bounded error to assign from a bounded vector object while
tampering with elements or cursors of that object is prohibited.  Either
Program_Error is raised by the assignment, execution proceeds with the
target object prohibiting tampering with elements or cursors, or
execution proceeds normally.

                         _Erroneous Execution_

11/3
When a bounded vector object V is finalized, if tampering with cursors
is prohibited for V other than due to an assignment from another vector,
then execution is erroneous. 

                     _Implementation Requirements_

12/3
For each instance of Containers.Vectors and each instance of
Containers.Bounded_Vectors, if the two instances meet the following
conditions, then the output generated by the Vector'Output or
Vector'Write subprograms of either instance shall be readable by the
Vector'Input or Vector'Read of the other instance, respectively:

13/3
   * the Element_Type parameters of the two instances are statically
     matching subtypes of the same type; and

14/3
   * the output generated by Element_Type'Output or Element_Type'Write
     is readable by Element_Type'Input or Element_Type'Read,
     respectively (where Element_Type denotes the type of the two actual
     Element_Type parameters); and

15/3
   * the preceding two conditions also hold for the Index_Type
     parameters of the instances.

                        _Implementation Advice_

16/3
Bounded vector objects should be implemented without implicit pointers
or dynamic allocation.

17/3
The implementation advice for procedure Move to minimize copying does
not apply.


File: arm2012.info,  Node: A.18.20,  Next: A.18.21,  Prev: A.18.19,  Up: A.18

A.18.20 The Generic Package Containers.Bounded_Doubly_Linked_Lists
------------------------------------------------------------------

1/3
The language-defined generic package
Containers.Bounded_Doubly_Linked_Lists provides a private type List and
a set of operations.  It provides the same operations as the package
Containers.Doubly_Linked_Lists (see *note A.18.3::), with the difference
that the maximum storage is bounded.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Bounded_Doubly_Linked_Lists has the same contents and
semantics as Containers.Doubly_Linked_Lists except:

3/3
   * The pragma Preelaborate is replaced with pragma Pure.

4/3
   * The type List is declared with a discriminant that specifies the
     capacity (maximum number of elements) as follows:

5/3
       type List (Capacity : Count_Type) is tagged private;

6/3
   * The type List needs finalization if and only if type Element_Type
     needs finalization.

7/3
   * The allocation of internal storage includes a check that the
     capacity is not exceeded, and Capacity_Error is raised if this
     check fails.

8/3
   * In procedure Assign, if Source length is greater than Target
     capacity, then Capacity_Error is propagated.

9/3
   * The function Copy is replaced with:

10/3
       function Copy (Source : List; Capacity : Count_Type := 0)
          return List;

11/3
          If Capacity is 0, then the list capacity is the length of
          Source; if Capacity is equal to or greater than the length of
          Source, the list capacity equals the value of the Capacity
          parameter; otherwise, the operation propagates Capacity_Error.

12/3
   * In the three-parameter procedure Splice whose Source has type List,
     if the sum of the length of Target and the length of Source is
     greater than the capacity of Target, then Splice propagates
     Capacity_Error.

13/3
   * In the four-parameter procedure Splice, if the length of Target
     equals the capacity of Target, then Splice propagates
     Capacity_Error.

                      _Bounded (Run-Time) Errors_

14/3
It is a bounded error to assign from a bounded list object while
tampering with elements or cursors of that object is prohibited.  Either
Program_Error is raised by the assignment, execution proceeds with the
target object prohibiting tampering with elements or cursors, or
execution proceeds normally.

                         _Erroneous Execution_

15/3
When a bounded list object L is finalized, if tampering with cursors is
prohibited for L other than due to an assignment from another list, then
execution is erroneous. 

                     _Implementation Requirements_

16/3
For each instance of Containers.Doubly_Linked_Lists and each instance of
Containers.Bounded_Doubly_Linked_Lists, if the two instances meet the
following conditions, then the output generated by the List'Output or
List'Write subprograms of either instance shall be readable by the
List'Input or List'Read of the other instance, respectively:

17/3
   * the Element_Type parameters of the two instances are statically
     matching subtypes of the same type; and

18/3
   * the output generated by Element_Type'Output or Element_Type'Write
     is readable by Element_Type'Input or Element_Type'Read,
     respectively (where Element_Type denotes the type of the two actual
     Element_Type parameters).

                        _Implementation Advice_

19/3
Bounded list objects should be implemented without implicit pointers or
dynamic allocation.

20/3
The implementation advice for procedure Move to minimize copying does
not apply.


File: arm2012.info,  Node: A.18.21,  Next: A.18.22,  Prev: A.18.20,  Up: A.18

A.18.21 The Generic Package Containers.Bounded_Hashed_Maps
----------------------------------------------------------

1/3
The language-defined generic package Containers.Bounded_Hashed_Maps
provides a private type Map and a set of operations.  It provides the
same operations as the package Containers.Hashed_Maps (see *note
A.18.5::), with the difference that the maximum storage is bounded.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Bounded_Hashed_Maps has the same contents and semantics as
Containers.Hashed_Maps except:

3/3
   * The pragma Preelaborate is replaced with pragma Pure.

4/3
   * The type Map is declared with discriminants that specify both the
     capacity (number of elements) and modulus (number of distinct hash
     values) of the hash table as follows:

5/3
       type Map (Capacity : Count_Type;
                 Modulus  : Hash_Type) is tagged private;

6/3
   * The type Map needs finalization if and only if type Key_Type or
     type Element_Type needs finalization.

7/3
   * The description of Reserve_Capacity is replaced with:

8/3
          If the specified Capacity is larger than the capacity of
          Container, then Reserve_Capacity propagates Capacity_Error.
          Otherwise, the operation has no effect.

9/3
   * An additional operation is added immediately following
     Reserve_Capacity:

10/3
       function Default_Modulus (Capacity : Count_Type) return Hash_Type;

11/3
          Default_Modulus returns an implementation-defined value for
          the number of distinct hash values to be used for the given
          capacity (maximum number of elements).

12/3
   * The function Copy is replaced with:

13/3
       function Copy (Source   : Map;
                      Capacity : Count_Type := 0;
                      Modulus  : Hash_Type := 0) return Map;

14/3
          Returns a map with key/element pairs initialized from the
          values in Source.  If Capacity is 0, then the map capacity is
          the length of Source; if Capacity is equal to or greater than
          the length of Source, the map capacity is the value of the
          Capacity parameter; otherwise, the operation propagates
          Capacity_Error.  If the Modulus argument is 0, then the map
          modulus is the value returned by a call to Default_Modulus
          with the map capacity as its argument; otherwise, the map
          modulus is the value of the Modulus parameter.

                      _Bounded (Run-Time) Errors_

15/3
It is a bounded error to assign from a bounded map object while
tampering with elements or cursors of that object is prohibited.  Either
Program_Error is raised by the assignment, execution proceeds with the
target object prohibiting tampering with elements or cursors, or
execution proceeds normally.

                         _Erroneous Execution_

16/3
When a bounded map object M is finalized, if tampering with cursors is
prohibited for M other than due to an assignment from another map, then
execution is erroneous. 

                     _Implementation Requirements_

17/3
For each instance of Containers.Hashed_Maps and each instance of
Containers.Bounded_Hashed_Maps, if the two instances meet the following
conditions, then the output generated by the Map'Output or Map'Write
subprograms of either instance shall be readable by the Map'Input or
Map'Read of the other instance, respectively:

18/3
   * the Element_Type parameters of the two instances are statically
     matching subtypes of the same type; and

19/3
   * the output generated by Element_Type'Output or Element_Type'Write
     is readable by Element_Type'Input or Element_Type'Read,
     respectively (where Element_Type denotes the type of the two actual
     Element_Type parameters); and

20/3
   * the preceding two conditions also hold for the Key_Type parameters
     of the instances.

                        _Implementation Advice_

21/3
Bounded hashed map objects should be implemented without implicit
pointers or dynamic allocation.

22/3
The implementation advice for procedure Move to minimize copying does
not apply.


File: arm2012.info,  Node: A.18.22,  Next: A.18.23,  Prev: A.18.21,  Up: A.18

A.18.22 The Generic Package Containers.Bounded_Ordered_Maps
-----------------------------------------------------------

1/3
The language-defined generic package Containers.Bounded_Ordered_Maps
provides a private type Map and a set of operations.  It provides the
same operations as the package Containers.Ordered_Maps (see *note
A.18.6::), with the difference that the maximum storage is bounded.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Bounded_Ordered_Maps has the same contents and semantics as
Containers.Ordered_Maps except:

3/3
   * The pragma Preelaborate is replaced with pragma Pure.

4/3
   * The type Map is declared with a discriminant that specifies the
     capacity (maximum number of elements) as follows:

5/3
       type Map (Capacity : Count_Type) is tagged private;

6/3
   * The type Map needs finalization if and only if type Key_Type or
     type Element_Type needs finalization.

7/3
   * The allocation of a new node includes a check that the capacity is
     not exceeded, and Capacity_Error is raised if this check fails.

8/3
   * In procedure Assign, if Source length is greater than Target
     capacity, then Capacity_Error is propagated.

9/3
   * The function Copy is replaced with:

10/3
       function Copy (Source   : Map;
                      Capacity : Count_Type := 0) return Map;

11/3
          Returns a map with key/element pairs initialized from the
          values in Source.  If Capacity is 0, then the map capacity is
          the length of Source; if Capacity is equal to or greater than
          the length of Source, the map capacity is the specified value;
          otherwise, the operation propagates Capacity_Error.

                      _Bounded (Run-Time) Errors_

12/3
It is a bounded error to assign from a bounded map object while
tampering with elements or cursors of that object is prohibited.  Either
Program_Error is raised by the assignment, execution proceeds with the
target object prohibiting tampering with elements or cursors, or
execution proceeds normally.

                         _Erroneous Execution_

13/3
When a bounded map object M is finalized, if tampering with cursors is
prohibited for M other than due to an assignment from another map, then
execution is erroneous. 

                     _Implementation Requirements_

14/3
For each instance of Containers.Ordered_Maps and each instance of
Containers.Bounded_Ordered_Maps, if the two instances meet the following
conditions, then the output generated by the Map'Output or Map'Write
subprograms of either instance shall be readable by the Map'Input or
Map'Read of the other instance, respectively:

15/3
   * the Element_Type parameters of the two instances are statically
     matching subtypes of the same type; and

16/3
   * the output generated by Element_Type'Output or Element_Type'Write
     is readable by Element_Type'Input or Element_Type'Read,
     respectively (where Element_Type denotes the type of the two actual
     Element_Type parameters); and

17/3
   * the preceding two conditions also hold for the Key_Type parameters
     of the instances.

                        _Implementation Advice_

18/3
Bounded ordered map objects should be implemented without implicit
pointers or dynamic allocation.

19/3
The implementation advice for procedure Move to minimize copying does
not apply.


File: arm2012.info,  Node: A.18.23,  Next: A.18.24,  Prev: A.18.22,  Up: A.18

A.18.23 The Generic Package Containers.Bounded_Hashed_Sets
----------------------------------------------------------

1/3
The language-defined generic package Containers.Bounded_Hashed_Sets
provides a private type Set and a set of operations.  It provides the
same operations as the package Containers.Hashed_Sets (see *note
A.18.8::), with the difference that the maximum storage is bounded.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Bounded_Hashed_Sets has the same contents and semantics as
Containers.Hashed_Sets except:

3/3
   * The pragma Preelaborate is replaced with pragma Pure.

4/3
   * The type Set is declared with discriminants that specify both the
     capacity (number of elements) and modulus (number of distinct hash
     values) of the hash table as follows:

5/3
       type Set (Capacity : Count_Type;
                 Modulus  : Hash_Type) is tagged private;

6/3
   * The type Set needs finalization if and only if type Element_Type
     needs finalization.

7/3
   * The description of Reserve_Capacity is replaced with:

8/3
          If the specified Capacity is larger than the capacity of
          Container, then Reserve_Capacity propagates Capacity_Error.
          Otherwise, the operation has no effect.

9/3
   * An additional operation is added immediately following
     Reserve_Capacity:

10/3
       function Default_Modulus (Capacity : Count_Type) return Hash_Type;

11/3
          Default_Modulus returns an implementation-defined value for
          the number of distinct hash values to be used for the given
          capacity (maximum number of elements).

12/3
   * The function Copy is replaced with:

13/3
       function Copy (Source   : Set;
                      Capacity : Count_Type := 0;
                      Modulus  : Hash_Type := 0) return Set;

14/3
          Returns a set whose elements are initialized from the values
          in Source.  If Capacity is 0, then the set capacity is the
          length of Source; if Capacity is equal to or greater than the
          length of Source, the set capacity is the value of the
          Capacity parameter; otherwise, the operation propagates
          Capacity_Error.  If the Modulus argument is 0, then the set
          modulus is the value returned by a call to Default_Modulus
          with the set capacity as its argument; otherwise, the set
          modulus is the value of the Modulus parameter.

                      _Bounded (Run-Time) Errors_

15/3
It is a bounded error to assign from a bounded set object while
tampering with elements or cursors of that object is prohibited.  Either
Program_Error is raised by the assignment, execution proceeds with the
target object prohibiting tampering with elements or cursors, or
execution proceeds normally.

                         _Erroneous Execution_

16/3
When a bounded set object S is finalized, if tampering with cursors is
prohibited for S other than due to an assignment from another set, then
execution is erroneous. 

                     _Implementation Requirements_

17/3
For each instance of Containers.Hashed_Sets and each instance of
Containers.Bounded_Hashed_Sets, if the two instances meet the following
conditions, then the output generated by the Set'Output or Set'Write
subprograms of either instance shall be readable by the Set'Input or
Set'Read of the other instance, respectively:

18/3
   * the Element_Type parameters of the two instances are statically
     matching subtypes of the same type; and

19/3
   * the output generated by Element_Type'Output or Element_Type'Write
     is readable by Element_Type'Input or Element_Type'Read,
     respectively (where Element_Type denotes the type of the two actual
     Element_Type parameters).

                        _Implementation Advice_

20/3
Bounded hashed set objects should be implemented without implicit
pointers or dynamic allocation.

21/3
The implementation advice for procedure Move to minimize copying does
not apply.


File: arm2012.info,  Node: A.18.24,  Next: A.18.25,  Prev: A.18.23,  Up: A.18

A.18.24 The Generic Package Containers.Bounded_Ordered_Sets
-----------------------------------------------------------

1/3
The language-defined generic package Containers.Bounded_Ordered_Sets
provides a private type Set and a set of operations.  It provides the
same operations as the package Containers.Ordered_Sets (see *note
A.18.9::), with the difference that the maximum storage is bounded.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Bounded_Ordered_Sets has the same contents and semantics as
Containers.Ordered_Sets except:

3/3
   * The pragma Preelaborate is replaced with pragma Pure.

4/3
   * The type Set is declared with a discriminant that specifies the
     capacity (maximum number of elements) as follows:

5/3
       type Set (Capacity : Count_Type) is tagged private;

6/3
   * The type Set needs finalization if and only if type Element_Type
     needs finalization.

7/3
   * If Insert (or Include) adds an element, a check is made that the
     capacity is not exceeded, and Capacity_Error is raised if this
     check fails.

8/3
   * In procedure Assign, if Source length is greater than Target
     capacity, then Capacity_Error is propagated.

9/3
   * The function Copy is replaced with:

10/3
       function Copy (Source   : Set;
                      Capacity : Count_Type := 0) return Set;

11/3
          Returns a set whose elements are initialized from the values
          in Source.  If Capacity is 0, then the set capacity is the
          length of Source; if Capacity is equal to or greater than the
          length of Source, the set capacity is the specified value;
          otherwise, the operation propagates Capacity_Error.

                      _Bounded (Run-Time) Errors_

12/3
It is a bounded error to assign from a bounded set object while
tampering with elements or cursors of that object is prohibited.  Either
Program_Error is raised by the assignment, execution proceeds with the
target object prohibiting tampering with elements or cursors, or
execution proceeds normally.

                         _Erroneous Execution_

13/3
When a bounded set object S is finalized, if tampering with cursors is
prohibited for S other than due to an assignment from another set, then
execution is erroneous. 

                     _Implementation Requirements_

14/3
For each instance of Containers.Ordered_Sets and each instance of
Containers.Bounded_Ordered_Sets, if the two instances meet the following
conditions, then the output generated by the Set'Output or Set'Write
subprograms of either instance shall be readable by the Set'Input or
Set'Read of the other instance, respectively:

15/3
   * the Element_Type parameters of the two instances are statically
     matching subtypes of the same type; and

16/3
   * the output generated by Element_Type'Output or Element_Type'Write
     is readable by Element_Type'Input or Element_Type'Read,
     respectively (where Element_Type denotes the type of the two actual
     Element_Type parameters).

                        _Implementation Advice_

17/3
Bounded ordered set objects should be implemented without implicit
pointers or dynamic allocation.

18/3
The implementation advice for procedure Move to minimize copying does
not apply.


File: arm2012.info,  Node: A.18.25,  Next: A.18.26,  Prev: A.18.24,  Up: A.18

A.18.25 The Generic Package Containers.Bounded_Multiway_Trees
-------------------------------------------------------------

1/3
The language-defined generic package Containers.Bounded_Multiway_Trees
provides a private type Tree and a set of operations.  It provides the
same operations as the package Containers.Multiway_Trees (see *note
A.18.10::), with the difference that the maximum storage is bounded.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Bounded_Multiway_Trees has the same contents and semantics as
Containers.Multiway_Trees except:

3/3
   * The pragma Preelaborate is replaced with pragma Pure.

4/3
   * The type Tree is declared with a discriminant that specifies the
     capacity (maximum number of elements) as follows:

5/3
       type Tree (Capacity : Count_Type) is tagged private;

6/3
   * The type Tree needs finalization if and only if type Element_Type
     needs finalization.

7/3
   * The allocation of internal storage includes a check that the
     capacity is not exceeded, and Capacity_Error is raised if this
     check fails.

8/3
   * In procedure Assign, if Source length is greater than Target
     capacity, then Capacity_Error is propagated.

9/3
   * Function Copy is declared as follows:

10/4
       function Copy (Source : Tree; Capacity : Count_Type := 0)
          return Tree;

11/3
     If Capacity is 0, then the tree capacity is the count of Source; if
     Capacity is equal to or greater than Source.Count, the tree
     capacity equals the value of the Capacity parameter; otherwise, the
     operation propagates Capacity_Error.

12/3
   * In the five-parameter procedure Splice_Subtree, if Source is not
     the same object as Target, and if the sum of Target.Count and
     Subtree_Node_Count (Position) is greater than Target.Capacity, then
     Splice_Subtree propagates Capacity_Error.

13/3
   * In the five-parameter procedure Splice_Children, if Source is not
     the same object as Target, and if the sum of Target.Count and
     Subtree_Node_Count (Source_Parent)-1 is greater than
     Target.Capacity, then Splice_Children propagates Capacity_Error.

                      _Bounded (Run-Time) Errors_

14/3
It is a bounded error to assign from a bounded tree object while
tampering with elements or cursors of that object is prohibited.  Either
Program_Error is raised by the assignment, execution proceeds with the
target object prohibiting tampering with elements or cursors, or
execution proceeds normally.

                         _Erroneous Execution_

15/3
When a bounded tree object T is finalized, if tampering with cursors is
prohibited for T other than due to an assignment from another tree, then
execution is erroneous. 

                     _Implementation Requirements_

16/3
For each instance of Containers.Multiway_Trees and each instance of
Containers.Bounded_Multiway_Trees, if the two instances meet the
following conditions, then the output generated by the Tree'Output or
Tree'Write subprograms of either instance shall be readable by the
Tree'Input or Tree'Read of the other instance, respectively:

17/3
   * the Element_Type parameters of the two instances are statically
     matching subtypes of the same type; and

18/3
   * the output generated by Element_Type'Output or Element_Type'Write
     is readable by Element_Type'Input or Element_Type'Read,
     respectively (where Element_Type denotes the type of the two actual
     Element_Type parameters).

                        _Implementation Advice_

19/3
Bounded tree objects should be implemented without implicit pointers or
dynamic allocation.

20/3
The implementation advice for procedure Move to minimize copying does
not apply.


File: arm2012.info,  Node: A.18.26,  Next: A.18.27,  Prev: A.18.25,  Up: A.18

A.18.26 Array Sorting
---------------------

1/3
The language-defined generic procedures Containers.Generic_Array_Sort,
Containers.Generic_Constrained_Array_Sort, and Containers.Generic_Sort
provide sorting on arbitrary array types.

                          _Static Semantics_

2/2
The generic library procedure Containers.Generic_Array_Sort has the
following declaration:

3/2
     generic
        type Index_Type is (<>);
        type Element_Type is private;
        type Array_Type is array (Index_Type range <>) of Element_Type;
        with function "<" (Left, Right : Element_Type)
           return Boolean is <>;
     procedure Ada.Containers.Generic_Array_Sort (Container : in out Array_Type);
     pragma Pure(Ada.Containers.Generic_Array_Sort);

4/2
          Reorders the elements of Container such that the elements are
          sorted smallest first as determined by the generic formal "<"
          operator provided.  Any exception raised during evaluation of
          "<" is propagated.

5/3
          The actual function for the generic formal function "<" of
          Generic_Array_Sort is expected to return the same value each
          time it is called with a particular pair of element values.
          It should define a strict weak ordering relationship (see
          *note A.18::); it should not modify Container.  If the actual
          for "<" behaves in some other manner, the behavior of the
          instance of Generic_Array_Sort is unspecified.  The number of
          times Generic_Array_Sort calls "<" is unspecified.

6/2
The generic library procedure Containers.Generic_Constrained_Array_Sort
has the following declaration:

7/2
     generic
        type Index_Type is (<>);
        type Element_Type is private;
        type Array_Type is array (Index_Type) of Element_Type;
        with function "<" (Left, Right : Element_Type)
           return Boolean is <>;
     procedure Ada.Containers.Generic_Constrained_Array_Sort
           (Container : in out Array_Type);
     pragma Pure(Ada.Containers.Generic_Constrained_Array_Sort);

8/2
          Reorders the elements of Container such that the elements are
          sorted smallest first as determined by the generic formal "<"
          operator provided.  Any exception raised during evaluation of
          "<" is propagated.

9/3
          The actual function for the generic formal function "<" of
          Generic_Constrained_Array_Sort is expected to return the same
          value each time it is called with a particular pair of element
          values.  It should define a strict weak ordering relationship
          (see *note A.18::); it should not modify Container.  If the
          actual for "<" behaves in some other manner, the behavior of
          the instance of Generic_Constrained_Array_Sort is unspecified.
          The number of times Generic_Constrained_Array_Sort calls "<"
          is unspecified.

9.1/3
The generic library procedure Containers.Generic_Sort has the following
declaration:

9.2/4
     generic
        type Index_Type is (<>);
        with function Before (Left, Right : Index_Type) return Boolean;
        with procedure Swap (Left, Right : in Index_Type);
     procedure Ada.Containers.Generic_Sort
           (First, Last : Index_Type'Base);
     pragma Pure(Ada.Containers.Generic_Sort);

9.3/3
          Reorders the elements of an indexable structure, over the
          range First ..  Last, such that the elements are sorted in the
          ordering determined by the generic formal function Before;
          Before should return True if Left is to be sorted before
          Right.  The generic formal Before compares the elements having
          the given indices, and the generic formal Swap exchanges the
          values of the indicated elements.  Any exception raised during
          evaluation of Before or Swap is propagated.

9.4/3
          The actual function for the generic formal function Before of
          Generic_Sort is expected to return the same value each time it
          is called with index values that identify a particular pair of
          element values.  It should define a strict weak ordering
          relationship (see *note A.18::); it should not modify the
          elements.  The actual function for the generic formal Swap
          should exchange the values of the indicated elements.  If the
          actual for either Before or Swap behaves in some other manner,
          the behavior of Generic_Sort is unspecified.  The number of
          times the Generic_Sort calls Before or Swap is unspecified.

                        _Implementation Advice_

10/2
The worst-case time complexity of a call on an instance of
Containers.Generic_Array_Sort or
Containers.Generic_Constrained_Array_Sort should be O(N**2) or better,
and the average time complexity should be better than O(N**2), where N
is the length of the Container parameter.

11/2
Containers.Generic_Array_Sort and
Containers.Generic_Constrained_Array_Sort should minimize copying of
elements.

12/3
The worst-case time complexity of a call on an instance of
Containers.Generic_Sort should be O(N**2) or better, and the average
time complexity should be better than O(N**2), where N is the difference
between the Last and First parameters plus 1.

13/3
Containers.Generic_Sort should minimize calls to the generic formal
Swap.


File: arm2012.info,  Node: A.18.27,  Next: A.18.28,  Prev: A.18.26,  Up: A.18

A.18.27 The Generic Package Containers.Synchronized_Queue_Interfaces
--------------------------------------------------------------------

1/3
The language-defined generic package
Containers.Synchronized_Queue_Interfaces provides interface type Queue,
and a set of operations for that type.  Interface Queue specifies a
first-in, first-out queue.

                          _Static Semantics_

2/3
The generic library package Containers.Synchronized_Queue_Interfaces has
the following declaration:

3/3
     generic
        type Element_Type is private;
     package Ada.Containers.Synchronized_Queue_Interfaces is
        pragma Pure(Synchronized_Queue_Interfaces);

4/3
        type Queue is synchronized interface;

5/3
        procedure Enqueue
          (Container : in out Queue;
           New_Item  : in     Element_Type) is abstract
            with Synchronization => By_Entry;

6/3
        procedure Dequeue
          (Container : in out Queue;
           Element   :    out Element_Type) is abstract
            with Synchronization => By_Entry;

7/3
        function Current_Use (Container : Queue) return Count_Type is abstract;
        function Peak_Use (Container : Queue) return Count_Type is abstract;

8/3
     end Ada.Containers.Synchronized_Queue_Interfaces;

9/3
     procedure Enqueue
       (Container : in out Queue;
        New_Item  : in     Element_Type) is abstract;

10/3
          A queue type that implements this interface is allowed to have
          a bounded capacity.  If the queue object has a bounded
          capacity, and the number of existing elements equals the
          capacity, then Enqueue blocks until storage becomes available;
          otherwise, Enqueue does not block.  In any case, it then
          copies New_Item onto the queue.

11/3
     procedure Dequeue
       (Container : in out Queue;
        Element   :    out Element_Type) is abstract;

12/3
          If the queue is empty, then Dequeue blocks until an item
          becomes available.  In any case, it then assigns the element
          at the head of the queue to Element, and removes it from the
          queue.

13/3
     function Current_Use (Container : Queue) return Count_Type is abstract;

14/3
          Returns the number of elements currently in the queue.

15/3
     function Peak_Use (Container : Queue) return Count_Type is abstract;

16/3
          Returns the maximum number of elements that have been in the
          queue at any one time.

     NOTES

17/3
     51  Unlike other language-defined containers, there are no queues
     whose element types are indefinite.  Elements of an indefinite type
     can be handled by defining the element of the queue to be a holder
     container (see *note A.18.18::) of the indefinite type, or to be an
     explicit access type that designates the indefinite type.


File: arm2012.info,  Node: A.18.28,  Next: A.18.29,  Prev: A.18.27,  Up: A.18

A.18.28 The Generic Package Containers.Unbounded_Synchronized_Queues
--------------------------------------------------------------------

                          _Static Semantics_

1/3
The language-defined generic package
Containers.Unbounded_Synchronized_Queues provides type Queue, which
implements the interface type
Containers.Synchronized_Queue_Interfaces.Queue.

2/3
     with System;
     with Ada.Containers.Synchronized_Queue_Interfaces;
     generic
        with package Queue_Interfaces is new Ada.Containers.Synchronized_Queue_Interfaces (<>);
        Default_Ceiling : System.Any_Priority := System.Priority'Last;
     package Ada.Containers.Unbounded_Synchronized_Queues is
        pragma Preelaborate(Unbounded_Synchronized_Queues);

3/3
        package Implementation is
           ... -- not specified by the language
        end Implementation;

4/3
        protected type Queue
             (Ceiling : System.Any_Priority := Default_Ceiling)
                with Priority => Ceiling is
             new Queue_Interfaces.Queue with

5/3
           overriding
           entry Enqueue (New_Item : in Queue_Interfaces.Element_Type);
           overriding
           entry Dequeue (Element : out Queue_Interfaces.Element_Type);

6/3
           overriding
           function Current_Use return Count_Type;
           overriding
           function Peak_Use return Count_Type;

7/3
        private
           ... -- not specified by the language
        end Queue;

8/3
     private

9/3
        ... -- not specified by the language

10/3
     end Ada.Containers.Unbounded_Synchronized_Queues;

11/3
The type Queue is used to represent task-safe queues.

12/3
The capacity for instances of type Queue is unbounded.


File: arm2012.info,  Node: A.18.29,  Next: A.18.30,  Prev: A.18.28,  Up: A.18

A.18.29 The Generic Package Containers.Bounded_Synchronized_Queues
------------------------------------------------------------------

                          _Static Semantics_

1/3
The language-defined generic package
Containers.Bounded_Synchronized_Queues provides type Queue, which
implements the interface type
Containers.Synchronized_Queue_Interfaces.Queue.

2/3
     with System;
     with Ada.Containers.Synchronized_Queue_Interfaces;
     generic
        with package Queue_Interfaces is new Ada.Containers.Synchronized_Queue_Interfaces (<>);
        Default_Capacity : Count_Type;
        Default_Ceiling  : System.Any_Priority := System.Priority'Last;
     package Ada.Containers.Bounded_Synchronized_Queues is
        pragma Preelaborate(Bounded_Synchronized_Queues);

3/3
        package Implementation is
           ... -- not specified by the language
        end Implementation;

4/3
        protected type Queue
             (Capacity : Count_Type := Default_Capacity;
              Ceiling  : System.Any_Priority := Default_Ceiling)
                with Priority => Ceiling is
             new Queue_Interfaces.Queue with

5/3
           overriding
           entry Enqueue (New_Item : in Queue_Interfaces.Element_Type);
           overriding
           entry Dequeue (Element : out Queue_Interfaces.Element_Type);

6/3
           overriding
           function Current_Use return Count_Type;
           overriding
           function Peak_Use return Count_Type;

7/3
        private
           ... -- not specified by the language
        end Queue;

8/3
     private

9/3
        ... -- not specified by the language

10/3
     end Ada.Containers.Bounded_Synchronized_Queues;

11/3
The semantics are the same as for Unbounded_Synchronized_Queues, except:

12/3
   * The capacity for instances of type Queue is bounded and specified
     by the discriminant Capacity.

                        _Implementation Advice_

13/3
Bounded queue objects should be implemented without implicit pointers or
dynamic allocation.


File: arm2012.info,  Node: A.18.30,  Next: A.18.31,  Prev: A.18.29,  Up: A.18

A.18.30 The Generic Package Containers.Unbounded_Priority_Queues
----------------------------------------------------------------

                          _Static Semantics_

1/3
The language-defined generic package
Containers.Unbounded_Priority_Queues provides type Queue, which
implements the interface type
Containers.Synchronized_Queue_Interfaces.Queue.

2/3
     with System;
     with Ada.Containers.Synchronized_Queue_Interfaces;
     generic
        with package Queue_Interfaces is new Ada.Containers.Synchronized_Queue_Interfaces (<>);
        type Queue_Priority is private;
        with function Get_Priority
          (Element : Queue_Interfaces.Element_Type) return Queue_Priority is <>;
        with function Before
          (Left, Right : Queue_Priority) return Boolean is <>;
        Default_Ceiling : System.Any_Priority := System.Priority'Last;
     package Ada.Containers.Unbounded_Priority_Queues is
        pragma Preelaborate(Unbounded_Priority_Queues);

3/3
        package Implementation is
           ... -- not specified by the language
        end Implementation;

4/3
        protected type Queue
             (Ceiling : System.Any_Priority := Default_Ceiling)
                with Priority => Ceiling is
             new Queue_Interfaces.Queue with

5/3
           overriding
           entry Enqueue (New_Item : in Queue_Interfaces.Element_Type);
           overriding
           entry Dequeue (Element : out Queue_Interfaces.Element_Type);

6/3
           not overriding
           procedure Dequeue_Only_High_Priority
             (At_Least : in     Queue_Priority;
              Element  : in out Queue_Interfaces.Element_Type;
              Success  :    out Boolean);

7/3
           overriding
           function Current_Use return Count_Type;
           overriding
           function Peak_Use return Count_Type;

8/3
        private
           ... -- not specified by the language
        end Queue;

9/3
     private

10/3
        ... -- not specified by the language

11/3
     end Ada.Containers.Unbounded_Priority_Queues;

12/3
The type Queue is used to represent task-safe priority queues.

13/3
The capacity for instances of type Queue is unbounded.

14/3
Two elements E1 and E2 are equivalent if Before(Get_Priority(E1),
Get_Priority(E2)) and Before(Get_Priority(E2), Get_Priority(E1)) both
return False.

15/3
The actual functions for Get_Priority and Before are expected to return
the same value each time they are called with the same actuals, and
should not modify their actuals.  Before should define a strict weak
ordering relationship (see *note A.18::).  If the actual functions
behave in some other manner, the behavior of Unbounded_Priority_Queues
is unspecified.

16/3
Enqueue inserts an item according to the order specified by the Before
function on the result of Get_Priority on the elements; Before should
return True if Left is to be inserted before Right.  If the queue
already contains elements equivalent to New_Item, then it is inserted
after the existing equivalent elements.

17/3
For a call on Dequeue_Only_High_Priority, if the head of the nonempty
queue is E, and the function Before(At_Least, Get_Priority(E)) returns
False, then E is assigned to Element and then removed from the queue,
and Success is set to True; otherwise, Success is set to False and
Element is unchanged.


File: arm2012.info,  Node: A.18.31,  Next: A.18.32,  Prev: A.18.30,  Up: A.18

A.18.31 The Generic Package Containers.Bounded_Priority_Queues
--------------------------------------------------------------

                          _Static Semantics_

1/3
The language-defined generic package Containers.Bounded_Priority_Queues
provides type Queue, which implements the interface type
Containers.Synchronized_Queue_Interfaces.Queue.

2/3
     with System;
     with Ada.Containers.Synchronized_Queue_Interfaces;
     generic
        with package Queue_Interfaces is new Ada.Containers.Synchronized_Queue_Interfaces (<>);
        type Queue_Priority is private;
        with function Get_Priority
          (Element : Queue_Interfaces.Element_Type) return Queue_Priority is <>;
        with function Before
          (Left, Right : Queue_Priority) return Boolean is <>;
        Default_Capacity : Count_Type;
        Default_Ceiling  : System.Any_Priority := System.Priority'Last;
     package Ada.Containers.Bounded_Priority_Queues is
        pragma Preelaborate(Bounded_Priority_Queues);

3/3
        package Implementation is
           ... -- not specified by the language
        end Implementation;

4/3
        protected type Queue
             (Capacity : Count_Type := Default_Capacity;
              Ceiling  : System.Any_Priority := Default_Ceiling)
                with Priority => Ceiling is
           new Queue_Interfaces.Queue with

5/3
           overriding
           entry Enqueue (New_Item : in Queue_Interfaces.Element_Type);
           overriding
           entry Dequeue (Element : out Queue_Interfaces.Element_Type);

6/3
           not overriding
           procedure Dequeue_Only_High_Priority
             (At_Least : in     Queue_Priority;
              Element  : in out Queue_Interfaces.Element_Type;
              Success  :    out Boolean);

7/3
           overriding
           function Current_Use return Count_Type;
           overriding
           function Peak_Use return Count_Type;

8/3
        private
           ... -- not specified by the language
        end Queue;

9/3
     private

10/3
        ... -- not specified by the language

11/3
     end Ada.Containers.Bounded_Priority_Queues;

12/3
The semantics are the same as for Unbounded_Priority_Queues, except:

13/3
   * The capacity for instances of type Queue is bounded and specified
     by the discriminant Capacity.

                        _Implementation Advice_

14/3
Bounded priority queue objects should be implemented without implicit
pointers or dynamic allocation.


File: arm2012.info,  Node: A.18.32,  Prev: A.18.31,  Up: A.18

A.18.32 Example of Container Use
--------------------------------

                              _Examples_

1/3
The following example is an implementation of Dijkstra's shortest path
algorithm in a directed graph with positive distances.  The graph is
represented by a map from nodes to sets of edges.

2/3
     with Ada.Containers.Vectors;
     with Ada.Containers.Doubly_Linked_Lists;
     use Ada.Containers;
     generic
        type Node is range <>;
     package Shortest_Paths is
        type Distance is new Float range 0.0 .. Float'Last;
        type Edge is record
           To, From : Node;
           Length   : Distance;
        end record;

3/3
        package Node_Maps is new Vectors (Node, Node);
        -- The algorithm builds a map to indicate the node used to reach a given
        -- node in the shortest distance.

4/3
        package Adjacency_Lists is new Doubly_Linked_Lists (Edge);
        use Adjacency_Lists;

5/3
        package Graphs is new Vectors (Node, Adjacency_Lists.List);

6/3
        package Paths is new Doubly_Linked_Lists (Node);

7/3
        function Shortest_Path
          (G : Graphs.Vector; Source : Node; Target : Node) return Paths.List
           with Pre => G (Source) /= Adjacency_Lists.Empty_List;

8/3
     end Shortest_Paths;

9/3
     package body Shortest_Paths is
        function Shortest_Path
          (G : Graphs.Vector; Source : Node; Target : Node) return Paths.List
        is
           use Adjacency_Lists, Node_Maps, Paths, Graphs;
           Reached  : array (Node) of Boolean := (others => False);
           -- The set of nodes whose shortest distance to the source is known.

10/3
           Reached_From : array (Node) of Node;
           So_Far   : array (Node) of Distance := (others => Distance'Last);
           The_Path : Paths.List := Paths.Empty_List;
           Nearest_Distance : Distance;
           Next     : Node;
        begin
           So_Far(Source)  := 0.0;

11/3
           while not Reached(Target) loop
              Nearest_Distance := Distance'Last;

12/3
              -- Find closest node not reached yet, by iterating over all nodes.
              -- A more efficient algorithm uses a priority queue for this step.

13/3
              Next := Source;
              for N in Node'First .. Node'Last loop
                 if not Reached(N)
                   and then So_Far(N) < Nearest_Distance then
                      Next := N;
                      Nearest_Distance := So_Far(N);
                 end if;
              end loop;

14/3
              if Nearest_Distance = Distance'Last then
                 -- No next node found, graph is not connected
                 return Paths.Empty_List;

15/3
              else
                 Reached(Next) := True;
              end if;

16/3
              -- Update minimum distance to newly reachable nodes.

17/3
              for E of G (Next) loop
                 if not Reached(E.To) then
                    Nearest_Distance := E.Length + So_Far(Next);

18/3
                    if Nearest_Distance < So_Far(E.To) then
                       Reached_From(E.To) := Next;
                       So_Far(E.To) := Nearest_Distance;
                    end if;
                 end if;
              end loop;
           end loop;

19/3
           -- Rebuild path from target to source.

20/3
           declare
              N : Node := Target;
           begin
              while N /= Source loop
                 N := Reached_From(N);
                 Prepend (The_Path, N);
              end loop;
           end;

21/3
           return The_Path;
        end;
     end Shortest_Paths;

22/3
Note that the effect of the Constant_Indexing aspect (on type Vector)
and the Implicit_Dereference aspect (on type Reference_Type) is that

23/3
     G (Next)

24/3
is a convenient short hand for

25/3
     G.Constant_Reference (Next).Element.all

26/3
Similarly, the effect of the loop:

27/3
     for E of G (Next) loop
        if not Reached(E.To) then
           ...
        end if;
     end loop;

28/3
is the same as:

29/4
     for C in G (Next).Iterate loop
        declare
           E : Edge renames G (Next)(C);
        begin
           if not Reached(E.To) then
              ...
           end if;
        end;
     end loop;

30/3
which is the same as:

31/4
     declare
        L : Adjacency_Lists.List renames G (Next);
        C : Adjacency_Lists.Cursor := L.First;
     begin
        while Has_Element (C) loop
           declare
              E : Edge renames L(C);
           begin
              if not Reached(E.To) then
                 ...
              end if;
           end;
           C := L.Next (C);
        end loop;
     end;


File: arm2012.info,  Node: A.19,  Prev: A.18,  Up: Annex A

A.19 The Package Locales
========================

1/3
A locale identifies a geopolitical place or region and its associated
language, which can be used to determine other
internationalization-related characteristics.

                          _Static Semantics_

2/3
The library package Locales has the following declaration:

3/3
     package Ada.Locales is
        pragma Preelaborate(Locales);
        pragma Remote_Types(Locales);

4/4
        type Language_Code is new String (1 .. 3)
           with Dynamic_Predicate =>
              (for all E of Language_Code => E in 'a' .. 'z');
        type Country_Code is new String (1 .. 2)
           with Dynamic_Predicate =>
              (for all E of Country_Code  => E in 'A' .. 'Z');

5/3
        Language_Unknown : constant Language_Code := "und";
        Country_Unknown : constant Country_Code := "ZZ";

6/3
        function Language return Language_Code;
        function Country return Country_Code;

7/3
     end Ada.Locales;

8/3
The active locale is the locale associated with the partition of the
current task.

9/3
Language_Code is a lower-case string representation of an ISO 639-3
alpha-3 code that identifies a language.

10/3
Country_Code is an upper-case string representation of an ISO 3166-1
alpha-2 code that identifies a country.

11/3
Function Language returns the code of the language associated with the
active locale.  If the Language_Code associated with the active locale
cannot be determined from the environment, then Language returns
Language_Unknown.

12/3
Function Country returns the code of the country associated with the
active locale.  If the Country_Code associated with the active locale
cannot be determined from the environment, then Country returns
Country_Unknown.


File: arm2012.info,  Node: Annex B,  Next: Annex C,  Prev: Annex A,  Up: Top

Annex B Interface to Other Languages
************************************

1
This Annex describes features for writing mixed-language programs.
General interface support is presented first; then specific support for
C, COBOL, and Fortran is defined, in terms of language interface
packages for each of these languages.

                     _Implementation Requirements_

2/3
Support for interfacing to any foreign language is optional.  However,
an implementation shall not provide any optional aspect, attribute,
library unit, or pragma having the same name as an aspect, attribute,
library unit, or pragma (respectively) specified in the subclauses of
this Annex unless the provided construct is either as specified in those
subclauses or is more limited in capability than that required by those
subclauses.  A program that attempts to use an unsupported capability of
this Annex shall either be identified by the implementation before run
time or shall raise an exception at run time.

* Menu:

* B.1 ::      Interfacing Aspects
* B.2 ::      The Package Interfaces
* B.3 ::      Interfacing with C and C++
* B.4 ::      Interfacing with COBOL
* B.5 ::      Interfacing with Fortran


File: arm2012.info,  Node: B.1,  Next: B.2,  Up: Annex B

B.1 Interfacing Aspects
=======================

0.1/3
An interfacing aspect is a representation aspect that is one of the
aspects Import, Export, Link_Name, External_Name, or Convention.

1/3
Specifying the Import aspect to have the value True is used to import an
entity defined in a foreign language into an Ada program, thus allowing
a foreign-language subprogram to be called from Ada, or a
foreign-language variable to be accessed from Ada.  In contrast, 
specifying the Export aspect to have the value True is used to export an
Ada entity to a foreign language, thus allowing an Ada subprogram to be
called from a foreign language, or an Ada object to be accessed from a
foreign language.  The Import and Export aspects are intended primarily
for objects and subprograms, although implementations are allowed to
support other entities.  The Link_Name and External_Name aspects are
used to specify the link name and external name, respectively, to be
used to identify imported or exported entities in the external
environment. 

2/3
The Convention aspect is used to indicate that an Ada entity should use
the conventions of another language.  It is intended primarily for types
and "callback" subprograms.  For example, "with Convention => Fortran"
on the declaration of an array type Matrix implies that Matrix should be
represented according to the conventions of the supported Fortran
implementation, namely column-major order.

3
A pragma Linker_Options is used to specify the system linker parameters
needed when a given compilation unit is included in a partition.

                               _Syntax_

4/3
     The form of a pragma Linker_Options is as follows:

     Paragraphs 5 through 7 were moved to *note Annex J::, "*note Annex
     J:: Obsolescent Features".

8
       pragma Linker_Options(string_expression);

9
     A pragma Linker_Options is allowed only at the place of a
     declarative_item.

9.1/3
     This paragraph was deleted.

                        _Name Resolution Rules_

9.2/3
The Import and Export aspects are of type Boolean.

10/3
The Link_Name and External_Name aspects are of type String.

10.1/3
The expected type for the string_expression in pragma Linker_Options is
String.

                           _Legality Rules_

11/3
The aspect Convention shall be specified by a convention_identifier
which shall be the name of a convention.  The convention names are
implementation defined, except for certain language-defined ones, such
as Ada and Intrinsic, as explained in *note 6.3.1::, "*note 6.3.1::
Conformance Rules".  Additional convention names generally represent the
calling conventions of foreign languages, language implementations, or
specific run-time models. The convention of a callable entity is its
calling convention.

12
If L is a convention_identifier for a language, then a type T is said to
be compatible with convention L, (alternatively, is said to be an
L-compatible type) if any of the following conditions are met:

13
   * T is declared in a language interface package corresponding to L
     and is defined to be L-compatible (see *note B.3::, *note B.3.1::,
     *note B.3.2::, *note B.4::, *note B.5::),

14/3
   * Convention L has been specified for T, and T is eligible for
     convention L; that is:

14.1/4
             * T is an enumeration type such that all internal codes
               (whether assigned by default or explicitly) are within an
               implementation-defined range that includes at least the
               range of values 0 ..  2**15-1;

15
             * T is an array type with either an unconstrained or
               statically-constrained first subtype, and its component
               type is L-compatible,

16
             * T is a record type that has no discriminants and that
               only has components with statically-constrained subtypes,
               and each component type is L-compatible,

17/3
             * T is an access-to-object type, its designated type is
               L-compatible, and its designated subtype is not an
               unconstrained array subtype,

18
             * T is an access-to-subprogram type, and its designated
               profile's parameter and result types are all
               L-compatible.

19
   * T is derived from an L-compatible type,

20
   * The implementation permits T as an L-compatible type.

21/3
If the Convention aspect is specified for a type, then the type shall
either be compatible with or eligible for the specified convention.

22/3
Notwithstanding any rule to the contrary, a declaration with a True
Import aspect shall not have a completion.

23/3
An entity with a True Import aspect (or Export aspect) is said to be
imported (respectively, exported).  An entity shall not be both imported
and exported.

24
The declaration of an imported object shall not include an explicit
initialization expression.  Default initializations are not performed.

25/3
The type of an imported or exported object shall be compatible with the
specified Convention aspect, if any.

26/3
For an imported or exported subprogram, the result and parameter types
shall each be compatible with the specified Convention aspect, if any.

27/3
The aspect_definition (if any) used to directly specify an Import,
Export, External_Name, or Link_Name aspect shall be a static expression.
The string_expression of a pragma Linker_Options shall be static.  An
External_Name or Link_Name aspect shall be specified only for an entity
that is either imported or exported.

                          _Static Semantics_

Paragraphs 28 and 29 were deleted.

30/3
The Convention aspect represents the calling convention or
representation convention of the entity.  For an access-to-subprogram
type, it represents the calling convention of designated subprograms.
In addition:

31/3
   * A True Import aspect indicates that the entity is defined
     externally (that is, outside the Ada program).  This aspect is
     never inherited; if not directly specified, the Import aspect is
     False.

32/3
   * A True Export aspect indicates that the entity is used externally.
     This aspect is never inherited; if not directly specified, the
     Export aspect is False.

33/3
   * For an entity with a True Import or Export aspect, an external
     name, link name, or both may also be specified.

34
An external name is a string value for the name used by a foreign
language program either for an entity that an Ada program imports, or
for referring to an entity that an Ada program exports.

35
A link name is a string value for the name of an exported or imported
entity, based on the conventions of the foreign language's compiler in
interfacing with the system's linker tool.

36
The meaning of link names is implementation defined.  If neither a link
name nor the Address attribute of an imported or exported entity is
specified, then a link name is chosen in an implementation-defined
manner, based on the external name if one is specified.

37
Pragma Linker_Options has the effect of passing its string argument as a
parameter to the system linker (if one exists), if the immediately
enclosing compilation unit is included in the partition being linked.
The interpretation of the string argument, and the way in which the
string arguments from multiple Linker_Options pragmas are combined, is
implementation defined.

                          _Dynamic Semantics_

38/3
Notwithstanding what this International Standard says elsewhere, the
elaboration of a declaration with a True Import aspect does not create
the entity.  Such an elaboration has no other effect than to allow the
defining name to denote the external entity.

                         _Erroneous Execution_

38.1/3
It is the programmer's responsibility to ensure that the use of
interfacing aspects does not violate Ada semantics; otherwise, program
execution is erroneous.

                        _Implementation Advice_

39/3
If an implementation supports Export for a given language, then it
should also allow the main subprogram to be written in that language.
It should support some mechanism for invoking the elaboration of the Ada
library units included in the system, and for invoking the finalization
of the environment task.  On typical systems, the recommended mechanism
is to provide two subprograms whose link names are "adainit" and
"adafinal".  Adainit should contain the elaboration code for library
units.  Adafinal should contain the finalization code.  These
subprograms should have no effect the second and subsequent time they
are called. 

40/3
Automatic elaboration of preelaborated packages should be provided when
specifying the Export aspect as True is supported.

41/4
For each supported convention L other than Intrinsic, an implementation
should support specifying the Import and Export aspects for objects of
L-compatible types and for subprograms, and the Convention aspect for
L-eligible types and for subprograms, presuming the other language has
corresponding features.  Specifying the Convention aspect need not be
supported for scalar types, other than enumeration types whose internal
codes fall within the range 0 ..  2**15-1.

     NOTES

42/3
     1  Implementations may place restrictions on interfacing aspects;
     for example, requiring each exported entity to be declared at the
     library level.

43/3
     2  The Convention aspect in combination with the Import aspect
     indicates the conventions for accessing external entities.  It is
     possible that the actual entity is written in assembly language,
     but reflects the conventions of a particular language.  For
     example, with Convention => Ada can be used to interface to an
     assembly language routine that obeys the Ada compiler's calling
     conventions.

44/3
     3  To obtain "call-back" to an Ada subprogram from a foreign
     language environment, the Convention aspect should be specified
     both for the access-to-subprogram type and the specific
     subprogram(s) to which 'Access is applied.

     Paragraphs 45 and 46 were deleted.

47
     4  See also *note 13.8::, "*note 13.8:: Machine Code Insertions".

48/3
     5  If both External_Name and Link_Name are specified for a given
     entity, then the External_Name is ignored.

49/2
     This paragraph was deleted.

                              _Examples_

50/4
Example of interfacing aspects:

51/3
     package Fortran_Library is
       function Sqrt (X : Float) return Float
         with Import => True, Convention => Fortran;
       type Matrix is array (Natural range <>, Natural range <>) of Float
         with Convention => Fortran;
       function Invert (M : Matrix) return Matrix
         with Import => True, Convention => Fortran;
     end Fortran_Library;


File: arm2012.info,  Node: B.2,  Next: B.3,  Prev: B.1,  Up: Annex B

B.2 The Package Interfaces
==========================

1
Package Interfaces is the parent of several library packages that
declare types and other entities useful for interfacing to foreign
languages.  It also contains some implementation-defined types that are
useful across more than one language (in particular for interfacing to
assembly language).

                          _Static Semantics_

2
The library package Interfaces has the following skeletal declaration:

3

     package Interfaces is
        pragma Pure(Interfaces);

4
        type Integer_n is range -2**(n-1) .. 2**(n-1) - 1;  --2's complement

5
        type Unsigned_n is mod 2**n;

6
        function Shift_Left  (Value : Unsigned_n; Amount : Natural)
           return Unsigned_n;
        function Shift_Right (Value : Unsigned_n; Amount : Natural)
           return Unsigned_n;
        function Shift_Right_Arithmetic (Value : Unsigned_n; Amount : Natural)
           return Unsigned_n;
        function Rotate_Left  (Value : Unsigned_n; Amount : Natural)
           return Unsigned_n;
        function Rotate_Right (Value : Unsigned_n; Amount : Natural)
           return Unsigned_n;
        ...
     end Interfaces;

                     _Implementation Requirements_

7
An implementation shall provide the following declarations in the
visible part of package Interfaces:

8
   * Signed and modular integer types of n bits, if supported by the
     target architecture, for each n that is at least the size of a
     storage element and that is a factor of the word size.  The names
     of these types are of the form Integer_n for the signed types, and
     Unsigned_n for the modular types;

9
   * For each such modular type in Interfaces, shifting and rotating
     subprograms as specified in the declaration of Interfaces above.
     These subprograms are Intrinsic.  They operate on a bit-by-bit
     basis, using the binary representation of the value of the operands
     to yield a binary representation for the result.  The Amount
     parameter gives the number of bits by which to shift or rotate.
     For shifting, zero bits are shifted in, except in the case of
     Shift_Right_Arithmetic, where one bits are shifted in if Value is
     at least half the modulus.

10
   * Floating point types corresponding to each floating point format
     fully supported by the hardware.

                     _Implementation Permissions_

11
An implementation may provide implementation-defined library units that
are children of Interfaces, and may add declarations to the visible part
of Interfaces in addition to the ones defined above.

11.1/3
A child package of package Interfaces with the name of a convention may
be provided independently of whether the convention is supported by the
Convention aspect and vice versa.  Such a child package should contain
any declarations that would be useful for interfacing to the language
(implementation) represented by the convention.  Any declarations useful
for interfacing to any language on the given hardware architecture
should be provided directly in Interfaces.

                        _Implementation Advice_

12/2
This paragraph was deleted.

13/3
An implementation supporting an interface to C, COBOL, or Fortran should
provide the corresponding package or packages described in the following
subclauses.


File: arm2012.info,  Node: B.3,  Next: B.4,  Prev: B.2,  Up: Annex B

B.3 Interfacing with C and C++
==============================

1/4
The facilities relevant to interfacing with the C language and the
corresponding subset of the C++ language are the package Interfaces.C
and its children, and support for specifying the Convention aspect with
convention_identifiers C, C_Pass_By_Copy, and any of the C_Variadic_n
conventions described below.

2/3
The package Interfaces.C contains the basic types, constants, and
subprograms that allow an Ada program to pass scalars and strings to C
and C++ functions.  When this subclause mentions a C entity, the
reference also applies to the corresponding entity in C++.

                          _Static Semantics_

3
The library package Interfaces.C has the following declaration:

4
     package Interfaces.C is
        pragma Pure(C);

5
        -- Declarations based on C's <limits.h>

6
        CHAR_BIT  : constant := implementation-defined;  -- typically 8
        SCHAR_MIN : constant := implementation-defined;  -- typically -128
        SCHAR_MAX : constant := implementation-defined;  -- typically 127
        UCHAR_MAX : constant := implementation-defined;  -- typically 255

7
        -- Signed and Unsigned Integers
        type int   is range implementation-defined;
        type short is range implementation-defined;
        type long  is range implementation-defined;

8
        type signed_char is range SCHAR_MIN .. SCHAR_MAX;
        for signed_char'Size use CHAR_BIT;

9
        type unsigned       is mod implementation-defined;
        type unsigned_short is mod implementation-defined;
        type unsigned_long  is mod implementation-defined;

10
        type unsigned_char is mod (UCHAR_MAX+1);
        for unsigned_char'Size use CHAR_BIT;

11
        subtype plain_char is implementation-defined;

12
        type ptrdiff_t is range implementation-defined;

13
        type size_t is mod implementation-defined;

14
        -- Floating Point

15
        type C_float     is digits implementation-defined;

16
        type double      is digits implementation-defined;

17
        type long_double is digits implementation-defined;

18
        -- Characters and Strings 

19
        type char is <implementation-defined character type>;

20/1
        nul : constant char := implementation-defined;

21
        function To_C   (Item : in Character) return char;

22
        function To_Ada (Item : in char) return Character;

23/3
        type char_array is array (size_t range <>) of aliased char
           with Pack;
        for char_array'Component_Size use CHAR_BIT;

24
        function Is_Nul_Terminated (Item : in char_array) return Boolean;

25
        function To_C   (Item       : in String;
                         Append_Nul : in Boolean := True)
           return char_array;

26
        function To_Ada (Item     : in char_array;
                         Trim_Nul : in Boolean := True)
           return String;

27
        procedure To_C (Item       : in  String;
                        Target     : out char_array;
                        Count      : out size_t;
                        Append_Nul : in  Boolean := True);

28
        procedure To_Ada (Item     : in  char_array;
                          Target   : out String;
                          Count    : out Natural;
                          Trim_Nul : in  Boolean := True);

29
        -- Wide Character and Wide String

30/1
        type wchar_t is <implementation-defined character type>;

31/1
        wide_nul : constant wchar_t := implementation-defined;

32
        function To_C   (Item : in Wide_Character) return wchar_t;
        function To_Ada (Item : in wchar_t       ) return Wide_Character;

33/3
        type wchar_array is array (size_t range <>) of aliased wchar_t
           with Pack;

34/3
     This paragraph was deleted.

35
        function Is_Nul_Terminated (Item : in wchar_array) return Boolean;

36
        function To_C   (Item       : in Wide_String;
                         Append_Nul : in Boolean := True)
           return wchar_array;

37
        function To_Ada (Item     : in wchar_array;
                         Trim_Nul : in Boolean := True)
           return Wide_String;

38
        procedure To_C (Item       : in  Wide_String;
                        Target     : out wchar_array;
                        Count      : out size_t;
                        Append_Nul : in  Boolean := True);

39
        procedure To_Ada (Item     : in  wchar_array;
                          Target   : out Wide_String;
                          Count    : out Natural;
                          Trim_Nul : in  Boolean := True);

39.1/2
        -- ISO/IEC 10646:2003 compatible types defined by ISO/IEC TR 19769:2004.

39.2/2
        type char16_t is <implementation-defined character type>;

39.3/2
        char16_nul : constant char16_t := implementation-defined;

39.4/2
        function To_C (Item : in Wide_Character) return char16_t;
        function To_Ada (Item : in char16_t) return Wide_Character;

39.5/3
        type char16_array is array (size_t range <>) of aliased char16_t
           with Pack;

39.6/3
     This paragraph was deleted.

39.7/2
        function Is_Nul_Terminated (Item : in char16_array) return Boolean;
        function To_C (Item       : in Wide_String;
                       Append_Nul : in Boolean := True)
           return char16_array;

39.8/2
        function To_Ada (Item     : in char16_array;
                         Trim_Nul : in Boolean := True)
           return Wide_String;

39.9/2
        procedure To_C (Item       : in  Wide_String;
                        Target     : out char16_array;
                        Count      : out size_t;
                        Append_Nul : in  Boolean := True);

39.10/2
        procedure To_Ada (Item     : in  char16_array;
                          Target   : out Wide_String;
                          Count    : out Natural;
                          Trim_Nul : in  Boolean := True);

39.11/2
        type char32_t is <implementation-defined character type>;

39.12/2
        char32_nul : constant char32_t := implementation-defined;

39.13/2
        function To_C (Item : in Wide_Wide_Character) return char32_t;
        function To_Ada (Item : in char32_t) return Wide_Wide_Character;

39.14/3
        type char32_array is array (size_t range <>) of aliased char32_t
           with Pack;

39.15/3
     This paragraph was deleted.

39.16/2
        function Is_Nul_Terminated (Item : in char32_array) return Boolean;
        function To_C (Item       : in Wide_Wide_String;
                       Append_Nul : in Boolean := True)
           return char32_array;

39.17/2
        function To_Ada (Item     : in char32_array;
                         Trim_Nul : in Boolean := True)
           return Wide_Wide_String;

39.18/2
        procedure To_C (Item       : in  Wide_Wide_String;
                        Target     : out char32_array;
                        Count      : out size_t;
                        Append_Nul : in  Boolean := True);

39.19/2
        procedure To_Ada (Item     : in  char32_array;
                          Target   : out Wide_Wide_String;
                          Count    : out Natural;
                          Trim_Nul : in  Boolean := True);

40
        Terminator_Error : exception;

41
     end Interfaces.C;

42
Each of the types declared in Interfaces.C is C-compatible.

43/2
The types int, short, long, unsigned, ptrdiff_t, size_t, double, char,
wchar_t, char16_t, and char32_t correspond respectively to the C types
having the same names.  The types signed_char, unsigned_short,
unsigned_long, unsigned_char, C_float, and long_double correspond
respectively to the C types signed char, unsigned short, unsigned long,
unsigned char, float, and long double.

44
The type of the subtype plain_char is either signed_char or
unsigned_char, depending on the C implementation.

45
     function To_C   (Item : in Character) return char;
     function To_Ada (Item : in char     ) return Character;

46
          The functions To_C and To_Ada map between the Ada type
          Character and the C type char.

47
     function Is_Nul_Terminated (Item : in char_array) return Boolean;

48
          The result of Is_Nul_Terminated is True if Item contains nul,
          and is False otherwise.

49
     function To_C   (Item : in String;     Append_Nul : in Boolean := True)
        return char_array;

     function To_Ada (Item : in char_array; Trim_Nul   : in Boolean := True)
        return String;

50/2
          The result of To_C is a char_array value of length Item'Length
          (if Append_Nul is False) or Item'Length+1 (if Append_Nul is
          True).  The lower bound is 0.  For each component Item(I), the
          corresponding component in the result is To_C applied to
          Item(I). The value nul is appended if Append_Nul is True.  If
          Append_Nul is False and Item'Length is 0, then To_C propagates
          Constraint_Error.

51
          The result of To_Ada is a String whose length is Item'Length
          (if Trim_Nul is False) or the length of the slice of Item
          preceding the first nul (if Trim_Nul is True).  The lower
          bound of the result is 1.  If Trim_Nul is False, then for each
          component Item(I) the corresponding component in the result is
          To_Ada applied to Item(I). If Trim_Nul is True, then for each
          component Item(I) before the first nul the corresponding
          component in the result is To_Ada applied to Item(I). The
          function propagates Terminator_Error if Trim_Nul is True and
          Item does not contain nul.

52
     procedure To_C (Item       : in  String;
                     Target     : out char_array;
                     Count      : out size_t;
                     Append_Nul : in  Boolean := True);

     procedure To_Ada (Item     : in  char_array;
                       Target   : out String;
                       Count    : out Natural;
                       Trim_Nul : in  Boolean := True);

53
          For procedure To_C, each element of Item is converted (via the
          To_C function) to a char, which is assigned to the
          corresponding element of Target.  If Append_Nul is True, nul
          is then assigned to the next element of Target.  In either
          case, Count is set to the number of Target elements assigned.
          If Target is not long enough, Constraint_Error is propagated.

54
          For procedure To_Ada, each element of Item (if Trim_Nul is
          False) or each element of Item preceding the first nul (if
          Trim_Nul is True) is converted (via the To_Ada function) to a
          Character, which is assigned to the corresponding element of
          Target.  Count is set to the number of Target elements
          assigned. If Target is not long enough, Constraint_Error is
          propagated.  If Trim_Nul is True and Item does not contain
          nul, then Terminator_Error is propagated.

55
     function Is_Nul_Terminated (Item : in wchar_array) return Boolean;

56
          The result of Is_Nul_Terminated is True if Item contains
          wide_nul, and is False otherwise.

57
     function To_C   (Item : in Wide_Character) return wchar_t;
     function To_Ada (Item : in wchar_t       ) return Wide_Character;

58
          To_C and To_Ada provide the mappings between the Ada and C
          wide character types.

59
     function To_C   (Item       : in Wide_String;
                      Append_Nul : in Boolean := True)
        return wchar_array;

     function To_Ada (Item     : in wchar_array;
                      Trim_Nul : in Boolean := True)
        return Wide_String;

     procedure To_C (Item       : in  Wide_String;
                     Target     : out wchar_array;
                     Count      : out size_t;
                     Append_Nul : in  Boolean := True);

     procedure To_Ada (Item     : in  wchar_array;
                       Target   : out Wide_String;
                       Count    : out Natural;
                       Trim_Nul : in  Boolean := True);

60
          The To_C and To_Ada subprograms that convert between
          Wide_String and wchar_array have analogous effects to the To_C
          and To_Ada subprograms that convert between String and
          char_array, except that wide_nul is used instead of nul.

60.1/2
     function Is_Nul_Terminated (Item : in char16_array) return Boolean;

60.2/2
          The result of Is_Nul_Terminated is True if Item contains
          char16_nul, and is False otherwise.

60.3/2
     function To_C (Item : in Wide_Character) return char16_t;
     function To_Ada (Item : in char16_t ) return Wide_Character;

60.4/2
          To_C and To_Ada provide mappings between the Ada and C 16-bit
          character types.

60.5/2
     function To_C (Item       : in Wide_String;
                    Append_Nul : in Boolean := True)
        return char16_array;

     function To_Ada (Item     : in char16_array;
                      Trim_Nul : in Boolean := True)
        return Wide_String;

     procedure To_C (Item       : in  Wide_String;
                     Target     : out char16_array;
                     Count      : out size_t;
                     Append_Nul : in  Boolean := True);

     procedure To_Ada (Item     : in  char16_array;
                       Target   : out Wide_String;
                       Count    : out Natural;
                       Trim_Nul : in  Boolean := True);

60.6/2
          The To_C and To_Ada subprograms that convert between
          Wide_String and char16_array have analogous effects to the
          To_C and To_Ada subprograms that convert between String and
          char_array, except that char16_nul is used instead of nul.

60.7/2
     function Is_Nul_Terminated (Item : in char32_array) return Boolean;

60.8/2
          The result of Is_Nul_Terminated is True if Item contains
          char16_nul, and is False otherwise.

60.9/2
     function To_C (Item : in Wide_Wide_Character) return char32_t;
     function To_Ada (Item : in char32_t ) return Wide_Wide_Character;

60.10/2
          To_C and To_Ada provide mappings between the Ada and C 32-bit
          character types.

60.11/2
     function To_C (Item       : in Wide_Wide_String;
                    Append_Nul : in Boolean := True)
        return char32_array;

     function To_Ada (Item     : in char32_array;
                      Trim_Nul : in Boolean := True)
        return Wide_Wide_String;

     procedure To_C (Item       : in  Wide_Wide_String;
                     Target     : out char32_array;
                     Count      : out size_t;
                     Append_Nul : in  Boolean := True);

     procedure To_Ada (Item     : in  char32_array;
                       Target   : out Wide_Wide_String;
                       Count    : out Natural;
                       Trim_Nul : in  Boolean := True);

60.12/2
          The To_C and To_Ada subprograms that convert between
          Wide_Wide_String and char32_array have analogous effects to
          the To_C and To_Ada subprograms that convert between String
          and char_array, except that char32_nul is used instead of nul.

60.13/3
The Convention aspect with convention_identifier C_Pass_By_Copy shall
only be specified for a type.

60.14/2
The eligibility rules in *note B.1:: do not apply to convention
C_Pass_By_Copy.  Instead, a type T is eligible for convention
C_Pass_By_Copy if T is an unchecked union type or if T is a record type
that has no discriminants and that only has components with statically
constrained subtypes, and each component is C-compatible.

60.15/3
If a type is C_Pass_By_Copy-compatible, then it is also C-compatible.

60.16/4
The identifiers C_Variadic_0, C_Variadic_1, C_Variadic_2, and so on are
convention_identifiers.  These conventions are said to be C_Variadic.
The convention C_Variadic_n is the calling convention for a variadic C
function taking n fixed parameters and then a variable number of
additional parameters.  The C_Variadic_n convention shall only be
specified as the convention aspect for a subprogram, or for an
access-to-subprogram type, having at least n parameters.  A type is
compatible with a C_Variadic convention if and only if the type is
C-compatible.

                     _Implementation Requirements_

61/3
An implementation shall support specifying aspect Convention with a C
convention_identifier for a C-eligible type (see *note B.1::).  An
implementation shall support specifying aspect Convention with a
C_Pass_By_Copy convention_identifier for a C_Pass_By_Copy-eligible type.

                     _Implementation Permissions_

62
An implementation may provide additional declarations in the C interface
packages.

62.1/3
An implementation need not support specifying the Convention aspect with
convention_identifier C in the following cases:

62.2/3
   * for a subprogram that has a parameter of an unconstrained array
     subtype, unless the Import aspect has the value True for the
     subprogram;

62.3/3
   * for a function with an unconstrained array result subtype;

62.4/3
   * for an object whose nominal subtype is an unconstrained array
     subtype.

                        _Implementation Advice_

62.5/3
The constants nul, wide_nul, char16_nul, and char32_nul should have a
representation of zero.

63
An implementation should support the following interface correspondences
between Ada and C.

64
   * An Ada procedure corresponds to a void-returning C function.

65
   * An Ada function corresponds to a non-void C function.

65.1/4
   * An Ada enumeration type corresponds to a C enumeration type with
     corresponding enumeration literals having the same internal codes,
     provided the internal codes fall within the range of the C int
     type.

66
   * An Ada in scalar parameter is passed as a scalar argument to a C
     function.

67
   * An Ada in parameter of an access-to-object type with designated
     type T is passed as a t* argument to a C function, where t is the C
     type corresponding to the Ada type T.

68
   * An Ada access T parameter, or an Ada out or in out parameter of an
     elementary type T, is passed as a t* argument to a C function,
     where t is the C type corresponding to the Ada type T. In the case
     of an elementary out or in out parameter, a pointer to a temporary
     copy is used to preserve by-copy semantics.

68.1/2
   * An Ada parameter of a (record) type T of convention C_Pass_By_Copy,
     of mode in, is passed as a t argument to a C function, where t is
     the C struct corresponding to the Ada type T.

69/2
   * An Ada parameter of a record type T, of any mode, other than an in
     parameter of a type of convention C_Pass_By_Copy, is passed as a t*
     argument to a C function, where t is the C struct corresponding to
     the Ada type T.

70
   * An Ada parameter of an array type with component type T, of any
     mode, is passed as a t* argument to a C function, where t is the C
     type corresponding to the Ada type T.

71
   * An Ada parameter of an access-to-subprogram type is passed as a
     pointer to a C function whose prototype corresponds to the
     designated subprogram's specification.

71.1/3
   * An Ada parameter of a private type is passed as specified for the
     full view of the type.

71.2/3
   * The rules of correspondence given above for parameters of mode in
     also apply to the return object of a function.

71.3/3
This paragraph was deleted.

     NOTES

72
     6  Values of type char_array are not implicitly terminated with
     nul.  If a char_array is to be passed as a parameter to an imported
     C function requiring nul termination, it is the programmer's
     responsibility to obtain this effect.

73
     7  To obtain the effect of C's sizeof(item_type), where Item_Type
     is the corresponding Ada type, evaluate the expression:
     size_t(Item_Type'Size/CHAR_BIT).

74/2
     This paragraph was deleted.

75/4
     8  A variadic C function can correspond to several Ada subprograms,
     taking various specific numbers and types of parameters.

                              _Examples_

76
Example of using the Interfaces.C package:

77
     --Calling the C Library Function strcpy
     with Interfaces.C;
     procedure Test is
        package C renames Interfaces.C;
        use type C.char_array;
        -- Call <string.h>strcpy:
        -- C definition of strcpy:  char *strcpy(char *s1, const char *s2);
        --    This function copies the string pointed to by s2 (including the terminating null character)
        --     into the array pointed to by s1. If copying takes place between objects that overlap, 
        --     the behavior is undefined. The strcpy function returns the value of s1.

78/3
        -- Note: since the C function's return value is of no interest, the Ada interface is a procedure
        procedure Strcpy (Target : out C.char_array;
                          Source : in  C.char_array)
           with Import => True, Convention => C, External_Name => "strcpy";

79/3
     This paragraph was deleted.

80
        Chars1 :  C.char_array(1..20);
        Chars2 :  C.char_array(1..20);

81
     begin
        Chars2(1..6) := "qwert" & C.nul;

82
        Strcpy(Chars1, Chars2);

83
     -- Now Chars1(1..6) = "qwert" & C.Nul

84
     end Test;

* Menu:

* B.3.1 ::    The Package Interfaces.C.Strings
* B.3.2 ::    The Generic Package Interfaces.C.Pointers
* B.3.3 ::    Unchecked Union Types


File: arm2012.info,  Node: B.3.1,  Next: B.3.2,  Up: B.3

B.3.1 The Package Interfaces.C.Strings
--------------------------------------

1/3
The package Interfaces.C.Strings declares types and subprograms allowing
an Ada program to allocate, reference, update, and free C-style strings.
In particular, the private type chars_ptr corresponds to a common use of
"char *" in C programs, and an object of this type can be passed to a
subprogram to which with Import => True, Convention => C has been
specified, and for which "char *" is the type of the argument of the C
function.

                          _Static Semantics_

2
The library package Interfaces.C.Strings has the following declaration:

3
     package Interfaces.C.Strings is
        pragma Preelaborate(Strings);

4
        type char_array_access is access all char_array;

5/2
        type chars_ptr is private;
        pragma Preelaborable_Initialization(chars_ptr);

6/2
        type chars_ptr_array is array (size_t range <>) of aliased chars_ptr;

7
        Null_Ptr : constant chars_ptr;

8
        function To_Chars_Ptr (Item      : in char_array_access;
                               Nul_Check : in Boolean := False)
           return chars_ptr;

9
        function New_Char_Array (Chars   : in char_array) return chars_ptr;

10
        function New_String (Str : in String) return chars_ptr;

11
        procedure Free (Item : in out chars_ptr);

12
        Dereference_Error : exception;

13
        function Value (Item : in chars_ptr) return char_array;

14
        function Value (Item : in chars_ptr; Length : in size_t)
           return char_array;

15
        function Value (Item : in chars_ptr) return String;

16
        function Value (Item : in chars_ptr; Length : in size_t)
           return String;

17
        function Strlen (Item : in chars_ptr) return size_t;

18
        procedure Update (Item   : in chars_ptr;
                          Offset : in size_t;
                          Chars  : in char_array;
                          Check  : in Boolean := True);

19
        procedure Update (Item   : in chars_ptr;
                          Offset : in size_t;
                          Str    : in String;
                          Check  : in Boolean := True);

20
        Update_Error : exception;

21
     private
        ... -- not specified by the language
     end Interfaces.C.Strings;

22
The type chars_ptr is C-compatible and corresponds to the use of C's
"char *" for a pointer to the first char in a char array terminated by
nul.  When an object of type chars_ptr is declared, its value is by
default set to Null_Ptr, unless the object is imported (see *note
B.1::).

23
     function To_Chars_Ptr (Item      : in char_array_access;
                            Nul_Check : in Boolean := False)
        return chars_ptr;

24/3
          If Item is null, then To_Chars_Ptr returns Null_Ptr.  If Item
          is not null, Nul_Check is True, and Item.all does not contain
          nul, then the function propagates Terminator_Error; otherwise,
          To_Chars_Ptr performs a pointer conversion with no allocation
          of memory.

25
     function New_Char_Array (Chars   : in char_array) return chars_ptr;

26
          This function returns a pointer to an allocated object
          initialized to Chars(Chars'First ..  Index) & nul, where

27
             * Index = Chars'Last if Chars does not contain nul, or

28
             * Index is the smallest size_t value I such that Chars(I+1)
               = nul.

28.1
          Storage_Error is propagated if the allocation fails.

29
     function New_String (Str : in String) return chars_ptr;

30
          This function is equivalent to New_Char_Array(To_C(Str)).

31
     procedure Free (Item : in out chars_ptr);

32
          If Item is Null_Ptr, then Free has no effect.  Otherwise, Free
          releases the storage occupied by Value(Item), and resets Item
          to Null_Ptr.

33
     function Value (Item : in chars_ptr) return char_array;

34/3
          If Item = Null_Ptr, then Value propagates Dereference_Error.
          Otherwise, Value returns the prefix of the array of chars
          pointed to by Item, up to and including the first nul.  The
          lower bound of the result is 0.  If Item does not point to a
          nul-terminated string, then execution of Value is erroneous.

35
     function Value (Item : in chars_ptr; Length : in size_t)
        return char_array;

36/3
          If Item = Null_Ptr, then Value propagates Dereference_Error.
          Otherwise, Value returns the shorter of two arrays, either the
          first Length chars pointed to by Item, or Value(Item).  The
          lower bound of the result is 0.  If Length is 0, then Value
          propagates Constraint_Error.

37
     function Value (Item : in chars_ptr) return String;

38
          Equivalent to To_Ada(Value(Item), Trim_Nul=>True).

39
     function Value (Item : in chars_ptr; Length : in size_t)
        return String;

40/1
          Equivalent to To_Ada(Value(Item, Length) & nul,
          Trim_Nul=>True).

41
     function Strlen (Item : in chars_ptr) return size_t;

42
          Returns Val'Length-1 where Val = Value(Item); propagates
          Dereference_Error if Item = Null_Ptr.

43
     procedure Update (Item   : in chars_ptr;
                       Offset : in size_t;
                       Chars  : in char_array;
                       Check  : Boolean := True);

44/1
          If Item = Null_Ptr, then Update propagates Dereference_Error.
          Otherwise, this procedure updates the value pointed to by
          Item, starting at position Offset, using Chars as the data to
          be copied into the array.  Overwriting the nul terminator, and
          skipping with the Offset past the nul terminator, are both
          prevented if Check is True, as follows:

45
             * Let N = Strlen(Item).  If Check is True, then:

46
                       * If Offset+Chars'Length>N, propagate
                         Update_Error.

47
                       * Otherwise, overwrite the data in the array
                         pointed to by Item, starting at the char at
                         position Offset, with the data in Chars.

48
             * If Check is False, then processing is as above, but with
               no check that Offset+Chars'Length>N.

49
     procedure Update (Item   : in chars_ptr;
                       Offset : in size_t;
                       Str    : in String;
                       Check  : in Boolean := True);

50/2
          Equivalent to Update(Item, Offset, To_C(Str, Append_Nul =>
          False), Check).

                         _Erroneous Execution_

51
Execution of any of the following is erroneous if the Item parameter is
not null_ptr and Item does not point to a nul-terminated array of chars.

52
   * a Value function not taking a Length parameter,

53
   * the Free procedure,

54
   * the Strlen function.

55
Execution of Free(X) is also erroneous if the chars_ptr X was not
returned by New_Char_Array or New_String.

56
Reading or updating a freed char_array is erroneous.

57
Execution of Update is erroneous if Check is False and a call with Check
equal to True would have propagated Update_Error.

     NOTES

58
     9  New_Char_Array and New_String might be implemented either
     through the allocation function from the C environment ("malloc")
     or through Ada dynamic memory allocation ("new").  The key points
     are

59
        * the returned value (a chars_ptr) is represented as a C "char
          *" so that it may be passed to C functions;

60
        * the allocated object should be freed by the programmer via a
          call of Free, not by a called C function.


File: arm2012.info,  Node: B.3.2,  Next: B.3.3,  Prev: B.3.1,  Up: B.3

B.3.2 The Generic Package Interfaces.C.Pointers
-----------------------------------------------

1
The generic package Interfaces.C.Pointers allows the Ada programmer to
perform C-style operations on pointers.  It includes an access type
Pointer, Value functions that dereference a Pointer and deliver the
designated array, several pointer arithmetic operations, and "copy"
procedures that copy the contents of a source pointer into the array
designated by a destination pointer.  As in C, it treats an object Ptr
of type Pointer as a pointer to the first element of an array, so that
for example, adding 1 to Ptr yields a pointer to the second element of
the array.

2
The generic allows two styles of usage: one in which the array is
terminated by a special terminator element; and another in which the
programmer needs to keep track of the length.

                          _Static Semantics_

3
The generic library package Interfaces.C.Pointers has the following
declaration:

4
     generic
        type Index is (<>);
        type Element is private;
        type Element_Array is array (Index range <>) of aliased Element;
        Default_Terminator : Element;
     package Interfaces.C.Pointers is
        pragma Preelaborate(Pointers);

5
        type Pointer is access all Element;

6
        function Value(Ref        : in Pointer;
                       Terminator : in Element := Default_Terminator)
           return Element_Array;

7
        function Value(Ref    : in Pointer;
                       Length : in ptrdiff_t)
           return Element_Array;

8
        Pointer_Error : exception;

9
        -- C-style Pointer arithmetic

10/3
        function "+" (Left : in Pointer;   Right : in ptrdiff_t) return Pointer
           with Convention => Intrinsic;
        function "+" (Left : in ptrdiff_t; Right : in Pointer)   return Pointer
           with Convention => Intrinsic;
        function "-" (Left : in Pointer;   Right : in ptrdiff_t) return Pointer
           with Convention => Intrinsic;
        function "-" (Left : in Pointer;   Right : in Pointer) return ptrdiff_t
           with Convention => Intrinsic;

11/3
        procedure Increment (Ref : in out Pointer)
           with Convention => Intrinsic;
        procedure Decrement (Ref : in out Pointer)
           with Convention => Intrinsic;

12/3
     This paragraph was deleted.

13
        function Virtual_Length (Ref        : in Pointer;
                                 Terminator : in Element := Default_Terminator)
           return ptrdiff_t;

14
        procedure Copy_Terminated_Array
           (Source     : in Pointer;
            Target     : in Pointer;
            Limit      : in ptrdiff_t := ptrdiff_t'Last;
            Terminator : in Element :=  Default_Terminator);

15
        procedure Copy_Array (Source  : in Pointer;
                              Target  : in Pointer;
                              Length  : in ptrdiff_t);

16
     end Interfaces.C.Pointers;

17
The type Pointer is C-compatible and corresponds to one use of C's
"Element *".  An object of type Pointer is interpreted as a pointer to
the initial Element in an Element_Array.  Two styles are supported:

18
   * Explicit termination of an array value with Default_Terminator (a
     special terminator value);

19
   * Programmer-managed length, with Default_Terminator treated simply
     as a data element.

20
     function Value(Ref        : in Pointer;
                    Terminator : in Element := Default_Terminator)
        return Element_Array;

21
          This function returns an Element_Array whose value is the
          array pointed to by Ref, up to and including the first
          Terminator; the lower bound of the array is Index'First.
          Interfaces.C.Strings.Dereference_Error is propagated if Ref is
          null.

22
     function Value(Ref    : in Pointer;
                    Length : in ptrdiff_t)
        return Element_Array;

23
          This function returns an Element_Array comprising the first
          Length elements pointed to by Ref.  The exception
          Interfaces.C.Strings.Dereference_Error is propagated if Ref is
          null.

24
The "+" and "-" functions perform arithmetic on Pointer values, based on
the Size of the array elements.  In each of these functions,
Pointer_Error is propagated if a Pointer parameter is null.

25
     procedure Increment (Ref : in out Pointer);

26
          Equivalent to Ref := Ref+1.

27
     procedure Decrement (Ref : in out Pointer);

28
          Equivalent to Ref := Ref-1.

29
     function Virtual_Length (Ref        : in Pointer;
                              Terminator : in Element := Default_Terminator)
        return ptrdiff_t;

30
          Returns the number of Elements, up to the one just before the
          first Terminator, in Value(Ref, Terminator).

31
     procedure Copy_Terminated_Array
        (Source     : in Pointer;
         Target     : in Pointer;
         Limit      : in ptrdiff_t := ptrdiff_t'Last;
         Terminator : in Element := Default_Terminator);

32
          This procedure copies Value(Source, Terminator) into the array
          pointed to by Target; it stops either after Terminator has
          been copied, or the number of elements copied is Limit,
          whichever occurs first.  Dereference_Error is propagated if
          either Source or Target is null.

33
     procedure Copy_Array (Source  : in Pointer;
                           Target  : in Pointer;
                           Length  : in ptrdiff_t);

34
          This procedure copies the first Length elements from the array
          pointed to by Source, into the array pointed to by Target.
          Dereference_Error is propagated if either Source or Target is
          null.

                         _Erroneous Execution_

35
It is erroneous to dereference a Pointer that does not designate an
aliased Element.

36
Execution of Value(Ref, Terminator) is erroneous if Ref does not
designate an aliased Element in an Element_Array terminated by
Terminator.

37
Execution of Value(Ref, Length) is erroneous if Ref does not designate
an aliased Element in an Element_Array containing at least Length
Elements between the designated Element and the end of the array,
inclusive.

38
Execution of Virtual_Length(Ref, Terminator) is erroneous if Ref does
not designate an aliased Element in an Element_Array terminated by
Terminator.

39
Execution of Copy_Terminated_Array(Source, Target, Limit, Terminator) is
erroneous in either of the following situations:

40
   * Execution of both Value(Source, Terminator) and Value(Source,
     Limit) are erroneous, or

41
   * Copying writes past the end of the array containing the Element
     designated by Target.

42
Execution of Copy_Array(Source, Target, Length) is erroneous if either
Value(Source, Length) is erroneous, or copying writes past the end of
the array containing the Element designated by Target.

     NOTES

43
     10  To compose a Pointer from an Element_Array, use 'Access on the
     first element.  For example (assuming appropriate instantiations):

44
          Some_Array   : Element_Array(0..5) ;
          Some_Pointer : Pointer := Some_Array(0)'Access;

                              _Examples_

45
Example of Interfaces.C.Pointers:

46
     with Interfaces.C.Pointers;
     with Interfaces.C.Strings;
     procedure Test_Pointers is
        package C renames Interfaces.C;
        package Char_Ptrs is
           new C.Pointers (Index              => C.size_t,
                           Element            => C.char,
                           Element_Array      => C.char_array,
                           Default_Terminator => C.nul);

47
        use type Char_Ptrs.Pointer;
        subtype Char_Star is Char_Ptrs.Pointer;

48
        procedure Strcpy (Target_Ptr, Source_Ptr : Char_Star) is
           Target_Temp_Ptr : Char_Star := Target_Ptr;
           Source_Temp_Ptr : Char_Star := Source_Ptr;
           Element : C.char;
        begin
           if Target_Temp_Ptr = null or Source_Temp_Ptr = null then
              raise C.Strings.Dereference_Error;
           end if;

49/1
           loop
              Element             := Source_Temp_Ptr.all;
              Target_Temp_Ptr.all := Element;
              exit when C."="(Element, C.nul);
              Char_Ptrs.Increment(Target_Temp_Ptr);
              Char_Ptrs.Increment(Source_Temp_Ptr);
           end loop;
        end Strcpy;
     begin
        ...
     end Test_Pointers;


File: arm2012.info,  Node: B.3.3,  Prev: B.3.2,  Up: B.3

B.3.3 Unchecked Union Types
---------------------------

1/3
Specifying aspect Unchecked_Union to have the value True defines an
interface correspondence between a given discriminated type and some C
union.  The aspect requires that the associated type shall be given a
representation that allocates no space for its discriminant(s).

Paragraphs 2 through 3 were moved to *note Annex J::, "*note Annex J::
Obsolescent Features".

                          _Static Semantics_

3.1/3
For a discriminated record type having a variant_part, the following
language-defined representation aspect may be specified:

3.2/3
Unchecked_Union
               The type of aspect Unchecked_Union is Boolean.  If
               directly specified, the aspect_definition shall be a
               static expression.  If not specified (including by
               inheritance), the aspect is False.

                           _Legality Rules_

Paragraphs 4 and 5 were deleted.

6/3
A type for which aspect Unchecked_Union is True is called an unchecked
union type.  A subtype of an unchecked union type is defined to be an
unchecked union subtype.  An object of an unchecked union type is
defined to be an unchecked union object.

7/2
All component subtypes of an unchecked union type shall be C-compatible.

8/2
If a component subtype of an unchecked union type is subject to a
per-object constraint, then the component subtype shall be an unchecked
union subtype.

9/3
Any name that denotes a discriminant of an object of an unchecked union
type shall occur within the declarative region of the type, and shall
not occur within a record_representation_clause.

10/3
The type of a component declared in a variant_part of an unchecked union
type shall not need finalization.  In addition to the places where
Legality Rules normally apply (see *note 12.3::), this rule also applies
in the private part of an instance of a generic unit.  For an unchecked
union type declared within the body of a generic unit, or within the
body of any of its descendant library units, no part of the type of a
component declared in a variant_part of the unchecked union type shall
be of a formal private type or formal private extension declared within
the formal part of the generic unit.

11/2
The completion of an incomplete or private type declaration having a
known_discriminant_part shall not be an unchecked union type.

12/2
An unchecked union subtype shall only be passed as a generic actual
parameter if the corresponding formal type has no known discriminants or
is an unchecked union type.

                          _Static Semantics_

13/2
An unchecked union type is eligible for convention C.

14/2
All objects of an unchecked union type have the same size.

15/2
Discriminants of objects of an unchecked union type are of size zero.

16/2
Any check which would require reading a discriminant of an unchecked
union object is suppressed (see *note 11.5::).  These checks include:

17/2
   * The check performed when addressing a variant component (i.e., a
     component that was declared in a variant part) of an unchecked
     union object that the object has this component (see *note
     4.1.3::).

18/2
   * Any checks associated with a type or subtype conversion of a value
     of an unchecked union type (see *note 4.6::).  This includes, for
     example, the check associated with the implicit subtype conversion
     of an assignment statement.

19/2
   * The subtype membership check associated with the evaluation of a
     qualified expression (see *note 4.7::) or an uninitialized
     allocator (see *note 4.8::).

                          _Dynamic Semantics_

20/2
A view of an unchecked union object (including a type conversion or
function call) has inferable discriminants if it has a constrained
nominal subtype, unless the object is a component of an enclosing
unchecked union object that is subject to a per-object constraint and
the enclosing object lacks inferable discriminants.

21/2
An expression of an unchecked union type has inferable discriminants if
it is either a name of an object with inferable discriminants or a
qualified expression whose subtype_mark denotes a constrained subtype.

22/2
Program_Error is raised in the following cases:

23/2
   * Evaluation of the predefined equality operator for an unchecked
     union type if either of the operands lacks inferable discriminants.

24/2
   * Evaluation of the predefined equality operator for a type which has
     a subcomponent of an unchecked union type whose nominal subtype is
     unconstrained.

25/2
   * Evaluation of a membership test if the subtype_mark denotes a
     constrained unchecked union subtype and the expression lacks
     inferable discriminants.

26/2
   * Conversion from a derived unchecked union type to an unconstrained
     non-unchecked-union type if the operand of the conversion lacks
     inferable discriminants.

27/2
   * Execution of the default implementation of the Write or Read
     attribute of an unchecked union type.

28/2
   * Execution of the default implementation of the Output or Input
     attribute of an unchecked union type if the type lacks default
     discriminant values.

Paragraph 29 was deleted.

     NOTES

30/2
     11  The use of an unchecked union to obtain the effect of an
     unchecked conversion results in erroneous execution (see *note
     11.5::).  Execution of the following example is erroneous even if
     Float'Size = Integer'Size:

31/3
          type T (Flag : Boolean := False) is
             record
                 case Flag is
                     when False =>
                         F1 : Float := 0.0;
                     when True =>
                         F2 : Integer := 0;
                 end case;
              end record
              with Unchecked_Union;

32/2
          X : T;
          Y : Integer := X.F2; -- erroneous


File: arm2012.info,  Node: B.4,  Next: B.5,  Prev: B.3,  Up: Annex B

B.4 Interfacing with COBOL
==========================

1/3
The facilities relevant to interfacing with the COBOL language are the
package Interfaces.COBOL and support for specifying the Convention
aspect with convention_identifier COBOL.

2
The COBOL interface package supplies several sets of facilities:

3
   * A set of types corresponding to the native COBOL types of the
     supported COBOL implementation (so-called "internal COBOL
     representations"), allowing Ada data to be passed as parameters to
     COBOL programs

4
   * A set of types and constants reflecting external data
     representations such as might be found in files or databases,
     allowing COBOL-generated data to be read by an Ada program, and
     Ada-generated data to be read by COBOL programs

5
   * A generic package for converting between an Ada decimal type value
     and either an internal or external COBOL representation

                          _Static Semantics_

6
The library package Interfaces.COBOL has the following declaration:

7
     package Interfaces.COBOL is
        pragma Preelaborate(COBOL);

8
     -- Types and operations for internal data representations

9
        type Floating      is digits implementation-defined;
        type Long_Floating is digits implementation-defined;

10
        type Binary      is range implementation-defined;
        type Long_Binary is range implementation-defined;

11
        Max_Digits_Binary      : constant := implementation-defined;
        Max_Digits_Long_Binary : constant := implementation-defined;

12/3
        type Decimal_Element  is mod implementation-defined;
        type Packed_Decimal is array (Positive range <>) of Decimal_Element
           with Pack;

13
        type COBOL_Character is implementation-defined character type;

14
        Ada_To_COBOL : array (Character) of COBOL_Character := implementation-defined;

15
        COBOL_To_Ada : array (COBOL_Character) of Character := implementation-defined;

16/3
        type Alphanumeric is array (Positive range <>) of COBOL_Character
           with Pack;

17
        function To_COBOL (Item : in String) return Alphanumeric;
        function To_Ada   (Item : in Alphanumeric) return String;

18
        procedure To_COBOL (Item       : in String;
                            Target     : out Alphanumeric;
                            Last       : out Natural);

19
        procedure To_Ada (Item     : in Alphanumeric;
                          Target   : out String;
                          Last     : out Natural);

20/3
        type Numeric is array (Positive range <>) of COBOL_Character
           with Pack;

21
     -- Formats for COBOL data representations

22
        type Display_Format is private;

23
        Unsigned             : constant Display_Format;
        Leading_Separate     : constant Display_Format;
        Trailing_Separate    : constant Display_Format;
        Leading_Nonseparate  : constant Display_Format;
        Trailing_Nonseparate : constant Display_Format;

24
        type Binary_Format is private;

25
        High_Order_First  : constant Binary_Format;
        Low_Order_First   : constant Binary_Format;
        Native_Binary     : constant Binary_Format;

26
        type Packed_Format is private;

27
        Packed_Unsigned   : constant Packed_Format;
        Packed_Signed     : constant Packed_Format;

28
     -- Types for external representation of COBOL binary data

29/3
        type Byte is mod 2**COBOL_Character'Size;
        type Byte_Array is array (Positive range <>) of Byte
           with Pack;

30
        Conversion_Error : exception;

31
        generic
           type Num is delta <> digits <>;
        package Decimal_Conversions is

32
           -- Display Formats: data values are represented as Numeric

33
           function Valid (Item   : in Numeric;
                           Format : in Display_Format) return Boolean;

34
           function Length (Format : in Display_Format) return Natural;

35
           function To_Decimal (Item   : in Numeric;
                                Format : in Display_Format) return Num;

36
           function To_Display (Item   : in Num;
                                Format : in Display_Format) return Numeric;

37
           -- Packed Formats: data values are represented as Packed_Decimal

38
           function Valid (Item   : in Packed_Decimal;
                           Format : in Packed_Format) return Boolean;

39
           function Length (Format : in Packed_Format) return Natural;

40
           function To_Decimal (Item   : in Packed_Decimal;
                                Format : in Packed_Format) return Num;

41
           function To_Packed (Item   : in Num;
                               Format : in Packed_Format) return Packed_Decimal;

42
           -- Binary Formats: external data values are represented as Byte_Array

43
           function Valid (Item   : in Byte_Array;
                           Format : in Binary_Format) return Boolean;

44
           function Length (Format : in Binary_Format) return Natural;
           function To_Decimal (Item   : in Byte_Array;
                                Format : in Binary_Format) return Num;

45
           function To_Binary (Item   : in Num;
                             Format : in Binary_Format) return Byte_Array;

46
           -- Internal Binary formats: data values are of type Binary or Long_Binary

47
           function To_Decimal (Item : in Binary)      return Num;
           function To_Decimal (Item : in Long_Binary) return Num;

48
           function To_Binary      (Item : in Num)  return Binary;
           function To_Long_Binary (Item : in Num)  return Long_Binary;

49
        end Decimal_Conversions;

50
     private
        ... -- not specified by the language
     end Interfaces.COBOL;

51
Each of the types in Interfaces.COBOL is COBOL-compatible.

52
The types Floating and Long_Floating correspond to the native types in
COBOL for data items with computational usage implemented by floating
point.  The types Binary and Long_Binary correspond to the native types
in COBOL for data items with binary usage, or with computational usage
implemented by binary.

53
Max_Digits_Binary is the largest number of decimal digits in a numeric
value that is represented as Binary.  Max_Digits_Long_Binary is the
largest number of decimal digits in a numeric value that is represented
as Long_Binary.

54
The type Packed_Decimal corresponds to COBOL's packed-decimal usage.

55
The type COBOL_Character defines the run-time character set used in the
COBOL implementation.  Ada_To_COBOL and COBOL_To_Ada are the mappings
between the Ada and COBOL run-time character sets.

56
Type Alphanumeric corresponds to COBOL's alphanumeric data category.

57
Each of the functions To_COBOL and To_Ada converts its parameter based
on the mappings Ada_To_COBOL and COBOL_To_Ada, respectively.  The length
of the result for each is the length of the parameter, and the lower
bound of the result is 1.  Each component of the result is obtained by
applying the relevant mapping to the corresponding component of the
parameter.

58
Each of the procedures To_COBOL and To_Ada copies converted elements
from Item to Target, using the appropriate mapping (Ada_To_COBOL or
COBOL_To_Ada, respectively).  The index in Target of the last element
assigned is returned in Last (0 if Item is a null array). If Item'Length
exceeds Target'Length, Constraint_Error is propagated.

59
Type Numeric corresponds to COBOL's numeric data category with display
usage.

60
The types Display_Format, Binary_Format, and Packed_Format are used in
conversions between Ada decimal type values and COBOL internal or
external data representations.  The value of the constant Native_Binary
is either High_Order_First or Low_Order_First, depending on the
implementation.

61
     function Valid (Item   : in Numeric;
                     Format : in Display_Format) return Boolean;

62
          The function Valid checks that the Item parameter has a value
          consistent with the value of Format.  If the value of Format
          is other than Unsigned, Leading_Separate, and
          Trailing_Separate, the effect is implementation defined.  If
          Format does have one of these values, the following rules
          apply:

63/3
             * Format=Unsigned: if Item comprises one or more decimal
               digit characters, then Valid returns True, else it
               returns False.

64/1
             * Format=Leading_Separate: if Item comprises a single
               occurrence of the plus or minus sign character, and then
               one or more decimal digit characters, then Valid returns
               True, else it returns False.

65/1
             * Format=Trailing_Separate: if Item comprises one or more
               decimal digit characters and finally a plus or minus sign
               character, then Valid returns True, else it returns
               False.

66
     function Length (Format : in Display_Format) return Natural;

67
          The Length function returns the minimal length of a Numeric
          value sufficient to hold any value of type Num when
          represented as Format.

68
     function To_Decimal (Item   : in Numeric;
                          Format : in Display_Format) return Num;

69
          Produces a value of type Num corresponding to Item as
          represented by Format.  The number of digits after the assumed
          radix point in Item is Num'Scale.  Conversion_Error is
          propagated if the value represented by Item is outside the
          range of Num.

70
     function To_Display (Item   : in Num;
                          Format : in Display_Format) return Numeric;

71/1
          This function returns the Numeric value for Item, represented
          in accordance with Format.  The length of the returned value
          is Length(Format), and the lower bound is 1.  Conversion_Error
          is propagated if Num is negative and Format is Unsigned.

72
     function Valid (Item   : in Packed_Decimal;
                     Format : in Packed_Format) return Boolean;

73
          This function returns True if Item has a value consistent with
          Format, and False otherwise.  The rules for the formation of
          Packed_Decimal values are implementation defined.

74
     function Length (Format : in Packed_Format) return Natural;

75
          This function returns the minimal length of a Packed_Decimal
          value sufficient to hold any value of type Num when
          represented as Format.

76
     function To_Decimal (Item   : in Packed_Decimal;
                          Format : in Packed_Format) return Num;

77
          Produces a value of type Num corresponding to Item as
          represented by Format.  Num'Scale is the number of digits
          after the assumed radix point in Item.  Conversion_Error is
          propagated if the value represented by Item is outside the
          range of Num.

78
     function To_Packed (Item   : in Num;
                         Format : in Packed_Format) return Packed_Decimal;

79/1
          This function returns the Packed_Decimal value for Item,
          represented in accordance with Format.  The length of the
          returned value is Length(Format), and the lower bound is 1.
          Conversion_Error is propagated if Num is negative and Format
          is Packed_Unsigned.

80
     function Valid (Item   : in Byte_Array;
                     Format : in Binary_Format) return Boolean;

81
          This function returns True if Item has a value consistent with
          Format, and False otherwise.

82
     function Length (Format : in Binary_Format) return Natural;

83
          This function returns the minimal length of a Byte_Array value
          sufficient to hold any value of type Num when represented as
          Format.

84
     function To_Decimal (Item   : in Byte_Array;
                          Format : in Binary_Format) return Num;

85
          Produces a value of type Num corresponding to Item as
          represented by Format.  Num'Scale is the number of digits
          after the assumed radix point in Item.  Conversion_Error is
          propagated if the value represented by Item is outside the
          range of Num.

86
     function To_Binary (Item   : in Num;
                         Format : in Binary_Format) return Byte_Array;

87/1
          This function returns the Byte_Array value for Item,
          represented in accordance with Format.  The length of the
          returned value is Length(Format), and the lower bound is 1.

88
     function To_Decimal (Item : in Binary)      return Num;

     function To_Decimal (Item : in Long_Binary) return Num;

89
          These functions convert from COBOL binary format to a
          corresponding value of the decimal type Num.  Conversion_Error
          is propagated if Item is too large for Num.

90
     function To_Binary      (Item : in Num)  return Binary;

     function To_Long_Binary (Item : in Num)  return Long_Binary;

91
          These functions convert from Ada decimal to COBOL binary
          format.  Conversion_Error is propagated if the value of Item
          is too large to be represented in the result type.

                     _Implementation Requirements_

92/3
An implementation shall support specifying aspect Convention with a
COBOL convention_identifier for a COBOL-eligible type (see *note B.1::).

                     _Implementation Permissions_

93
An implementation may provide additional constants of the private types
Display_Format, Binary_Format, or Packed_Format.

94
An implementation may provide further floating point and integer types
in Interfaces.COBOL to match additional native COBOL types, and may also
supply corresponding conversion functions in the generic package
Decimal_Conversions.

                        _Implementation Advice_

95
An Ada implementation should support the following interface
correspondences between Ada and COBOL.

96
   * An Ada access T parameter is passed as a "BY REFERENCE" data item
     of the COBOL type corresponding to T.

97
   * An Ada in scalar parameter is passed as a "BY CONTENT" data item of
     the corresponding COBOL type.

98
   * Any other Ada parameter is passed as a "BY REFERENCE" data item of
     the COBOL type corresponding to the Ada parameter type; for
     scalars, a local copy is used if necessary to ensure by-copy
     semantics.

     NOTES

99/3
     12  An implementation is not required to support specifying aspect
     Convention for access types, nor is it required to support
     specifying aspects Import, Export, or Convention for functions.

100
     13  If an Ada subprogram is exported to COBOL, then a call from
     COBOL call may specify either "BY CONTENT" or "BY REFERENCE".

                              _Examples_

101
Examples of Interfaces.COBOL:

102
     with Interfaces.COBOL;
     procedure Test_Call is

103
        -- Calling a foreign COBOL program
        -- Assume that a COBOL program PROG has the following declaration
        --  in its LINKAGE section:
        --  01 Parameter-Area
        --     05 NAME   PIC X(20).
        --     05 SSN    PIC X(9).
        --     05 SALARY PIC 99999V99 USAGE COMP.
        -- The effect of PROG is to update SALARY based on some algorithm

104
        package COBOL renames Interfaces.COBOL;

105
        type Salary_Type is delta 0.01 digits 7;

106/3
        type COBOL_Record is
           record
              Name   : COBOL.Numeric(1..20);
              SSN    : COBOL.Numeric(1..9);
              Salary : COBOL.Binary;  -- Assume Binary = 32 bits
           end record
           with Convention => COBOL;

107/3
        procedure Prog (Item : in out COBOL_Record)
           with Import => True, Convention => COBOL;

108
        package Salary_Conversions is
           new COBOL.Decimal_Conversions(Salary_Type);

109
        Some_Salary : Salary_Type := 12_345.67;
        Some_Record : COBOL_Record :=
           (Name   => "Johnson, John       ",
            SSN    => "111223333",
            Salary => Salary_Conversions.To_Binary(Some_Salary));

110
     begin
        Prog (Some_Record);
        ...
     end Test_Call;

111
     with Interfaces.COBOL;
     with COBOL_Sequential_IO; -- Assumed to be supplied by implementation
     procedure Test_External_Formats is

112
        -- Using data created by a COBOL program
        -- Assume that a COBOL program has created a sequential file with
        --  the following record structure, and that we need to
        --  process the records in an Ada program
        --  01 EMPLOYEE-RECORD
        --     05 NAME    PIC X(20).
        --     05 SSN     PIC X(9).
        --     05 SALARY  PIC 99999V99 USAGE COMP.
        --     05 ADJUST  PIC S999V999 SIGN LEADING SEPARATE.
        -- The COMP data is binary (32 bits), high-order byte first

113
        package COBOL renames Interfaces.COBOL;

114
        type Salary_Type      is delta 0.01  digits 7;
        type Adjustments_Type is delta 0.001 digits 6;

115/3
        type COBOL_Employee_Record_Type is  -- External representation
           record
              Name    : COBOL.Alphanumeric(1..20);
              SSN     : COBOL.Alphanumeric(1..9);
              Salary  : COBOL.Byte_Array(1..4);
              Adjust  : COBOL.Numeric(1..7);  -- Sign and 6 digits
           end record
           with Convention => COBOL;

116
        package COBOL_Employee_IO is
           new COBOL_Sequential_IO(COBOL_Employee_Record_Type);
        use COBOL_Employee_IO;

117
        COBOL_File : File_Type;

118
        type Ada_Employee_Record_Type is  -- Internal representation
           record
              Name    : String(1..20);
              SSN     : String(1..9);
              Salary  : Salary_Type;
              Adjust  : Adjustments_Type;
           end record;

119
        COBOL_Record : COBOL_Employee_Record_Type;
        Ada_Record   : Ada_Employee_Record_Type;

120
        package Salary_Conversions is
           new COBOL.Decimal_Conversions(Salary_Type);
        use Salary_Conversions;

121
        package Adjustments_Conversions is
           new COBOL.Decimal_Conversions(Adjustments_Type);
        use Adjustments_Conversions;

122
     begin
        Open (COBOL_File, Name => "Some_File");

123
        loop
          Read (COBOL_File, COBOL_Record);

124
          Ada_Record.Name := To_Ada(COBOL_Record.Name);
          Ada_Record.SSN  := To_Ada(COBOL_Record.SSN);
          Ada_Record.Salary :=
             To_Decimal(COBOL_Record.Salary, COBOL.High_Order_First);
          Ada_Record.Adjust :=
             To_Decimal(COBOL_Record.Adjust, COBOL.Leading_Separate);
          ... -- Process Ada_Record
        end loop;
     exception
        when End_Error => ...
     end Test_External_Formats;


File: arm2012.info,  Node: B.5,  Prev: B.4,  Up: Annex B

B.5 Interfacing with Fortran
============================

1/3
The facilities relevant to interfacing with the Fortran language are the
package Interfaces.Fortran and support for specifying the Convention
aspect with convention_identifier Fortran.

2
The package Interfaces.Fortran defines Ada types whose representations
are identical to the default representations of the Fortran intrinsic
types Integer, Real, Double Precision, Complex, Logical, and Character
in a supported Fortran implementation.  These Ada types can therefore be
used to pass objects between Ada and Fortran programs.

                          _Static Semantics_

3
The library package Interfaces.Fortran has the following declaration:

4
     with Ada.Numerics.Generic_Complex_Types;  -- see *note G.1.1::
     pragma Elaborate_All(Ada.Numerics.Generic_Complex_Types);
     package Interfaces.Fortran is
        pragma Pure(Fortran);

5
        type Fortran_Integer is range implementation-defined;

6
        type Real             is digits implementation-defined;
        type Double_Precision is digits implementation-defined;

7
        type Logical is new Boolean;

8
        package Single_Precision_Complex_Types is
           new Ada.Numerics.Generic_Complex_Types (Real);

9
        type Complex is new Single_Precision_Complex_Types.Complex;

10
        subtype Imaginary is Single_Precision_Complex_Types.Imaginary;
        i : Imaginary renames Single_Precision_Complex_Types.i;
        j : Imaginary renames Single_Precision_Complex_Types.j;

11
        type Character_Set is implementation-defined character type;

12/3
        type Fortran_Character is array (Positive range <>) of Character_Set
           with Pack;

13
        function To_Fortran (Item : in Character) return Character_Set;
        function To_Ada (Item : in Character_Set) return Character;

14
        function To_Fortran (Item : in String) return Fortran_Character;
        function To_Ada     (Item : in Fortran_Character) return String;

15
        procedure To_Fortran (Item       : in String;
                              Target     : out Fortran_Character;
                              Last       : out Natural);

16
        procedure To_Ada (Item     : in Fortran_Character;
                          Target   : out String;
                          Last     : out Natural);

17
     end Interfaces.Fortran;

18
The types Fortran_Integer, Real, Double_Precision, Logical, Complex, and
Fortran_Character are Fortran-compatible.

19
The To_Fortran and To_Ada functions map between the Ada type Character
and the Fortran type Character_Set, and also between the Ada type String
and the Fortran type Fortran_Character.  The To_Fortran and To_Ada
procedures have analogous effects to the string conversion subprograms
found in Interfaces.COBOL.

                     _Implementation Requirements_

20/3
An implementation shall support specifying aspect Convention with a
Fortran convention_identifier for a Fortran-eligible type (see *note
B.1::).

                     _Implementation Permissions_

21
An implementation may add additional declarations to the Fortran
interface packages.  For example, the Fortran interface package for an
implementation of Fortran 77 (ANSI X3.9-1978) that defines types like
Integer*n, Real*n, Logical*n, and Complex*n may contain the declarations
of types named Integer_Star_n, Real_Star_n, Logical_Star_n, and
Complex_Star_n.  (This convention should not apply to Character*n, for
which the Ada analog is the constrained array subtype Fortran_Character
(1..n).)  Similarly, the Fortran interface package for an implementation
of Fortran 90 that provides multiple kinds of intrinsic types, e.g.
Integer (Kind=n), Real (Kind=n), Logical (Kind=n), Complex (Kind=n), and
Character (Kind=n), may contain the declarations of types with the
recommended names Integer_Kind_n, Real_Kind_n, Logical_Kind_n,
Complex_Kind_n, and Character_Kind_n.

                        _Implementation Advice_

22
An Ada implementation should support the following interface
correspondences between Ada and Fortran:

23
   * An Ada procedure corresponds to a Fortran subroutine.

24
   * An Ada function corresponds to a Fortran function.

25
   * An Ada parameter of an elementary, array, or record type T is
     passed as a TF argument to a Fortran procedure, where TF is the
     Fortran type corresponding to the Ada type T, and where the INTENT
     attribute of the corresponding dummy argument matches the Ada
     formal parameter mode; the Fortran implementation's parameter
     passing conventions are used.  For elementary types, a local copy
     is used if necessary to ensure by-copy semantics.

26
   * An Ada parameter of an access-to-subprogram type is passed as a
     reference to a Fortran procedure whose interface corresponds to the
     designated subprogram's specification.

     NOTES

27
     14  An object of a Fortran-compatible record type, declared in a
     library package or subprogram, can correspond to a Fortran common
     block; the type also corresponds to a Fortran "derived type".

                              _Examples_

28
Example of Interfaces.Fortran:

29
     with Interfaces.Fortran;
     use Interfaces.Fortran;
     procedure Ada_Application is

30/3
        type Fortran_Matrix is array (Integer range <>,
                                      Integer range <>) of Double_Precision
           with Convention => Fortran;                  -- stored in Fortran's
                                                        -- column-major order
        procedure Invert (Rank : in Fortran_Integer; X : in out Fortran_Matrix)
           with Import => True, Convention => Fortran; -- a Fortran subroutine

31
        Rank      : constant Fortran_Integer := 100;
        My_Matrix : Fortran_Matrix (1 .. Rank, 1 .. Rank);

32
     begin

33
        ...
        My_Matrix := ...;
        ...
        Invert (Rank, My_Matrix);
        ...

34
     end Ada_Application;


File: arm2012.info,  Node: Annex C,  Next: Annex D,  Prev: Annex B,  Up: Top

Annex C Systems Programming
***************************

1
The Systems Programming Annex specifies additional capabilities provided
for low-level programming.  These capabilities are also required in many
real-time, embedded, distributed, and information systems.

* Menu:

* C.1 ::      Access to Machine Operations
* C.2 ::      Required Representation Support
* C.3 ::      Interrupt Support
* C.4 ::      Preelaboration Requirements
* C.5 ::      Aspect Discard_Names
* C.6 ::      Shared Variable Control
* C.7 ::      Task Information


File: arm2012.info,  Node: C.1,  Next: C.2,  Up: Annex C

C.1 Access to Machine Operations
================================

1/3
This subclause specifies rules regarding access to machine instructions
from within an Ada program.

                     _Implementation Requirements_

2
The implementation shall support machine code insertions (see *note
13.8::) or intrinsic subprograms (see *note 6.3.1::) (or both).
Implementation-defined attributes shall be provided to allow the use of
Ada entities as operands.

                        _Implementation Advice_

3
The machine code or intrinsics support should allow access to all
operations normally available to assembly language programmers for the
target environment, including privileged instructions, if any.

4/3
The support for interfacing aspects (see *note Annex B::) should include
interface to assembler; the default assembler should be associated with
the convention identifier Assembler.

5
If an entity is exported to assembly language, then the implementation
should allocate it at an addressable location, and should ensure that it
is retained by the linking process, even if not otherwise referenced
from the Ada code.  The implementation should assume that any call to a
machine code or assembler subprogram is allowed to read or update every
object that is specified as exported.

                     _Documentation Requirements_

6
The implementation shall document the overhead associated with calling
machine-code or intrinsic subprograms, as compared to a fully-inlined
call, and to a regular out-of-line call.

7
The implementation shall document the types of the package
System.Machine_Code usable for machine code insertions, and the
attributes to be used in machine code insertions for references to Ada
entities.

8/3
The implementation shall document the subprogram calling conventions
associated with the convention identifiers available for use with the
Convention aspect (Ada and Assembler, at a minimum), including register
saving, exception propagation, parameter passing, and function value
returning.

9
For exported and imported subprograms, the implementation shall document
the mapping between the Link_Name string, if specified, or the Ada
designator, if not, and the external link name used for such a
subprogram.

                        _Implementation Advice_

10
The implementation should ensure that little or no overhead is
associated with calling intrinsic and machine-code subprograms.

11
It is recommended that intrinsic subprograms be provided for convenient
access to any machine operations that provide special capabilities or
efficiency and that are not otherwise available through the language
constructs.  Examples of such instructions include:

12
   * Atomic read-modify-write operations -- e.g., test and set, compare
     and swap, decrement and test, enqueue/dequeue.

13
   * Standard numeric functions -- e.g., sin, log.

14
   * String manipulation operations -- e.g., translate and test.

15
   * Vector operations -- e.g., compare vector against thresholds.

16
   * Direct operations on I/O ports.


File: arm2012.info,  Node: C.2,  Next: C.3,  Prev: C.1,  Up: Annex C

C.2 Required Representation Support
===================================

1/3
This subclause specifies minimal requirements on the support for
representation items and related features.

                     _Implementation Requirements_

2/3
The implementation shall support at least the functionality defined by
the recommended levels of support in Clause *note 13::.


File: arm2012.info,  Node: C.3,  Next: C.4,  Prev: C.2,  Up: Annex C

C.3 Interrupt Support
=====================

1/3
This subclause specifies the language-defined model for hardware
interrupts in addition to mechanisms for handling interrupts. 

                          _Dynamic Semantics_

2
An interrupt represents a class of events that are detected by the
hardware or the system software. Interrupts are said to occur.  An
occurrence of an interrupt is separable into generation and delivery.
Generation of an interrupt is the event in the underlying hardware or
system that makes the interrupt available to the program. Delivery is
the action that invokes part of the program as response to the interrupt
occurrence. Between generation and delivery, the interrupt occurrence
(or interrupt) is pending. Some or all interrupts may be blocked.  When
an interrupt is blocked, all occurrences of that interrupt are prevented
from being delivered. Certain interrupts are reserved.  The set of
reserved interrupts is implementation defined.  A reserved interrupt is
either an interrupt for which user-defined handlers are not supported,
or one which already has an attached handler by some other
implementation-defined means. Program units can be connected to
nonreserved interrupts.  While connected, the program unit is said to be
attached to that interrupt.  The execution of that program unit, the
interrupt handler, is invoked upon delivery of the interrupt occurrence.

3
While a handler is attached to an interrupt, it is called once for each
delivered occurrence of that interrupt.  While the handler executes, the
corresponding interrupt is blocked.

4
While an interrupt is blocked, all occurrences of that interrupt are
prevented from being delivered.  Whether such occurrences remain pending
or are lost is implementation defined.

5
Each interrupt has a default treatment which determines the system's
response to an occurrence of that interrupt when no user-defined handler
is attached.  The set of possible default treatments is implementation
defined, as is the method (if one exists) for configuring the default
treatments for interrupts.

6
An interrupt is delivered to the handler (or default treatment) that is
in effect for that interrupt at the time of delivery.

7
An exception propagated from a handler that is invoked by an interrupt
has no effect.

8
If the Ceiling_Locking policy (see *note D.3::) is in effect, the
interrupt handler executes with the active priority that is the ceiling
priority of the corresponding protected object.

                     _Implementation Requirements_

9
The implementation shall provide a mechanism to determine the minimum
stack space that is needed for each interrupt handler and to reserve
that space for the execution of the handler.  This space should
accommodate nested invocations of the handler where the system permits
this.

10
If the hardware or the underlying system holds pending interrupt
occurrences, the implementation shall provide for later delivery of
these occurrences to the program.

11
If the Ceiling_Locking policy is not in effect, the implementation shall
provide means for the application to specify whether interrupts are to
be blocked during protected actions.

                     _Documentation Requirements_

12
The implementation shall document the following items:

13
     1.  For each interrupt, which interrupts are blocked from delivery
     when a handler attached to that interrupt executes (either as a
     result of an interrupt delivery or of an ordinary call on a
     procedure of the corresponding protected object).

14
     2.  Any interrupts that cannot be blocked, and the effect of
     attaching handlers to such interrupts, if this is permitted.

15
     3.  Which run-time stack an interrupt handler uses when it executes
     as a result of an interrupt delivery; if this is configurable, what
     is the mechanism to do so; how to specify how much space to reserve
     on that stack.

16
     4.  Any implementation- or hardware-specific activity that happens
     before a user-defined interrupt handler gets control (e.g., reading
     device registers, acknowledging devices).

17
     5.  Any timing or other limitations imposed on the execution of
     interrupt handlers.

18
     6.  The state (blocked/unblocked) of the nonreserved interrupts
     when the program starts; if some interrupts are unblocked, what is
     the mechanism a program can use to protect itself before it can
     attach the corresponding handlers.

19
     7.  Whether the interrupted task is allowed to resume execution
     before the interrupt handler returns.

20
     8.  The treatment of interrupt occurrences that are generated while
     the interrupt is blocked; i.e., whether one or more occurrences are
     held for later delivery, or all are lost.

21
     9.  Whether predefined or implementation-defined exceptions are
     raised as a result of the occurrence of any interrupt, and the
     mapping between the machine interrupts (or traps) and the
     predefined exceptions.

22
     10.  On a multi-processor, the rules governing the delivery of an
     interrupt to a particular processor.

                     _Implementation Permissions_

23/2
If the underlying system or hardware does not allow interrupts to be
blocked, then no blocking is required as part of the execution of
subprograms of a protected object for which one of its subprograms is an
interrupt handler.

24
In a multi-processor with more than one interrupt subsystem, it is
implementation defined whether (and how) interrupt sources from separate
subsystems share the same Interrupt_Id type (see *note C.3.2::).  In
particular, the meaning of a blocked or pending interrupt may then be
applicable to one processor only.

25
Implementations are allowed to impose timing or other limitations on the
execution of interrupt handlers.

26/3
Other forms of handlers are allowed to be supported, in which case the
rules of this subclause should be adhered to.

27
The active priority of the execution of an interrupt handler is allowed
to vary from one occurrence of the same interrupt to another.

                        _Implementation Advice_

28/2
If the Ceiling_Locking policy is not in effect, the implementation
should provide means for the application to specify which interrupts are
to be blocked during protected actions, if the underlying system allows
for finer-grained control of interrupt blocking.

     NOTES

29
     1  The default treatment for an interrupt can be to keep the
     interrupt pending or to deliver it to an implementation-defined
     handler.  Examples of actions that an implementation-defined
     handler is allowed to perform include aborting the partition,
     ignoring (i.e., discarding occurrences of) the interrupt, or
     queuing one or more occurrences of the interrupt for possible later
     delivery when a user-defined handler is attached to that interrupt.

30
     2  It is a bounded error to call Task_Identification.Current_Task
     (see *note C.7.1::) from an interrupt handler.

31
     3  The rule that an exception propagated from an interrupt handler
     has no effect is modeled after the rule about exceptions propagated
     out of task bodies.

* Menu:

* C.3.1 ::    Protected Procedure Handlers
* C.3.2 ::    The Package Interrupts


File: arm2012.info,  Node: C.3.1,  Next: C.3.2,  Up: C.3

C.3.1 Protected Procedure Handlers
----------------------------------

Paragraphs 1 through 6 were moved to *note Annex J::, "*note Annex J::
Obsolescent Features".

                          _Static Semantics_

6.1/3
For a parameterless protected procedure, the following language-defined
representation aspects may be specified:

6.2/3
Interrupt_Handler
               The type of aspect Interrupt_Handler is Boolean.  If
               directly specified, the aspect_definition shall be a
               static expression.  This aspect is never inherited; if
               not directly specified, the aspect is False.

6.3/3
Attach_Handler
               The aspect Attach_Handler is an expression, which shall
               be of type Interrupts.Interrupt_Id.  This aspect is never
               inherited.

                           _Legality Rules_

7/3
If either the Attach_Handler or Interrupt_Handler aspect are specified
for a protected procedure, the corresponding protected_type_declaration
(*note 9.4: S0210.) or single_protected_declaration (*note 9.4: S0211.)
shall be a library-level declaration and shall not be declared within a
generic body. In addition to the places where Legality Rules normally
apply (see *note 12.3::), this rule also applies in the private part of
an instance of a generic unit.

8/3
This paragraph was deleted.

                          _Dynamic Semantics_

9/3
If the Interrupt_Handler aspect of a protected procedure is True, then
the procedure may be attached dynamically, as a handler, to interrupts
(see *note C.3.2::).  Such procedures are allowed to be attached to
multiple interrupts.

10/3
The expression specified for the Attach_Handler aspect of a protected
procedure P is evaluated as part of the creation of the protected object
that contains P. The value of the expression identifies an interrupt.
As part of the initialization of that object, P (the handler procedure)
is attached to the identified interrupt. A check is made that the
corresponding interrupt is not reserved. Program_Error is raised if the
check fails, and the existing treatment for the interrupt is not
affected.

11/3
If the Ceiling_Locking policy (see *note D.3::) is in effect, then upon
the initialization of a protected object that contains a protected
procedure for which either the Attach_Handler aspect is specified or the
Interrupt_Handler aspect is True, a check is made that the initial
ceiling priority of the object is in the range of
System.Interrupt_Priority. If the check fails, Program_Error is raised.

12/3
When a protected object is finalized, for any of its procedures that are
attached to interrupts, the handler is detached.  If the handler was
attached by a procedure in the Interrupts package or if no user handler
was previously attached to the interrupt, the default treatment is
restored.  If the Attach_Handler aspect was specified and the most
recently attached handler for the same interrupt is the same as the one
that was attached at the time the protected object was initialized, the
previous handler is restored.

13
When a handler is attached to an interrupt, the interrupt is blocked
(subject to the Implementation Permission in *note C.3::) during the
execution of every protected action on the protected object containing
the handler.

                         _Erroneous Execution_

14
If the Ceiling_Locking policy (see *note D.3::) is in effect and an
interrupt is delivered to a handler, and the interrupt hardware priority
is higher than the ceiling priority of the corresponding protected
object, the execution of the program is erroneous.

14.1/3
If the handlers for a given interrupt attached via aspect Attach_Handler
are not attached and detached in a stack-like (LIFO) order, program
execution is erroneous.  In particular, when a protected object is
finalized, the execution is erroneous if any of the procedures of the
protected object are attached to interrupts via aspect Attach_Handler
and the most recently attached handler for the same interrupt is not the
same as the one that was attached at the time the protected object was
initialized.

                               _Metrics_

15
The following metric shall be documented by the implementation:

16/2
   * The worst-case overhead for an interrupt handler that is a
     parameterless protected procedure, in clock cycles.  This is the
     execution time not directly attributable to the handler procedure
     or the interrupted execution.  It is estimated as C - (A+B), where
     A is how long it takes to complete a given sequence of instructions
     without any interrupt, B is how long it takes to complete a normal
     call to a given protected procedure, and C is how long it takes to
     complete the same sequence of instructions when it is interrupted
     by one execution of the same procedure called via an interrupt.

                     _Implementation Permissions_

17/3
When the aspects Attach_Handler or Interrupt_Handler are specified for a
protected procedure, the implementation is allowed to impose
implementation-defined restrictions on the corresponding
protected_type_declaration (*note 9.4: S0210.) and protected_body (*note
9.4: S0215.).

18
An implementation may use a different mechanism for invoking a protected
procedure in response to a hardware interrupt than is used for a call to
that protected procedure from a task.

19/3
Notwithstanding what this subclause says elsewhere, the Attach_Handler
and Interrupt_Handler aspects are allowed to be used for other,
implementation defined, forms of interrupt handlers.

                        _Implementation Advice_

20
Whenever possible, the implementation should allow interrupt handlers to
be called directly by the hardware.

21
Whenever practical, the implementation should detect violations of any
implementation-defined restrictions before run time.

     NOTES

22/3
     4  The Attach_Handler aspect may provide static attachment of
     handlers to interrupts if the implementation supports
     preelaboration of protected objects.  (See *note C.4::.)

23/2
     5  A protected object that has a (protected) procedure attached to
     an interrupt should have a ceiling priority at least as high as the
     highest processor priority at which that interrupt will ever be
     delivered.

24
     6  Protected procedures can also be attached dynamically to
     interrupts via operations declared in the predefined package
     Interrupts.

25
     7  An example of a possible implementation-defined restriction is
     disallowing the use of the standard storage pools within the body
     of a protected procedure that is an interrupt handler.


File: arm2012.info,  Node: C.3.2,  Prev: C.3.1,  Up: C.3

C.3.2 The Package Interrupts
----------------------------

                          _Static Semantics_

1
The following language-defined packages exist:

2/3
     with System;
     with System.Multiprocessors;
     package Ada.Interrupts is
        type Interrupt_Id is implementation-defined;
        type Parameterless_Handler is
           access protected procedure;

3/1
     This paragraph was deleted.

4
        function Is_Reserved (Interrupt : Interrupt_Id)
           return Boolean;

5
        function Is_Attached (Interrupt : Interrupt_Id)
           return Boolean;

6
        function Current_Handler (Interrupt : Interrupt_Id)
           return Parameterless_Handler;

7
        procedure Attach_Handler
           (New_Handler : in Parameterless_Handler;
            Interrupt   : in Interrupt_Id);

8
        procedure Exchange_Handler
           (Old_Handler : out Parameterless_Handler;
            New_Handler : in Parameterless_Handler;
            Interrupt   : in Interrupt_Id);

9
        procedure Detach_Handler
           (Interrupt : in Interrupt_Id);

10
        function Reference (Interrupt : Interrupt_Id)
           return System.Address;

10.1/3
        function Get_CPU (Interrupt : Interrupt_Id)
           return System.Multiprocessors.CPU_Range;

11
     private
        ... -- not specified by the language
     end Ada.Interrupts;

12
     package Ada.Interrupts.Names is
        implementation-defined : constant Interrupt_Id :=
          implementation-defined;
           . . .
        implementation-defined : constant Interrupt_Id :=
          implementation-defined;
     end Ada.Interrupts.Names;

                          _Dynamic Semantics_

13
The Interrupt_Id type is an implementation-defined discrete type used to
identify interrupts.

14
The Is_Reserved function returns True if and only if the specified
interrupt is reserved.

15
The Is_Attached function returns True if and only if a user-specified
interrupt handler is attached to the interrupt.

16/1
The Current_Handler function returns a value that represents the
attached handler of the interrupt.  If no user-defined handler is
attached to the interrupt, Current_Handler returns null.

17/3
The Attach_Handler procedure attaches the specified handler to the
interrupt, overriding any existing treatment (including a user handler)
in effect for that interrupt.  If New_Handler is null, the default
treatment is restored. If New_Handler designates a protected procedure
for which the aspect Interrupt_Handler is False, Program_Error is
raised.  In this case, the operation does not modify the existing
interrupt treatment.

18/1
The Exchange_Handler procedure operates in the same manner as
Attach_Handler with the addition that the value returned in Old_Handler
designates the previous treatment for the specified interrupt.  If the
previous treatment is not a user-defined handler, null is returned.

19
The Detach_Handler procedure restores the default treatment for the
specified interrupt.

20
For all operations defined in this package that take a parameter of type
Interrupt_Id, with the exception of Is_Reserved and Reference, a check
is made that the specified interrupt is not reserved. Program_Error is
raised if this check fails.

21/3
If, by using the Attach_Handler, Detach_Handler, or Exchange_Handler
procedures, an attempt is made to detach a handler that was attached
statically (using the aspect Attach_Handler), the handler is not
detached and Program_Error is raised. 

22/2
The Reference function returns a value of type System.Address that can
be used to attach a task entry via an address clause (see *note J.7.1::)
to the interrupt specified by Interrupt.  This function raises
Program_Error if attaching task entries to interrupts (or to this
particular interrupt) is not supported. 

22.1/3
The function Get_CPU returns the processor on which the handler for
Interrupt is executed.  If the handler can execute on more than one
processor the value System.Multiprocessors.Not_A_Specific_CPU is
returned.

                     _Implementation Requirements_

23
At no time during attachment or exchange of handlers shall the current
handler of the corresponding interrupt be undefined.

                     _Documentation Requirements_

24/3
If the Ceiling_Locking policy (see *note D.3::) is in effect, the
implementation shall document the default ceiling priority assigned to a
protected object that contains a protected procedure that specifies
either the Attach_Handler or Interrupt_Handler aspects, but does not
specify the Interrupt_Priority aspect.  This default need not be the
same for all interrupts.

                        _Implementation Advice_

25
If implementation-defined forms of interrupt handler procedures are
supported, such as protected procedures with parameters, then for each
such form of a handler, a type analogous to Parameterless_Handler should
be specified in a child package of Interrupts, with the same operations
as in the predefined package Interrupts.

     NOTES

26
     8  The package Interrupts.Names contains implementation-defined
     names (and constant values) for the interrupts that are supported
     by the implementation.

                              _Examples_

27
Example of interrupt handlers:

28/3
     Device_Priority : constant
       array (1..5) of System.Interrupt_Priority := ( ... );
     protected type Device_Interface
       (Int_Id : Ada.Interrupts.Interrupt_Id) 
          with Interrupt_Priority => Device_Priority(Int_Id) is
       procedure Handler
          with Attach_Handler => Int_Id;
       ...
       end Device_Interface;
       ...
     Device_1_Driver : Device_Interface(1);
       ...
     Device_5_Driver : Device_Interface(5);
       ...


File: arm2012.info,  Node: C.4,  Next: C.5,  Prev: C.3,  Up: Annex C

C.4 Preelaboration Requirements
===============================

1/3
This subclause specifies additional implementation and documentation
requirements for the Preelaborate pragma (see *note 10.2.1::).

                     _Implementation Requirements_

2
The implementation shall not incur any run-time overhead for the
elaboration checks of subprograms and protected_bodies declared in
preelaborated library units. 

3
The implementation shall not execute any memory write operations after
load time for the elaboration of constant objects declared immediately
within the declarative region of a preelaborated library package, so
long as the subtype and initial expression (or default initial
expressions if initialized by default) of the object_declaration satisfy
the following restrictions. The meaning of load time is implementation
defined.

4
   * Any subtype_mark denotes a statically constrained subtype, with
     statically constrained subcomponents, if any;

4.1/2
   * no subtype_mark denotes a controlled type, a private type, a
     private extension, a generic formal private type, a generic formal
     derived type, or a descendant of such a type;

5
   * any constraint is a static constraint;

6
   * any allocator is for an access-to-constant type;

7
   * any uses of predefined operators appear only within static
     expressions;

8
   * any primaries that are names, other than attribute_references for
     the Access or Address attributes, appear only within static
     expressions;

9
   * any name that is not part of a static expression is an expanded
     name or direct_name that statically denotes some entity;

10
   * any discrete_choice of an array_aggregate is static;

11
   * no language-defined check associated with the elaboration of the
     object_declaration can fail.

                     _Documentation Requirements_

12
The implementation shall document any circumstances under which the
elaboration of a preelaborated package causes code to be executed at run
time.

13
The implementation shall document whether the method used for
initialization of preelaborated variables allows a partition to be
restarted without reloading.

                        _Implementation Advice_

14
It is recommended that preelaborated packages be implemented in such a
way that there should be little or no code executed at run time for the
elaboration of entities not already covered by the Implementation
Requirements.


File: arm2012.info,  Node: C.5,  Next: C.6,  Prev: C.4,  Up: Annex C

C.5 Aspect Discard_Names
========================

1/4
Specifying the aspect Discard_Names can be used to request a reduction
in storage used for the names of entities with runtime name text.

                          _Static Semantics_

1.1/4
An entity with runtime name text is a nonderived enumeration first
subtype, a tagged first subtype, or an exception.

1.2/4
For an entity with runtime name text, the following language-defined
representation aspect may be specified:

1.3/4
Discard_Names
               The type of aspect Discard_Names is Boolean.  If directly
               specified, the aspect_definition shall be a static
               expression.  If not specified (including by inheritance),
               the aspect is False.

                               _Syntax_

2
     The form of a pragma Discard_Names is as follows:

3
       pragma Discard_Names[([On => ] local_name)];

4
     A pragma Discard_Names is allowed only immediately within a
     declarative_part, immediately within a package_specification, or as
     a configuration pragma. 

                           _Legality Rules_

5/4
The local_name (if present) shall denote an entity with runtime name
text.  The pragma specifies that the aspect Discard_Names for the type
or exception has the value True.  Without a local_name, the pragma
specifies that all entities with runtime name text declared after the
pragma, within the same declarative region have the value True for
aspect Discard_Names.  Alternatively, the pragma can be used as a
configuration pragma.  If the configuration pragma Discard_Names applies
to a compilation unit, all entities with runtime name text declared in
the compilation unit have the value True for the aspect Discard_Names..

                          _Static Semantics_

6
If a local_name is given, then a pragma Discard_Names is a
representation pragma.

7/4
If the aspect Discard_Names is True for an enumeration type, then the
semantics of the Wide_Wide_Image and Wide_Wide_Value attributes are
implementation defined for that type; the semantics of Image,
Wide_Image, Value, and Wide_Value are still defined in terms of
Wide_Wide_Image and Wide_Wide_Value.  In addition, the semantics of
Text_IO.Enumeration_IO are implementation defined.  If the aspect
Discard_Names is True for a tagged type, then the semantics of the
Tags.Wide_Wide_Expanded_Name function are implementation defined for
that type; the semantics of Tags.Expanded_Name and
Tags.Wide_Expanded_Name are still defined in terms of
Tags.Wide_Wide_Expanded_Name.  If the aspect Discard_Names is True for
an exception, then the semantics of the
Exceptions.Wide_Wide_Exception_Name function are implementation defined
for that exception; the semantics of Exceptions.Exception_Name and
Exceptions.Wide_Exception_Name are still defined in terms of
Exceptions.Wide_Wide_Exception_Name.

                        _Implementation Advice_

8/4
If the aspect Discard_Names is True for an entity, then the
implementation should reduce the amount of storage used for storing
names associated with that entity.


File: arm2012.info,  Node: C.6,  Next: C.7,  Prev: C.5,  Up: Annex C

C.6 Shared Variable Control
===========================

1/3
This subclause defines representation aspects that control the use of
shared variables.

Paragraphs 2 through 6 were moved to *note Annex J::, "*note Annex J::
Obsolescent Features".

                          _Static Semantics_

6.1/3
For an object_declaration, a component_declaration, or a
full_type_declaration, the following representation aspects may be
specified:

6.2/3
Atomic
               The type of aspect Atomic is Boolean.

6.3/3
Independent
               The type of aspect Independent is Boolean.

6.4/3
Volatile
               The type of aspect Volatile is Boolean.

6.5/3
For a full_type_declaration of an array type (including the anonymous
type of an object_declaration of an anonymous array object), the
following representation aspects may be specified:

6.6/3
Atomic_Components
               The type of aspect Atomic_Components is Boolean.

6.7/3
Volatile_Components
               The type of aspect Volatile_Components is Boolean.

6.8/3
For a full_type_declaration (including the anonymous type of an
object_declaration of an anonymous array object), the following
representation aspect may be specified:

6.9/3
Independent_Components
               The type of aspect Independent_Components is Boolean.

6.10/3
If any of these aspects are directly specified, the aspect_definition
shall be a static expression.  If not specified (including by
inheritance), each of these aspects is False.

7/3
An atomic type is one for which the aspect Atomic is True.  An atomic
object (including a component) is one for which the aspect Atomic is
True, or a component of an array for which the aspect Atomic_Components
is True for the associated type, or any object of an atomic type, other
than objects obtained by evaluating a slice.

8/3
A volatile type is one for which the aspect Volatile is True.  A
volatile object (including a component) is one for which the aspect
Volatile is True, or a component of an array for which the aspect
Volatile_Components is True for the associated type, or any object of a
volatile type.  In addition, every atomic type or object is also defined
to be volatile.  Finally, if an object is volatile, then so are all of
its subcomponents (the same does not apply to atomic).

8.1/4
When True, the aspects Independent and Independent_Components specify as
independently addressable the named object or component(s), or in the
case of a type, all objects or components of that type.  All atomic
objects and aliased objects are considered to be specified as
independently addressable.

Paragraph 9 was moved to *note Annex J::, "*note Annex J:: Obsolescent
Features".

                           _Legality Rules_

9.1/3
If aspect Independent_Components is specified for a
full_type_declaration, the declaration shall be that of an array or
record type.

10/4
It is illegal to specify either of the aspects Atomic or
Atomic_Components to have the value True for an object or type if the
implementation cannot support the indivisible and independent reads and
updates required by the aspect (see below).

11/4
It is illegal to specify the Size attribute of an atomic object, the
Component_Size attribute for an array type with atomic components, or
the layout attributes of an atomic component, in a way that prevents the
implementation from performing the required indivisible and independent
reads and updates.

12/3
If an atomic object is passed as a parameter, then the formal parameter
shall either have an atomic type or allow pass by copy.  If an atomic
object is used as an actual for a generic formal object of mode in out,
then the type of the generic formal object shall be atomic.  If the
prefix of an attribute_reference for an Access attribute denotes an
atomic object (including a component), then the designated type of the
resulting access type shall be atomic.  If an atomic type is used as an
actual for a generic formal derived type, then the ancestor of the
formal type shall be atomic.  Corresponding rules apply to volatile
objects and types.

12.1/3
If a volatile type is used as an actual for a generic formal array type,
then the element type of the formal type shall be volatile.

13/3
If an aspect Volatile, Volatile_Components, Atomic, or Atomic_Components
is directly specified to have the value True for a stand-alone constant
object, then the aspect Import shall also be specified as True for it.

13.1/3
It is illegal to specify the aspect Independent or
Independent_Components as True for a component, object or type if the
implementation cannot provide the independent addressability required by
the aspect (see *note 9.10::).

13.2/3
It is illegal to specify a representation aspect for a component, object
or type for which the aspect Independent or Independent_Components is
True, in a way that prevents the implementation from providing the
independent addressability required by the aspect.

Paragraph 14 was moved to *note Annex J::, "*note Annex J:: Obsolescent
Features".

                          _Dynamic Semantics_

15
For an atomic object (including an atomic component) all reads and
updates of the object as a whole are indivisible.

16/3
All tasks of the program (on all processors) that read or update
volatile variables see the same order of updates to the variables.  A
use of an atomic variable or other mechanism may be necessary to avoid
erroneous execution and to ensure that access to nonatomic volatile
variables is sequential (see *note 9.10::).

17
Two actions are sequential (see *note 9.10::) if each is the read or
update of the same atomic object.

18
If a type is atomic or volatile and it is not a by-copy type, then the
type is defined to be a by-reference type.  If any subcomponent of a
type is atomic or volatile, then the type is defined to be a
by-reference type.

19
If an actual parameter is atomic or volatile, and the corresponding
formal parameter is not, then the parameter is passed by copy.

                     _Implementation Requirements_

20
The external effect of a program (see *note 1.1.3::) is defined to
include each read and update of a volatile or atomic object.  The
implementation shall not generate any memory reads or updates of atomic
or volatile objects other than those specified by the program.

21/4
This paragraph was deleted.

                        _Implementation Advice_

22/2
A load or store of a volatile object whose size is a multiple of
System.Storage_Unit and whose alignment is nonzero, should be
implemented by accessing exactly the bits of the object and no others.

23/2
A load or store of an atomic object should, where possible, be
implemented by a single load or store instruction.

     NOTES

24
     9  An imported volatile or atomic constant behaves as a constant
     (i.e.  read-only) with respect to other parts of the Ada program,
     but can still be modified by an "external source."

25/4
     10  Specifying the Pack aspect cannot override the effect of
     specifying an Atomic or Atomic_Components aspect.


File: arm2012.info,  Node: C.7,  Prev: C.6,  Up: Annex C

C.7 Task Information
====================

1/3
This subclause describes operations and attributes that can be used to
obtain the identity of a task.  In addition, a package that associates
user-defined information with a task is defined.  Finally, a package
that associates termination procedures with a task or set of tasks is
defined.

* Menu:

* C.7.1 ::    The Package Task_Identification
* C.7.2 ::    The Package Task_Attributes
* C.7.3 ::    The Package Task_Termination


File: arm2012.info,  Node: C.7.1,  Next: C.7.2,  Up: C.7

C.7.1 The Package Task_Identification
-------------------------------------

                          _Static Semantics_

1
The following language-defined library package exists:

2/2
     package Ada.Task_Identification is
        pragma Preelaborate(Task_Identification);
        type Task_Id is private;
        pragma Preelaborable_Initialization (Task_Id);
        Null_Task_Id : constant Task_Id;
        function  "=" (Left, Right : Task_Id) return Boolean;

3/3
        function  Image                  (T : Task_Id) return String;
        function  Current_Task     return Task_Id;
        function  Environment_Task return Task_Id;
        procedure Abort_Task             (T : in Task_Id);

4/3
        function  Is_Terminated          (T : Task_Id) return Boolean;
        function  Is_Callable            (T : Task_Id) return Boolean;
        function  Activation_Is_Complete (T : Task_Id) return Boolean;
     private
        ... -- not specified by the language
     end Ada.Task_Identification;

                          _Dynamic Semantics_

5
A value of the type Task_Id identifies an existent task.  The constant
Null_Task_Id does not identify any task.  Each object of the type
Task_Id is default initialized to the value of Null_Task_Id.

6
The function "=" returns True if and only if Left and Right identify the
same task or both have the value Null_Task_Id.

7
The function Image returns an implementation-defined string that
identifies T. If T equals Null_Task_Id, Image returns an empty string.

8
The function Current_Task returns a value that identifies the calling
task.

8.1/3
The function Environment_Task returns a value that identifies the
environment task.

9
The effect of Abort_Task is the same as the abort_statement for the task
identified by T. In addition, if T identifies the environment task, the
entire partition is aborted, See *note E.1::.

10
The functions Is_Terminated and Is_Callable return the value of the
corresponding attribute of the task identified by T.

10.1/3
The function Activation_Is_Complete returns True if the task identified
by T has completed its activation (whether successfully or not).  It
returns False otherwise.  If T identifies the environment task,
Activation_Is_Complete returns True after the elaboration of the
library_items of the partition has completed.

11
For a prefix T that is of a task type (after any implicit dereference),
the following attribute is defined:

12
T'Identity
               Yields a value of the type Task_Id that identifies the
               task denoted by T.

13
For a prefix E that denotes an entry_declaration, the following
attribute is defined:

14/3
E'Caller
               Yields a value of the type Task_Id that identifies the
               task whose call is now being serviced.  Use of this
               attribute is allowed only inside an accept_statement, or
               entry_body after the entry_barrier, corresponding to the
               entry_declaration denoted by E.

15
Program_Error is raised if a value of Null_Task_Id is passed as a
parameter to Abort_Task, Is_Terminated, and Is_Callable.

16
Abort_Task is a potentially blocking operation (see *note 9.5.1::).

                      _Bounded (Run-Time) Errors_

17/3
It is a bounded error to call the Current_Task function from an
entry_body, interrupt handler, or finalization of a task attribute.
Program_Error is raised, or an implementation-defined value of the type
Task_Id is returned.

                         _Erroneous Execution_

18
If a value of Task_Id is passed as a parameter to any of the operations
declared in this package (or any language-defined child of this
package), and the corresponding task object no longer exists, the
execution of the program is erroneous.

                     _Documentation Requirements_

19
The implementation shall document the effect of calling Current_Task
from an entry body or interrupt handler.

     NOTES

20
     11  This package is intended for use in writing user-defined task
     scheduling packages and constructing server tasks.  Current_Task
     can be used in conjunction with other operations requiring a task
     as an argument such as Set_Priority (see *note D.5::).

21
     12  The function Current_Task and the attribute Caller can return a
     Task_Id value that identifies the environment task.


File: arm2012.info,  Node: C.7.2,  Next: C.7.3,  Prev: C.7.1,  Up: C.7

C.7.2 The Package Task_Attributes
---------------------------------

                          _Static Semantics_

1
The following language-defined generic library package exists:

2
     with Ada.Task_Identification; use Ada.Task_Identification;
     generic
        type Attribute is private;
        Initial_Value : in Attribute;
     package Ada.Task_Attributes is

3
        type Attribute_Handle is access all Attribute;

4
        function Value(T : Task_Id := Current_Task)
          return Attribute;

5
        function Reference(T : Task_Id := Current_Task)
          return Attribute_Handle;

6
        procedure Set_Value(Val : in Attribute;
                            T : in Task_Id := Current_Task);
        procedure Reinitialize(T : in Task_Id := Current_Task);

7
     end Ada.Task_Attributes;

                          _Dynamic Semantics_

8
When an instance of Task_Attributes is elaborated in a given active
partition, an object of the actual type corresponding to the formal type
Attribute is implicitly created for each task (of that partition) that
exists and is not yet terminated.  This object acts as a user-defined
attribute of the task.  A task created previously in the partition and
not yet terminated has this attribute from that point on.  Each task
subsequently created in the partition will have this attribute when
created.  In all these cases, the initial value of the given attribute
is Initial_Value.

9
The Value operation returns the value of the corresponding attribute of
T.

10
The Reference operation returns an access value that designates the
corresponding attribute of T.

11
The Set_Value operation performs any finalization on the old value of
the attribute of T and assigns Val to that attribute (see *note 5.2::
and *note 7.6::).

12
The effect of the Reinitialize operation is the same as Set_Value where
the Val parameter is replaced with Initial_Value.

13
For all the operations declared in this package, Tasking_Error is raised
if the task identified by T is terminated. Program_Error is raised if
the value of T is Null_Task_Id.

13.1/2
After a task has terminated, all of its attributes are finalized, unless
they have been finalized earlier.  When the master of an instantiation
of Ada.Task_Attributes is finalized, the corresponding attribute of each
task is finalized, unless it has been finalized earlier.

                      _Bounded (Run-Time) Errors_

13.2/1
If the package Ada.Task_Attributes is instantiated with a controlled
type and the controlled type has user-defined Adjust or Finalize
operations that in turn access task attributes by any of the above
operations, then a call of Set_Value of the instantiated package
constitutes a bounded error.  The call may perform as expected or may
result in forever blocking the calling task and subsequently some or all
tasks of the partition.

                         _Erroneous Execution_

14
It is erroneous to dereference the access value returned by a given call
on Reference after a subsequent call on Reinitialize for the same task
attribute, or after the associated task terminates.

15
If a value of Task_Id is passed as a parameter to any of the operations
declared in this package and the corresponding task object no longer
exists, the execution of the program is erroneous.

15.1/2
An access to a task attribute via a value of type Attribute_Handle is
erroneous if executed concurrently with another such access or a call of
any of the operations declared in package Task_Attributes.  An access to
a task attribute is erroneous if executed concurrently with or after the
finalization of the task attribute.

                     _Implementation Requirements_

16/1
For a given attribute of a given task, the implementation shall perform
the operations declared in this package atomically with respect to any
of these operations of the same attribute of the same task.  The
granularity of any locking mechanism necessary to achieve such atomicity
is implementation defined.

17/2
After task attributes are finalized, the implementation shall reclaim
any storage associated with the attributes.

                     _Documentation Requirements_

18
The implementation shall document the limit on the number of attributes
per task, if any, and the limit on the total storage for attribute
values per task, if such a limit exists.

19
In addition, if these limits can be configured, the implementation shall
document how to configure them.

                               _Metrics_

20/2
The implementation shall document the following metrics: A task calling
the following subprograms shall execute at a sufficiently high priority
as to not be preempted during the measurement period.  This period shall
start just before issuing the call and end just after the call
completes.  If the attributes of task T are accessed by the measurement
tests, no other task shall access attributes of that task during the
measurement period.  For all measurements described here, the Attribute
type shall be a scalar type whose size is equal to the size of the
predefined type Integer.  For each measurement, two cases shall be
documented: one where the accessed attributes are of the calling task
(that is, the default value for the T parameter is used), and the other,
where T identifies another, nonterminated, task.

21
The following calls (to subprograms in the Task_Attributes package)
shall be measured:

22
   * a call to Value, where the return value is Initial_Value;

23
   * a call to Value, where the return value is not equal to
     Initial_Value;

24
   * a call to Reference, where the return value designates a value
     equal to Initial_Value;

25
   * a call to Reference, where the return value designates a value not
     equal to Initial_Value;

26/2
   * a call to Set_Value where the Val parameter is not equal to
     Initial_Value and the old attribute value is equal to
     Initial_Value;

27
   * a call to Set_Value where the Val parameter is not equal to
     Initial_Value and the old attribute value is not equal to
     Initial_Value.

                     _Implementation Permissions_

28
An implementation need not actually create the object corresponding to a
task attribute until its value is set to something other than that of
Initial_Value, or until Reference is called for the task attribute.
Similarly, when the value of the attribute is to be reinitialized to
that of Initial_Value, the object may instead be finalized and its
storage reclaimed, to be recreated when needed later.  While the object
does not exist, the function Value may simply return Initial_Value,
rather than implicitly creating the object.

29
An implementation is allowed to place restrictions on the maximum number
of attributes a task may have, the maximum size of each attribute, and
the total storage size allocated for all the attributes of a task.

                        _Implementation Advice_

30/2
Some implementations are targeted to domains in which memory use at run
time must be completely deterministic.  For such implementations, it is
recommended that the storage for task attributes will be pre-allocated
statically and not from the heap.  This can be accomplished by either
placing restrictions on the number and the size of the attributes of a
task, or by using the pre-allocated storage for the first N attribute
objects, and the heap for the others.  In the latter case, N should be
documented.

30.1/2
Finalization of task attributes and reclamation of associated storage
should be performed as soon as possible after task termination.

     NOTES

31
     13  An attribute always exists (after instantiation), and has the
     initial value.  It need not occupy memory until the first operation
     that potentially changes the attribute value.  The same holds true
     after Reinitialize.

32
     14  The result of the Reference function should be used with care;
     it is always safe to use that result in the task body whose
     attribute is being accessed.  However, when the result is being
     used by another task, the programmer must make sure that the task
     whose attribute is being accessed is not yet terminated.  Failing
     to do so could make the program execution erroneous.


File: arm2012.info,  Node: C.7.3,  Prev: C.7.2,  Up: C.7

C.7.3 The Package Task_Termination
----------------------------------

                          _Static Semantics_

1/2
The following language-defined library package exists:

2/2
     with Ada.Task_Identification;
     with Ada.Exceptions;
     package Ada.Task_Termination is
        pragma Preelaborate(Task_Termination);

3/2
        type Cause_Of_Termination is (Normal, Abnormal, Unhandled_Exception);

4/2
        type Termination_Handler is access protected procedure
          (Cause : in Cause_Of_Termination;
           T     : in Ada.Task_Identification.Task_Id;
           X     : in Ada.Exceptions.Exception_Occurrence);

5/2
        procedure Set_Dependents_Fallback_Handler
          (Handler: in Termination_Handler);
        function Current_Task_Fallback_Handler return Termination_Handler;

6/2
        procedure Set_Specific_Handler
          (T       : in Ada.Task_Identification.Task_Id;
           Handler : in Termination_Handler);
        function Specific_Handler (T : Ada.Task_Identification.Task_Id)
           return Termination_Handler;

7/2
     end Ada.Task_Termination;

                          _Dynamic Semantics_

8/3
The type Termination_Handler identifies a protected procedure to be
executed by the implementation when a task terminates.  Such a protected
procedure is called a handler.  In all cases T identifies the task that
is terminating.  If the task terminates due to completing the last
statement of its body, or as a result of waiting on a terminate
alternative, and the finalization of the task completes normally, then
Cause is set to Normal and X is set to Null_Occurrence.  If the task
terminates because it is being aborted, then Cause is set to Abnormal; X
is set to Null_Occurrence if the finalization of the task completes
normally.  If the task terminates because of an exception raised by the
execution of its task_body, then Cause is set to Unhandled_Exception; X
is set to the associated exception occurrence if the finalization of the
task completes normally.  Independent of how the task completes, if
finalization of the task propagates an exception, then Cause is either
Unhandled_Exception or Abnormal, and X is an exception occurrence that
identifies the Program_Error exception.

9/2
Each task has two termination handlers, a fall-back handler and a
specific handler.  The specific handler applies only to the task itself,
while the fall-back handler applies only to the dependent tasks of the
task.  A handler is said to be set if it is associated with a nonnull
value of type Termination_Handler, and cleared otherwise.  When a task
is created, its specific handler and fall-back handler are cleared.

10/3
The procedure Set_Dependents_Fallback_Handler changes the fall-back
handler for the calling task: if Handler is null, that fall-back handler
is cleared; otherwise, it is set to be Handler.all.  If a fall-back
handler had previously been set it is replaced.

11/3
The function Current_Task_Fallback_Handler returns the fall-back handler
that is currently set for the calling task, if one is set; otherwise, it
returns null.

12/3
The procedure Set_Specific_Handler changes the specific handler for the
task identified by T: if Handler is null, that specific handler is
cleared; otherwise, it is set to be Handler.all.  If a specific handler
had previously been set it is replaced.

13/3
The function Specific_Handler returns the specific handler that is
currently set for the task identified by T, if one is set; otherwise, it
returns null.

14/2
As part of the finalization of a task_body, after performing the actions
specified in *note 7.6:: for finalization of a master, the specific
handler for the task, if one is set, is executed.  If the specific
handler is cleared, a search for a fall-back handler proceeds by
recursively following the master relationship for the task.  If a task
is found whose fall-back handler is set, that handler is executed;
otherwise, no handler is executed.

15/2
For Set_Specific_Handler or Specific_Handler, Tasking_Error is raised if
the task identified by T has already terminated.  Program_Error is
raised if the value of T is Ada.Task_Identification.Null_Task_Id.

16/2
An exception propagated from a handler that is invoked as part of the
termination of a task has no effect.

                         _Erroneous Execution_

17/2
For a call of Set_Specific_Handler or Specific_Handler, if the task
identified by T no longer exists, the execution of the program is
erroneous.


File: arm2012.info,  Node: Annex D,  Next: Annex E,  Prev: Annex C,  Up: Top

Annex D Real-Time Systems
*************************

1
This Annex specifies additional characteristics of Ada implementations
intended for real-time systems software.  To conform to this Annex, an
implementation shall also conform to the Systems Programming Annex.

                               _Metrics_

2
The metrics are documentation requirements; an implementation shall
document the values of the language-defined metrics for at least one
configuration of hardware or an underlying system supported by the
implementation, and shall document the details of that configuration.

3
The metrics do not necessarily yield a simple number.  For some, a range
is more suitable, for others a formula dependent on some parameter is
appropriate, and for others, it may be more suitable to break the metric
into several cases.  Unless specified otherwise, the metrics in this
annex are expressed in processor clock cycles.  For metrics that require
documentation of an upper bound, if there is no upper bound, the
implementation shall report that the metric is unbounded.

     NOTES

4
     1  The specification of the metrics makes a distinction between
     upper bounds and simple execution times.  Where something is just
     specified as "the execution time of" a piece of code, this leaves
     one the freedom to choose a nonpathological case.  This kind of
     metric is of the form "there exists a program such that the value
     of the metric is V". Conversely, the meaning of upper bounds is
     "there is no program such that the value of the metric is greater
     than V". This kind of metric can only be partially tested, by
     finding the value of V for one or more test programs.

5
     2  The metrics do not cover the whole language; they are limited to
     features that are specified in *note Annex C::, "*note Annex C::
     Systems Programming" and in this Annex.  The metrics are intended
     to provide guidance to potential users as to whether a particular
     implementation of such a feature is going to be adequate for a
     particular real-time application.  As such, the metrics are aimed
     at known implementation choices that can result in significant
     performance differences.

6
     3  The purpose of the metrics is not necessarily to provide
     fine-grained quantitative results or to serve as a comparison
     between different implementations on the same or different
     platforms.  Instead, their goal is rather qualitative; to define a
     standard set of approximate values that can be measured and used to
     estimate the general suitability of an implementation, or to
     evaluate the comparative utility of certain features of an
     implementation for a particular real-time application.

* Menu:

* D.1 ::      Task Priorities
* D.2 ::      Priority Scheduling
* D.3 ::      Priority Ceiling Locking
* D.4 ::      Entry Queuing Policies
* D.5 ::      Dynamic Priorities
* D.6 ::      Preemptive Abort
* D.7 ::      Tasking Restrictions
* D.8 ::      Monotonic Time
* D.9 ::      Delay Accuracy
* D.10 ::     Synchronous Task Control
* D.11 ::     Asynchronous Task Control
* D.12 ::     Other Optimizations and Determinism Rules
* D.13 ::     The Ravenscar Profile
* D.14 ::     Execution Time
* D.15 ::     Timing Events
* D.16 ::     Multiprocessor Implementation


File: arm2012.info,  Node: D.1,  Next: D.2,  Up: Annex D

D.1 Task Priorities
===================

1/3
This subclause specifies the priority model for real-time systems.  In
addition, the methods for specifying priorities are defined.

Paragraphs 2 through 6 were moved to *note Annex J::, "*note Annex J::
Obsolescent Features".

                          _Static Semantics_

6.1/3
For a task type (including the anonymous type of a
single_task_declaration), protected type (including the anonymous type
of a single_protected_declaration), or subprogram, the following
language-defined representation aspects may be specified:

6.2/3
Priority
               The aspect Priority is an expression, which shall be of
               type Integer.

6.3/3
Interrupt_Priority
               The aspect Interrupt_Priority is an expression, which
               shall be of type Integer.

                           _Legality Rules_

7/3
This paragraph was deleted.

8/3
If the Priority aspect is specified for a subprogram, the expression
shall be static, and its value shall be in the range of System.Priority.

8.1/3
At most one of the Priority and Interrupt_Priority aspects may be
specified for a given entity.

8.2/3
Neither of the Priority or Interrupt_Priority aspects shall be specified
for a synchronized interface type.

                          _Static Semantics_

9
The following declarations exist in package System:

10
     subtype Any_Priority is Integer range implementation-defined;
     subtype Priority is Any_Priority
        range Any_Priority'First .. implementation-defined;
     subtype Interrupt_Priority is Any_Priority
        range Priority'Last+1 .. Any_Priority'Last;

11
     Default_Priority : constant Priority := (Priority'First + Priority'Last)/2;

12
The full range of priority values supported by an implementation is
specified by the subtype Any_Priority.  The subrange of priority values
that are high enough to require the blocking of one or more interrupts
is specified by the subtype Interrupt_Priority.  The subrange of
priority values below System.Interrupt_Priority'First is specified by
the subtype System.Priority.

13/3
This paragraph was deleted.

                          _Dynamic Semantics_

14/3
The Priority aspect has no effect if it is specified for a subprogram
other than the main subprogram; the Priority value is not associated
with any task.

15
A task priority is an integer value that indicates a degree of urgency
and is the basis for resolving competing demands of tasks for resources.
Unless otherwise specified, whenever tasks compete for processors or
other implementation-defined resources, the resources are allocated to
the task with the highest priority value.  The base priority of a task
is the priority with which it was created, or to which it was later set
by Dynamic_Priorities.Set_Priority (see *note D.5::).  At all times, a
task also has an active priority, which generally reflects its base
priority as well as any priority it inherits from other sources.
Priority inheritance is the process by which the priority of a task or
other entity (e.g.  a protected object; see *note D.3::) is used in the
evaluation of another task's active priority.

16/3
The effect of specifying a Priority or Interrupt_Priority aspect for a
protected type or single_protected_declaration is discussed in *note
D.3::.

17/4
The expression specified for the Priority or Interrupt_Priority aspect
of a task type is evaluated each time an object of the task type is
created (see *note 9.1::).  For the Priority aspect, the value of the
expression is converted to the subtype Priority; for the
Interrupt_Priority aspect, this value is converted to the subtype
Any_Priority.  The priority value is then associated with the task
object. 

18/3
Likewise, the priority value is associated with the environment task if
the aspect is specified for the main subprogram.

19/3
The initial value of a task's base priority is specified by default or
by means of a Priority or Interrupt_Priority aspect.  After a task is
created, its base priority can be changed only by a call to
Dynamic_Priorities.Set_Priority (see *note D.5::).  The initial base
priority of a task in the absence of an aspect is the base priority of
the task that creates it at the time of creation (see *note 9.1::).  If
the aspect Priority is not specified for the main subprogram, the
initial base priority of the environment task is
System.Default_Priority.  The task's active priority is used when the
task competes for processors.  Similarly, the task's active priority is
used to determine the task's position in any queue when Priority_Queuing
is specified (see *note D.4::).

20/2
At any time, the active priority of a task is the maximum of all the
priorities the task is inheriting at that instant.  For a task that is
not held (see *note D.11::), its base priority is a source of priority
inheritance unless otherwise specified for a particular task dispatching
policy.  Other sources of priority inheritance are specified under the
following conditions:

21/1
   * During activation, a task being activated inherits the active
     priority that its activator (see *note 9.2::) had at the time the
     activation was initiated.

22/1
   * During rendezvous, the task accepting the entry call inherits the
     priority of the entry call (see *note 9.5.3:: and *note D.4::).

23
   * During a protected action on a protected object, a task inherits
     the ceiling priority of the protected object (see *note 9.5:: and
     *note D.3::).

24
In all of these cases, the priority ceases to be inherited as soon as
the condition calling for the inheritance no longer exists.

                     _Implementation Requirements_

25
The range of System.Interrupt_Priority shall include at least one value.

26
The range of System.Priority shall include at least 30 values.

     NOTES

27
     4  The priority expression can include references to discriminants
     of the enclosing type.

28
     5  It is a consequence of the active priority rules that at the
     point when a task stops inheriting a priority from another source,
     its active priority is re-evaluated.  This is in addition to other
     instances described in this Annex for such re-evaluation.

29/3
     6  An implementation may provide a nonstandard mode in which tasks
     inherit priorities under conditions other than those specified
     above.


File: arm2012.info,  Node: D.2,  Next: D.3,  Prev: D.1,  Up: Annex D

D.2 Priority Scheduling
=======================

1/3
This subclause describes the rules that determine which task is selected
for execution when more than one task is ready (see *note 9::).

* Menu:

* D.2.1 ::    The Task Dispatching Model
* D.2.2 ::    Task Dispatching Pragmas
* D.2.3 ::    Preemptive Dispatching
* D.2.4 ::    Non-Preemptive Dispatching
* D.2.5 ::    Round Robin Dispatching
* D.2.6 ::    Earliest Deadline First Dispatching


File: arm2012.info,  Node: D.2.1,  Next: D.2.2,  Up: D.2

D.2.1 The Task Dispatching Model
--------------------------------

1/2
The task dispatching model specifies task scheduling, based on
conceptual priority-ordered ready queues.

                          _Static Semantics_

1.1/2
The following language-defined library package exists:

1.2/3
     package Ada.Dispatching is
       pragma Preelaborate(Dispatching);

1.3/3
       procedure Yield;

1.4/3
       Dispatching_Policy_Error : exception;
     end Ada.Dispatching;

1.5/2
Dispatching serves as the parent of other language-defined library units
concerned with task dispatching.

                          _Dynamic Semantics_

2/2
A task can become a running task only if it is ready (see *note 9::) and
the execution resources required by that task are available.  Processors
are allocated to tasks based on each task's active priority.

3
It is implementation defined whether, on a multiprocessor, a task that
is waiting for access to a protected object keeps its processor busy.

4/2
Task dispatching is the process by which one ready task is selected for
execution on a processor.  This selection is done at certain points
during the execution of a task called task dispatching points.  A task
reaches a task dispatching point whenever it becomes blocked, and when
it terminates.  Other task dispatching points are defined throughout
this Annex for specific policies.

5/2
Task dispatching policies are specified in terms of conceptual ready
queues and task states.  A ready queue is an ordered list of ready
tasks.  The first position in a queue is called the head of the queue,
and the last position is called the tail of the queue.  A task is ready
if it is in a ready queue, or if it is running.  Each processor has one
ready queue for each priority value.  At any instant, each ready queue
of a processor contains exactly the set of tasks of that priority that
are ready for execution on that processor, but are not running on any
processor; that is, those tasks that are ready, are not running on any
processor, and can be executed using that processor and other available
resources.  A task can be on the ready queues of more than one
processor.

6/2
Each processor also has one running task, which is the task currently
being executed by that processor.  Whenever a task running on a
processor reaches a task dispatching point it goes back to one or more
ready queues; a task (possibly the same task) is then selected to run on
that processor.  The task selected is the one at the head of the highest
priority nonempty ready queue; this task is then removed from all ready
queues to which it belongs.

7/3
A call of Yield is a task dispatching point.  Yield is a potentially
blocking operation (see *note 9.5.1::).

8/2
This paragraph was deleted.

                     _Implementation Permissions_

9/2
An implementation is allowed to define additional resources as execution
resources, and to define the corresponding allocation policies for them.
Such resources may have an implementation-defined effect on task
dispatching.

10
An implementation may place implementation-defined restrictions on tasks
whose active priority is in the Interrupt_Priority range.

10.1/2
For optimization purposes, an implementation may alter the points at
which task dispatching occurs, in an implementation-defined manner.
However, a delay_statement always corresponds to at least one task
dispatching point.

     NOTES

11/3
     7  Clause *note 9:: specifies under which circumstances a task
     becomes ready.  The ready state is affected by the rules for task
     activation and termination, delay statements, and entry calls. When
     a task is not ready, it is said to be blocked.

12
     8  An example of a possible implementation-defined execution
     resource is a page of physical memory, which needs to be loaded
     with a particular page of virtual memory before a task can continue
     execution.

13
     9  The ready queues are purely conceptual; there is no requirement
     that such lists physically exist in an implementation.

14
     10  While a task is running, it is not on any ready queue.  Any
     time the task that is running on a processor is added to a ready
     queue, a new running task is selected for that processor.

15
     11  In a multiprocessor system, a task can be on the ready queues
     of more than one processor.  At the extreme, if several processors
     share the same set of ready tasks, the contents of their ready
     queues is identical, and so they can be viewed as sharing one ready
     queue, and can be implemented that way.  Thus, the dispatching
     model covers multiprocessors where dispatching is implemented using
     a single ready queue, as well as those with separate dispatching
     domains.

16
     12  The priority of a task is determined by rules specified in this
     subclause, and under *note D.1::, "*note D.1:: Task Priorities",
     *note D.3::, "*note D.3:: Priority Ceiling Locking", and *note
     D.5::, "*note D.5:: Dynamic Priorities".

17/2
     13  The setting of a task's base priority as a result of a call to
     Set_Priority does not always take effect immediately when
     Set_Priority is called.  The effect of setting the task's base
     priority is deferred while the affected task performs a protected
     action.


File: arm2012.info,  Node: D.2.2,  Next: D.2.3,  Prev: D.2.1,  Up: D.2

D.2.2 Task Dispatching Pragmas
------------------------------

1/3
This subclause allows a single task dispatching policy to be defined for
all priorities, or the range of priorities to be split into subranges
that are assigned individual dispatching policies.

                               _Syntax_

2
     The form of a pragma Task_Dispatching_Policy is as follows:

3
       pragma Task_Dispatching_Policy(policy_identifier);

3.1/2
     The form of a pragma Priority_Specific_Dispatching is as follows:

3.2/2
       pragma Priority_Specific_Dispatching (
          policy_identifier, first_priority_expression, last_priority_
     expression);

                        _Name Resolution Rules_

3.3/2
The expected type for first_priority_expression and
last_priority_expression is Integer.

                           _Legality Rules_

4/2
The policy_identifier used in a pragma Task_Dispatching_Policy shall be
the name of a task dispatching policy.

4.1/2
The policy_identifier used in a pragma Priority_Specific_Dispatching
shall be the name of a task dispatching policy.

4.2/2
Both first_priority_expression and last_priority_expression shall be
static expressions in the range of System.Any_Priority;
last_priority_expression shall have a value greater than or equal to
first_priority_expression.

                          _Static Semantics_

4.3/2
Pragma Task_Dispatching_Policy specifies the single task dispatching
policy.

4.4/2
Pragma Priority_Specific_Dispatching specifies the task dispatching
policy for the specified range of priorities.  Tasks with base
priorities within the range of priorities specified in a
Priority_Specific_Dispatching pragma have their active priorities
determined according to the specified dispatching policy.  Tasks with
active priorities within the range of priorities specified in a
Priority_Specific_Dispatching pragma are dispatched according to the
specified dispatching policy.

4.5/3
If a partition contains one or more Priority_Specific_Dispatching
pragmas, the dispatching policy for priorities not covered by any
Priority_Specific_Dispatching pragmas is FIFO_Within_Priorities.

                       _Post-Compilation Rules_

5/2
A Task_Dispatching_Policy pragma is a configuration pragma.  A
Priority_Specific_Dispatching pragma is a configuration pragma. 

5.1/2
The priority ranges specified in more than one
Priority_Specific_Dispatching pragma within the same partition shall not
be overlapping.

5.2/2
If a partition contains one or more Priority_Specific_Dispatching
pragmas it shall not contain a Task_Dispatching_Policy pragma.

6/2
This paragraph was deleted.

                          _Dynamic Semantics_

7/2
A task dispatching policy specifies the details of task dispatching that
are not covered by the basic task dispatching model.  These rules govern
when tasks are inserted into and deleted from the ready queues.  A
single task dispatching policy is specified by a Task_Dispatching_Policy
pragma.  Pragma Priority_Specific_Dispatching assigns distinct
dispatching policies to subranges of System.Any_Priority.

7.1/2
If neither pragma applies to any of the program units comprising a
partition, the task dispatching policy for that partition is
unspecified.

7.2/3
If a partition contains one or more Priority_Specific_Dispatching
pragmas, a task dispatching point occurs for the currently running task
of a processor whenever there is a nonempty ready queue for that
processor with a higher priority than the priority of the running task.

7.3/2
A task that has its base priority changed may move from one dispatching
policy to another.  It is immediately subject to the new dispatching
policy.

Paragraphs 7 through 13 were moved to D.2.3.

                     _Implementation Requirements_

14.1/2
An implementation shall allow, for a single partition, both the locking
policy (see *note D.3::) to be specified as Ceiling_Locking and also one
or more Priority_Specific_Dispatching pragmas to be given.

                     _Documentation Requirements_

Paragraphs 14 through 16 were moved to D.2.3.

                     _Implementation Permissions_

18/2
Implementations are allowed to define other task dispatching policies,
but need not support more than one task dispatching policy per
partition.

19/2
An implementation need not support pragma Priority_Specific_Dispatching
if it is infeasible to support it in the target environment.

     NOTES

     Paragraphs 19 through 21 were deleted.


File: arm2012.info,  Node: D.2.3,  Next: D.2.4,  Prev: D.2.2,  Up: D.2

D.2.3 Preemptive Dispatching
----------------------------

1/3
This subclause defines a preemptive task dispatching policy.

                          _Static Semantics_

2/2
The policy_identifier FIFO_Within_Priorities is a task dispatching
policy.

                          _Dynamic Semantics_

3/2
When FIFO_Within_Priorities is in effect, modifications to the ready
queues occur only as follows:

4/2
   * When a blocked task becomes ready, it is added at the tail of the
     ready queue for its active priority.

5/2
   * When the active priority of a ready task that is not running
     changes, or the setting of its base priority takes effect, the task
     is removed from the ready queue for its old active priority and is
     added at the tail of the ready queue for its new active priority,
     except in the case where the active priority is lowered due to the
     loss of inherited priority, in which case the task is added at the
     head of the ready queue for its new active priority.

6/2
   * When the setting of the base priority of a running task takes
     effect, the task is added to the tail of the ready queue for its
     active priority.

7/2
   * When a task executes a delay_statement that does not result in
     blocking, it is added to the tail of the ready queue for its active
     priority.

8/2
Each of the events specified above is a task dispatching point (see
*note D.2.1::).

9/2
A task dispatching point occurs for the currently running task of a
processor whenever there is a nonempty ready queue for that processor
with a higher priority than the priority of the running task.  The
currently running task is said to be preempted and it is added at the
head of the ready queue for its active priority.

                     _Implementation Requirements_

10/2
An implementation shall allow, for a single partition, both the task
dispatching policy to be specified as FIFO_Within_Priorities and also
the locking policy (see *note D.3::) to be specified as Ceiling_Locking.

                     _Documentation Requirements_

11/2
Priority inversion is the duration for which a task remains at the head
of the highest priority nonempty ready queue while the processor
executes a lower priority task.  The implementation shall document:

12/2
   * The maximum priority inversion a user task can experience due to
     activity of the implementation (on behalf of lower priority tasks),
     and

13/2
   * whether execution of a task can be preempted by the implementation
     processing of delay expirations for lower priority tasks, and if
     so, for how long.

     NOTES

14/2
     14  If the active priority of a running task is lowered due to loss
     of inherited priority (as it is on completion of a protected
     operation) and there is a ready task of the same active priority
     that is not running, the running task continues to run (provided
     that there is no higher priority task).

15/2
     15  Setting the base priority of a ready task causes the task to
     move to the tail of the queue for its active priority, regardless
     of whether the active priority of the task actually changes.


File: arm2012.info,  Node: D.2.4,  Next: D.2.5,  Prev: D.2.3,  Up: D.2

D.2.4 Non-Preemptive Dispatching
--------------------------------

1/3
This subclause defines a non-preemptive task dispatching policy.

                          _Static Semantics_

2/2
The policy_identifier Non_Preemptive_FIFO_Within_Priorities is a task
dispatching policy.

2.1/3
The following language-defined library package exists:

2.2/3
     package Ada.Dispatching.Non_Preemptive is
       pragma Preelaborate(Non_Preemptive);
       procedure Yield_To_Higher;
       procedure Yield_To_Same_Or_Higher renames Yield;
     end Ada.Dispatching.Non_Preemptive;

2.3/3
A call of Yield_To_Higher is a task dispatching point for this policy.
If the task at the head of the highest priority ready queue has a higher
active priority than the calling task, then the calling task is
preempted.

                           _Legality Rules_

3/2
Non_Preemptive_FIFO_Within_Priorities shall not be specified as the
policy_identifier of pragma Priority_Specific_Dispatching (see *note
D.2.2::).

                          _Dynamic Semantics_

4/2
When Non_Preemptive_FIFO_Within_Priorities is in effect, modifications
to the ready queues occur only as follows:

5/2
   * When a blocked task becomes ready, it is added at the tail of the
     ready queue for its active priority.

6/2
   * When the active priority of a ready task that is not running
     changes, or the setting of its base priority takes effect, the task
     is removed from the ready queue for its old active priority and is
     added at the tail of the ready queue for its new active priority.

7/2
   * When the setting of the base priority of a running task takes
     effect, the task is added to the tail of the ready queue for its
     active priority.

8/2
   * When a task executes a delay_statement that does not result in
     blocking, it is added to the tail of the ready queue for its active
     priority.

9/3
For this policy, blocking or termination of a task, a delay_statement, a
call to Yield_To_Higher, and a call to Yield_To_Same_Or_Higher or Yield
are the only task dispatching points (see *note D.2.1::). 

                     _Implementation Requirements_

10/2
An implementation shall allow, for a single partition, both the task
dispatching policy to be specified as
Non_Preemptive_FIFO_Within_Priorities and also the locking policy (see
*note D.3::) to be specified as Ceiling_Locking.

                     _Implementation Permissions_

11/3
Since implementations are allowed to round all ceiling priorities in
subrange System.Priority to System.Priority'Last (see *note D.3::), an
implementation may allow a task of a partition using the
Non_Premptive_FIFO_Within_Priorities policy to execute within a
protected object without raising its active priority provided the
associated protected unit does not contain any subprograms with aspects
Interrupt_Handler or Attach_Handler specified, nor does the unit have
aspect Interrupt_Priority specified.  When the locking policy (see *note
D.3::) is Ceiling_Locking, an implementation taking advantage of this
permission shall ensure that a call to Yield_to_Higher that occurs
within a protected action uses the ceiling priority of the protected
object (rather than the active priority of the task) when determining
whether to preempt the task.


File: arm2012.info,  Node: D.2.5,  Next: D.2.6,  Prev: D.2.4,  Up: D.2

D.2.5 Round Robin Dispatching
-----------------------------

1/3
This subclause defines the task dispatching policy
Round_Robin_Within_Priorities and the package Round_Robin.

                          _Static Semantics_

2/2
The policy_identifier Round_Robin_Within_Priorities is a task
dispatching policy.

3/2
The following language-defined library package exists:

4/2
     with System;
     with Ada.Real_Time;
     package Ada.Dispatching.Round_Robin is
       Default_Quantum : constant Ada.Real_Time.Time_Span :=
                  implementation-defined;
       procedure Set_Quantum (Pri     : in System.Priority;
                              Quantum : in Ada.Real_Time.Time_Span);
       procedure Set_Quantum (Low, High : in System.Priority;
                              Quantum   : in Ada.Real_Time.Time_Span);
       function Actual_Quantum (Pri : System.Priority)
                  return Ada.Real_Time.Time_Span;
       function Is_Round_Robin (Pri : System.Priority) return Boolean;
     end Ada.Dispatching.Round_Robin;

5/2
When task dispatching policy Round_Robin_Within_Priorities is the single
policy in effect for a partition, each task with priority in the range
of System.Interrupt_Priority is dispatched according to policy
FIFO_Within_Priorities.

                          _Dynamic Semantics_

6/2
The procedures Set_Quantum set the required Quantum value for a single
priority level Pri or a range of priority levels Low ..  High.  If no
quantum is set for a Round Robin priority level, Default_Quantum is
used.

7/2
The function Actual_Quantum returns the actual quantum used by the
implementation for the priority level Pri.

8/3
The function Is_Round_Robin returns True if priority Pri is covered by
task dispatching policy Round_Robin_Within_Priorities; otherwise, it
returns False.

9/2
A call of Actual_Quantum or Set_Quantum raises exception
Dispatching.Dispatching_Policy_Error if a predefined policy other than
Round_Robin_Within_Priorities applies to the specified priority or any
of the priorities in the specified range.

10/2
For Round_Robin_Within_Priorities, the dispatching rules for
FIFO_Within_Priorities apply with the following additional rules:

11/2
   * When a task is added or moved to the tail of the ready queue for
     its base priority, it has an execution time budget equal to the
     quantum for that priority level.  This will also occur when a
     blocked task becomes executable again.

12/2
   * When a task is preempted (by a higher priority task) and is added
     to the head of the ready queue for its priority level, it retains
     its remaining budget.

13/2
   * While a task is executing, its budget is decreased by the amount of
     execution time it uses.  The accuracy of this accounting is the
     same as that for execution time clocks (see *note D.14::).

14/2
   * When a task has exhausted its budget and is without an inherited
     priority (and is not executing within a protected operation), it is
     moved to the tail of the ready queue for its priority level.  This
     is a task dispatching point.

                     _Implementation Requirements_

15/2
An implementation shall allow, for a single partition, both the task
dispatching policy to be specified as Round_Robin_Within_Priorities and
also the locking policy (see *note D.3::) to be specified as
Ceiling_Locking.

                     _Documentation Requirements_

16/2
An implementation shall document the quantum values supported.

17/2
An implementation shall document the accuracy with which it detects the
exhaustion of the budget of a task.

     NOTES

18/2
     16  Due to implementation constraints, the quantum value returned
     by Actual_Quantum might not be identical to that set with
     Set_Quantum.

19/2
     17  A task that executes continuously with an inherited priority
     will not be subject to round robin dispatching.


File: arm2012.info,  Node: D.2.6,  Prev: D.2.5,  Up: D.2

D.2.6 Earliest Deadline First Dispatching
-----------------------------------------

1/2
The deadline of a task is an indication of the urgency of the task; it
represents a point on an ideal physical time line.  The deadline might
affect how resources are allocated to the task.

2/3
This subclause defines a package for representing the deadline of a task
and a dispatching policy that defines Earliest Deadline First (EDF)
dispatching.  An aspect is defined to assign an initial deadline to a
task.

Paragraphs 3 through 6 were moved to *note Annex J::, "*note Annex J::
Obsolescent Features".

                          _Static Semantics_

7/2
The policy_identifier EDF_Across_Priorities is a task dispatching
policy.

8/2
The following language-defined library package exists:

9/2
     with Ada.Real_Time;
     with Ada.Task_Identification;
     package Ada.Dispatching.EDF is
       subtype Deadline is Ada.Real_Time.Time;
       Default_Deadline : constant Deadline :=
                   Ada.Real_Time.Time_Last;
       procedure Set_Deadline (D : in Deadline;
                   T : in Ada.Task_Identification.Task_Id :=
                   Ada.Task_Identification.Current_Task);
       procedure Delay_Until_And_Set_Deadline (
                   Delay_Until_Time : in Ada.Real_Time.Time;
                   Deadline_Offset : in Ada.Real_Time.Time_Span);
       function Get_Deadline (T : Ada.Task_Identification.Task_Id :=
                   Ada.Task_Identification.Current_Task) return Deadline;
     end Ada.Dispatching.EDF;

9.1/3
For a task type (including the anonymous type of a
single_task_declaration) or subprogram, the following language-defined
representation aspect may be specified:

9.2/3
Relative_Deadline
               The aspect Relative_Deadline is an expression, which
               shall be of type Real_Time.Time_Span.

                           _Legality Rules_

9.3/3
The Relative_Deadline aspect shall not be specified on a task interface
type.

                       _Post-Compilation Rules_

10/2
If the EDF_Across_Priorities policy is specified for a partition, then
the Ceiling_Locking policy (see *note D.3::) shall also be specified for
the partition.

11/2
If the EDF_Across_Priorities policy appears in a
Priority_Specific_Dispatching pragma (see *note D.2.2::) in a partition,
then the Ceiling_Locking policy (see *note D.3::) shall also be
specified for the partition.

                          _Dynamic Semantics_

12/3
The Relative_Deadline aspect has no effect if it is specified for a
subprogram other than the main subprogram.

13/3
The initial absolute deadline of a task for which aspect
Relative_Deadline is specified is the value of Real_Time.Clock + the
expression that is the value of the aspect, where this entire
expression, including the call of Real_Time.Clock, is evaluated between
task creation and the start of its activation.  If the aspect
Relative_Deadline is not specified, then the initial absolute deadline
of a task is the value of Default_Deadline.  The environment task is
also given an initial deadline by this rule, using the value of the
Relative_Deadline aspect of the main subprogram (if any).

14/2
The procedure Set_Deadline changes the absolute deadline of the task to
D. The function Get_Deadline returns the absolute deadline of the task.

15/2
The procedure Delay_Until_And_Set_Deadline delays the calling task until
time Delay_Until_Time.  When the task becomes runnable again it will
have deadline Delay_Until_Time + Deadline_Offset.

16/2
On a system with a single processor, the setting of the deadline of a
task to the new value occurs immediately at the first point that is
outside the execution of a protected action.  If the task is currently
on a ready queue it is removed and re-entered on to the ready queue
determined by the rules defined below.

17/2
When EDF_Across_Priorities is specified for priority range Low..High all
ready queues in this range are ordered by deadline.  The task at the
head of a queue is the one with the earliest deadline.

18/2
A task dispatching point occurs for the currently running task T to
which policy EDF_Across_Priorities applies:

19/2
   * when a change to the deadline of T occurs;

20/2
   * there is a task on the ready queue for the active priority of T
     with a deadline earlier than the deadline of T; or

21/2
   * there is a nonempty ready queue for that processor with a higher
     priority than the active priority of the running task.

22/2
In these cases, the currently running task is said to be preempted and
is returned to the ready queue for its active priority.

23/2
For a task T to which policy EDF_Across_Priorities applies, the base
priority is not a source of priority inheritance; the active priority
when first activated or while it is blocked is defined as the maximum of
the following:

24/2
   * the lowest priority in the range specified as EDF_Across_Priorities
     that includes the base priority of T;

25/2
   * the priorities, if any, currently inherited by T;

26/3
   * the highest priority P, if any, less than the base priority of T
     such that one or more tasks are executing within a protected object
     with ceiling priority P and task T has an earlier deadline than all
     such tasks; and furthermore T has an earlier deadline than all
     other tasks on ready queues with priorities in the given
     EDF_Across_Priorities range that are strictly less than P.

27/2
When a task T is first activated or becomes unblocked, it is added to
the ready queue corresponding to this active priority.  Until it becomes
blocked again, the active priority of T remains no less than this value;
it will exceed this value only while it is inheriting a higher priority.

28/2
When the setting of the base priority of a ready task takes effect and
the new priority is in a range specified as EDF_Across_Priorities, the
task is added to the ready queue corresponding to its new active
priority, as determined above.

29/2
For all the operations defined in Dispatching.EDF, Tasking_Error is
raised if the task identified by T has terminated.  Program_Error is
raised if the value of T is Null_Task_Id.

                      _Bounded (Run-Time) Errors_

30/2
If EDF_Across_Priorities is specified for priority range Low..High, it
is a bounded error to declare a protected object with ceiling priority
Low or to assign the value Low to attribute 'Priority.  In either case
either Program_Error is raised or the ceiling of the protected object is
assigned the value Low+1.

                         _Erroneous Execution_

31/2
If a value of Task_Id is passed as a parameter to any of the subprograms
of this package and the corresponding task object no longer exists, the
execution of the program is erroneous.

                     _Documentation Requirements_

32/2
On a multiprocessor, the implementation shall document any conditions
that cause the completion of the setting of the deadline of a task to be
delayed later than what is specified for a single processor.

     NOTES

33/3
     18  If two adjacent priority ranges, A..B and B+1..C are specified
     to have policy EDF_Across_Priorities, then this is not equivalent
     to this policy being specified for the single range, A..C.

34/2
     19  The above rules implement the preemption-level protocol (also
     called Stack Resource Policy protocol) for resource sharing under
     EDF dispatching.  The preemption-level for a task is denoted by its
     base priority.  The definition of a ceiling preemption-level for a
     protected object follows the existing rules for ceiling locking.


File: arm2012.info,  Node: D.3,  Next: D.4,  Prev: D.2,  Up: Annex D

D.3 Priority Ceiling Locking
============================

1/3
This subclause specifies the interactions between priority task
scheduling and protected object ceilings.  This interaction is based on
the concept of the ceiling priority of a protected object.

                               _Syntax_

2
     The form of a pragma Locking_Policy is as follows:

3
       pragma Locking_Policy(policy_identifier);

                           _Legality Rules_

4
The policy_identifier shall either be Ceiling_Locking or an
implementation-defined identifier.

                       _Post-Compilation Rules_

5
A Locking_Policy pragma is a configuration pragma.

                          _Dynamic Semantics_

6/2
A locking policy specifies the details of protected object locking.  All
protected objects have a priority.  The locking policy specifies the
meaning of the priority of a protected object, and the relationships
between these priorities and task priorities.  In addition, the policy
specifies the state of a task when it executes a protected action, and
how its active priority is affected by the locking.  The locking policy
is specified by a Locking_Policy pragma.  For implementation-defined
locking policies, the meaning of the priority of a protected object is
implementation defined.  If no Locking_Policy pragma applies to any of
the program units comprising a partition, the locking policy for that
partition, as well as the meaning of the priority of a protected object,
are implementation defined. 

6.1/3
The expression specified for the Priority or Interrupt_Priority aspect
(see *note D.1::) is evaluated as part of the creation of the
corresponding protected object and converted to the subtype
System.Any_Priority or System.Interrupt_Priority, respectively.  The
value of the expression is the initial priority of the corresponding
protected object.  If no Priority or Interrupt_Priority aspect is
specified for a protected object, the initial priority is specified by
the locking policy. 

7
There is one predefined locking policy, Ceiling_Locking; this policy is
defined as follows:

8/3
   * Every protected object has a ceiling priority, which is determined
     by either a Priority or Interrupt_Priority aspect as defined in
     *note D.1::, or by assignment to the Priority attribute as
     described in *note D.5.2::.  The ceiling priority of a protected
     object (or ceiling, for short) is an upper bound on the active
     priority a task can have when it calls protected operations of that
     protected object.

9/2
   * The initial ceiling priority of a protected object is equal to the
     initial priority for that object.

10/4
   * If an Interrupt_Handler or Attach_Handler aspect (see *note
     C.3.1::) is specified for a protected subprogram of a protected
     type that does not have either the Priority or Interrupt_Priority
     aspect specified, the initial priority of protected objects of that
     type is implementation defined, but in the range of the subtype
     System.Interrupt_Priority.

11/3
   * If neither aspect Priority nor Interrupt_Priority is specified for
     a protected type, and no protected subprogram of the type has
     aspect Interrupt_Handler or Attach_Handler specified, then the
     initial priority of the corresponding protected object is
     System.Priority'Last.

12
   * While a task executes a protected action, it inherits the ceiling
     priority of the corresponding protected object.

13
   * When a task calls a protected operation, a check is made that its
     active priority is not higher than the ceiling of the corresponding
     protected object; Program_Error is raised if this check fails.

                      _Bounded (Run-Time) Errors_

13.1/2
Following any change of priority, it is a bounded error for the active
priority of any task with a call queued on an entry of a protected
object to be higher than the ceiling priority of the protected object.
In this case one of the following applies:

13.2/2
   * at any time prior to executing the entry body Program_Error is
     raised in the calling task; 

13.3/2
   * when the entry is open the entry body is executed at the ceiling
     priority of the protected object;

13.4/2
   * when the entry is open the entry body is executed at the ceiling
     priority of the protected object and then Program_Error is raised
     in the calling task; or 

13.5/2
   * when the entry is open the entry body is executed at the ceiling
     priority of the protected object that was in effect when the entry
     call was queued.

                     _Implementation Permissions_

14
The implementation is allowed to round all ceilings in a certain
subrange of System.Priority or System.Interrupt_Priority up to the top
of that subrange, uniformly.

15/2
Implementations are allowed to define other locking policies, but need
not support more than one locking policy per partition.

16
Since implementations are allowed to place restrictions on code that
runs at an interrupt-level active priority (see *note C.3.1:: and *note
D.2.1::), the implementation may implement a language feature in terms
of a protected object with an implementation-defined ceiling, but the
ceiling shall be no less than Priority'Last.

                        _Implementation Advice_

17
The implementation should use names that end with "_Locking" for
implementation-defined locking policies.

     NOTES

18
     20  While a task executes in a protected action, it can be
     preempted only by tasks whose active priorities are higher than the
     ceiling priority of the protected object.

19
     21  If a protected object has a ceiling priority in the range of
     Interrupt_Priority, certain interrupts are blocked while protected
     actions of that object execute.  In the extreme, if the ceiling is
     Interrupt_Priority'Last, all blockable interrupts are blocked
     during that time.

20
     22  The ceiling priority of a protected object has to be in the
     Interrupt_Priority range if one of its procedures is to be used as
     an interrupt handler (see *note C.3::).

21
     23  When specifying the ceiling of a protected object, one should
     choose a value that is at least as high as the highest active
     priority at which tasks can be executing when they call protected
     operations of that object.  In determining this value the following
     factors, which can affect active priority, should be considered:
     the effect of Set_Priority, nested protected operations, entry
     calls, task activation, and other implementation-defined factors.

22
     24  Attaching a protected procedure whose ceiling is below the
     interrupt hardware priority to an interrupt causes the execution of
     the program to be erroneous (see *note C.3.1::).

23
     25  On a single processor implementation, the ceiling priority
     rules guarantee that there is no possibility of deadlock involving
     only protected subprograms (excluding the case where a protected
     operation calls another protected operation on the same protected
     object).


File: arm2012.info,  Node: D.4,  Next: D.5,  Prev: D.3,  Up: Annex D

D.4 Entry Queuing Policies
==========================

1/3
This subclause specifies a mechanism for a user to choose an entry
queuing policy.  It also defines two such policies.  Other policies are
implementation defined.

                               _Syntax_

2
     The form of a pragma Queuing_Policy is as follows:

3
       pragma Queuing_Policy(policy_identifier);

                           _Legality Rules_

4
The policy_identifier shall be either FIFO_Queuing, Priority_Queuing or
an implementation-defined identifier.

                       _Post-Compilation Rules_

5
A Queuing_Policy pragma is a configuration pragma.

                          _Dynamic Semantics_

6
A queuing policy governs the order in which tasks are queued for entry
service, and the order in which different entry queues are considered
for service.  The queuing policy is specified by a Queuing_Policy
pragma.

7/2
Two queuing policies, FIFO_Queuing and Priority_Queuing, are language
defined.  If no Queuing_Policy pragma applies to any of the program
units comprising the partition, the queuing policy for that partition is
FIFO_Queuing.  The rules for this policy are specified in *note 9.5.3::
and *note 9.7.1::.

8
The Priority_Queuing policy is defined as follows:

9
   * The calls to an entry (including a member of an entry family) are
     queued in an order consistent with the priorities of the calls.
     The priority of an entry call is initialized from the active
     priority of the calling task at the time the call is made, but can
     change later.  Within the same priority, the order is consistent
     with the calling (or requeuing, or priority setting) time (that is,
     a FIFO order).

10/1
   * After a call is first queued, changes to the active priority of a
     task do not affect the priority of the call, unless the base
     priority of the task is set while the task is blocked on an entry
     call.

11
   * When the base priority of a task is set (see *note D.5::), if the
     task is blocked on an entry call, and the call is queued, the
     priority of the call is updated to the new active priority of the
     calling task.  This causes the call to be removed from and then
     reinserted in the queue at the new active priority.

12
   * When more than one condition of an entry_barrier of a protected
     object becomes True, and more than one of the respective queues is
     nonempty, the call with the highest priority is selected.  If more
     than one such call has the same priority, the call that is queued
     on the entry whose declaration is first in textual order in the
     protected_definition is selected.  For members of the same entry
     family, the one with the lower family index is selected.

13
   * If the expiration time of two or more open delay_alternatives is
     the same and no other accept_alternatives are open, the
     sequence_of_statements of the delay_alternative that is first in
     textual order in the selective_accept is executed.

14
   * When more than one alternative of a selective_accept is open and
     has queued calls, an alternative whose queue has the
     highest-priority call at its head is selected.  If two or more open
     alternatives have equal-priority queued calls, then a call on the
     entry in the accept_alternative that is first in textual order in
     the selective_accept is selected.

                     _Implementation Permissions_

15/2
Implementations are allowed to define other queuing policies, but need
not support more than one queuing policy per partition.

15.1/2
Implementations are allowed to defer the reordering of entry queues
following a change of base priority of a task blocked on the entry call
if it is not practical to reorder the queue immediately.

                        _Implementation Advice_

16
The implementation should use names that end with "_Queuing" for
implementation-defined queuing policies.


File: arm2012.info,  Node: D.5,  Next: D.6,  Prev: D.4,  Up: Annex D

D.5 Dynamic Priorities
======================

1/3
This subclause describes how the priority of an entity can be modified
or queried at run time.

* Menu:

* D.5.1 ::    Dynamic Priorities for Tasks
* D.5.2 ::    Dynamic Priorities for Protected Objects


File: arm2012.info,  Node: D.5.1,  Next: D.5.2,  Up: D.5

D.5.1 Dynamic Priorities for Tasks
----------------------------------

1/3
This subclause describes how the base priority of a task can be modified
or queried at run time.

                          _Static Semantics_

2
The following language-defined library package exists:

3/2
     with System;
     with Ada.Task_Identification; -- See *note C.7.1::
     package Ada.Dynamic_Priorities is
         pragma Preelaborate(Dynamic_Priorities);

4
         procedure Set_Priority(Priority : in System.Any_Priority;
                                T : in Ada.Task_Identification.Task_Id :=
                                Ada.Task_Identification.Current_Task);

5
         function Get_Priority (T : Ada.Task_Identification.Task_Id :=
                                Ada.Task_Identification.Current_Task)
                                return System.Any_Priority;

6
     end Ada.Dynamic_Priorities;

                          _Dynamic Semantics_

7
The procedure Set_Priority sets the base priority of the specified task
to the specified Priority value.  Set_Priority has no effect if the task
is terminated.

8
The function Get_Priority returns T's current base priority.
Tasking_Error is raised if the task is terminated.

9
Program_Error is raised by Set_Priority and Get_Priority if T is equal
to Null_Task_Id.

10/2
On a system with a single processor, the setting of the base priority of
a task T to the new value occurs immediately at the first point when T
is outside the execution of a protected action.

Paragraph 11 was deleted.

                         _Erroneous Execution_

12
If any subprogram in this package is called with a parameter T that
specifies a task object that no longer exists, the execution of the
program is erroneous.

                     _Documentation Requirements_

12.1/2
On a multiprocessor, the implementation shall document any conditions
that cause the completion of the setting of the priority of a task to be
delayed later than what is specified for a single processor.

                               _Metrics_

13
The implementation shall document the following metric:

14
   * The execution time of a call to Set_Priority, for the nonpreempting
     case, in processor clock cycles.  This is measured for a call that
     modifies the priority of a ready task that is not running (which
     cannot be the calling one), where the new base priority of the
     affected task is lower than the active priority of the calling
     task, and the affected task is not on any entry queue and is not
     executing a protected operation.

     NOTES

15/2
     26  Setting a task's base priority affects task dispatching.
     First, it can change the task's active priority.  Second, under the
     FIFO_Within_Priorities policy it always causes the task to move to
     the tail of the ready queue corresponding to its active priority,
     even if the new base priority is unchanged.

16
     27  Under the priority queuing policy, setting a task's base
     priority has an effect on a queued entry call if the task is
     blocked waiting for the call.  That is, setting the base priority
     of a task causes the priority of a queued entry call from that task
     to be updated and the call to be removed and then reinserted in the
     entry queue at the new priority (see *note D.4::), unless the call
     originated from the triggering_statement of an asynchronous_select.

17
     28  The effect of two or more Set_Priority calls executed in
     parallel on the same task is defined as executing these calls in
     some serial order.

18/3
     29  The rule for when Tasking_Error is raised for Set_Priority or
     Get_Priority is different from the rule for when Tasking_Error is
     raised on an entry call (see *note 9.5.3::).  In particular,
     querying the priority of a completed or an abnormal task is
     allowed, so long as the task is not yet terminated, and setting the
     priority of a task is allowed for any task state (including for
     terminated tasks).

19
     30  Changing the priorities of a set of tasks can be performed by a
     series of calls to Set_Priority for each task separately.  For this
     to work reliably, it should be done within a protected operation
     that has high enough ceiling priority to guarantee that the
     operation completes without being preempted by any of the affected
     tasks.


File: arm2012.info,  Node: D.5.2,  Prev: D.5.1,  Up: D.5

D.5.2 Dynamic Priorities for Protected Objects
----------------------------------------------

1/3
This subclause specifies how the priority of a protected object can be
modified or queried at run time.

                          _Static Semantics_

2/2
The following attribute is defined for a prefix P that denotes a
protected object:

3/2
P'Priority
               Denotes a non-aliased component of the protected object
               P. This component is of type System.Any_Priority and its
               value is the priority of P. P'Priority denotes a variable
               if and only if P denotes a variable.  A reference to this
               attribute shall appear only within the body of P.

4/2
The initial value of this attribute is the initial value of the priority
of the protected object, and can be changed by an assignment.

                          _Dynamic Semantics_

5/3
If the locking policy Ceiling_Locking (see *note D.3::) is in effect,
then the ceiling priority of a protected object P is set to the value of
P'Priority at the end of each protected action of P.

6/3
If the locking policy Ceiling_Locking is in effect, then for a protected
object P with either an Attach_Handler or Interrupt_Handler aspect
specified for one of its procedures, a check is made that the value to
be assigned to P'Priority is in the range System.Interrupt_Priority.  If
the check fails, Program_Error is raised.

                               _Metrics_

7/2
The implementation shall document the following metric:

8/2
   * The difference in execution time of calls to the following
     procedures in protected object P:

9/2
     protected P is
        procedure Do_Not_Set_Ceiling (Pr : System.Any_Priority);
        procedure Set_Ceiling (Pr : System.Any_Priority);
     end P;

10/2
     protected body P is
        procedure Do_Not_Set_Ceiling (Pr : System.Any_Priority) is
        begin
           null;
        end;
        procedure Set_Ceiling (Pr : System.Any_Priority) is
        begin
           P'Priority := Pr;
        end;
     end P;

     NOTES

11/2
     31  Since P'Priority is a normal variable, the value following an
     assignment to the attribute immediately reflects the new value even
     though its impact on the ceiling priority of P is postponed until
     completion of the protected action in which it is executed.


File: arm2012.info,  Node: D.6,  Next: D.7,  Prev: D.5,  Up: Annex D

D.6 Preemptive Abort
====================

1/3
This subclause specifies requirements on the immediacy with which an
aborted construct is completed.

                          _Dynamic Semantics_

2
On a system with a single processor, an aborted construct is completed
immediately at the first point that is outside the execution of an
abort-deferred operation.

                     _Documentation Requirements_

3
On a multiprocessor, the implementation shall document any conditions
that cause the completion of an aborted construct to be delayed later
than what is specified for a single processor.

                               _Metrics_

4
The implementation shall document the following metrics:

5
   * The execution time, in processor clock cycles, that it takes for an
     abort_statement to cause the completion of the aborted task.  This
     is measured in a situation where a task T2 preempts task T1 and
     aborts T1.  T1 does not have any finalization code.  T2 shall
     verify that T1 has terminated, by means of the Terminated
     attribute.

6
   * On a multiprocessor, an upper bound in seconds, on the time that
     the completion of an aborted task can be delayed beyond the point
     that it is required for a single processor.

7/2
   * An upper bound on the execution time of an asynchronous_select, in
     processor clock cycles.  This is measured between a point
     immediately before a task T1 executes a protected operation Pr.Set
     that makes the condition of an entry_barrier Pr.Wait True, and the
     point where task T2 resumes execution immediately after an entry
     call to Pr.Wait in an asynchronous_select.  T1 preempts T2 while T2
     is executing the abortable part, and then blocks itself so that T2
     can execute.  The execution time of T1 is measured separately, and
     subtracted.

8
   * An upper bound on the execution time of an asynchronous_select, in
     the case that no asynchronous transfer of control takes place.
     This is measured between a point immediately before a task executes
     the asynchronous_select with a nonnull abortable part, and the
     point where the task continues execution immediately after it.  The
     execution time of the abortable part is subtracted.

                        _Implementation Advice_

9
Even though the abort_statement is included in the list of potentially
blocking operations (see *note 9.5.1::), it is recommended that this
statement be implemented in a way that never requires the task executing
the abort_statement to block.

10
On a multi-processor, the delay associated with aborting a task on
another processor should be bounded; the implementation should use
periodic polling, if necessary, to achieve this.

     NOTES

11
     32  Abortion does not change the active or base priority of the
     aborted task.

12
     33  Abortion cannot be more immediate than is allowed by the rules
     for deferral of abortion during finalization and in protected
     actions.


File: arm2012.info,  Node: D.7,  Next: D.8,  Prev: D.6,  Up: Annex D

D.7 Tasking Restrictions
========================

1/3
This subclause defines restrictions that can be used with a pragma
Restrictions (see *note 13.12::) to facilitate the construction of
highly efficient tasking run-time systems.

                          _Static Semantics_

2
The following restriction_identifiers are language defined:

3/3
No_Task_Hierarchy
               No task depends on a master other than the library-level
               master.

4/3
No_Nested_Finalization
               Objects of a type that needs finalization (see *note
               7.6::) are declared only at library level.  If an access
               type does not have library-level accessibility, then
               there are no allocators of the type where the type
               determined by the subtype_mark of the subtype_indication
               or qualified_expression needs finalization.

5/3
No_Abort_Statements
               There are no abort_statements, and there is no use of a
               name denoting Task_Identification.Abort_Task.

6
No_Terminate_Alternatives
               There are no selective_accepts with
               terminate_alternatives.

7
No_Task_Allocators
               There are no allocators for task types or types
               containing task subcomponents.

7.1/3
               In the case of an initialized allocator of an access type
               whose designated type is class-wide and limited, a check
               is made that the specific type of the allocated object
               has no task subcomponents.  Program_Error is raised if
               this check fails.

8
No_Implicit_Heap_Allocations
               There are no operations that implicitly require heap
               storage allocation to be performed by the implementation.
               The operations that implicitly require heap storage
               allocation are implementation defined.

9/2
No_Dynamic_Priorities
               There are no semantic dependences on the package
               Dynamic_Priorities, and no occurrences of the attribute
               Priority. 

10/3
No_Dynamic_Attachment
               There is no use of a name denoting any of the operations
               defined in package Interrupts (Is_Reserved, Is_Attached,
               Current_Handler, Attach_Handler, Exchange_Handler,
               Detach_Handler, and Reference).

10.1/4
No_Dynamic_CPU_Assignment
               No task has the CPU aspect specified to be a non-static
               expression.  Each task (including the environment task)
               that has the CPU aspect specified as Not_A_Specific_CPU
               will be assigned to a particular implementation-defined
               CPU. The same is true for the environment task when the
               CPU aspect is not specified.  Any other task without a
               CPU aspect will activate and execute on the same
               processor as its activating task.

10.2/3
No_Local_Protected_Objects
               Protected objects are declared only at library level.

10.3/3
No_Local_Timing_Events
               Timing_Events are declared only at library level.

10.4/2
No_Protected_Type_Allocators
               There are no allocators for protected types or types
               containing protected type subcomponents.

10.5/3
               In the case of an initialized allocator of an access type
               whose designated type is class-wide and limited, a check
               is made that the specific type of the allocated object
               has no protected subcomponents.  Program_Error is raised
               if this check fails.

10.6/3
No_Relative_Delay
               There are no delay_relative_statements, and there is no
               use of a name that denotes the Timing_Events.Set_Handler
               subprogram that has a Time_Span parameter.

10.7/3
No_Requeue_Statements
               There are no requeue_statements.

10.8/3
No_Select_Statements
               There are no select_statements.

10.9/3
No_Specific_Termination_Handlers
               There is no use of a name denoting the
               Set_Specific_Handler and Specific_Handler subprograms in
               Task_Termination.

10.10/4
No_Tasks_Unassigned_To_CPU
               The CPU aspect is specified for the environment task.  No
               CPU aspect is specified to be statically equal to
               Not_A_Specific_CPU. If aspect CPU is specified
               (dynamically) to the value Not_A_Specific_CPU, then
               Program_Error is raised.  If Set_CPU or
               Delay_Until_And_Set_CPU are called with the CPU parameter
               equal to Not_A_Specific_CPU, then Program_Error is
               raised.

10.11/3
Simple_Barriers
               The Boolean expression in each entry barrier is either a
               static expression or a name that statically denotes a
               component of the enclosing protected object.

11
The following restriction_parameter_identifiers are language defined:

12
Max_Select_Alternatives
               Specifies the maximum number of alternatives in a
               selective_accept.

13
Max_Task_Entries
               Specifies the maximum number of entries per task.  The
               bounds of every entry family of a task unit shall be
               static, or shall be defined by a discriminant of a
               subtype whose corresponding bound is static.  A value of
               zero indicates that no rendezvous are possible.

14
Max_Protected_Entries
               Specifies the maximum number of entries per protected
               type.  The bounds of every entry family of a protected
               unit shall be static, or shall be defined by a
               discriminant of a subtype whose corresponding bound is
               static. 

                          _Dynamic Semantics_

15/2
The following restriction_identifier is language defined:

15.1/2
No_Task_Termination
               All tasks are nonterminating.  It is
               implementation-defined what happens if a task attempts to
               terminate.  If there is a fall-back handler (see C.7.3)
               set for the partition it should be called when the first
               task attempts to terminate.

16
The following restriction_parameter_identifiers are language defined:

17/1
Max_Storage_At_Blocking
               Specifies the maximum portion (in storage elements) of a
               task's Storage_Size that can be retained by a blocked
               task.  If an implementation chooses to detect a violation
               of this restriction, Storage_Error should be raised; 
               otherwise, the behavior is implementation defined.

18/1
Max_Asynchronous_Select_Nesting
               Specifies the maximum dynamic nesting level of
               asynchronous_selects.  A value of zero prevents the use
               of any asynchronous_select (*note 9.7.4: S0241.) and, if
               a program contains an asynchronous_select (*note 9.7.4:
               S0241.), it is illegal.  If an implementation chooses to
               detect a violation of this restriction for values other
               than zero, Storage_Error should be raised; otherwise, the
               behavior is implementation defined.

19/1
Max_Tasks
               Specifies the maximum number of task creations that may
               be executed over the lifetime of a partition, not
               counting the creation of the environment task.  A value
               of zero prevents any task creation and, if a program
               contains a task creation, it is illegal.  If an
               implementation chooses to detect a violation of this
               restriction, Storage_Error should be raised; otherwise,
               the behavior is implementation defined.

19.1/2
Max_Entry_Queue_Length
               Max_Entry_Queue_Length defines the maximum number of
               calls that are queued on an entry.  Violation of this
               restriction results in the raising of Program_Error at
               the point of the call or requeue.

19.2/3
No_Standard_Allocators_After_Elaboration
               Specifies that an allocator using a standard storage pool
               (see *note 13.11::) shall not occur within a
               parameterless library subprogram, nor within the
               handled_sequence_of_statements of a task body.  For the
               purposes of this rule, an allocator of a type derived
               from a formal access type does not use a standard storage
               pool.

19.3/3
               At run time, Storage_Error is raised if an allocator
               using a standard storage pool is evaluated after the
               elaboration of the library_items of the partition has
               completed.

20
It is implementation defined whether the use of pragma Restrictions
results in a reduction in executable program size, storage requirements,
or execution time.  If possible, the implementation should provide
quantitative descriptions of such effects for each restriction.

                        _Implementation Advice_

21
When feasible, the implementation should take advantage of the specified
restrictions to produce a more efficient implementation.

     NOTES

22
     34  The above Storage_Checks can be suppressed with pragma
     Suppress.


File: arm2012.info,  Node: D.8,  Next: D.9,  Prev: D.7,  Up: Annex D

D.8 Monotonic Time
==================

1/3
This subclause specifies a high-resolution, monotonic clock package.

                          _Static Semantics_

2
The following language-defined library package exists:

3
     package Ada.Real_Time is

4
       type Time is private;
       Time_First : constant Time;
       Time_Last : constant Time;
       Time_Unit : constant := implementation-defined-real-number;

5
       type Time_Span is private;
       Time_Span_First : constant Time_Span;
       Time_Span_Last : constant Time_Span;
       Time_Span_Zero : constant Time_Span;
       Time_Span_Unit : constant Time_Span;

6
       Tick : constant Time_Span;
       function Clock return Time;

7
       function "+" (Left : Time; Right : Time_Span) return Time;
       function "+" (Left : Time_Span; Right : Time) return Time;
       function "-" (Left : Time; Right : Time_Span) return Time;
       function "-" (Left : Time; Right : Time) return Time_Span;

8
       function "<" (Left, Right : Time) return Boolean;
       function "<="(Left, Right : Time) return Boolean;
       function ">" (Left, Right : Time) return Boolean;
       function ">="(Left, Right : Time) return Boolean;

9
       function "+" (Left, Right : Time_Span) return Time_Span;
       function "-" (Left, Right : Time_Span) return Time_Span;
       function "-" (Right : Time_Span) return Time_Span;
       function "*" (Left : Time_Span; Right : Integer) return Time_Span;
       function "*" (Left : Integer; Right : Time_Span) return Time_Span;
       function "/" (Left, Right : Time_Span) return Integer;
       function "/" (Left : Time_Span; Right : Integer) return Time_Span;

10
       function "abs"(Right : Time_Span) return Time_Span;

11/1
     This paragraph was deleted.

12
       function "<" (Left, Right : Time_Span) return Boolean;
       function "<="(Left, Right : Time_Span) return Boolean;
       function ">" (Left, Right : Time_Span) return Boolean;
       function ">="(Left, Right : Time_Span) return Boolean;

13
       function To_Duration (TS : Time_Span) return Duration;
       function To_Time_Span (D : Duration) return Time_Span;

14/2
       function Nanoseconds  (NS : Integer) return Time_Span;
       function Microseconds (US : Integer) return Time_Span;
       function Milliseconds (MS : Integer) return Time_Span;
       function Seconds      (S  : Integer) return Time_Span;
       function Minutes      (M  : Integer) return Time_Span;

15
       type Seconds_Count is range implementation-defined;

16
       procedure Split(T : in Time; SC : out Seconds_Count; TS : out Time_Span);
       function Time_Of(SC : Seconds_Count; TS : Time_Span) return Time;

17
     private
        ... -- not specified by the language
     end Ada.Real_Time;

18
In this Annex, real time is defined to be the physical time as observed
in the external environment.  The type Time is a time type as defined by
*note 9.6::; values of this type may be used in a delay_until_statement.
Values of this type represent segments of an ideal time line.  The set
of values of the type Time corresponds one-to-one with an
implementation-defined range of mathematical integers.

19
The Time value I represents the half-open real time interval that starts
with E+I*Time_Unit and is limited by E+(I+1)*Time_Unit, where Time_Unit
is an implementation-defined real number and E is an unspecified origin
point, the epoch, that is the same for all values of the type Time.  It
is not specified by the language whether the time values are
synchronized with any standard time reference.  For example, E can
correspond to the time of system initialization or it can correspond to
the epoch of some time standard.

20
Values of the type Time_Span represent length of real time duration.
The set of values of this type corresponds one-to-one with an
implementation-defined range of mathematical integers.  The Time_Span
value corresponding to the integer I represents the real-time duration
I*Time_Unit.

21
Time_First and Time_Last are the smallest and largest values of the Time
type, respectively.  Similarly, Time_Span_First and Time_Span_Last are
the smallest and largest values of the Time_Span type, respectively.

22
A value of type Seconds_Count represents an elapsed time, measured in
seconds, since the epoch.

                          _Dynamic Semantics_

23
Time_Unit is the smallest amount of real time representable by the Time
type; it is expressed in seconds.  Time_Span_Unit is the difference
between two successive values of the Time type.  It is also the smallest
positive value of type Time_Span.  Time_Unit and Time_Span_Unit
represent the same real time duration. A clock tick is a real time
interval during which the clock value (as observed by calling the Clock
function) remains constant.  Tick is the average length of such
intervals.

24/2
The function To_Duration converts the value TS to a value of type
Duration.  Similarly, the function To_Time_Span converts the value D to
a value of type Time_Span.  For To_Duration, the result is rounded to
the nearest value of type Duration (away from zero if exactly halfway
between two values).  If the result is outside the range of Duration,
Constraint_Error is raised.  For To_Time_Span, the value of D is first
rounded to the nearest integral multiple of Time_Unit, away from zero if
exactly halfway between two multiples.  If the rounded value is outside
the range of Time_Span, Constraint_Error is raised.  Otherwise, the
value is converted to the type Time_Span.

25
To_Duration(Time_Span_Zero) returns 0.0, and To_Time_Span(0.0) returns
Time_Span_Zero.

26/2
The functions Nanoseconds, Microseconds, Milliseconds, Seconds, and
Minutes convert the input parameter to a value of the type Time_Span.
NS, US, MS, S, and M are interpreted as a number of nanoseconds,
microseconds, milliseconds, seconds, and minutes respectively.  The
input parameter is first converted to seconds and rounded to the nearest
integral multiple of Time_Unit, away from zero if exactly halfway
between two multiples.  If the rounded value is outside the range of
Time_Span, Constraint_Error is raised.  Otherwise, the rounded value is
converted to the type Time_Span.

27
The effects of the operators on Time and Time_Span are as for the
operators defined for integer types.

28
The function Clock returns the amount of time since the epoch.

29
The effects of the Split and Time_Of operations are defined as follows,
treating values of type Time, Time_Span, and Seconds_Count as
mathematical integers.  The effect of Split(T,SC,TS) is to set SC and TS
to values such that T*Time_Unit = SC*1.0 + TS*Time_Unit, and 0.0 <=
TS*Time_Unit < 1.0.  The value returned by Time_Of(SC,TS) is the value T
such that T*Time_Unit = SC*1.0 + TS*Time_Unit.

                     _Implementation Requirements_

30
The range of Time values shall be sufficient to uniquely represent the
range of real times from program start-up to 50 years later.  Tick shall
be no greater than 1 millisecond.  Time_Unit shall be less than or equal
to 20 microseconds.

31
Time_Span_First shall be no greater than -3600 seconds, and
Time_Span_Last shall be no less than 3600 seconds.

32
A clock jump is the difference between two successive distinct values of
the clock (as observed by calling the Clock function).  There shall be
no backward clock jumps.

                     _Documentation Requirements_

33
The implementation shall document the values of Time_First, Time_Last,
Time_Span_First, Time_Span_Last, Time_Span_Unit, and Tick.

34
The implementation shall document the properties of the underlying time
base used for the clock and for type Time, such as the range of values
supported and any relevant aspects of the underlying hardware or
operating system facilities used.

35
The implementation shall document whether or not there is any
synchronization with external time references, and if such
synchronization exists, the sources of synchronization information, the
frequency of synchronization, and the synchronization method applied.

36/3
The implementation shall document any aspects of the external
environment that could interfere with the clock behavior as defined in
this subclause.

                               _Metrics_

37/3
For the purpose of the metrics defined in this subclause, real time is
defined to be the International Atomic Time (TAI).

38
The implementation shall document the following metrics:

39
   * An upper bound on the real-time duration of a clock tick.  This is
     a value D such that if t1 and t2 are any real times such that t1 <
     t2 and Clockt1 = Clockt2 then t2 - t1 <= D.

40
   * An upper bound on the size of a clock jump.

41
   * An upper bound on the drift rate of Clock with respect to real
     time.  This is a real number D such that

42
          E*(1-D) <= (Clockt+E - Clockt) <= E*(1+D)
                  provided that: Clockt + E*(1+D) <= Time_Last.

43
   * where Clockt is the value of Clock at time t, and E is a real time
     duration not less than 24 hours.  The value of E used for this
     metric shall be reported.

44
   * An upper bound on the execution time of a call to the Clock
     function, in processor clock cycles.

45
   * Upper bounds on the execution times of the operators of the types
     Time and Time_Span, in processor clock cycles.

                     _Implementation Permissions_

46
Implementations targeted to machines with word size smaller than 32 bits
need not support the full range and granularity of the Time and
Time_Span types.

                        _Implementation Advice_

47
When appropriate, implementations should provide configuration
mechanisms to change the value of Tick.

48
It is recommended that Calendar.Clock and Real_Time.Clock be implemented
as transformations of the same time base.

49
It is recommended that the "best" time base which exists in the
underlying system be available to the application through Clock.  "Best"
may mean highest accuracy or largest range.

     NOTES

50/3
     35  The rules in this subclause do not imply that the
     implementation can protect the user from operator or installation
     errors which could result in the clock being set incorrectly.

51
     36  Time_Unit is the granularity of the Time type.  In contrast,
     Tick represents the granularity of Real_Time.Clock.  There is no
     requirement that these be the same.


File: arm2012.info,  Node: D.9,  Next: D.10,  Prev: D.8,  Up: Annex D

D.9 Delay Accuracy
==================

1/3
This subclause specifies performance requirements for the
delay_statement.  The rules apply both to delay_relative_statement
(*note 9.6: S0229.) and to delay_until_statement (*note 9.6: S0228.).
Similarly, they apply equally to a simple delay_statement (*note 9.6:
S0227.) and to one which appears in a delay_alternative (*note 9.7.1:
S0235.).

                          _Dynamic Semantics_

2
The effect of the delay_statement for Real_Time.Time is defined in terms
of Real_Time.Clock:

3
   * If C1 is a value of Clock read before a task executes a
     delay_relative_statement with duration D, and C2 is a value of
     Clock read after the task resumes execution following that
     delay_statement, then C2 - C1 >= D.

4
   * If C is a value of Clock read after a task resumes execution
     following a delay_until_statement with Real_Time.Time value T, then
     C >= T.

5
A simple delay_statement with a negative or zero value for the
expiration time does not cause the calling task to be blocked; it is
nevertheless a potentially blocking operation (see *note 9.5.1::).

6/3
When a delay_statement appears in a delay_alternative of a
timed_entry_call the selection of the entry call is attempted,
regardless of the specified expiration time.  When a delay_statement
appears in a select_alternative, and a call is queued on one of the open
entries, the selection of that entry call proceeds, regardless of the
value of the delay expression.

                     _Documentation Requirements_

7
The implementation shall document the minimum value of the delay
expression of a delay_relative_statement that causes the task to
actually be blocked.

8
The implementation shall document the minimum difference between the
value of the delay expression of a delay_until_statement and the value
of Real_Time.Clock, that causes the task to actually be blocked.

                               _Metrics_

9
The implementation shall document the following metrics:

10
   * An upper bound on the execution time, in processor clock cycles, of
     a delay_relative_statement whose requested value of the delay
     expression is less than or equal to zero.

11
   * An upper bound on the execution time, in processor clock cycles, of
     a delay_until_statement whose requested value of the delay
     expression is less than or equal to the value of Real_Time.Clock at
     the time of executing the statement.  Similarly, for
     Calendar.Clock.

12
   * An upper bound on the lateness of a delay_relative_statement, for a
     positive value of the delay expression, in a situation where the
     task has sufficient priority to preempt the processor as soon as it
     becomes ready, and does not need to wait for any other execution
     resources.  The upper bound is expressed as a function of the value
     of the delay expression.  The lateness is obtained by subtracting
     the value of the delay expression from the actual duration.  The
     actual duration is measured from a point immediately before a task
     executes the delay_statement to a point immediately after the task
     resumes execution following this statement.

13
   * An upper bound on the lateness of a delay_until_statement, in a
     situation where the value of the requested expiration time is after
     the time the task begins executing the statement, the task has
     sufficient priority to preempt the processor as soon as it becomes
     ready, and it does not need to wait for any other execution
     resources.  The upper bound is expressed as a function of the
     difference between the requested expiration time and the clock
     value at the time the statement begins execution.  The lateness of
     a delay_until_statement is obtained by subtracting the requested
     expiration time from the real time that the task resumes execution
     following this statement.


File: arm2012.info,  Node: D.10,  Next: D.11,  Prev: D.9,  Up: Annex D

D.10 Synchronous Task Control
=============================

1/3
This subclause describes a language-defined private semaphore
(suspension object), which can be used for two-stage suspend operations
and as a simple building block for implementing higher-level queues.

                          _Static Semantics_

2
The following language-defined package exists:

3/2
     package Ada.Synchronous_Task_Control is
       pragma Preelaborate(Synchronous_Task_Control);

4
       type Suspension_Object is limited private;
       procedure Set_True(S : in out Suspension_Object);
       procedure Set_False(S : in out Suspension_Object);
       function Current_State(S : Suspension_Object) return Boolean;
       procedure Suspend_Until_True(S : in out Suspension_Object);
     private
          ... -- not specified by the language
     end Ada.Synchronous_Task_Control;

5
The type Suspension_Object is a by-reference type.

5.1/3
The following language-defined package exists:

5.2/3
     package Ada.Synchronous_Task_Control.EDF is
        procedure Suspend_Until_True_And_Set_Deadline
           (S  : in out Suspension_Object;
            TS : in     Ada.Real_Time.Time_Span);
     end Ada.Synchronous_Task_Control.EDF;

                          _Dynamic Semantics_

6/2
An object of the type Suspension_Object has two visible states: True and
False.  Upon initialization, its value is set to False.

7/2
The operations Set_True and Set_False are atomic with respect to each
other and with respect to Suspend_Until_True; they set the state to True
and False respectively.

8
Current_State returns the current state of the object.

9/2
The procedure Suspend_Until_True blocks the calling task until the state
of the object S is True; at that point the task becomes ready and the
state of the object becomes False.

10
Program_Error is raised upon calling Suspend_Until_True if another task
is already waiting on that suspension object.  Suspend_Until_True is a
potentially blocking operation (see *note 9.5.1::).

10.1/3
The procedure Suspend_Until_True_And_Set_Deadline blocks the calling
task until the state of the object S is True; at that point the task
becomes ready with a deadline of Ada.Real_Time.Clock + TS, and the state
of the object becomes False.  Program_Error is raised upon calling
Suspend_Until_True_And_Set_Deadline if another task is already waiting
on that suspension object.  Suspend_Until_True_And_Set_Deadline is a
potentially blocking operation.

                     _Implementation Requirements_

11
The implementation is required to allow the calling of Set_False and
Set_True during any protected action, even one that has its ceiling
priority in the Interrupt_Priority range.

     NOTES

12/3
     37  More complex schemes, such as setting the deadline relative to
     when Set_True is called, can be programmed using a protected
     object.

* Menu:

* D.10.1 ::   Synchronous Barriers


File: arm2012.info,  Node: D.10.1,  Up: D.10

D.10.1 Synchronous Barriers
---------------------------

1/3
This subclause introduces a language-defined package to synchronously
release a group of tasks after the number of blocked tasks reaches a
specified count value.

                          _Static Semantics_

2/3
The following language-defined library package exists:

3/3
     package Ada.Synchronous_Barriers is
        pragma Preelaborate(Synchronous_Barriers);

4/3
        subtype Barrier_Limit is Positive range 1 .. implementation-defined;

5/3
        type Synchronous_Barrier (Release_Threshold : Barrier_Limit) is limited private;

6/3
        procedure Wait_For_Release (The_Barrier : in out Synchronous_Barrier;
                                    Notified    :    out Boolean);

7/3
     private
        -- not specified by the language
     end Ada.Synchronous_Barriers;

8/3
Type Synchronous_Barrier needs finalization (see *note 7.6::).

                          _Dynamic Semantics_

9/3
Each call to Wait_For_Release blocks the calling task until the number
of blocked tasks associated with the Synchronous_Barrier object is equal
to Release_Threshold, at which time all blocked tasks are released.
Notified is set to True for one of the released tasks, and set to False
for all other released tasks.

10/3
The mechanism for determining which task sets Notified to True is
implementation defined.

11/3
Once all tasks have been released, a Synchronous_Barrier object may be
reused to block another Release_Threshold number of tasks.

12/3
As the first step of the finalization of a Synchronous_Barrier, each
blocked task is unblocked and Program_Error is raised at the place of
the call to Wait_For_Release.

13/3
It is implementation defined whether an abnormal task which is waiting
on a Synchronous_Barrier object is aborted immediately or aborted when
the tasks waiting on the object are released.

14/3
Wait_For_Release is a potentially blocking operation (see *note
9.5.1::).

                      _Bounded (Run-Time) Errors_

15/3
It is a bounded error to call Wait_For_Release on a Synchronous_Barrier
object after that object is finalized.  If the error is detected,
Program_Error is raised.  Otherwise, the call proceeds normally, which
may leave a task blocked forever.


File: arm2012.info,  Node: D.11,  Next: D.12,  Prev: D.10,  Up: Annex D

D.11 Asynchronous Task Control
==============================

1/3
This subclause introduces a language-defined package to do asynchronous
suspend/resume on tasks.  It uses a conceptual held priority value to
represent the task's held state.

                          _Static Semantics_

2
The following language-defined library package exists:

3/2
     with Ada.Task_Identification;
     package Ada.Asynchronous_Task_Control is
       pragma Preelaborate(Asynchronous_Task_Control);
       procedure Hold(T : in Ada.Task_Identification.Task_Id);
       procedure Continue(T : in Ada.Task_Identification.Task_Id);
       function Is_Held(T : Ada.Task_Identification.Task_Id)
        return Boolean;
     end Ada.Asynchronous_Task_Control;

                          _Dynamic Semantics_

4/2
After the Hold operation has been applied to a task, the task becomes
held.  For each processor there is a conceptual idle task, which is
always ready.  The base priority of the idle task is below
System.Any_Priority'First.  The held priority is a constant of the type
Integer whose value is below the base priority of the idle task.

4.1/2
For any priority below System.Any_Priority'First, the task dispatching
policy is FIFO_Within_Priorities.

5/2
The Hold operation sets the state of T to held.  For a held task, the
active priority is reevaluated as if the base priority of the task were
the held priority.

6/2
The Continue operation resets the state of T to not-held; its active
priority is then reevaluated as determined by the task dispatching
policy associated with its base priority.

7
The Is_Held function returns True if and only if T is in the held state.

8
As part of these operations, a check is made that the task identified by
T is not terminated. Tasking_Error is raised if the check fails.
Program_Error is raised if the value of T is Null_Task_Id.

                         _Erroneous Execution_

9
If any operation in this package is called with a parameter T that
specifies a task object that no longer exists, the execution of the
program is erroneous.

                     _Implementation Permissions_

10
An implementation need not support Asynchronous_Task_Control if it is
infeasible to support it in the target environment.

     NOTES

11
     38  It is a consequence of the priority rules that held tasks
     cannot be dispatched on any processor in a partition (unless they
     are inheriting priorities) since their priorities are defined to be
     below the priority of any idle task.

12
     39  The effect of calling Get_Priority and Set_Priority on a Held
     task is the same as on any other task.

13
     40  Calling Hold on a held task or Continue on a non-held task has
     no effect.

14
     41  The rules affecting queuing are derived from the above rules,
     in addition to the normal priority rules:

15
        * When a held task is on the ready queue, its priority is so low
          as to never reach the top of the queue as long as there are
          other tasks on that queue.

16
        * If a task is executing in a protected action, inside a
          rendezvous, or is inheriting priorities from other sources
          (e.g.  when activated), it continues to execute until it is no
          longer executing the corresponding construct.

17
        * If a task becomes held while waiting (as a caller) for a
          rendezvous to complete, the active priority of the accepting
          task is not affected.

18/1
        * If a task becomes held while waiting in a selective_accept,
          and an entry call is issued to one of the open entries, the
          corresponding accept_alternative (*note 9.7.1: S0234.)
          executes.  When the rendezvous completes, the active priority
          of the accepting task is lowered to the held priority (unless
          it is still inheriting from other sources), and the task does
          not execute until another Continue.

19
        * The same holds if the held task is the only task on a
          protected entry queue whose barrier becomes open.  The
          corresponding entry body executes.


File: arm2012.info,  Node: D.12,  Next: D.13,  Prev: D.11,  Up: Annex D

D.12 Other Optimizations and Determinism Rules
==============================================

1/3
This subclause describes various requirements for improving the response
and determinism in a real-time system.

                     _Implementation Requirements_

2
If the implementation blocks interrupts (see *note C.3::) not as a
result of direct user action (e.g.  an execution of a protected action)
there shall be an upper bound on the duration of this blocking.

3
The implementation shall recognize entry-less protected types.  The
overhead of acquiring the execution resource of an object of such a type
(see *note 9.5.1::) shall be minimized.  In particular, there should not
be any overhead due to evaluating entry_barrier conditions.

4
Unchecked_Deallocation shall be supported for terminated tasks that are
designated by access types, and shall have the effect of releasing all
the storage associated with the task.  This includes any run-time system
or heap storage that has been implicitly allocated for the task by the
implementation.

                     _Documentation Requirements_

5
The implementation shall document the upper bound on the duration of
interrupt blocking caused by the implementation.  If this is different
for different interrupts or interrupt priority levels, it should be
documented for each case.

                               _Metrics_

6
The implementation shall document the following metric:

7
   * The overhead associated with obtaining a mutual-exclusive access to
     an entry-less protected object.  This shall be measured in the
     following way:

8
     For a protected object of the form:

9
     protected Lock is
        procedure Set;
        function Read return Boolean;
     private
        Flag : Boolean := False;
     end Lock;

10
     protected body Lock is
        procedure Set is
        begin
           Flag := True;
        end Set;
        function Read return Boolean
        Begin
           return Flag;
        end Read;
     end Lock;

11
     The execution time, in processor clock cycles, of a call to Set.
     This shall be measured between the point just before issuing the
     call, and the point just after the call completes.  The function
     Read shall be called later to verify that Set was indeed called
     (and not optimized away).  The calling task shall have sufficiently
     high priority as to not be preempted during the measurement period.
     The protected object shall have sufficiently high ceiling priority
     to allow the task to call Set.

12
     For a multiprocessor, if supported, the metric shall be reported
     for the case where no contention (on the execution resource) exists
     from tasks executing on other processors.


File: arm2012.info,  Node: D.13,  Next: D.14,  Prev: D.12,  Up: Annex D

D.13 The Ravenscar Profile
==========================

1/3
This subclause defines the Ravenscar profile.

Paragraphs 2 and 3 were moved to *note 13.12::, "*note 13.12:: Pragma
Restrictions and Pragma Profile".

                           _Legality Rules_

4/3
The profile_identifier Ravenscar is a usage profile (see *note 13.12::).
For usage profile Ravenscar, there shall be no
profile_pragma_argument_association (*note 2.8: S0020.)s.

                          _Static Semantics_

5/3
The usage profile Ravenscar is equivalent to the following set of
pragmas:

6/4
     pragma Task_Dispatching_Policy (FIFO_Within_Priorities);
     pragma Locking_Policy (Ceiling_Locking);
     pragma Detect_Blocking;
     pragma Restrictions (
                   No_Abort_Statements,
                   No_Dynamic_Attachment,
                   No_Dynamic_CPU_Assignment,
                   No_Dynamic_Priorities,
                   No_Implicit_Heap_Allocations,
                   No_Local_Protected_Objects,
                   No_Local_Timing_Events,
                   No_Protected_Type_Allocators,
                   No_Relative_Delay,
                   No_Requeue_Statements,
                   No_Select_Statements,
                   No_Specific_Termination_Handlers,
                   No_Task_Allocators,
                   No_Task_Hierarchy,
                   No_Task_Termination,
                   Simple_Barriers,
                   Max_Entry_Queue_Length => 1,
                   Max_Protected_Entries => 1,
                   Max_Task_Entries => 0,
                   No_Dependence => Ada.Asynchronous_Task_Control,
                   No_Dependence => Ada.Calendar,
                   No_Dependence => Ada.Execution_Time.Group_Budgets,
                   No_Dependence => Ada.Execution_Time.Timers,
                   No_Dependence => Ada.Synchronous_Barriers,
                   No_Dependence => Ada.Task_Attributes,
                   No_Dependence => System.Multiprocessors.Dispatching_Domains);

Paragraph 7 was deleted.

                     _Implementation Requirements_

8/4
This paragraph was deleted.

                        _Implementation Advice_

9/3
On a multiprocessor system, an implementation should support a fully
partitioned approach.  Each processor should have separate and disjoint
ready queues.

     NOTES

10/3
     42  The effect of the Max_Entry_Queue_Length => 1 restriction
     applies only to protected entry queues due to the accompanying
     restriction of Max_Task_Entries => 0.

11/4
     43  When the Ravenscar profile is in effect (via the effect of the
     No_Dynamic_CPU_Assignment restriction), all of the tasks in the
     partition will execute on a single CPU unless the programmer
     explicitly uses aspect CPU to specify the CPU assignments for
     tasks.  The use of multiple CPUs requires care, as many guarantees
     of single CPU scheduling no longer apply.

12/4
     44  It is not recommended to specify the CPU of a task to be
     Not_A_Specific_CPU when the Ravenscar profile is in effect.  How a
     partition executes strongly depends on the assignment of tasks to
     CPUs.


File: arm2012.info,  Node: D.14,  Next: D.15,  Prev: D.13,  Up: Annex D

D.14 Execution Time
===================

1/3
This subclause describes a language-defined package to measure execution
time.

                          _Static Semantics_

2/2
The following language-defined library package exists:

3/2
     with Ada.Task_Identification;
     with Ada.Real_Time; use Ada.Real_Time;
     package Ada.Execution_Time is

4/2
        type CPU_Time is private;
        CPU_Time_First : constant CPU_Time;
        CPU_Time_Last  : constant CPU_Time;
        CPU_Time_Unit  : constant := implementation-defined-real-number;
        CPU_Tick : constant Time_Span;

5/2
        function Clock
          (T : Ada.Task_Identification.Task_Id
               := Ada.Task_Identification.Current_Task)
          return CPU_Time;

6/2
        function "+"  (Left : CPU_Time; Right : Time_Span) return CPU_Time;
        function "+"  (Left : Time_Span; Right : CPU_Time) return CPU_Time;
        function "-"  (Left : CPU_Time; Right : Time_Span) return CPU_Time;
        function "-"  (Left : CPU_Time; Right : CPU_Time)  return Time_Span;

7/2
        function "<"  (Left, Right : CPU_Time) return Boolean;
        function "<=" (Left, Right : CPU_Time) return Boolean;
        function ">"  (Left, Right : CPU_Time) return Boolean;
        function ">=" (Left, Right : CPU_Time) return Boolean;

8/2
        procedure Split
          (T : in CPU_Time; SC : out Seconds_Count; TS : out Time_Span);

9/2
        function Time_Of (SC : Seconds_Count;
                          TS : Time_Span := Time_Span_Zero) return CPU_Time;

9.1/3
        Interrupt_Clocks_Supported : constant Boolean := implementation-defined;

9.2/3
        Separate_Interrupt_Clocks_Supported : constant Boolean :=
          implementation-defined;

9.3/3
        function Clock_For_Interrupts return CPU_Time;

10/2
     private
        ... -- not specified by the language
     end Ada.Execution_Time;

11/3
The execution time or CPU time of a given task is defined as the time
spent by the system executing that task, including the time spent
executing run-time or system services on its behalf.  The mechanism used
to measure execution time is implementation defined.  The Boolean
constant Interrupt_Clocks_Supported is set to True if the implementation
separately accounts for the execution time of interrupt handlers.  If it
is set to False it is implementation defined which task, if any, is
charged the execution time that is consumed by interrupt handlers.  The
Boolean constant Separate_Interrupt_Clocks_Supported is set to True if
the implementation separately accounts for the execution time of
individual interrupt handlers (see *note D.14.3::).

12/2
The type CPU_Time represents the execution time of a task.  The set of
values of this type corresponds one-to-one with an
implementation-defined range of mathematical integers.

13/2
The CPU_Time value I represents the half-open execution-time interval
that starts with I*CPU_Time_Unit and is limited by (I+1)*CPU_Time_Unit,
where CPU_Time_Unit is an implementation-defined real number.  For each
task, the execution time value is set to zero at the creation of the
task.

14/2
CPU_Time_First and CPU_Time_Last are the smallest and largest values of
the CPU_Time type, respectively.

14.1/3
The execution time value for the function Clock_For_Interrupts is
initialized to zero.

                          _Dynamic Semantics_

15/2
CPU_Time_Unit is the smallest amount of execution time representable by
the CPU_Time type; it is expressed in seconds.  A CPU clock tick is an
execution time interval during which the clock value (as observed by
calling the Clock function) remains constant.  CPU_Tick is the average
length of such intervals.

16/2
The effects of the operators on CPU_Time and Time_Span are as for the
operators defined for integer types.

17/2
The function Clock returns the current execution time of the task
identified by T; Tasking_Error is raised if that task has terminated;
Program_Error is raised if the value of T is
Task_Identification.Null_Task_Id.

18/2
The effects of the Split and Time_Of operations are defined as follows,
treating values of type CPU_Time, Time_Span, and Seconds_Count as
mathematical integers.  The effect of Split (T, SC, TS) is to set SC and
TS to values such that T*CPU_Time_Unit = SC*1.0 + TS*CPU_Time_Unit, and
0.0 <= TS*CPU_Time_Unit < 1.0.  The value returned by Time_Of(SC,TS) is
the execution-time value T such that T*CPU_Time_Unit=SC*1.0 +
TS*CPU_Time_Unit.

18.1/3
The function Clock_For_Interrupts returns the total cumulative time
spent executing within all interrupt handlers.  This time is not
allocated to any task execution time clock.  If
Interrupt_Clocks_Supported is set to False the function raises
Program_Error.

                         _Erroneous Execution_

19/2
For a call of Clock, if the task identified by T no longer exists, the
execution of the program is erroneous.

                     _Implementation Requirements_

20/2
The range of CPU_Time values shall be sufficient to uniquely represent
the range of execution times from the task start-up to 50 years of
execution time later.  CPU_Tick shall be no greater than 1 millisecond.

                     _Documentation Requirements_

21/2
The implementation shall document the values of CPU_Time_First,
CPU_Time_Last, CPU_Time_Unit, and CPU_Tick.

22/2
The implementation shall document the properties of the underlying
mechanism used to measure execution times, such as the range of values
supported and any relevant aspects of the underlying hardware or
operating system facilities used.

                               _Metrics_

23/2
The implementation shall document the following metrics:

24/2
   * An upper bound on the execution-time duration of a clock tick.
     This is a value D such that if t1 and t2 are any execution times of
     a given task such that t1 < t2 and Clockt1 = Clockt2 then t2 - t1
     <= D.

25/2
   * An upper bound on the size of a clock jump.  A clock jump is the
     difference between two successive distinct values of an
     execution-time clock (as observed by calling the Clock function
     with the same Task_Id).

26/2
   * An upper bound on the execution time of a call to the Clock
     function, in processor clock cycles.

27/2
   * Upper bounds on the execution times of the operators of the type
     CPU_Time, in processor clock cycles.

                     _Implementation Permissions_

28/2
Implementations targeted to machines with word size smaller than 32 bits
need not support the full range and granularity of the CPU_Time type.

                        _Implementation Advice_

29/2
When appropriate, implementations should provide configuration
mechanisms to change the value of CPU_Tick.

* Menu:

* D.14.1 ::   Execution Time Timers
* D.14.2 ::   Group Execution Time Budgets
* D.14.3 ::   Execution Time of Interrupt Handlers


File: arm2012.info,  Node: D.14.1,  Next: D.14.2,  Up: D.14

D.14.1 Execution Time Timers
----------------------------

1/3
This subclause describes a language-defined package that provides a
facility for calling a handler when a task has used a defined amount of
CPU time.

                          _Static Semantics_

2/2
The following language-defined library package exists:

3/2
     with System;
     package Ada.Execution_Time.Timers is

4/2
        type Timer (T : not null access constant
                            Ada.Task_Identification.Task_Id) is
           tagged limited private;

5/2
        type Timer_Handler is
           access protected procedure (TM : in out Timer);

6/2
        Min_Handler_Ceiling : constant System.Any_Priority :=
        implementation-defined;

7/2
        procedure Set_Handler (TM      : in out Timer;
                               In_Time : in Time_Span;
                               Handler : in Timer_Handler);
        procedure Set_Handler (TM      : in out Timer;
                               At_Time : in CPU_Time;
                               Handler : in Timer_Handler);
        function Current_Handler (TM : Timer) return Timer_Handler;
        procedure Cancel_Handler (TM        : in out Timer;
                                  Cancelled :    out Boolean);

8/2
        function Time_Remaining (TM : Timer) return Time_Span;

9/2
        Timer_Resource_Error : exception;

10/2
     private
        ... -- not specified by the language
     end Ada.Execution_Time.Timers;

11/2
The type Timer represents an execution-time event for a single task and
is capable of detecting execution-time overruns.  The access
discriminant T identifies the task concerned.  The type Timer needs
finalization (see *note 7.6::).

12/2
An object of type Timer is said to be set if it is associated with a
nonnull value of type Timer_Handler and cleared otherwise.  All Timer
objects are initially cleared. 

13/2
The type Timer_Handler identifies a protected procedure to be executed
by the implementation when the timer expires.  Such a protected
procedure is called a handler. 

                          _Dynamic Semantics_

14/2
When a Timer object is created, or upon the first call of a Set_Handler
procedure with the timer as parameter, the resources required to operate
an execution-time timer based on the associated execution-time clock are
allocated and initialized.  If this operation would exceed the available
resources, Timer_Resource_Error is raised.

15/3
The procedures Set_Handler associate the handler Handler with the timer
TM: if Handler is null, the timer is cleared; otherwise, it is set.  The
first procedure Set_Handler loads the timer TM with an interval
specified by the Time_Span parameter.  In this mode, the timer TM
expires when the execution time of the task identified by TM.T.all has
increased by In_Time; if In_Time is less than or equal to zero, the
timer expires immediately.  The second procedure Set_Handler loads the
timer TM with the absolute value specified by At_Time.  In this mode,
the timer TM expires when the execution time of the task identified by
TM.T.all reaches At_Time; if the value of At_Time has already been
reached when Set_Handler is called, the timer expires immediately.

16/2
A call of a procedure Set_Handler for a timer that is already set
replaces the handler and the (absolute or relative) execution time; if
Handler is not null, the timer remains set.

17/2
When a timer expires, the associated handler is executed, passing the
timer as parameter.  The initial action of the execution of the handler
is to clear the event.

18/3
The function Current_Handler returns the handler associated with the
timer TM if that timer is set; otherwise, it returns null.

19/3
The procedure Cancel_Handler clears the timer if it is set.  Cancelled
is assigned True if the timer was set prior to it being cleared;
otherwise, it is assigned False.

20/3
The function Time_Remaining returns the execution time interval that
remains until the timer TM would expire, if that timer is set;
otherwise, it returns Time_Span_Zero.

21/2
The constant Min_Handler_Ceiling is the minimum ceiling priority
required for a protected object with a handler to ensure that no ceiling
violation will occur when that handler is invoked.

22/2
As part of the finalization of an object of type Timer, the timer is
cleared.

23/2
For all the subprograms defined in this package, Tasking_Error is raised
if the task identified by TM.T.all has terminated, and Program_Error is
raised if the value of TM.T.all is Task_Identification.Null_Task_Id.

24/2
An exception propagated from a handler invoked as part of the expiration
of a timer has no effect.

                         _Erroneous Execution_

25/2
For a call of any of the subprograms defined in this package, if the
task identified by TM.T.all no longer exists, the execution of the
program is erroneous.

                     _Implementation Requirements_

26/2
For a given Timer object, the implementation shall perform the
operations declared in this package atomically with respect to any of
these operations on the same Timer object.  The replacement of a handler
by a call of Set_Handler shall be performed atomically with respect to
the execution of the handler.

27/2
When an object of type Timer is finalized, the system resources used by
the timer shall be deallocated.

                     _Implementation Permissions_

28/3
Implementations may limit the number of timers that can be defined for
each task.  If this limit is exceeded, then Timer_Resource_Error is
raised.

     NOTES

29/2
     45  A Timer_Handler can be associated with several Timer objects.


File: arm2012.info,  Node: D.14.2,  Next: D.14.3,  Prev: D.14.1,  Up: D.14

D.14.2 Group Execution Time Budgets
-----------------------------------

1/3
This subclause describes a language-defined package to assign execution
time budgets to groups of tasks.

                          _Static Semantics_

2/2
The following language-defined library package exists:

3/3
     with System;
     with System.Multiprocessors;
     package Ada.Execution_Time.Group_Budgets is

4/3
       type Group_Budget(CPU : System.Multiprocessors.CPU :=
                                  System.Multiprocessors.CPU'First)
         is tagged limited private;

5/2
       type Group_Budget_Handler is access
            protected procedure (GB : in out Group_Budget);

6/2
       type Task_Array is array (Positive range <>) of
                                       Ada.Task_Identification.Task_Id;

7/2
       Min_Handler_Ceiling : constant System.Any_Priority :=
         implementation-defined;

8/2
       procedure Add_Task (GB : in out Group_Budget;
                           T  : in Ada.Task_Identification.Task_Id);
       procedure Remove_Task (GB: in out Group_Budget;
                              T  : in Ada.Task_Identification.Task_Id);
       function Is_Member (GB : Group_Budget;
                           T : Ada.Task_Identification.Task_Id) return Boolean;
       function Is_A_Group_Member
          (T : Ada.Task_Identification.Task_Id) return Boolean;
       function Members (GB : Group_Budget) return Task_Array;

9/2
       procedure Replenish (GB : in out Group_Budget; To : in Time_Span);
       procedure Add (GB : in out Group_Budget; Interval : in Time_Span);
       function Budget_Has_Expired (GB : Group_Budget) return Boolean;
       function Budget_Remaining (GB : Group_Budget) return Time_Span;

10/2
       procedure Set_Handler (GB      : in out Group_Budget;
                              Handler : in Group_Budget_Handler);
       function Current_Handler (GB : Group_Budget)
          return Group_Budget_Handler;
       procedure Cancel_Handler (GB        : in out Group_Budget;
                                 Cancelled : out Boolean);

11/2
       Group_Budget_Error : exception;

12/2
     private
         --  not specified by the language
     end Ada.Execution_Time.Group_Budgets;

13/2
The type Group_Budget represents an execution time budget to be used by
a group of tasks.  The type Group_Budget needs finalization (see *note
7.6::).  A task can belong to at most one group.  Tasks of any priority
can be added to a group.

14/2
An object of type Group_Budget has an associated nonnegative value of
type Time_Span known as its budget, which is initially Time_Span_Zero.
The type Group_Budget_Handler identifies a protected procedure to be
executed by the implementation when the budget is exhausted, that is,
reaches zero.  Such a protected procedure is called a handler. 

15/2
An object of type Group_Budget also includes a handler, which is a value
of type Group_Budget_Handler.  The handler of the object is said to be
set if it is not null and cleared otherwise.  The handler of all
Group_Budget objects is initially cleared. 

                          _Dynamic Semantics_

16/2
The procedure Add_Task adds the task identified by T to the group GB; if
that task is already a member of some other group, Group_Budget_Error is
raised.

17/2
The procedure Remove_Task removes the task identified by T from the
group GB; if that task is not a member of the group GB,
Group_Budget_Error is raised.  After successful execution of this
procedure, the task is no longer a member of any group.

18/3
The function Is_Member returns True if the task identified by T is a
member of the group GB; otherwise, it returns False.

19/3
The function Is_A_Group_Member returns True if the task identified by T
is a member of some group; otherwise, it returns False.

20/2
The function Members returns an array of values of type
Task_Identification.Task_Id identifying the members of the group GB. The
order of the components of the array is unspecified.

21/3
The procedure Replenish loads the group budget GB with To as the
Time_Span value.  The exception Group_Budget_Error is raised if the
Time_Span value To is nonpositive.  Any execution on CPU of any member
of the group of tasks results in the budget counting down, unless
exhausted.  When the budget becomes exhausted (reaches Time_Span_Zero),
the associated handler is executed if the handler of group budget GB is
set.  Nevertheless, the tasks continue to execute.

22/2
The procedure Add modifies the budget of the group GB. A positive value
for Interval increases the budget.  A negative value for Interval
reduces the budget, but never below Time_Span_Zero.  A zero value for
Interval has no effect.  A call of procedure Add that results in the
value of the budget going to Time_Span_Zero causes the associated
handler to be executed if the handler of the group budget GB is set.

23/3
The function Budget_Has_Expired returns True if the budget of group GB
is exhausted (equal to Time_Span_Zero); otherwise, it returns False.

24/2
The function Budget_Remaining returns the remaining budget for the group
GB. If the budget is exhausted it returns Time_Span_Zero.  This is the
minimum value for a budget.

25/3
The procedure Set_Handler associates the handler Handler with the
Group_Budget GB: if Handler is null, the handler of Group_Budget is
cleared; otherwise, it is set.

26/2
A call of Set_Handler for a Group_Budget that already has a handler set
replaces the handler; if Handler is not null, the handler for
Group_Budget remains set.

27/3
The function Current_Handler returns the handler associated with the
group budget GB if the handler for that group budget is set; otherwise,
it returns null.

28/3
The procedure Cancel_Handler clears the handler for the group budget if
it is set.  Cancelled is assigned True if the handler for the group
budget was set prior to it being cleared; otherwise, it is assigned
False.

29/2
The constant Min_Handler_Ceiling is the minimum ceiling priority
required for a protected object with a handler to ensure that no ceiling
violation will occur when that handler is invoked.

30/2
The precision of the accounting of task execution time to a Group_Budget
is the same as that defined for execution-time clocks from the parent
package.

31/2
As part of the finalization of an object of type Group_Budget all member
tasks are removed from the group identified by that object.

32/3
If a task is a member of a Group_Budget when it terminates, then as part
of the finalization of the task it is removed from the group.

33/2
For all the operations defined in this package, Tasking_Error is raised
if the task identified by T has terminated, and Program_Error is raised
if the value of T is Task_Identification.Null_Task_Id.

34/2
An exception propagated from a handler invoked when the budget of a
group of tasks becomes exhausted has no effect.

                         _Erroneous Execution_

35/2
For a call of any of the subprograms defined in this package, if the
task identified by T no longer exists, the execution of the program is
erroneous.

                     _Implementation Requirements_

36/2
For a given Group_Budget object, the implementation shall perform the
operations declared in this package atomically with respect to any of
these operations on the same Group_Budget object.  The replacement of a
handler, by a call of Set_Handler, shall be performed atomically with
respect to the execution of the handler.

     NOTES

37/2
     46  Clearing or setting of the handler of a group budget does not
     change the current value of the budget.  Exhaustion or loading of a
     budget does not change whether the handler of the group budget is
     set or cleared.

38/2
     47  A Group_Budget_Handler can be associated with several
     Group_Budget objects.


File: arm2012.info,  Node: D.14.3,  Prev: D.14.2,  Up: D.14

D.14.3 Execution Time of Interrupt Handlers
-------------------------------------------

1/3
This subclause describes a language-defined package to measure the
execution time of interrupt handlers.

                          _Static Semantics_

2/3
The following language-defined library package exists:

3/3
     with Ada.Interrupts;
     package Ada.Execution_Time.Interrupts is
        function Clock (Interrupt : Ada.Interrupts.Interrupt_Id)
             return CPU_Time;
        function Supported (Interrupt : Ada.Interrupts.Interrupt_Id)
             return Boolean;
     end Ada.Execution_Time.Interrupts;

4/3
The execution time or CPU time of a given interrupt Interrupt is defined
as the time spent by the system executing interrupt handlers identified
by Interrupt, including the time spent executing run-time or system
services on its behalf.  The mechanism used to measure execution time is
implementation defined.  Time spent executing interrupt handlers is
distinct from time spent executing any task.

5/3
For each interrupt, the execution time value is initially set to zero.

                          _Dynamic Semantics_

6/3
The function Clock returns the current cumulative execution time of the
interrupt identified by Interrupt.  If
Separate_Interrupt_Clocks_Supported is set to False the function raises
Program_Error.

7/3
The function Supported returns True if the implementation is monitoring
the execution time of the interrupt identified by Interrupt; otherwise,
it returns False.  For any Interrupt_Id Interrupt for which
Supported(Interrupt) returns False, the function Clock(Interrupt) will
return a value equal to Ada.Execution_Time.Time_Of(0).


File: arm2012.info,  Node: D.15,  Next: D.16,  Prev: D.14,  Up: Annex D

D.15 Timing Events
==================

1/3
This subclause describes a language-defined package to allow
user-defined protected procedures to be executed at a specified time
without the need for a task or a delay statement.

                          _Static Semantics_

2/2
The following language-defined library package exists:

3/2
     package Ada.Real_Time.Timing_Events is

4/2
       type Timing_Event is tagged limited private;
       type Timing_Event_Handler
            is access protected procedure (Event : in out Timing_Event);

5/2
       procedure Set_Handler (Event   : in out Timing_Event;
                              At_Time : in Time;
                              Handler : in Timing_Event_Handler);
       procedure Set_Handler (Event   : in out Timing_Event;
                              In_Time : in Time_Span;
                              Handler : in Timing_Event_Handler);
       function Current_Handler (Event : Timing_Event)
            return Timing_Event_Handler;
       procedure Cancel_Handler (Event     : in out Timing_Event;
                                 Cancelled : out Boolean);

6/2
       function Time_Of_Event (Event : Timing_Event) return Time;

7/2
     private
       ... -- not specified by the language
     end Ada.Real_Time.Timing_Events;

8/2
The type Timing_Event represents a time in the future when an event is
to occur.  The type Timing_Event needs finalization (see *note 7.6::).

9/2
An object of type Timing_Event is said to be set if it is associated
with a nonnull value of type Timing_Event_Handler and cleared otherwise.
All Timing_Event objects are initially cleared. 

10/2
The type Timing_Event_Handler identifies a protected procedure to be
executed by the implementation when the timing event occurs.  Such a
protected procedure is called a handler. 

                          _Dynamic Semantics_

11/3
The procedures Set_Handler associate the handler Handler with the event
Event: if Handler is null, the event is cleared; otherwise, it is set.
The first procedure Set_Handler sets the execution time for the event to
be At_Time.  The second procedure Set_Handler sets the execution time
for the event to be Real_Time.Clock + In_Time.

12/2
A call of a procedure Set_Handler for an event that is already set
replaces the handler and the time of execution; if Handler is not null,
the event remains set.

13/2
As soon as possible after the time set for the event, the handler is
executed, passing the event as parameter.  The handler is only executed
if the timing event is in the set state at the time of execution.  The
initial action of the execution of the handler is to clear the event.

14/2
If the Ceiling_Locking policy (see *note D.3::) is in effect when a
procedure Set_Handler is called, a check is made that the ceiling
priority of Handler.all is Interrupt_Priority'Last.  If the check fails,
Program_Error is raised.

15/3
If a procedure Set_Handler is called with zero or negative In_Time or
with At_Time indicating a time in the past, then the handler is executed
as soon as possible after the completion of the call of Set_Handler.

16/3
The function Current_Handler returns the handler associated with the
event Event if that event is set; otherwise, it returns null.

17/3
The procedure Cancel_Handler clears the event if it is set.  Cancelled
is assigned True if the event was set prior to it being cleared;
otherwise, it is assigned False.

18/3
The function Time_Of_Event returns the time of the event if the event is
set; otherwise, it returns Real_Time.Time_First.

19/2
As part of the finalization of an object of type Timing_Event, the
Timing_Event is cleared.

20/2
If several timing events are set for the same time, they are executed in
FIFO order of being set.

21/2
An exception propagated from a handler invoked by a timing event has no
effect.

                     _Implementation Requirements_

22/2
For a given Timing_Event object, the implementation shall perform the
operations declared in this package atomically with respect to any of
these operations on the same Timing_Event object.  The replacement of a
handler by a call of Set_Handler shall be performed atomically with
respect to the execution of the handler.

                               _Metrics_

23/2
The implementation shall document the following metric:

24/3
   * An upper bound on the lateness of the execution of a handler.  That
     is, the maximum time between the time specified for the event and
     when a handler is actually invoked assuming no other handler or
     task is executing during this interval.

                        _Implementation Advice_

25/2
The protected handler procedure should be executed directly by the
real-time clock interrupt mechanism.

     NOTES

26/2
     48  Since a call of Set_Handler is not a potentially blocking
     operation, it can be called from within a handler.

27/2
     49  A Timing_Event_Handler can be associated with several
     Timing_Event objects.


File: arm2012.info,  Node: D.16,  Prev: D.15,  Up: Annex D

D.16 Multiprocessor Implementation
==================================

1/3
This subclause allows implementations on multiprocessor platforms to be
configured.

                          _Static Semantics_

2/3
The following language-defined library package exists:

3/3
     package System.Multiprocessors is
        pragma Preelaborate(Multiprocessors);

4/3
        type CPU_Range is range 0 .. implementation-defined;
        Not_A_Specific_CPU : constant CPU_Range := 0;
        subtype CPU is CPU_Range range 1 .. CPU_Range'Last;

5/3
        function Number_Of_CPUs return CPU;
     end System.Multiprocessors;

6/3
A call of Number_Of_CPUs returns the number of processors available to
the program.  Within a given partition, each call on Number_Of_CPUs will
return the same value.

7/3
For a task type (including the anonymous type of a
single_task_declaration) or subprogram, the following language-defined
representation aspect may be specified:

8/3
CPU
               The aspect CPU is an expression, which shall be of type
               System.Multiprocessors.CPU_Range.

                           _Legality Rules_

9/3
If the CPU aspect is specified for a subprogram, the expression shall be
static.

10/3
The CPU aspect shall not be specified on a task interface type.

                          _Dynamic Semantics_

11/4
The expression specified for the CPU aspect of a task type is evaluated
each time an object of the task type is created (see *note 9.1::).  The
CPU value is then associated with the task object.

12/3
The CPU aspect has no effect if it is specified for a subprogram other
than the main subprogram; the CPU value is not associated with any task.

13/3
The CPU value is associated with the environment task if the CPU aspect
is specified for the main subprogram.  If the CPU aspect is not
specified for the main subprogram it is implementation defined on which
processor the environment task executes.

14/3
The CPU value determines the processor on which the task will activate
and execute; the task is said to be assigned to that processor.  If the
CPU value is Not_A_Specific_CPU, then the task is not assigned to a
processor.  A task without a CPU aspect specified will activate and
execute on the same processor as its activating task if the activating
task is assigned a processor.  If the CPU value is not in the range of
System.Multiprocessors.CPU_Range or is greater than Number_Of_CPUs the
task is defined to have failed, and it becomes a completed task (see
*note 9.2::).

* Menu:

* D.16.1 ::   Multiprocessor Dispatching Domains


File: arm2012.info,  Node: D.16.1,  Up: D.16

D.16.1 Multiprocessor Dispatching Domains
-----------------------------------------

1/3
This subclause allows implementations on multiprocessor platforms to be
partitioned into distinct dispatching domains during program startup.

                          _Static Semantics_

2/3
The following language-defined library package exists:

3/3
     with Ada.Real_Time;
     with Ada.Task_Identification;
     package System.Multiprocessors.Dispatching_Domains is

4/3
        Dispatching_Domain_Error : exception;

5/3
        type Dispatching_Domain (<>) is limited private;

6/3
        System_Dispatching_Domain : constant Dispatching_Domain;

7/4
        function Create (First : CPU; Last : CPU_Range) return Dispatching_Domain;

8/3
        function Get_First_CPU (Domain : Dispatching_Domain) return CPU;

9/4
        function Get_Last_CPU  (Domain : Dispatching_Domain) return CPU_Range;

9.1/4
        type CPU_Set is array(CPU range <>) of Boolean;

9.2/4
        function Create (Set : CPU_Set) return Dispatching_Domain;

9.3/4
        function Get_CPU_Set (Domain : Dispatching_Domain) return CPU_Set;

10/3
        function Get_Dispatching_Domain
           (T   : Ada.Task_Identification.Task_Id :=
                      Ada.Task_Identification.Current_Task)
                return Dispatching_Domain;

11/3
        procedure Assign_Task
           (Domain : in out Dispatching_Domain;
            CPU    : in     CPU_Range := Not_A_Specific_CPU;
            T      : in     Ada.Task_Identification.Task_Id :=
                      Ada.Task_Identification.Current_Task);

12/3
        procedure Set_CPU
           (CPU : in CPU_Range;
            T   : in Ada.Task_Identification.Task_Id :=
                      Ada.Task_Identification.Current_Task);

13/3
        function Get_CPU
           (T   : Ada.Task_Identification.Task_Id :=
                      Ada.Task_Identification.Current_Task)
                return CPU_Range;

14/3
        procedure Delay_Until_And_Set_CPU
           (Delay_Until_Time : in Ada.Real_Time.Time; CPU : in CPU_Range);

15/3
     private
        ... -- not specified by the language
     end System.Multiprocessors.Dispatching_Domains;

16/4
A dispatching domain represents a set of processors on which a task may
execute.  Each processor is contained within exactly one dispatching
domain.  An object of type Dispatching_Domain identifies a dispatching
domain.  System_Dispatching_Domain identifies a domain that contains the
processor or processors on which the environment task executes.  At
program start-up all processors are contained within this domain.

17/3
For a task type (including the anonymous type of a
single_task_declaration), the following language-defined representation
aspect may be specified:

18/3
Dispatching_Domain
               The value of aspect Dispatching_Domain is an expression,
               which shall be of type
               Dispatching_Domains.Dispatching_Domain.  This aspect is
               the domain to which the task (or all objects of the task
               type) are assigned.

                           _Legality Rules_

19/3
The Dispatching_Domain aspect shall not be specified for a task
interface.

                          _Dynamic Semantics_

20/4
The expression specified for the Dispatching_Domain aspect of a task
type is evaluated each time an object of the task type is created (see
*note 9.1::).  If the identified dispatching domain is empty, then
Dispatching_Domain_Error is raised; otherwise the newly created task is
assigned to the domain identified by the value of the expression.

21/3
If a task is not explicitly assigned to any domain, it is assigned to
that of the activating task.  A task always executes on some CPU in its
domain.

22/4
If both the dispatching domain and CPU are specified for a task, and the
CPU value is not contained within the set of processors for the domain
(and is not Not_A_Specific_CPU), the activation of the task is defined
to have failed, and it becomes a completed task (see *note 9.2::).

23/4
The function Create with First and Last parameters creates and returns a
dispatching domain containing all the processors in the range First ..
Last.  The function Create with a Set parameter creates and returns a
dispatching domain containing the processors for which Set(I) is True.
These processors are removed from System_Dispatching_Domain.  A call of
Create will raise Dispatching_Domain_Error if any designated processor
is not currently in System_Dispatching_Domain, or if the system cannot
support a distinct domain over the processors identified, or if a
processor has a task assigned to it, or if the allocation would leave
System_Dispatching_Domain empty.  A call of Create will raise
Dispatching_Domain_Error if the calling task is not the environment
task, or if Create is called after the call to the main subprogram.

24/4
The function Get_First_CPU returns the first CPU in Domain, or CPU'First
if Domain is empty; Get_Last_CPU returns the last CPU in Domain, or
CPU_Range'First if Domain is empty.  The function Get_CPU_Set(D) returns
an array whose low bound is Get_First_CPU(D), whose high bound is
Get_Last_CPU(D), with True values in the Set corresponding to the CPUs
that are in the given Domain.

25/4
The function Get_Dispatching_Domain returns the dispatching domain on
which the task is assigned.

26/4
A call of the procedure Assign_Task assigns task T to the CPU within the
dispatching domain Domain.  Task T can now execute only on CPU, unless
CPU designates Not_A_Specific_CPU in which case it can execute on any
processor within Domain.  The exception Dispatching_Domain_Error is
propagated if Domain is empty, T is already assigned to a dispatching
domain other than System_Dispatching_Domain, or if CPU is not one of the
processors of Domain (and is not Not_A_Specific_CPU). A call of
Assign_Task is a task dispatching point for task T unless T is inside of
a protected action, in which case the effect on task T is delayed until
its next task dispatching point.  If T is the Current_Task the effect is
immediate if T is not inside a protected action, otherwise the effect is
as soon as practical.  Assigning a task already assigned to
System_Dispatching_Domain to that domain has no effect.

27/4
A call of procedure Set_CPU assigns task T to the CPU. Task T can now
execute only on CPU, unless CPU designates Not_A_Specific_CPU, in which
case it can execute on any processor within its dispatching domain.  The
exception Dispatching_Domain_Error is propagated if CPU is not one of
the processors of the dispatching domain on which T is assigned (and is
not Not_A_Specific_CPU). A call of Set_CPU is a task dispatching point
for task T unless T is inside of a protected action, in which case the
effect on task T is delayed until its next task dispatching point.  If T
is the Current_Task the effect is immediate if T is not inside a
protected action, otherwise the effect is as soon as practical.

28/3
The function Get_CPU returns the processor assigned to task T, or
Not_A_Specific_CPU if the task is not assigned to a processor.

29/4
A call of Delay_Until_And_Set_CPU delays the calling task for the
designated time and then assigns the task to the specified processor
when the delay expires.  The exception Dispatching_Domain_Error is
propagated if P is not one of the processors of the calling task's
dispatching domain (and is not Not_A_Specific_CPU).

                     _Implementation Requirements_

30/3
The implementation shall perform the operations Assign_Task, Set_CPU,
Get_CPU and Delay_Until_And_Set_CPU atomically with respect to any of
these operations on the same dispatching_domain, processor or task.

30.1/4
Any task that belongs to the system dispatching domain can execute on
any CPU within that domain, unless the assignment of the task has been
specified.

                        _Implementation Advice_

31/3
Each dispatching domain should have separate and disjoint ready queues.

                     _Documentation Requirements_

32/3
The implementation shall document the processor(s) on which the clock
interrupt is handled and hence where delay queue and ready queue
manipulations occur.  For any Interrupt_Id whose handler can execute on
more than one processor the implementation shall also document this set
of processors.

                     _Implementation Permissions_

33/3
An implementation may limit the number of dispatching domains that can
be created and raise Dispatching_Domain_Error if an attempt is made to
exceed this number.


File: arm2012.info,  Node: Annex E,  Next: Annex F,  Prev: Annex D,  Up: Top

Annex E Distributed Systems
***************************

1
This Annex defines facilities for supporting the implementation of
distributed systems using multiple partitions working cooperatively as
part of a single Ada program.

                       _Post-Compilation Rules_

2
A distributed system is an interconnection of one or more processing
nodes (a system resource that has both computational and storage
capabilities), and zero or more storage nodes (a system resource that
has only storage capabilities, with the storage addressable by one or
more processing nodes).

3
A distributed program comprises one or more partitions that execute
independently (except when they communicate) in a distributed system.

4
The process of mapping the partitions of a program to the nodes in a
distributed system is called configuring the partitions of the program.

                     _Implementation Requirements_

5
The implementation shall provide means for explicitly assigning library
units to a partition and for the configuring and execution of a program
consisting of multiple partitions on a distributed system; the means are
implementation defined.

                     _Implementation Permissions_

6
An implementation may require that the set of processing nodes of a
distributed system be homogeneous.

     NOTES

7
     1  The partitions comprising a program may be executed on
     differently configured distributed systems or on a nondistributed
     system without requiring recompilation.  A distributed program may
     be partitioned differently from the same set of library units
     without recompilation.  The resulting execution is semantically
     equivalent.

8
     2  A distributed program retains the same type safety as the
     equivalent single partition program.

* Menu:

* E.1 ::      Partitions
* E.2 ::      Categorization of Library Units
* E.3 ::      Consistency of a Distributed System
* E.4 ::      Remote Subprogram Calls
* E.5 ::      Partition Communication Subsystem


File: arm2012.info,  Node: E.1,  Next: E.2,  Up: Annex E

E.1 Partitions
==============

1
The partitions of a distributed program are classified as either active
or passive.

                       _Post-Compilation Rules_

2
An active partition is a partition as defined in *note 10.2::.  A
passive partition is a partition that has no thread of control of its
own, whose library units are all preelaborated, and whose data and
subprograms are accessible to one or more active partitions.

3
A passive partition shall include only library_items that either are
declared pure or are shared passive (see *note 10.2.1:: and *note
E.2.1::).

4
An active partition shall be configured on a processing node.  A passive
partition shall be configured either on a storage node or on a
processing node.

5
The configuration of the partitions of a program onto a distributed
system shall be consistent with the possibility for data references or
calls between the partitions implied by their semantic dependences. Any
reference to data or call of a subprogram across partitions is called a
remote access.

                          _Dynamic Semantics_

6
A library_item is elaborated as part of the elaboration of each
partition that includes it.  If a normal library unit (see *note E.2::)
has state, then a separate copy of the state exists in each active
partition that elaborates it.  The state evolves independently in each
such partition.

7
An active partition terminates when its environment task terminates.  A
partition becomes inaccessible if it terminates or if it is aborted.  An
active partition is aborted when its environment task is aborted.  In
addition, if a partition fails during its elaboration, it becomes
inaccessible to other partitions.  Other implementation-defined events
can also result in a partition becoming inaccessible.

8/1
For a prefix D that denotes a library-level declaration, excepting a
declaration of or within a declared-pure library unit, the following
attribute is defined:

9
D'Partition_Id
               Denotes a value of the type universal_integer that
               identifies the partition in which D was elaborated.  If D
               denotes the declaration of a remote call interface
               library unit (see *note E.2.3::) the given partition is
               the one where the body of D was elaborated.

                      _Bounded (Run-Time) Errors_

10/2
It is a bounded error for there to be cyclic elaboration dependences
between the active partitions of a single distributed program. The
possible effects, in each of the partitions involved, are deadlock
during elaboration, or the raising of Communication_Error or
Program_Error.

                     _Implementation Permissions_

11
An implementation may allow multiple active or passive partitions to be
configured on a single processing node, and multiple passive partitions
to be configured on a single storage node.  In these cases, the
scheduling policies, treatment of priorities, and management of shared
resources between these partitions are implementation defined.

12
An implementation may allow separate copies of an active partition to be
configured on different processing nodes, and to provide appropriate
interactions between the copies to present a consistent state of the
partition to other active partitions.

13
In an implementation, the partitions of a distributed program need not
be loaded and elaborated all at the same time; they may be loaded and
elaborated one at a time over an extended period of time.  An
implementation may provide facilities to abort and reload a partition
during the execution of a distributed program.

14
An implementation may allow the state of some of the partitions of a
distributed program to persist while other partitions of the program
terminate and are later reinvoked.

     NOTES

15
     3  Library units are grouped into partitions after compile time,
     but before run time.  At compile time, only the relevant library
     unit properties are identified using categorization pragmas.

16
     4  The value returned by the Partition_Id attribute can be used as
     a parameter to implementation-provided subprograms in order to
     query information about the partition.


File: arm2012.info,  Node: E.2,  Next: E.3,  Prev: E.1,  Up: Annex E

E.2 Categorization of Library Units
===================================

1
Library units can be categorized according to the role they play in a
distributed program.  Certain restrictions are associated with each
category to ensure that the semantics of a distributed program remain
close to the semantics for a nondistributed program.

2/3
A categorization pragma is a library unit pragma (see *note 10.1.5::)
that specifies a corresponding categorization aspect.  A categorization
aspect restricts the declarations, child units, or semantic dependences
of the library unit to which it applies.  A categorized library unit is
a library unit that has a categorization aspect that is True.

3/3
The pragmas Shared_Passive, Remote_Types, and Remote_Call_Interface are
categorization pragmas, and the associated aspects are categorization
aspects.  In addition, for the purposes of this Annex, the aspect Pure
(see *note 10.2.1::) is considered a categorization aspect and the
pragma Pure is considered a categorization pragma.

4/3
A library package or generic library package is called a shared passive
library unit if the Shared_Passive aspect of the unit is True.   A
library package or generic library package is called a remote types
library unit if the Remote_Types aspect of the unit is True.   A library
unit is called a remote call interface if the Remote_Call_Interface
aspect of the unit is True. A normal library unit is one for which no
categorization aspect is True.

5/3
The various categories of library units and the associated restrictions
are described in this and the following subclauses.  The categories are
related hierarchically in that the library units of one category can
depend semantically only on library units of that category or an earlier
one in the hierarchy, except that the body of a remote types or remote
call interface library unit is unrestricted, the declaration of a remote
types or remote call interface library unit may depend on preelaborated
normal library units that are mentioned only in private with clauses,
and all categories can depend on limited views.

6/3
The overall hierarchy (including declared pure) is as follows, with a
lower-numbered category being "earlier in the hierarchy" in the sense of
the previous paragraph:

6.1/3
     1.  Declared Pure

6.2/3
     2.  Shared Passive

6.3/3
     3.  Remote Types

6.4/3
     4.  Remote Call Interface

6.5/3
     5.  Normal (no restrictions)

Paragraphs 7 through 11 were deleted.

12
Declared pure and shared passive library units are preelaborated.  The
declaration of a remote types or remote call interface library unit is
required to be preelaborable.

Paragraph 13 was deleted.

                     _Implementation Permissions_

14
Implementations are allowed to define other categorization pragmas.

* Menu:

* E.2.1 ::    Shared Passive Library Units
* E.2.2 ::    Remote Types Library Units
* E.2.3 ::    Remote Call Interface Library Units


File: arm2012.info,  Node: E.2.1,  Next: E.2.2,  Up: E.2

E.2.1 Shared Passive Library Units
----------------------------------

1
A shared passive library unit is used for managing global data shared
between active partitions.  The restrictions on shared passive library
units prevent the data or tasks of one active partition from being
accessible to another active partition through references implicit in
objects declared in the shared passive library unit.

                               _Syntax_

2
     The form of a pragma Shared_Passive is as follows:

3
       pragma Shared_Passive[(library_unit_name)];

                           _Legality Rules_

4/3
A pragma Shared_Passive is used to specify that a library unit is a
shared passive library unit, namely that the Shared_Passive aspect of
the library unit is True.  The following restrictions apply to such a
library unit:

5
   * it shall be preelaborable (see *note 10.2.1::);

6/3
   * it shall depend semantically only upon declared pure or shared
     passive library_items;

7/4
   * it shall not contain a library-level declaration of an access type
     that designates a class-wide type, nor a type with a part that is
     of a task type or protected type with entry_declarations;

7.1/4
   * it shall not contain a library-level declaration that contains a
     name that denotes a type declared within a declared-pure package,
     if that type has a part that is of an access type; for the purposes
     of this rule, the parts considered include those of the full views
     of any private types or private extensions.

8
Notwithstanding the definition of accessibility given in *note 3.10.2::,
the declaration of a library unit P1 is not accessible from within the
declarative region of a shared passive library unit P2, unless the
shared passive library unit P2 depends semantically on P1.

                          _Static Semantics_

9
A shared passive library unit is preelaborated.

                       _Post-Compilation Rules_

10
A shared passive library unit shall be assigned to at most one partition
within a given program.

11
Notwithstanding the rule given in *note 10.2::, a compilation unit in a
given partition does not need (in the sense of *note 10.2::) the shared
passive library units on which it depends semantically to be included in
that same partition; they will typically reside in separate passive
partitions.


File: arm2012.info,  Node: E.2.2,  Next: E.2.3,  Prev: E.2.1,  Up: E.2

E.2.2 Remote Types Library Units
--------------------------------

1
A remote types library unit supports the definition of types intended
for use in communication between active partitions.

                               _Syntax_

2
     The form of a pragma Remote_Types is as follows:

3
       pragma Remote_Types[(library_unit_name)];

                           _Legality Rules_

4/3
A pragma Remote_Types is used to specify that a library unit is a remote
types library unit, namely that the Remote_Types aspect of the library
unit is True.  The following restrictions apply to the declaration of
such a library unit:

5
   * it shall be preelaborable;

6/3
   * it shall depend semantically only on declared pure library_items,
     shared passive library units, other remote types library units, or
     preelaborated normal library units that are mentioned only in
     private with clauses;

7
   * it shall not contain the declaration of any variable within the
     visible part of the library unit;

8/2
   * the full view of each type declared in the visible part of the
     library unit that has any available stream attributes shall support
     external streaming (see *note 13.13.2::).

9/3
A named access type declared in the visible part of a remote types or
remote call interface library unit is called a remote access type. Such
a type shall be:

9.1/1
   * an access-to-subprogram type, or

9.2/3
   * a general access type that designates a class-wide limited private
     type, a class-wide limited interface type, or a class-wide private
     extension all of whose ancestors are either private extensions,
     limited interface types, or limited private types.

9.3/1
A type that is derived from a remote access type is also a remote access
type.

10
The following restrictions apply to the use of a remote
access-to-subprogram type:

11/2
   * A value of a remote access-to-subprogram type shall be converted
     only to or from another (subtype-conformant) remote
     access-to-subprogram type;

12
   * The prefix of an Access attribute_reference that yields a value of
     a remote access-to-subprogram type shall statically denote a
     (subtype-conformant) remote subprogram.

13
The following restrictions apply to the use of a remote
access-to-class-wide type:

14/3
   * The primitive subprograms of the corresponding specific type shall
     only have access parameters if they are controlling formal
     parameters.  The primitive functions of the corresponding specific
     type shall only have an access result if it is a controlling access
     result.  Each noncontrolling formal parameter and noncontrolling
     result type shall support external streaming (see *note 13.13.2::);

14.1/3
   * The corresponding specific type shall not have a primitive
     procedure with the Synchronization aspect specified unless the
     synchronization_kind is Optional (see *note 9.5::);

15
   * A value of a remote access-to-class-wide type shall be explicitly
     converted only to another remote access-to-class-wide type;

16/4
   * A value of a remote access-to-class-wide type shall be dereferenced
     (or implicitly converted to an anonymous access type) only as part
     of a dispatching call to a primitive operation of the designated
     type where the value designates a controlling operand of the call
     (see *note E.4::, "*note E.4:: Remote Subprogram Calls");

16.1/3
   * A controlling access result value for a primitive function with any
     controlling operands of the corresponding specific type shall
     either be explicitly converted to a remote access-to-class-wide
     type or be part of a dispatching call where the value designates a
     controlling operand of the call;

17/4
   * The Storage_Pool attribute is not defined for a remote
     access-to-class-wide type; the expected type for an allocator shall
     not be a remote access-to-class-wide type.  A remote
     access-to-class-wide type shall not be an actual parameter for a
     generic formal access type.  The Storage_Size attribute of a remote
     access-to-class-wide type yields 0.  The Storage_Pool and
     Storage_Size aspects shall not be specified for a remote
     access-to-class-wide type.

                         _Erroneous Execution_

17.1/4
Execution is erroneous if some operation (other than the initialization
or finalization of the object) modifies the value of a constant object
declared in the visible part of a remote types package.

     NOTES

18
     5  A remote types library unit need not be pure, and the types it
     defines may include levels of indirection implemented by using
     access types.  User-specified Read and Write attributes (see *note
     13.13.2::) provide for sending values of such a type between active
     partitions, with Write marshalling the representation, and Read
     unmarshalling any levels of indirection.

19/3
     6  The value of a remote access-to-class-wide limited interface can
     designate an object of a nonlimited type derived from the
     interface.

20/3
     7  A remote access type may designate a class-wide synchronized,
     protected, or task interface type.


File: arm2012.info,  Node: E.2.3,  Prev: E.2.2,  Up: E.2

E.2.3 Remote Call Interface Library Units
-----------------------------------------

1
A remote call interface library unit can be used as an interface for
remote procedure calls (RPCs) (or remote function calls) between active
partitions.

                               _Syntax_

2
     The form of a pragma Remote_Call_Interface is as follows:

3
       pragma Remote_Call_Interface[(library_unit_name)];

4
     The form of a pragma All_Calls_Remote is as follows:

5
       pragma All_Calls_Remote[(library_unit_name)];

6
     A pragma All_Calls_Remote is a library unit pragma.

                           _Legality Rules_

7/3
A pragma Remote_Call_Interface is used to specify that a library unit is
a remote call interface (RCI), namely that the Remote_Call_Interface
aspect of the library unit is True.  A subprogram declared in the
visible part of such a library unit, or declared by such a library unit,
is called a remote subprogram.

8/3
The declaration of an RCI library unit shall be preelaborable (see *note
10.2.1::), and shall depend semantically only upon declared pure
library_items, shared passive library units, remote types library units,
other remote call interface library units, or preelaborated normal
library units that are mentioned only in private with clauses.

9/1
In addition, the following restrictions apply to an RCI library unit:

10/1
   * its visible part shall not contain the declaration of a variable;

11/1
   * its visible part shall not contain the declaration of a limited
     type;

12/1
   * its visible part shall not contain a nested generic_declaration;

13/3
   * it shall not be, nor shall its visible part contain, the
     declaration of a subprogram for which aspect Inline is True;

14/3
   * it shall not be, nor shall its visible part contain, a subprogram
     (or access-to-subprogram) declaration whose profile has a parameter
     or result of a type that does not support external streaming (see
     *note 13.13.2::);

15
   * any public child of the library unit shall be a remote call
     interface library unit.

16/3
A pragma All_Calls_Remote sets the All_Calls_Remote representation
aspect of the library unit to which the pragma applies to the value
True.  If the All_Calls_Remote aspect of a library unit is True, the
library unit shall be a remote call interface.

                       _Post-Compilation Rules_

17
A remote call interface library unit shall be assigned to at most one
partition of a given program.  A remote call interface library unit
whose parent is also an RCI library unit shall be assigned only to the
same partition as its parent.

18
Notwithstanding the rule given in *note 10.2::, a compilation unit in a
given partition that semantically depends on the declaration of an RCI
library unit, needs (in the sense of *note 10.2::) only the declaration
of the RCI library unit, not the body, to be included in that same
partition.  Therefore, the body of an RCI library unit is included only
in the partition to which the RCI library unit is explicitly assigned.

                     _Implementation Requirements_

19/4
If aspect All_Calls_Remote is True for a given RCI library unit, then
the implementation shall route any of the following calls through the
Partition Communication Subsystem (PCS); see *note E.5:::

19.1/4
   * A direct call to a subprogram of the RCI unit from outside the
     declarative region of the unit;

19.2/4
   * An indirect call through a remote access-to-subprogram value that
     designates a subprogram of the RCI unit;

19.3/4
   * A dispatching call with a controlling operand designated by a
     remote access-to-class-wide value whose tag identifies a type
     declared in the RCI unit.

                     _Implementation Permissions_

20/3
An implementation need not support the Remote_Call_Interface pragma or
aspect nor the All_Calls_Remote pragma.  Explicit message-based
communication between active partitions can be supported as an
alternative to RPC.


File: arm2012.info,  Node: E.3,  Next: E.4,  Prev: E.2,  Up: Annex E

E.3 Consistency of a Distributed System
=======================================

1/3
This subclause defines attributes and rules associated with verifying
the consistency of a distributed program.

                          _Static Semantics_

2/1
For a prefix P that statically denotes a program unit, the following
attributes are defined:

3
P'Version
               Yields a value of the predefined type String that
               identifies the version of the compilation unit that
               contains the declaration of the program unit.

4
P'Body_Version
               Yields a value of the predefined type String that
               identifies the version of the compilation unit that
               contains the body (but not any subunits) of the program
               unit.

5/1
The version of a compilation unit changes whenever the compilation unit
changes in a semantically significant way.  This International Standard
does not define the exact meaning of "semantically significant".  It is
unspecified whether there are other events (such as recompilation) that
result in the version of a compilation unit changing. 

5.1/1
If P is not a library unit, and P has no completion, then P'Body_Version
returns the Body_Version of the innermost program unit enclosing the
declaration of P. If P is a library unit, and P has no completion, then
P'Body_Version returns a value that is different from Body_Version of
any version of P that has a completion.

                      _Bounded (Run-Time) Errors_

6
In a distributed program, a library unit is consistent if the same
version of its declaration is used throughout.  It is a bounded error to
elaborate a partition of a distributed program that contains a
compilation unit that depends on a different version of the declaration
of a shared passive or RCI library unit than that included in the
partition to which the shared passive or RCI library unit was assigned.
As a result of this error, Program_Error can be raised in one or both
partitions during elaboration; in any case, the partitions become
inaccessible to one another.


File: arm2012.info,  Node: E.4,  Next: E.5,  Prev: E.3,  Up: Annex E

E.4 Remote Subprogram Calls
===========================

1
A remote subprogram call is a subprogram call that invokes the execution
of a subprogram in another partition.  The partition that originates the
remote subprogram call is the calling partition, and the partition that
executes the corresponding subprogram body is the called partition.
Some remote procedure calls are allowed to return prior to the
completion of subprogram execution.  These are called asynchronous
remote procedure calls.

2
There are three different ways of performing a remote subprogram call:

3
   * As a direct call on a (remote) subprogram explicitly declared in a
     remote call interface;

4
   * As an indirect call through a value of a remote
     access-to-subprogram type;

5
   * As a dispatching call with a controlling operand designated by a
     value of a remote access-to-class-wide type.

6
The first way of calling corresponds to a static binding between the
calling and the called partition.  The latter two ways correspond to a
dynamic binding between the calling and the called partition.

7/3
Remote types library units (see *note E.2.2::) and remote call interface
library units (see *note E.2.3::) define the remote subprograms or
remote access types used for remote subprogram calls.

                           _Legality Rules_

8
In a dispatching call with two or more controlling operands, if one
controlling operand is designated by a value of a remote
access-to-class-wide type, then all shall be.

                          _Dynamic Semantics_

9
For the execution of a remote subprogram call, subprogram parameters
(and later the results, if any) are passed using a stream-oriented
representation (see *note 13.13.1::) which is suitable for transmission
between partitions.  This action is called marshalling.  Unmarshalling
is the reverse action of reconstructing the parameters or results from
the stream-oriented representation.  Marshalling is performed initially
as part of the remote subprogram call in the calling partition;
unmarshalling is done in the called partition.  After the remote
subprogram completes, marshalling is performed in the called partition,
and finally unmarshalling is done in the calling partition.

10
A calling stub is the sequence of code that replaces the subprogram body
of a remotely called subprogram in the calling partition.  A receiving
stub is the sequence of code (the "wrapper") that receives a remote
subprogram call on the called partition and invokes the appropriate
subprogram body.

11
Remote subprogram calls are executed at most once, that is, if the
subprogram call returns normally, then the called subprogram's body was
executed exactly once.

12
The task executing a remote subprogram call blocks until the subprogram
in the called partition returns, unless the call is asynchronous.  For
an asynchronous remote procedure call, the calling task can become ready
before the procedure in the called partition returns.

13
If a construct containing a remote call is aborted, the remote
subprogram call is cancelled.  Whether the execution of the remote
subprogram is immediately aborted as a result of the cancellation is
implementation defined.

14
If a remote subprogram call is received by a called partition before the
partition has completed its elaboration, the call is kept pending until
the called partition completes its elaboration (unless the call is
cancelled by the calling partition prior to that).

15
If an exception is propagated by a remotely called subprogram, and the
call is not an asynchronous call, the corresponding exception is
reraised at the point of the remote subprogram call.  For an
asynchronous call, if the remote procedure call returns prior to the
completion of the remotely called subprogram, any exception is lost.

16
The exception Communication_Error (see *note E.5::) is raised if a
remote call cannot be completed due to difficulties in communicating
with the called partition.

17
All forms of remote subprogram calls are potentially blocking operations
(see *note 9.5.1::).

18/1
In a remote subprogram call with a formal parameter of a class-wide
type, a check is made that the tag of the actual parameter identifies a
tagged type declared in a declared-pure or shared passive library unit,
or in the visible part of a remote types or remote call interface
library unit. Program_Error is raised if this check fails.  In a remote
function call which returns a class-wide type, the same check is made on
the function result.

19
In a dispatching call with two or more controlling operands that are
designated by values of a remote access-to-class-wide type, a check is
made (in addition to the normal Tag_Check -- see *note 11.5::) that all
the remote access-to-class-wide values originated from Access
attribute_references that were evaluated by tasks of the same active
partition. Constraint_Error is raised if this check fails.

                     _Implementation Requirements_

20
The implementation of remote subprogram calls shall conform to the PCS
interface as defined by the specification of the language-defined
package System.RPC (see *note E.5::).  The calling stub shall use the
Do_RPC procedure unless the remote procedure call is asynchronous in
which case Do_APC shall be used.  On the receiving side, the
corresponding receiving stub shall be invoked by the RPC-receiver.

20.1/1
With respect to shared variables in shared passive library units, the
execution of the corresponding subprogram body of a synchronous remote
procedure call is considered to be part of the execution of the calling
task.  The execution of the corresponding subprogram body of an
asynchronous remote procedure call proceeds in parallel with the calling
task and does not signal the next action of the calling task (see *note
9.10::).

     NOTES

21
     8  A given active partition can both make and receive remote
     subprogram calls.  Thus, an active partition can act as both a
     client and a server.

22
     9  If a given exception is propagated by a remote subprogram call,
     but the exception does not exist in the calling partition, the
     exception can be handled by an others choice or be propagated to
     and handled by a third partition.

* Menu:

* E.4.1 ::    Asynchronous Remote Calls
* E.4.2 ::    Example of Use of a Remote Access-to-Class-Wide Type


File: arm2012.info,  Node: E.4.1,  Next: E.4.2,  Up: E.4

E.4.1 Asynchronous Remote Calls
-------------------------------

1/3
This subclause introduces the aspect Asynchronous which can be specified
to allow a remote subprogram call to return prior to completion of the
execution of the corresponding remote subprogram body.

Paragraphs 2 through 7 were deleted.

                          _Static Semantics_

8/3
For a remote procedure, the following language-defined representation
aspect may be specified:

8.1/3
Asynchronous
               The type of aspect Asynchronous is Boolean.  If directly
               specified, the aspect_definition shall be a static
               expression.  If not specified, the aspect is False.

8.2/3
For a remote access type, the following language-defined representation
aspect may be specified:

8.3/3
Asynchronous
               The type of aspect Asynchronous is Boolean.  If directly
               specified, the aspect_definition shall be a static
               expression.  If not specified (including by inheritance),
               the aspect is False.

                           _Legality Rules_

8.4/3
If aspect Asynchronous is specified for a remote procedure, the formal
parameters of the procedure shall all be of mode in.

8.5/3
If aspect Asynchronous is specified for a remote access type, the type
shall be a remote access-to-class-wide type, or the type shall be a
remote access-to-procedure type with the formal parameters of the
designated profile of the type all of mode in.

                          _Dynamic Semantics_

9/3
A remote call is asynchronous if it is a call to a procedure, or a call
through a value of an access-to-procedure type, for which aspect
Asynchronous is True.  In addition, if aspect Asynchronous is True for a
remote access-to-class-wide type, then a dispatching call on a procedure
with a controlling operand designated by a value of the type is
asynchronous if the formal parameters of the procedure are all of mode
in.

                     _Implementation Requirements_

10
Asynchronous remote procedure calls shall be implemented such that the
corresponding body executes at most once as a result of the call.


File: arm2012.info,  Node: E.4.2,  Prev: E.4.1,  Up: E.4

E.4.2 Example of Use of a Remote Access-to-Class-Wide Type
----------------------------------------------------------

                              _Examples_

1
Example of using a remote access-to-class-wide type to achieve dynamic
binding across active partitions:

2
     package Tapes is
        pragma Pure(Tapes);
        type Tape is abstract tagged limited private;
        -- Primitive dispatching operations where
        -- Tape is controlling operand
        procedure Copy (From, To : access Tape; Num_Recs : in Natural) is abstract;
        procedure Rewind (T : access Tape) is abstract;
        -- More operations
     private
        type Tape is ...
     end Tapes;

3
     with Tapes;
     package Name_Server is
        pragma Remote_Call_Interface;
        -- Dynamic binding to remote operations is achieved
        -- using the access-to-limited-class-wide type Tape_Ptr
        type Tape_Ptr is access all Tapes.Tape'Class;
        -- The following statically bound remote operations
        -- allow for a name-server capability in this example
        function  Find     (Name : String) return Tape_Ptr;
        procedure Register (Name : in String; T : in Tape_Ptr);
        procedure Remove   (T : in Tape_Ptr);
        -- More operations
     end Name_Server;

4
     package Tape_Driver is
       -- Declarations are not shown, they are irrelevant here
     end Tape_Driver;

5
     with Tapes, Name_Server;
     package body Tape_Driver is
        type New_Tape is new Tapes.Tape with ...
        procedure Copy
         (From, To : access New_Tape; Num_Recs: in Natural) is
        begin
          . . .
        end Copy;
        procedure Rewind (T : access New_Tape) is
        begin
           . . .
        end Rewind;
        -- Objects remotely accessible through use
        -- of Name_Server operations
        Tape1, Tape2 : aliased New_Tape;
     begin
        Name_Server.Register ("NINE-TRACK",  Tape1'Access);
        Name_Server.Register ("SEVEN-TRACK", Tape2'Access);
     end Tape_Driver;

6
     with Tapes, Name_Server;
     -- Tape_Driver is not needed and thus not mentioned in the with_clause
     procedure Tape_Client is
        T1, T2 : Name_Server.Tape_Ptr;
     begin
        T1 := Name_Server.Find ("NINE-TRACK");
        T2 := Name_Server.Find ("SEVEN-TRACK");
        Tapes.Rewind (T1);
        Tapes.Rewind (T2);
        Tapes.Copy (T1, T2, 3);
     end Tape_Client;

7
Notes on the example:

8/1
This paragraph was deleted.

9
   * The package Tapes provides the necessary declarations of the type
     and its primitive operations.

10
   * Name_Server is a remote call interface package and is elaborated in
     a separate active partition to provide the necessary naming
     services (such as Register and Find) to the entire distributed
     program through remote subprogram calls.

11
   * Tape_Driver is a normal package that is elaborated in a partition
     configured on the processing node that is connected to the tape
     device(s).  The abstract operations are overridden to support the
     locally declared tape devices (Tape1, Tape2).  The package is not
     visible to its clients, but it exports the tape devices (as remote
     objects) through the services of the Name_Server.  This allows for
     tape devices to be dynamically added, removed or replaced without
     requiring the modification of the clients' code.

12
   * The Tape_Client procedure references only declarations in the Tapes
     and Name_Server packages.  Before using a tape for the first time,
     it needs to query the Name_Server for a system-wide identity for
     that tape.  From then on, it can use that identity to access the
     tape device.

13
   * Values of remote access type Tape_Ptr include the necessary
     information to complete the remote dispatching operations that
     result from dereferencing the controlling operands T1 and T2.


File: arm2012.info,  Node: E.5,  Prev: E.4,  Up: Annex E

E.5 Partition Communication Subsystem
=====================================

1/2
The Partition Communication Subsystem (PCS) provides facilities for
supporting communication between the active partitions of a distributed
program.  The package System.RPC is a language-defined interface to the
PCS.

                          _Static Semantics_

2
The following language-defined library package exists:

3
     with Ada.Streams; -- see *note 13.13.1::
     package System.RPC is

4
        type Partition_Id is range 0 .. implementation-defined;

5
        Communication_Error : exception;

6
        type Params_Stream_Type (
           Initial_Size : Ada.Streams.Stream_Element_Count) is new
           Ada.Streams.Root_Stream_Type with private;

7
        procedure Read(
           Stream : in out Params_Stream_Type;
           Item : out Ada.Streams.Stream_Element_Array;
           Last : out Ada.Streams.Stream_Element_Offset);

8
        procedure Write(
           Stream : in out Params_Stream_Type;
           Item : in Ada.Streams.Stream_Element_Array);

9
        -- Synchronous call
        procedure Do_RPC(
           Partition  : in Partition_Id;
           Params     : access Params_Stream_Type;
           Result     : access Params_Stream_Type);

10
        -- Asynchronous call
        procedure Do_APC(
           Partition  : in Partition_Id;
           Params     : access Params_Stream_Type);

11
        -- The handler for incoming RPCs
        type RPC_Receiver is access procedure(
           Params     : access Params_Stream_Type;
           Result     : access Params_Stream_Type);

12
        procedure Establish_RPC_Receiver(
           Partition : in Partition_Id;
           Receiver  : in RPC_Receiver);

13
     private
        ... -- not specified by the language
     end System.RPC;

14
A value of the type Partition_Id is used to identify a partition.

15
An object of the type Params_Stream_Type is used for identifying the
particular remote subprogram that is being called, as well as
marshalling and unmarshalling the parameters or result of a remote
subprogram call, as part of sending them between partitions.

16
The Read and Write procedures override the corresponding abstract
operations for the type Params_Stream_Type.

                          _Dynamic Semantics_

17
The Do_RPC and Do_APC procedures send a message to the active partition
identified by the Partition parameter.

18
After sending the message, Do_RPC blocks the calling task until a reply
message comes back from the called partition or some error is detected
by the underlying communication system in which case Communication_Error
is raised at the point of the call to Do_RPC.

19
Do_APC operates in the same way as Do_RPC except that it is allowed to
return immediately after sending the message.

20
Upon normal return, the stream designated by the Result parameter of
Do_RPC contains the reply message.

21
The procedure System.RPC.Establish_RPC_Receiver is called once,
immediately after elaborating the library units of an active partition
(that is, right after the elaboration of the partition) if the partition
includes an RCI library unit, but prior to invoking the main subprogram,
if any.  The Partition parameter is the Partition_Id of the active
partition being elaborated. The Receiver parameter designates an
implementation-provided procedure called the RPC-receiver which will
handle all RPCs received by the partition from the PCS.
Establish_RPC_Receiver saves a reference to the RPC-receiver; when a
message is received at the called partition, the RPC-receiver is called
with the Params stream containing the message.  When the RPC-receiver
returns, the contents of the stream designated by Result is placed in a
message and sent back to the calling partition.

22
If a call on Do_RPC is aborted, a cancellation message is sent to the
called partition, to request that the execution of the remotely called
subprogram be aborted.

23
The subprograms declared in System.RPC are potentially blocking
operations.

                     _Implementation Requirements_

24
The implementation of the RPC-receiver shall be reentrant, thereby
allowing concurrent calls on it from the PCS to service concurrent
remote subprogram calls into the partition.

24.1/1
An implementation shall not restrict the replacement of the body of
System.RPC. An implementation shall not restrict children of System.RPC.
The related implementation permissions in the introduction to Annex A do
not apply.

24.2/1
If the implementation of System.RPC is provided by the user, an
implementation shall support remote subprogram calls as specified.

                     _Documentation Requirements_

25
The implementation of the PCS shall document whether the RPC-receiver is
invoked from concurrent tasks.  If there is an upper limit on the number
of such tasks, this limit shall be documented as well, together with the
mechanisms to configure it (if this is supported).

                     _Implementation Permissions_

26
The PCS is allowed to contain implementation-defined interfaces for
explicit message passing, broadcasting, etc.  Similarly, it is allowed
to provide additional interfaces to query the state of some remote
partition (given its partition ID) or of the PCS itself, to set timeouts
and retry parameters, to get more detailed error status, etc.  These
additional interfaces should be provided in child packages of
System.RPC.

27
A body for the package System.RPC need not be supplied by the
implementation.

27.1/3
An alternative declaration is allowed for package System.RPC as long as
it provides a set of operations that is substantially equivalent to the
specification defined in this subclause.

                        _Implementation Advice_

28
Whenever possible, the PCS on the called partition should allow for
multiple tasks to call the RPC-receiver with different messages and
should allow them to block until the corresponding subprogram body
returns.

29
The Write operation on a stream of type Params_Stream_Type should raise
Storage_Error if it runs out of space trying to write the Item into the
stream.

     NOTES

30
     10  The package System.RPC is not designed for direct calls by user
     programs.  It is instead designed for use in the implementation of
     remote subprograms calls, being called by the calling stubs
     generated for a remote call interface library unit to initiate a
     remote call, and in turn calling back to an RPC-receiver that
     dispatches to the receiving stubs generated for the body of a
     remote call interface, to handle a remote call received from
     elsewhere.


File: arm2012.info,  Node: Annex F,  Next: Annex G,  Prev: Annex E,  Up: Top

Annex F Information Systems
***************************

1
This Annex provides a set of facilities relevant to Information Systems
programming.  These fall into several categories:

2
   * an attribute definition clause specifying Machine_Radix for a
     decimal subtype;

3
   * the package Decimal, which declares a set of constants defining the
     implementation's capacity for decimal types, and a generic
     procedure for decimal division; and

4/2
   * the child packages Text_IO.Editing, Wide_Text_IO.Editing, and
     Wide_Wide_Text_IO.Editing, which support formatted and localized
     output of decimal data, based on "picture String" values.

5/2
See also: *note 3.5.9::, "*note 3.5.9:: Fixed Point Types"; *note
3.5.10::, "*note 3.5.10:: Operations of Fixed Point Types"; *note 4.6::,
"*note 4.6:: Type Conversions"; *note 13.3::, "*note 13.3:: Operational
and Representation Attributes"; *note A.10.9::, "*note A.10.9::
Input-Output for Real Types"; *note B.3::, "*note B.3:: Interfacing with
C and C++"; *note B.4::, "*note B.4:: Interfacing with COBOL"; *note
Annex G::, "*note Annex G:: Numerics".

6
The character and string handling packages in *note Annex A::, "*note
Annex A:: Predefined Language Environment" are also relevant for
Information Systems.

                        _Implementation Advice_

7/3
If COBOL (respectively, C) is widely supported in the target
environment, implementations supporting the Information Systems Annex
should provide the child package Interfaces.COBOL (respectively,
Interfaces.C) specified in *note Annex B:: and should support a
convention_identifier of COBOL (respectively, C) for the Convention
aspect (see *note Annex B::), thus allowing Ada programs to interface
with programs written in that language.

* Menu:

* F.1 ::      Machine_Radix Attribute Definition Clause
* F.2 ::      The Package Decimal
* F.3 ::      Edited Output for Decimal Types


File: arm2012.info,  Node: F.1,  Next: F.2,  Up: Annex F

F.1 Machine_Radix Attribute Definition Clause
=============================================

                          _Static Semantics_

1
Machine_Radix may be specified for a decimal first subtype (see *note
3.5.9::) via an attribute_definition_clause; the expression of such a
clause shall be static, and its value shall be 2 or 10.  A value of 2
implies a binary base range; a value of 10 implies a decimal base range.

                        _Implementation Advice_

2
Packed decimal should be used as the internal representation for objects
of subtype S when S'Machine_Radix = 10.

                              _Examples_

3
Example of Machine_Radix attribute definition clause:

4
     type Money is delta 0.01 digits 15;
     for Money'Machine_Radix use 10;


File: arm2012.info,  Node: F.2,  Next: F.3,  Prev: F.1,  Up: Annex F

F.2 The Package Decimal
=======================

                          _Static Semantics_

1
The library package Decimal has the following declaration:

2
     package Ada.Decimal is
        pragma Pure(Decimal);

3
        Max_Scale : constant := implementation-defined;
        Min_Scale : constant := implementation-defined;

4
        Min_Delta : constant := 10.0**(-Max_Scale);
        Max_Delta : constant := 10.0**(-Min_Scale);

5
        Max_Decimal_Digits : constant := implementation-defined;

6/3
        generic
           type Dividend_Type  is delta <> digits <>;
           type Divisor_Type   is delta <> digits <>;
           type Quotient_Type  is delta <> digits <>;
           type Remainder_Type is delta <> digits <>;
        procedure Divide (Dividend  : in Dividend_Type;
                          Divisor   : in Divisor_Type;
                          Quotient  : out Quotient_Type;
                          Remainder : out Remainder_Type)
           with Convention => Intrinsic;

7
     end Ada.Decimal;

8
Max_Scale is the largest N such that 10.0**(-N) is allowed as a decimal
type's delta.  Its type is universal_integer.

9
Min_Scale is the smallest N such that 10.0**(-N) is allowed as a decimal
type's delta.  Its type is universal_integer.

10
Min_Delta is the smallest value allowed for delta in a
decimal_fixed_point_definition.  Its type is universal_real.

11
Max_Delta is the largest value allowed for delta in a
decimal_fixed_point_definition.  Its type is universal_real.

12
Max_Decimal_Digits is the largest value allowed for digits in a
decimal_fixed_point_definition.  Its type is universal_integer.

                          _Static Semantics_

13
The effect of Divide is as follows.  The value of Quotient is
Quotient_Type(Dividend/Divisor).  The value of Remainder is
Remainder_Type(Intermediate), where Intermediate is the difference
between Dividend and the product of Divisor and Quotient; this result is
computed exactly.

                     _Implementation Requirements_

14
Decimal.Max_Decimal_Digits shall be at least 18.

15
Decimal.Max_Scale shall be at least 18.

16
Decimal.Min_Scale shall be at most 0.

     NOTES

17
     1  The effect of division yielding a quotient with control over
     rounding versus truncation is obtained by applying either the
     function attribute Quotient_Type'Round or the conversion
     Quotient_Type to the expression Dividend/Divisor.


File: arm2012.info,  Node: F.3,  Prev: F.2,  Up: Annex F

F.3 Edited Output for Decimal Types
===================================

1/2
The child packages Text_IO.Editing, Wide_Text_IO.Editing, and
Wide_Wide_Text_IO.Editing provide localizable formatted text output,
known as edited output, for decimal types.  An edited output string is a
function of a numeric value, program-specifiable locale elements, and a
format control value.  The numeric value is of some decimal type.  The
locale elements are:

2
   * the currency string;

3
   * the digits group separator character;

4
   * the radix mark character; and

5
   * the fill character that replaces leading zeros of the numeric
     value.

6/2
For Text_IO.Editing the edited output and currency strings are of type
String, and the locale characters are of type Character.  For
Wide_Text_IO.Editing their types are Wide_String and Wide_Character,
respectively.  For Wide_Wide_Text_IO.Editing their types are
Wide_Wide_String and Wide_Wide_Character, respectively.

7
Each of the locale elements has a default value that can be replaced or
explicitly overridden.

8
A format-control value is of the private type Picture; it determines the
composition of the edited output string and controls the form and
placement of the sign, the position of the locale elements and the
decimal digits, the presence or absence of a radix mark, suppression of
leading zeros, and insertion of particular character values.

9
A Picture object is composed from a String value, known as a picture
String, that serves as a template for the edited output string, and a
Boolean value that controls whether a string of all space characters is
produced when the number's value is zero.  A picture String comprises a
sequence of one- or two-Character symbols, each serving as a placeholder
for a character or string at a corresponding position in the edited
output string.  The picture String symbols fall into several categories
based on their effect on the edited output string:

10
        Decimal Digit:    '9'
        Radix Control:    '.'    'V'
        Sign Control:    '+'    '-'    '<'    '>'    "CR"    "DB"
        Currency Control:    '$'    '#'
        Zero Suppression:    'Z'    '*'
        Simple Insertion:    '_'    'B'    '0'    '/'

11
The entries are not case-sensitive.  Mixed- or lower-case forms for "CR"
and "DB", and lower-case forms for 'V', 'Z', and 'B', have the same
effect as the upper-case symbols shown.

12
An occurrence of a '9' Character in the picture String represents a
decimal digit position in the edited output string.

13
A radix control Character in the picture String indicates the position
of the radix mark in the edited output string: an actual character
position for '.', or an assumed position for 'V'.

14
A sign control Character in the picture String affects the form of the
sign in the edited output string.  The '<' and '>' Character values
indicate parentheses for negative values.  A Character '+', '-', or '<'
appears either singly, signifying a fixed-position sign in the edited
output, or repeated, signifying a floating-position sign that is
preceded by zero or more space characters and that replaces a leading 0.

15
A currency control Character in the picture String indicates an
occurrence of the currency string in the edited output string.  The '$'
Character represents the complete currency string; the '#' Character
represents one character of the currency string.  A '$' Character
appears either singly, indicating a fixed-position currency string in
the edited output, or repeated, indicating a floating-position currency
string that occurs in place of a leading 0.  A sequence of '#' Character
values indicates either a fixed- or floating-position currency string,
depending on context.

16
A zero suppression Character in the picture String allows a leading zero
to be replaced by either the space character (for 'Z') or the fill
character (for '*').

17
A simple insertion Character in the picture String represents, in
general, either itself (if '/' or '0'), the space character (if 'B'), or
the digits group separator character (if '_').  In some contexts it is
treated as part of a floating sign, floating currency, or zero
suppression string.

18/2
An example of a picture String is "<###Z_ZZ9.99>".  If the currency
string is "kr", the separator character is ',', and the radix mark is
'.'  then the edited output string values for the decimal values 32.10
and -5432.10 are "bbkrbbb32.10b" and "(bkr5,432.10)", respectively,
where 'b' indicates the space character.

19/2
The generic packages Text_IO.Decimal_IO, Wide_Text_IO.Decimal_IO, and
Wide_Wide_Text_IO.Decimal_IO (see *note A.10.9::, "*note A.10.9::
Input-Output for Real Types") provide text input and nonedited text
output for decimal types.

     NOTES

20/2
     2  A picture String is of type Standard.String, for all of
     Text_IO.Editing, Wide_Text_IO.Editing, and
     Wide_Wide_Text_IO.Editing.

* Menu:

* F.3.1 ::    Picture String Formation
* F.3.2 ::    Edited Output Generation
* F.3.3 ::    The Package Text_IO.Editing
* F.3.4 ::    The Package Wide_Text_IO.Editing
* F.3.5 ::    The Package Wide_Wide_Text_IO.Editing


File: arm2012.info,  Node: F.3.1,  Next: F.3.2,  Up: F.3

F.3.1 Picture String Formation
------------------------------

1/3
A well-formed picture String, or simply picture String, is a String
value that conforms to the syntactic rules, composition constraints, and
character replication conventions specified in this subclause.

                          _Dynamic Semantics_

2/1
This paragraph was deleted.

3
     picture_string ::=
        fixed_$_picture_string
      | fixed_#_picture_string
      | floating_currency_picture_string
      | non_currency_picture_string

4
     fixed_$_picture_string ::=
        [fixed_LHS_sign] fixed_$_char {direct_insertion} [zero_suppression]
          number [RHS_sign]

      | [fixed_LHS_sign {direct_insertion}] [zero_suppression]
          number fixed_$_char {direct_insertion} [RHS_sign]

      | floating_LHS_sign number fixed_$_char {direct_insertion} [RHS_sign]

      | [fixed_LHS_sign] fixed_$_char {direct_insertion}
          all_zero_suppression_number {direct_insertion}  [RHS_sign]

      | [fixed_LHS_sign {direct_insertion}] all_zero_suppression_number {direct_insertion}
          fixed_$_char {direct_insertion} [RHS_sign]

      | all_sign_number {direct_insertion} fixed_$_char {direct_insertion} [RHS_sign]

5
     fixed_#_picture_string ::=
        [fixed_LHS_sign] single_#_currency {direct_insertion}
          [zero_suppression] number [RHS_sign]

      | [fixed_LHS_sign] multiple_#_currency {direct_insertion}
          zero_suppression number [RHS_sign]

      | [fixed_LHS_sign {direct_insertion}] [zero_suppression]
          number fixed_#_currency {direct_insertion} [RHS_sign]

      | floating_LHS_sign number fixed_#_currency {direct_insertion} [RHS_sign]

      | [fixed_LHS_sign] single_#_currency {direct_insertion}
          all_zero_suppression_number {direct_insertion} [RHS_sign]

      | [fixed_LHS_sign] multiple_#_currency {direct_insertion}
          all_zero_suppression_number {direct_insertion} [RHS_sign]

      | [fixed_LHS_sign {direct_insertion}] all_zero_suppression_number {direct_insertion}
          fixed_#_currency {direct_insertion} [RHS_sign]

      | all_sign_number {direct_insertion} fixed_#_currency {direct_insertion} [RHS_sign]

6
     floating_currency_picture_string ::=
        [fixed_LHS_sign] {direct_insertion} floating_$_currency number [RHS_sign]
      | [fixed_LHS_sign] {direct_insertion} floating_#_currency number [RHS_sign]
      | [fixed_LHS_sign] {direct_insertion} all_currency_number {direct_insertion} [RHS_sign]

7
     non_currency_picture_string ::=
        [fixed_LHS_sign {direct_insertion}] zero_suppression number [RHS_sign]
      | [floating_LHS_sign] number [RHS_sign]
      | [fixed_LHS_sign {direct_insertion}] all_zero_suppression_number {direct_insertion}
          [RHS_sign]
      | all_sign_number {direct_insertion}
      | fixed_LHS_sign direct_insertion {direct_insertion} number [RHS_sign]

8
     fixed_LHS_sign ::=  LHS_Sign

9
     LHS_Sign ::=  + | - | <

10
     fixed_$_char ::= $

11
     direct_insertion ::=  simple_insertion

12
     simple_insertion ::=  _ | B | 0 | /

13
     zero_suppression ::=  Z {Z | context_sensitive_insertion} | fill_string

14
     context_sensitive_insertion ::=  simple_insertion

15
     fill_string ::=  * {* | context_sensitive_insertion}

16
     number ::=
        fore_digits [radix [aft_digits] {direct_insertion}]
      | radix aft_digits {direct_insertion}

17
     fore_digits ::= 9 {9 | direct_insertion}

18
     aft_digits ::=  {9 | direct_insertion} 9

19
     radix ::= . | V

20
     RHS_sign ::= + | - | > | CR | DB

21
     floating_LHS_sign ::=
        LHS_Sign {context_sensitive_insertion} LHS_Sign {LHS_Sign | context_sensitive_insertion}

22
     single_#_currency ::= #

23
     multiple_#_currency ::= ## {#}

24
     fixed_#_currency ::= single_#_currency | multiple_#_currency

25
     floating_$_currency ::=
        $ {context_sensitive_insertion} $ {$ | context_sensitive_insertion}

26
     floating_#_currency ::=
        # {context_sensitive_insertion} # {# | context_sensitive_insertion}

27
     all_sign_number ::=  all_sign_fore [radix [all_sign_aft]] [>]

28
     all_sign_fore ::=
        sign_char {context_sensitive_insertion} sign_char {sign_char | context_sensitive_insertion}

29
     all_sign_aft ::= {all_sign_aft_char} sign_char

     all_sign_aft_char ::=  sign_char | context_sensitive_insertion

30
     sign_char ::= + | - | <

31
     all_currency_number ::=  all_currency_fore [radix [all_currency_aft]]

32
     all_currency_fore ::=
        currency_char {context_sensitive_insertion}
          currency_char {currency_char | context_sensitive_insertion}

33
     all_currency_aft ::= {all_currency_aft_char} currency_char

     all_currency_aft_char ::= currency_char | context_sensitive_insertion

34
     currency_char ::= $ | #

35
     all_zero_suppression_number ::=  all_zero_suppression_fore [ radix [all_zero_suppression_aft]]

36
     all_zero_suppression_fore ::=
        zero_suppression_char {zero_suppression_char | context_sensitive_insertion}

37
     all_zero_suppression_aft ::= {all_zero_suppression_aft_char} zero_suppression_char

     all_zero_suppression_aft_char ::=  zero_suppression_char | context_sensitive_insertion

38
     zero_suppression_char ::= Z | *

39
The following composition constraints apply to a picture String:

40
   * A floating_LHS_sign does not have occurrences of different LHS_Sign
     Character values.

41
   * If a picture String has '<' as fixed_LHS_sign, then it has '>' as
     RHS_sign.

42
   * If a picture String has '<' in a floating_LHS_sign or in an
     all_sign_number, then it has an occurrence of '>'.

43/1
   * If a picture String has '+' or '-' as fixed_LHS_sign, in a
     floating_LHS_sign, or in an all_sign_number, then it has no
     RHS_sign or '>' character.

44
   * An instance of all_sign_number does not have occurrences of
     different sign_char Character values.

45
   * An instance of all_currency_number does not have occurrences of
     different currency_char Character values.

46
   * An instance of all_zero_suppression_number does not have
     occurrences of different zero_suppression_char Character values,
     except for possible case differences between 'Z' and 'z'.

47
A replicable Character is a Character that, by the above rules, can
occur in two consecutive positions in a picture String.

48
A Character replication is a String

49
     char & '(' & spaces & count_string & ')'

50
where char is a replicable Character, spaces is a String (possibly
empty) comprising only space Character values, and count_string is a
String of one or more decimal digit Character values.  A Character
replication in a picture String has the same effect as (and is said to
be equivalent to) a String comprising n consecutive occurrences of char,
where n=Integer'Value(count_string).

51
An expanded picture String is a picture String containing no Character
replications.

     NOTES

52
     3  Although a sign to the left of the number can float, a sign to
     the right of the number is in a fixed position.


File: arm2012.info,  Node: F.3.2,  Next: F.3.3,  Prev: F.3.1,  Up: F.3

F.3.2 Edited Output Generation
------------------------------

                          _Dynamic Semantics_

1
The contents of an edited output string are based on:

2
   * A value, Item, of some decimal type Num,

3
   * An expanded picture String Pic_String,

4
   * A Boolean value, Blank_When_Zero,

5
   * A Currency string,

6
   * A Fill character,

7
   * A Separator character, and

8
   * A Radix_Mark character.

9
The combination of a True value for Blank_When_Zero and a '*' character
in Pic_String is inconsistent; no edited output string is defined.

10
A layout error is identified in the rules below if leading nonzero
digits of Item, character values of the Currency string, or a negative
sign would be truncated; in such cases no edited output string is
defined.

11
The edited output string has lower bound 1 and upper bound N where N =
Pic_String'Length + Currency_Length_Adjustment - Radix_Adjustment, and

12
   * Currency_Length_Adjustment = Currency'Length - 1 if there is some
     occurrence of '$' in Pic_String, and 0 otherwise.

13
   * Radix_Adjustment = 1 if there is an occurrence of 'V' or 'v' in
     Pic_Str, and 0 otherwise.

14
Let the magnitude of Item be expressed as a base-10 number
Ip···I1.F1···Fq, called the displayed magnitude of Item, where:

15
   * q = Min(Max(Num'Scale, 0), n) where n is 0 if Pic_String has no
     radix and is otherwise the number of digit positions following
     radix in Pic_String, where a digit position corresponds to an
     occurrence of '9', a zero_suppression_char (for an
     all_zero_suppression_number), a currency_char (for an
     all_currency_number), or a sign_char (for an all_sign_number).

16
   * Ip /= 0 if p>0.

17
If n < Num'Scale, then the above number is the result of rounding (away
from 0 if exactly midway between values).

18
If Blank_When_Zero = True and the displayed magnitude of Item is zero,
then the edited output string comprises all space character values.
Otherwise, the picture String is treated as a sequence of instances of
syntactic categories based on the rules in *note F.3.1::, and the edited
output string is the concatenation of string values derived from these
categories according to the following mapping rules.

19
Table F-1 shows the mapping from a sign control symbol to a
corresponding character or string in the edited output.  In the columns
showing the edited output, a lower-case 'b' represents the space
character.  If there is no sign control symbol but the value of Item is
negative, a layout error occurs and no edited output string is produced.

Table F-1: Edited Output for Sign Control Symbols
Sign Control Symbol   Edited Output for    Edited Output for 
                      Nonnegative Number   Negative Number
'+'                   '+'                  '-'
'-'                   'b'                  '-'
'<'                   'b'                  '('
'>'                   'b'                  ')'
"CR"                  "bb"                 "CR"
"DB"                  "bb"                 "DB"
20
An instance of fixed_LHS_sign maps to a character as shown in Table F-1.

21
An instance of fixed_$_char maps to Currency.

22
An instance of direct_insertion maps to Separator if direct_insertion =
'_', and to the direct_insertion Character otherwise.

23
An instance of number maps to a string integer_part & radix_part &
fraction_part where:

24
   * The string for integer_part is obtained as follows:

25
          1.  Occurrences of '9' in fore_digits of number are replaced
          from right to left with the decimal digit character values for
          I1, ..., Ip, respectively.

26
          2.  Each occurrence of '9' in fore_digits to the left of the
          leftmost '9' replaced according to rule 1 is replaced with
          '0'.

27
          3.  If p exceeds the number of occurrences of '9' in
          fore_digits of number, then the excess leftmost digits are
          eligible for use in the mapping of an instance of
          zero_suppression, floating_LHS_sign, floating_$_currency, or
          floating_#_currency to the left of number; if there is no such
          instance, then a layout error occurs and no edited output
          string is produced.

28
   * The radix_part is:

29
             * "" if number does not include a radix, if radix = 'V', or
               if radix = 'v'

30
             * Radix_Mark if number includes '.'  as radix

31
   * The string for fraction_part is obtained as follows:

32
          1.  Occurrences of '9' in aft_digits of number are replaced
          from left to right with the decimal digit character values for
          F1, ...  Fq.

33
          2.  Each occurrence of '9' in aft_digits to the right of the
          rightmost '9' replaced according to rule 1 is replaced by '0'.

34
An instance of zero_suppression maps to the string obtained as follows:

35
     1.  The rightmost 'Z', 'z', or '*' Character values are replaced
     with the excess digits (if any) from the integer_part of the
     mapping of the number to the right of the zero_suppression
     instance,

36
     2.  A context_sensitive_insertion Character is replaced as though
     it were a direct_insertion Character, if it occurs to the right of
     some 'Z', 'z', or '*' in zero_suppression that has been mapped to
     an excess digit,

37
     3.  Each Character to the left of the leftmost Character replaced
     according to rule 1 above is replaced by:

38
             * the space character if the zero suppression Character is
               'Z' or 'z', or

39
             * the Fill character if the zero suppression Character is
               '*'.

40
     4.  A layout error occurs if some excess digits remain after all
     'Z', 'z', and '*' Character values in zero_suppression have been
     replaced via rule 1; no edited output string is produced.

41
An instance of RHS_sign maps to a character or string as shown in Table
F-1.

42
An instance of floating_LHS_sign maps to the string obtained as follows.

43
     1.  Up to all but one of the rightmost LHS_Sign Character values
     are replaced by the excess digits (if any) from the integer_part of
     the mapping of the number to the right of the floating_LHS_sign
     instance.

44
     2.  The next Character to the left is replaced with the character
     given by the entry in Table F-1 corresponding to the LHS_Sign
     Character.

45
     3.  A context_sensitive_insertion Character is replaced as though
     it were a direct_insertion Character, if it occurs to the right of
     the leftmost LHS_Sign character replaced according to rule 1.

46
     4.  Any other Character is replaced by the space character..

47
     5.  A layout error occurs if some excess digits remain after
     replacement via rule 1; no edited output string is produced.

48
An instance of fixed_#_currency maps to the Currency string with n space
character values concatenated on the left (if the instance does not
follow a radix) or on the right (if the instance does follow a radix),
where n is the difference between the length of the fixed_#_currency
instance and Currency'Length.  A layout error occurs if Currency'Length
exceeds the length of the fixed_#_currency instance; no edited output
string is produced.

49
An instance of floating_$_currency maps to the string obtained as
follows:

50
     1.  Up to all but one of the rightmost '$' Character values are
     replaced with the excess digits (if any) from the integer_part of
     the mapping of the number to the right of the floating_$_currency
     instance.

51
     2.  The next Character to the left is replaced by the Currency
     string.

52
     3.  A context_sensitive_insertion Character is replaced as though
     it were a direct_insertion Character, if it occurs to the right of
     the leftmost '$' Character replaced via rule 1.

53
     4.  Each other Character is replaced by the space character.

54
     5.  A layout error occurs if some excess digits remain after
     replacement by rule 1; no edited output string is produced.

55
An instance of floating_#_currency maps to the string obtained as
follows:

56
     1.  Up to all but one of the rightmost '#' Character values are
     replaced with the excess digits (if any) from the integer_part of
     the mapping of the number to the right of the floating_#_currency
     instance.

57
     2.  The substring whose last Character occurs at the position
     immediately preceding the leftmost Character replaced via rule 1,
     and whose length is Currency'Length, is replaced by the Currency
     string.

58
     3.  A context_sensitive_insertion Character is replaced as though
     it were a direct_insertion Character, if it occurs to the right of
     the leftmost '#' replaced via rule 1.

59
     4.  Any other Character is replaced by the space character.

60
     5.  A layout error occurs if some excess digits remain after
     replacement rule 1, or if there is no substring with the required
     length for replacement rule 2; no edited output string is produced.

61
An instance of all_zero_suppression_number maps to:

62
   * a string of all spaces if the displayed magnitude of Item is zero,
     the zero_suppression_char is 'Z' or 'z', and the instance of
     all_zero_suppression_number does not have a radix at its last
     character position;

63
   * a string containing the Fill character in each position except for
     the character (if any) corresponding to radix, if
     zero_suppression_char = '*' and the displayed magnitude of Item is
     zero;

64
   * otherwise, the same result as if each zero_suppression_char in
     all_zero_suppression_aft were '9', interpreting the instance of
     all_zero_suppression_number as either zero_suppression number (if a
     radix and all_zero_suppression_aft are present), or as
     zero_suppression otherwise.

65
An instance of all_sign_number maps to:

66
   * a string of all spaces if the displayed magnitude of Item is zero
     and the instance of all_sign_number does not have a radix at its
     last character position;

67
   * otherwise, the same result as if each sign_char in
     all_sign_number_aft were '9', interpreting the instance of
     all_sign_number as either floating_LHS_sign number (if a radix and
     all_sign_number_aft are present), or as floating_LHS_sign
     otherwise.

68
An instance of all_currency_number maps to:

69
   * a string of all spaces if the displayed magnitude of Item is zero
     and the instance of all_currency_number does not have a radix at
     its last character position;

70
   * otherwise, the same result as if each currency_char in
     all_currency_number_aft were '9', interpreting the instance of
     all_currency_number as floating_$_currency number or
     floating_#_currency number (if a radix and all_currency_number_aft
     are present), or as floating_$_currency or floating_#_currency
     otherwise.

                              _Examples_

71
In the result string values shown below, 'b' represents the space
character.

72
     Item:         Picture and Result Strings:

73/3
     123456.78     Picture:  "-###**_***_**9.99"
                   Result:   "bbb$***123,456.78"
                             "bbFF***123.456,78" (currency = "FF",
                                                  separator = '.',
                                                  radix mark = ',')

74/1
     123456.78     Picture:  "-$**_***_**9.99"
                   Result:   "b$***123,456.78"
                            "bFF***123.456,78" (currency = "FF",
                                                separator = '.',
                                                radix mark = ',')

75
     0.0          Picture: "-$$$$$$.$$"
                  Result:  "bbbbbbbbbb"

76
     0.20         Picture: "-$$$$$$.$$"
                  Result:  "bbbbbb$.20"

77
     -1234.565    Picture: "<<<<_<<<.<<###>"
                  Result:  "bb(1,234.57DMb)"  (currency = "DM")

78
     12345.67     Picture: "###_###_##9.99"
                  Result:  "bbCHF12,345.67"   (currency = "CHF")


File: arm2012.info,  Node: F.3.3,  Next: F.3.4,  Prev: F.3.2,  Up: F.3

F.3.3 The Package Text_IO.Editing
---------------------------------

1
The package Text_IO.Editing provides a private type Picture with
associated operations, and a generic package Decimal_Output.  An object
of type Picture is composed from a well-formed picture String (see *note
F.3.1::) and a Boolean item indicating whether a zero numeric value will
result in an edited output string of all space characters.  The package
Decimal_Output contains edited output subprograms implementing the
effects defined in *note F.3.2::.

                          _Static Semantics_

2
The library package Text_IO.Editing has the following declaration:

3
     package Ada.Text_IO.Editing is

4
        type Picture is private;

5
        function Valid (Pic_String      : in String;
                        Blank_When_Zero : in Boolean := False) return Boolean;

6
        function To_Picture (Pic_String      : in String;
                             Blank_When_Zero : in Boolean := False)
           return Picture;

7
        function Pic_String      (Pic : in Picture) return String;
        function Blank_When_Zero (Pic : in Picture) return Boolean;

8
        Max_Picture_Length  : constant := implementation_defined;

9
        Picture_Error       : exception;

10
        Default_Currency    : constant String    := "$";
        Default_Fill        : constant Character := '*';
        Default_Separator   : constant Character := ',';
        Default_Radix_Mark  : constant Character := '.';

11
        generic
           type Num is delta <> digits <>;
           Default_Currency   : in String    := Text_IO.Editing.Default_Currency;
           Default_Fill       : in Character := Text_IO.Editing.Default_Fill;
           Default_Separator  : in Character :=
                                   Text_IO.Editing.Default_Separator;
           Default_Radix_Mark : in Character :=
                                   Text_IO.Editing.Default_Radix_Mark;
        package Decimal_Output is
           function Length (Pic      : in Picture;
                            Currency : in String := Default_Currency)
              return Natural;

12
           function Valid (Item     : in Num;
                           Pic      : in Picture;
                           Currency : in String := Default_Currency)
              return Boolean;

13
           function Image (Item       : in Num;
                           Pic        : in Picture;
                           Currency   : in String    := Default_Currency;
                           Fill       : in Character := Default_Fill;
                           Separator  : in Character := Default_Separator;
                           Radix_Mark : in Character := Default_Radix_Mark)
              return String;

14
           procedure Put (File       : in File_Type;
                          Item       : in Num;
                          Pic        : in Picture;
                          Currency   : in String    := Default_Currency;
                          Fill       : in Character := Default_Fill;
                          Separator  : in Character := Default_Separator;
                          Radix_Mark : in Character := Default_Radix_Mark);

15
           procedure Put (Item       : in Num;
                          Pic        : in Picture;
                          Currency   : in String    := Default_Currency;
                          Fill       : in Character := Default_Fill;
                          Separator  : in Character := Default_Separator;
                          Radix_Mark : in Character := Default_Radix_Mark);

16
           procedure Put (To         : out String;
                          Item       : in Num;
                          Pic        : in Picture;
                          Currency   : in String    := Default_Currency;
                          Fill       : in Character := Default_Fill;
                          Separator  : in Character := Default_Separator;
                          Radix_Mark : in Character := Default_Radix_Mark);
        end Decimal_Output;
     private
        ... -- not specified by the language
     end Ada.Text_IO.Editing;

17
The exception Constraint_Error is raised if the Image function or any of
the Put procedures is invoked with a null string for Currency.

18
     function Valid (Pic_String      : in String;
                     Blank_When_Zero : in Boolean := False) return Boolean;

19
          Valid returns True if Pic_String is a well-formed picture
          String (see *note F.3.1::) the length of whose expansion does
          not exceed Max_Picture_Length, and if either Blank_When_Zero
          is False or Pic_String contains no '*'.

20
     function To_Picture (Pic_String      : in String;
                          Blank_When_Zero : in Boolean := False)
        return Picture;

21
          To_Picture returns a result Picture such that the application
          of the function Pic_String to this result yields an expanded
          picture String equivalent to Pic_String, and such that
          Blank_When_Zero applied to the result Picture is the same
          value as the parameter Blank_When_Zero.  Picture_Error is
          raised if not Valid(Pic_String, Blank_When_Zero).

22
     function Pic_String      (Pic : in Picture) return String;

     function Blank_When_Zero (Pic : in Picture) return Boolean;

23
          If Pic is To_Picture(String_Item, Boolean_Item) for some
          String_Item and Boolean_Item, then:

24
             * Pic_String(Pic) returns an expanded picture String
               equivalent to String_Item and with any lower-case letter
               replaced with its corresponding upper-case form, and

25
             * Blank_When_Zero(Pic) returns Boolean_Item.

26
          If Pic_1 and Pic_2 are objects of type Picture, then
          "="(Pic_1, Pic_2) is True when

27
             * Pic_String(Pic_1) = Pic_String(Pic_2), and

28
             * Blank_When_Zero(Pic_1) = Blank_When_Zero(Pic_2).

29
     function Length (Pic      : in Picture;
                      Currency : in String := Default_Currency)
        return Natural;

30
          Length returns Pic_String(Pic)'Length +
          Currency_Length_Adjustment - Radix_Adjustment where

31
             * Currency_Length_Adjustment =

32
                       * Currency'Length - 1 if there is some occurrence
                         of '$' in Pic_String(Pic), and

33
                       * 0 otherwise.

34
             * Radix_Adjustment =

35
                       * 1 if there is an occurrence of 'V' or 'v' in
                         Pic_Str(Pic), and

36
                       * 0 otherwise.

37
     function Valid (Item     : in Num;
                     Pic      : in Picture;
                     Currency : in String := Default_Currency)
        return Boolean;

38
          Valid returns True if Image(Item, Pic, Currency) does not
          raise Layout_Error, and returns False otherwise.

39
     function Image (Item       : in Num;
                     Pic        : in Picture;
                     Currency   : in String    := Default_Currency;
                     Fill       : in Character := Default_Fill;
                     Separator  : in Character := Default_Separator;
                     Radix_Mark : in Character := Default_Radix_Mark)
        return String;

40
          Image returns the edited output String as defined in *note
          F.3.2:: for Item, Pic_String(Pic), Blank_When_Zero(Pic),
          Currency, Fill, Separator, and Radix_Mark.  If these rules
          identify a layout error, then Image raises the exception
          Layout_Error.

41
     procedure Put (File       : in File_Type;
                    Item       : in Num;
                    Pic        : in Picture;
                    Currency   : in String    := Default_Currency;
                    Fill       : in Character := Default_Fill;
                    Separator  : in Character := Default_Separator;
                    Radix_Mark : in Character := Default_Radix_Mark);

     procedure Put (Item       : in Num;
                    Pic        : in Picture;
                    Currency   : in String    := Default_Currency;
                    Fill       : in Character := Default_Fill;
                    Separator  : in Character := Default_Separator;
                    Radix_Mark : in Character := Default_Radix_Mark);

42
          Each of these Put procedures outputs Image(Item, Pic,
          Currency, Fill, Separator, Radix_Mark) consistent with the
          conventions for Put for other real types in case of bounded
          line length (see *note A.10.6::, "*note A.10.6:: Get and Put
          Procedures").

43
     procedure Put (To         : out String;
                    Item       : in Num;
                    Pic        : in Picture;
                    Currency   : in String    := Default_Currency;
                    Fill       : in Character := Default_Fill;
                    Separator  : in Character := Default_Separator;
                    Radix_Mark : in Character := Default_Radix_Mark);

44/3
          Put copies Image(Item, Pic, Currency, Fill, Separator,
          Radix_Mark) to the given string, right justified.  Otherwise,
          unassigned Character values in To are assigned the space
          character.  If To'Length is less than the length of the string
          resulting from Image, then Layout_Error is raised.

                     _Implementation Requirements_

45
Max_Picture_Length shall be at least 30.  The implementation shall
support currency strings of length up to at least 10, both for
Default_Currency in an instantiation of Decimal_Output, and for Currency
in an invocation of Image or any of the Put procedures.

     NOTES

46
     4  The rules for edited output are based on COBOL (ANSI X3.23:1985,
     endorsed by ISO as ISO 1989-1985), with the following differences:

47
        * The COBOL provisions for picture string localization and for
          'P' format are absent from Ada.

48
        * The following Ada facilities are not in COBOL:

49
                  * currency symbol placement after the number,

50
                  * localization of edited output string for
                    multi-character currency string values, including
                    support for both length-preserving and
                    length-expanding currency symbols in picture strings

51
                  * localization of the radix mark, digits separator,
                    and fill character, and

52
                  * parenthesization of negative values.

52.1
     The value of 30 for Max_Picture_Length is the same limit as in
     COBOL.


File: arm2012.info,  Node: F.3.4,  Next: F.3.5,  Prev: F.3.3,  Up: F.3

F.3.4 The Package Wide_Text_IO.Editing
--------------------------------------

                          _Static Semantics_

1
The child package Wide_Text_IO.Editing has the same contents as
Text_IO.Editing, except that:

2
   * each occurrence of Character is replaced by Wide_Character,

3
   * each occurrence of Text_IO is replaced by Wide_Text_IO,

4
   * the subtype of Default_Currency is Wide_String rather than String,
     and

5
   * each occurrence of String in the generic package Decimal_Output is
     replaced by Wide_String.

     NOTES

6
     5  Each of the functions Wide_Text_IO.Editing.Valid, To_Picture,
     and Pic_String has String (versus Wide_String) as its parameter or
     result subtype, since a picture String is not localizable.


File: arm2012.info,  Node: F.3.5,  Prev: F.3.4,  Up: F.3

F.3.5 The Package Wide_Wide_Text_IO.Editing
-------------------------------------------

                          _Static Semantics_

1/2
The child package Wide_Wide_Text_IO.Editing has the same contents as
Text_IO.Editing, except that:

2/2
   * each occurrence of Character is replaced by Wide_Wide_Character,

3/2
   * each occurrence of Text_IO is replaced by Wide_Wide_Text_IO,

4/2
   * the subtype of Default_Currency is Wide_Wide_String rather than
     String, and

5/2
   * each occurrence of String in the generic package Decimal_Output is
     replaced by Wide_Wide_String.

     NOTES

6/2
     6  Each of the functions Wide_Wide_Text_IO.Editing.Valid,
     To_Picture, and Pic_String has String (versus Wide_Wide_String) as
     its parameter or result subtype, since a picture String is not
     localizable.


File: arm2012.info,  Node: Annex G,  Next: Annex H,  Prev: Annex F,  Up: Top

Annex G Numerics
****************

1
The Numerics Annex specifies

2
   * features for complex arithmetic, including complex I/O;

3
   * a mode ("strict mode"), in which the predefined arithmetic
     operations of floating point and fixed point types and the
     functions and operations of various predefined packages have to
     provide guaranteed accuracy or conform to other numeric performance
     requirements, which the Numerics Annex also specifies;

4
   * a mode ("relaxed mode"), in which no accuracy or other numeric
     performance requirements need be satisfied, as for implementations
     not conforming to the Numerics Annex;

5/2
   * models of floating point and fixed point arithmetic on which the
     accuracy requirements of strict mode are based;

6/2
   * the definitions of the model-oriented attributes of floating point
     types that apply in the strict mode; and

6.1/2
   * features for the manipulation of real and complex vectors and
     matrices.

                        _Implementation Advice_

7/3
If Fortran (respectively, C) is widely supported in the target
environment, implementations supporting the Numerics Annex should
provide the child package Interfaces.Fortran (respectively,
Interfaces.C) specified in *note Annex B:: and should support a
convention_identifier of Fortran (respectively, C) for the Convention
aspect (see *note Annex B::), thus allowing Ada programs to interface
with programs written in that language.

* Menu:

* G.1 ::      Complex Arithmetic
* G.2 ::      Numeric Performance Requirements
* G.3 ::      Vector and Matrix Manipulation


File: arm2012.info,  Node: G.1,  Next: G.2,  Up: Annex G

G.1 Complex Arithmetic
======================

1
Types and arithmetic operations for complex arithmetic are provided in
Generic_Complex_Types, which is defined in *note G.1.1::.
Implementation-defined approximations to the complex analogs of the
mathematical functions known as the "elementary functions" are provided
by the subprograms in Generic_Complex_Elementary_Functions, which is
defined in *note G.1.2::.  Both of these library units are generic
children of the predefined package Numerics (see *note A.5::).
Nongeneric equivalents of these generic packages for each of the
predefined floating point types are also provided as children of
Numerics.

* Menu:

* G.1.1 ::    Complex Types
* G.1.2 ::    Complex Elementary Functions
* G.1.3 ::    Complex Input-Output
* G.1.4 ::    The Package Wide_Text_IO.Complex_IO
* G.1.5 ::    The Package Wide_Wide_Text_IO.Complex_IO


File: arm2012.info,  Node: G.1.1,  Next: G.1.2,  Up: G.1

G.1.1 Complex Types
-------------------

                          _Static Semantics_

1
The generic library package Numerics.Generic_Complex_Types has the
following declaration:

2/1
     generic
        type Real is digits <>;
     package Ada.Numerics.Generic_Complex_Types is
        pragma Pure(Generic_Complex_Types);

3
        type Complex is
           record
              Re, Im : Real'Base;
           end record;

4/2
        type Imaginary is private;
        pragma Preelaborable_Initialization(Imaginary);

5
        i : constant Imaginary;
        j : constant Imaginary;

6
        function Re (X : Complex)   return Real'Base;
        function Im (X : Complex)   return Real'Base;
        function Im (X : Imaginary) return Real'Base;

7
        procedure Set_Re (X  : in out Complex;
                          Re : in     Real'Base);
        procedure Set_Im (X  : in out Complex;
                          Im : in     Real'Base);
        procedure Set_Im (X  :    out Imaginary;
                          Im : in     Real'Base);

8
        function Compose_From_Cartesian (Re, Im : Real'Base) return Complex;
        function Compose_From_Cartesian (Re     : Real'Base) return Complex;
        function Compose_From_Cartesian (Im     : Imaginary) return Complex;

9
        function Modulus (X     : Complex) return Real'Base;
        function "abs"   (Right : Complex) return Real'Base renames Modulus;

10
        function Argument (X     : Complex)   return Real'Base;
        function Argument (X     : Complex;
                           Cycle : Real'Base) return Real'Base;

11
        function Compose_From_Polar (Modulus, Argument        : Real'Base)
           return Complex;
        function Compose_From_Polar (Modulus, Argument, Cycle : Real'Base)
           return Complex;

12
        function "+"       (Right : Complex) return Complex;
        function "-"       (Right : Complex) return Complex;
        function Conjugate (X     : Complex) return Complex;

13
        function "+" (Left, Right : Complex) return Complex;
        function "-" (Left, Right : Complex) return Complex;
        function "*" (Left, Right : Complex) return Complex;
        function "/" (Left, Right : Complex) return Complex;

14
        function "**" (Left : Complex; Right : Integer) return Complex;

15
        function "+"       (Right : Imaginary) return Imaginary;
        function "-"       (Right : Imaginary) return Imaginary;
        function Conjugate (X     : Imaginary) return Imaginary renames "-";
        function "abs"     (Right : Imaginary) return Real'Base;

16
        function "+" (Left, Right : Imaginary) return Imaginary;
        function "-" (Left, Right : Imaginary) return Imaginary;
        function "*" (Left, Right : Imaginary) return Real'Base;
        function "/" (Left, Right : Imaginary) return Real'Base;

17
        function "**" (Left : Imaginary; Right : Integer) return Complex;

18
        function "<"  (Left, Right : Imaginary) return Boolean;
        function "<=" (Left, Right : Imaginary) return Boolean;
        function ">"  (Left, Right : Imaginary) return Boolean;
        function ">=" (Left, Right : Imaginary) return Boolean;

19
        function "+" (Left : Complex;   Right : Real'Base) return Complex;
        function "+" (Left : Real'Base; Right : Complex)   return Complex;
        function "-" (Left : Complex;   Right : Real'Base) return Complex;
        function "-" (Left : Real'Base; Right : Complex)   return Complex;
        function "*" (Left : Complex;   Right : Real'Base) return Complex;
        function "*" (Left : Real'Base; Right : Complex)   return Complex;
        function "/" (Left : Complex;   Right : Real'Base) return Complex;
        function "/" (Left : Real'Base; Right : Complex)   return Complex;

20
        function "+" (Left : Complex;   Right : Imaginary) return Complex;
        function "+" (Left : Imaginary; Right : Complex)   return Complex;
        function "-" (Left : Complex;   Right : Imaginary) return Complex;
        function "-" (Left : Imaginary; Right : Complex)   return Complex;
        function "*" (Left : Complex;   Right : Imaginary) return Complex;
        function "*" (Left : Imaginary; Right : Complex)   return Complex;
        function "/" (Left : Complex;   Right : Imaginary) return Complex;
        function "/" (Left : Imaginary; Right : Complex)   return Complex;

21
        function "+" (Left : Imaginary; Right : Real'Base) return Complex;
        function "+" (Left : Real'Base; Right : Imaginary) return Complex;
        function "-" (Left : Imaginary; Right : Real'Base) return Complex;
        function "-" (Left : Real'Base; Right : Imaginary) return Complex;
        function "*" (Left : Imaginary; Right : Real'Base) return Imaginary;
        function "*" (Left : Real'Base; Right : Imaginary) return Imaginary;
        function "/" (Left : Imaginary; Right : Real'Base) return Imaginary;
        function "/" (Left : Real'Base; Right : Imaginary) return Imaginary;

22
     private

23
        type Imaginary is new Real'Base;
        i : constant Imaginary := 1.0;
        j : constant Imaginary := 1.0;

24
     end Ada.Numerics.Generic_Complex_Types;

25/1
The library package Numerics.Complex_Types is declared pure and defines
the same types, constants, and subprograms as
Numerics.Generic_Complex_Types, except that the predefined type Float is
systematically substituted for Real'Base throughout.  Nongeneric
equivalents of Numerics.Generic_Complex_Types for each of the other
predefined floating point types are defined similarly, with the names
Numerics.Short_Complex_Types, Numerics.Long_Complex_Types, etc.

26/2
Complex is a visible type with Cartesian components.

27
Imaginary is a private type; its full type is derived from Real'Base.

28
The arithmetic operations and the Re, Im, Modulus, Argument, and
Conjugate functions have their usual mathematical meanings.  When
applied to a parameter of pure-imaginary type, the "imaginary-part"
function Im yields the value of its parameter, as the corresponding real
value.  The remaining subprograms have the following meanings:

29
   * The Set_Re and Set_Im procedures replace the designated component
     of a complex parameter with the given real value; applied to a
     parameter of pure-imaginary type, the Set_Im procedure replaces the
     value of that parameter with the imaginary value corresponding to
     the given real value.

30
   * The Compose_From_Cartesian function constructs a complex value from
     the given real and imaginary components.  If only one component is
     given, the other component is implicitly zero.

31
   * The Compose_From_Polar function constructs a complex value from the
     given modulus (radius) and argument (angle).  When the value of the
     parameter Modulus is positive (resp., negative), the result is the
     complex value represented by the point in the complex plane lying
     at a distance from the origin given by the absolute value of
     Modulus and forming an angle measured counterclockwise from the
     positive (resp., negative) real axis given by the value of the
     parameter Argument.

32
When the Cycle parameter is specified, the result of the Argument
function and the parameter Argument of the Compose_From_Polar function
are measured in units such that a full cycle of revolution has the given
value; otherwise, they are measured in radians.

33
The computed results of the mathematically multivalued functions are
rendered single-valued by the following conventions, which are meant to
imply the principal branch:

34
   * The result of the Modulus function is nonnegative.

35
   * The result of the Argument function is in the quadrant containing
     the point in the complex plane represented by the parameter X. This
     may be any quadrant (I through IV); thus, the range of the Argument
     function is approximately -PI to PI (-Cycle/2.0 to Cycle/2.0, if
     the parameter Cycle is specified).  When the point represented by
     the parameter X lies on the negative real axis, the result
     approximates

36
             * PI (resp., -PI) when the sign of the imaginary component
               of X is positive (resp., negative), if Real'Signed_Zeros
               is True;

37
             * PI, if Real'Signed_Zeros is False.

38
   * Because a result lying on or near one of the axes may not be
     exactly representable, the approximation inherent in computing the
     result may place it in an adjacent quadrant, close to but on the
     wrong side of the axis.

                          _Dynamic Semantics_

39
The exception Numerics.Argument_Error is raised by the Argument and
Compose_From_Polar functions with specified cycle, signaling a parameter
value outside the domain of the corresponding mathematical function,
when the value of the parameter Cycle is zero or negative.

40
The exception Constraint_Error is raised by the division operator when
the value of the right operand is zero, and by the exponentiation
operator when the value of the left operand is zero and the value of the
exponent is negative, provided that Real'Machine_Overflows is True; when
Real'Machine_Overflows is False, the result is unspecified.
Constraint_Error can also be raised when a finite result overflows (see
*note G.2.6::).

                     _Implementation Requirements_

41
In the implementation of Numerics.Generic_Complex_Types, the range of
intermediate values allowed during the calculation of a final result
shall not be affected by any range constraint of the subtype Real.

42
In the following cases, evaluation of a complex arithmetic operation
shall yield the prescribed result, provided that the preceding rules do
not call for an exception to be raised:

43
   * The results of the Re, Im, and Compose_From_Cartesian functions are
     exact.

44
   * The real (resp., imaginary) component of the result of a binary
     addition operator that yields a result of complex type is exact
     when either of its operands is of pure-imaginary (resp., real)
     type.

45
   * The real (resp., imaginary) component of the result of a binary
     subtraction operator that yields a result of complex type is exact
     when its right operand is of pure-imaginary (resp., real) type.

46
   * The real component of the result of the Conjugate function for the
     complex type is exact.

47
   * When the point in the complex plane represented by the parameter X
     lies on the nonnegative real axis, the Argument function yields a
     result of zero.

48
   * When the value of the parameter Modulus is zero, the
     Compose_From_Polar function yields a result of zero.

49
   * When the value of the parameter Argument is equal to a multiple of
     the quarter cycle, the result of the Compose_From_Polar function
     with specified cycle lies on one of the axes.  In this case, one of
     its components is zero, and the other has the magnitude of the
     parameter Modulus.

50
   * Exponentiation by a zero exponent yields the value one.
     Exponentiation by a unit exponent yields the value of the left
     operand.  Exponentiation of the value one yields the value one.
     Exponentiation of the value zero yields the value zero, provided
     that the exponent is nonzero.  When the left operand is of
     pure-imaginary type, one component of the result of the
     exponentiation operator is zero.

51
When the result, or a result component, of any operator of
Numerics.Generic_Complex_Types has a mathematical definition in terms of
a single arithmetic or relational operation, that result or result
component exhibits the accuracy of the corresponding operation of the
type Real.

52
Other accuracy requirements for the Modulus, Argument, and
Compose_From_Polar functions, and accuracy requirements for the
multiplication of a pair of complex operands or for division by a
complex operand, all of which apply only in the strict mode, are given
in *note G.2.6::.

53
The sign of a zero result or zero result component yielded by a complex
arithmetic operation or function is implementation defined when
Real'Signed_Zeros is True.

                     _Implementation Permissions_

54
The nongeneric equivalent packages may, but need not, be actual
instantiations of the generic package for the appropriate predefined
type.

55/2
Implementations may obtain the result of exponentiation of a complex or
pure-imaginary operand by repeated complex multiplication, with
arbitrary association of the factors and with a possible final complex
reciprocation (when the exponent is negative).  Implementations are also
permitted to obtain the result of exponentiation of a complex operand,
but not of a pure-imaginary operand, by converting the left operand to a
polar representation; exponentiating the modulus by the given exponent;
multiplying the argument by the given exponent; and reconverting to a
Cartesian representation.  Because of this implementation freedom, no
accuracy requirement is imposed on complex exponentiation (except for
the prescribed results given above, which apply regardless of the
implementation method chosen).

                        _Implementation Advice_

56
Because the usual mathematical meaning of multiplication of a complex
operand and a real operand is that of the scaling of both components of
the former by the latter, an implementation should not perform this
operation by first promoting the real operand to complex type and then
performing a full complex multiplication.  In systems that, in the
future, support an Ada binding to IEC 559:1989, the latter technique
will not generate the required result when one of the components of the
complex operand is infinite.  (Explicit multiplication of the infinite
component by the zero component obtained during promotion yields a NaN
that propagates into the final result.)  Analogous advice applies in the
case of multiplication of a complex operand and a pure-imaginary
operand, and in the case of division of a complex operand by a real or
pure-imaginary operand.

57
Likewise, because the usual mathematical meaning of addition of a
complex operand and a real operand is that the imaginary operand remains
unchanged, an implementation should not perform this operation by first
promoting the real operand to complex type and then performing a full
complex addition.  In implementations in which the Signed_Zeros
attribute of the component type is True (and which therefore conform to
IEC 559:1989 in regard to the handling of the sign of zero in predefined
arithmetic operations), the latter technique will not generate the
required result when the imaginary component of the complex operand is a
negatively signed zero.  (Explicit addition of the negative zero to the
zero obtained during promotion yields a positive zero.)  Analogous
advice applies in the case of addition of a complex operand and a
pure-imaginary operand, and in the case of subtraction of a complex
operand and a real or pure-imaginary operand.

58
Implementations in which Real'Signed_Zeros is True should attempt to
provide a rational treatment of the signs of zero results and result
components.  As one example, the result of the Argument function should
have the sign of the imaginary component of the parameter X when the
point represented by that parameter lies on the positive real axis; as
another, the sign of the imaginary component of the Compose_From_Polar
function should be the same as (resp., the opposite of) that of the
Argument parameter when that parameter has a value of zero and the
Modulus parameter has a nonnegative (resp., negative) value.


File: arm2012.info,  Node: G.1.2,  Next: G.1.3,  Prev: G.1.1,  Up: G.1

G.1.2 Complex Elementary Functions
----------------------------------

                          _Static Semantics_

1
The generic library package
Numerics.Generic_Complex_Elementary_Functions has the following
declaration:

2/2
     with Ada.Numerics.Generic_Complex_Types;
     generic
        with package Complex_Types is
              new Ada.Numerics.Generic_Complex_Types (<>);
        use Complex_Types;
     package Ada.Numerics.Generic_Complex_Elementary_Functions is
        pragma Pure(Generic_Complex_Elementary_Functions);

3
        function Sqrt (X : Complex)   return Complex;
        function Log  (X : Complex)   return Complex;
        function Exp  (X : Complex)   return Complex;
        function Exp  (X : Imaginary) return Complex;
        function "**" (Left : Complex;   Right : Complex)   return Complex;
        function "**" (Left : Complex;   Right : Real'Base) return Complex;
        function "**" (Left : Real'Base; Right : Complex)   return Complex;

4
        function Sin (X : Complex) return Complex;
        function Cos (X : Complex) return Complex;
        function Tan (X : Complex) return Complex;
        function Cot (X : Complex) return Complex;

5
        function Arcsin (X : Complex) return Complex;
        function Arccos (X : Complex) return Complex;
        function Arctan (X : Complex) return Complex;
        function Arccot (X : Complex) return Complex;

6
        function Sinh (X : Complex) return Complex;
        function Cosh (X : Complex) return Complex;
        function Tanh (X : Complex) return Complex;
        function Coth (X : Complex) return Complex;

7
        function Arcsinh (X : Complex) return Complex;
        function Arccosh (X : Complex) return Complex;
        function Arctanh (X : Complex) return Complex;
        function Arccoth (X : Complex) return Complex;

8
     end Ada.Numerics.Generic_Complex_Elementary_Functions;

9/1
The library package Numerics.Complex_Elementary_Functions is declared
pure and defines the same subprograms as
Numerics.Generic_Complex_Elementary_Functions, except that the
predefined type Float is systematically substituted for Real'Base, and
the Complex and Imaginary types exported by Numerics.Complex_Types are
systematically substituted for Complex and Imaginary, throughout.
Nongeneric equivalents of Numerics.Generic_Complex_Elementary_Functions
corresponding to each of the other predefined floating point types are
defined similarly, with the names
Numerics.Short_Complex_Elementary_Functions,
Numerics.Long_Complex_Elementary_Functions, etc.

10
The overloading of the Exp function for the pure-imaginary type is
provided to give the user an alternate way to compose a complex value
from a given modulus and argument.  In addition to
Compose_From_Polar(Rho, Theta) (see *note G.1.1::), the programmer may
write Rho * Exp(i * Theta).

11
The imaginary (resp., real) component of the parameter X of the forward
hyperbolic (resp., trigonometric) functions and of the Exp function (and
the parameter X, itself, in the case of the overloading of the Exp
function for the pure-imaginary type) represents an angle measured in
radians, as does the imaginary (resp., real) component of the result of
the Log and inverse hyperbolic (resp., trigonometric) functions.

12
The functions have their usual mathematical meanings.  However, the
arbitrariness inherent in the placement of branch cuts, across which
some of the complex elementary functions exhibit discontinuities, is
eliminated by the following conventions:

13
   * The imaginary component of the result of the Sqrt and Log functions
     is discontinuous as the parameter X crosses the negative real axis.

14
   * The result of the exponentiation operator when the left operand is
     of complex type is discontinuous as that operand crosses the
     negative real axis.

15/2
   * The imaginary component of the result of the Arcsin, Arccos, and
     Arctanh functions is discontinuous as the parameter X crosses the
     real axis to the left of -1.0 or the right of 1.0.

16/2
   * The real component of the result of the Arctan and Arcsinh
     functions is discontinuous as the parameter X crosses the imaginary
     axis below -i or above i.

17/2
   * The real component of the result of the Arccot function is
     discontinuous as the parameter X crosses the imaginary axis below
     -i or above i.

18
   * The imaginary component of the Arccosh function is discontinuous as
     the parameter X crosses the real axis to the left of 1.0.

19
   * The imaginary component of the result of the Arccoth function is
     discontinuous as the parameter X crosses the real axis between -1.0
     and 1.0.

20/2
The computed results of the mathematically multivalued functions are
rendered single-valued by the following conventions, which are meant to
imply that the principal branch is an analytic continuation of the
corresponding real-valued function in
Numerics.Generic_Elementary_Functions.  (For Arctan and Arccot, the
single-argument function in question is that obtained from the
two-argument version by fixing the second argument to be its default
value.)

21
   * The real component of the result of the Sqrt and Arccosh functions
     is nonnegative.

22
   * The same convention applies to the imaginary component of the
     result of the Log function as applies to the result of the
     natural-cycle version of the Argument function of
     Numerics.Generic_Complex_Types (see *note G.1.1::).

23
   * The range of the real (resp., imaginary) component of the result of
     the Arcsin and Arctan (resp., Arcsinh and Arctanh) functions is
     approximately -PI/2.0 to PI/2.0.

24
   * The real (resp., imaginary) component of the result of the Arccos
     and Arccot (resp., Arccoth) functions ranges from 0.0 to
     approximately PI.

25
   * The range of the imaginary component of the result of the Arccosh
     function is approximately -PI to PI.

26
In addition, the exponentiation operator inherits the single-valuedness
of the Log function.

                          _Dynamic Semantics_

27
The exception Numerics.Argument_Error is raised by the exponentiation
operator, signaling a parameter value outside the domain of the
corresponding mathematical function, when the value of the left operand
is zero and the real component of the exponent (or the exponent itself,
when it is of real type) is zero.

28
The exception Constraint_Error is raised, signaling a pole of the
mathematical function (analogous to dividing by zero), in the following
cases, provided that Complex_Types.Real'Machine_Overflows is True:

29
   * by the Log, Cot, and Coth functions, when the value of the
     parameter X is zero;

30
   * by the exponentiation operator, when the value of the left operand
     is zero and the real component of the exponent (or the exponent
     itself, when it is of real type) is negative;

31
   * by the Arctan and Arccot functions, when the value of the parameter
     X is ± i;

32
   * by the Arctanh and Arccoth functions, when the value of the
     parameter X is ± 1.0.

33
Constraint_Error can also be raised when a finite result overflows (see
*note G.2.6::); this may occur for parameter values sufficiently near
poles, and, in the case of some of the functions, for parameter values
having components of sufficiently large magnitude. When
Complex_Types.Real'Machine_Overflows is False, the result at poles is
unspecified.

                     _Implementation Requirements_

34
In the implementation of Numerics.Generic_Complex_Elementary_Functions,
the range of intermediate values allowed during the calculation of a
final result shall not be affected by any range constraint of the
subtype Complex_Types.Real.

35
In the following cases, evaluation of a complex elementary function
shall yield the prescribed result (or a result having the prescribed
component), provided that the preceding rules do not call for an
exception to be raised:

36
   * When the parameter X has the value zero, the Sqrt, Sin, Arcsin,
     Tan, Arctan, Sinh, Arcsinh, Tanh, and Arctanh functions yield a
     result of zero; the Exp, Cos, and Cosh functions yield a result of
     one; the Arccos and Arccot functions yield a real result; and the
     Arccoth function yields an imaginary result.

37
   * When the parameter X has the value one, the Sqrt function yields a
     result of one; the Log, Arccos, and Arccosh functions yield a
     result of zero; and the Arcsin function yields a real result.

38
   * When the parameter X has the value -1.0, the Sqrt function yields
     the result

39
             * i (resp., -i), when the sign of the imaginary component
               of X is positive (resp., negative), if
               Complex_Types.Real'Signed_Zeros is True;

40
             * i, if Complex_Types.Real'Signed_Zeros is False;

41/2
   * When the parameter X has the value -1.0, the Log function yields an
     imaginary result; and the Arcsin and Arccos functions yield a real
     result.

42
   * When the parameter X has the value ± i, the Log function yields an
     imaginary result.

43
   * Exponentiation by a zero exponent yields the value one.
     Exponentiation by a unit exponent yields the value of the left
     operand (as a complex value).  Exponentiation of the value one
     yields the value one.  Exponentiation of the value zero yields the
     value zero.

44
Other accuracy requirements for the complex elementary functions, which
apply only in the strict mode, are given in *note G.2.6::.

45
The sign of a zero result or zero result component yielded by a complex
elementary function is implementation defined when
Complex_Types.Real'Signed_Zeros is True.

                     _Implementation Permissions_

46
The nongeneric equivalent packages may, but need not, be actual
instantiations of the generic package with the appropriate predefined
nongeneric equivalent of Numerics.Generic_Complex_Types; if they are,
then the latter shall have been obtained by actual instantiation of
Numerics.Generic_Complex_Types.

47
The exponentiation operator may be implemented in terms of the Exp and
Log functions.  Because this implementation yields poor accuracy in some
parts of the domain, no accuracy requirement is imposed on complex
exponentiation.

48
The implementation of the Exp function of a complex parameter X is
allowed to raise the exception Constraint_Error, signaling overflow,
when the real component of X exceeds an unspecified threshold that is
approximately log(Complex_Types.Real'Safe_Last).  This permission
recognizes the impracticality of avoiding overflow in the marginal case
that the exponential of the real component of X exceeds the safe range
of Complex_Types.Real but both components of the final result do not.
Similarly, the Sin and Cos (resp., Sinh and Cosh) functions are allowed
to raise the exception Constraint_Error, signaling overflow, when the
absolute value of the imaginary (resp., real) component of the parameter
X exceeds an unspecified threshold that is approximately
log(Complex_Types.Real'Safe_Last) + log(2.0). This permission recognizes
the impracticality of avoiding overflow in the marginal case that the
hyperbolic sine or cosine of the imaginary (resp., real) component of X
exceeds the safe range of Complex_Types.Real but both components of the
final result do not.

                        _Implementation Advice_

49
Implementations in which Complex_Types.Real'Signed_Zeros is True should
attempt to provide a rational treatment of the signs of zero results and
result components.  For example, many of the complex elementary
functions have components that are odd functions of one of the parameter
components; in these cases, the result component should have the sign of
the parameter component at the origin.  Other complex elementary
functions have zero components whose sign is opposite that of a
parameter component at the origin, or is always positive or always
negative.


File: arm2012.info,  Node: G.1.3,  Next: G.1.4,  Prev: G.1.2,  Up: G.1

G.1.3 Complex Input-Output
--------------------------

1
The generic package Text_IO.Complex_IO defines procedures for the
formatted input and output of complex values.  The generic actual
parameter in an instantiation of Text_IO.Complex_IO is an instance of
Numerics.Generic_Complex_Types for some floating point subtype.
Exceptional conditions are reported by raising the appropriate exception
defined in Text_IO.

                          _Static Semantics_

2
The generic library package Text_IO.Complex_IO has the following
declaration:

3
     with Ada.Numerics.Generic_Complex_Types;
     generic
        with package Complex_Types is
              new Ada.Numerics.Generic_Complex_Types (<>);
     package Ada.Text_IO.Complex_IO is

4
        use Complex_Types;

5
        Default_Fore : Field := 2;
        Default_Aft  : Field := Real'Digits - 1;
        Default_Exp  : Field := 3;

6
        procedure Get (File  : in  File_Type;
                       Item  : out Complex;
                       Width : in  Field := 0);
        procedure Get (Item  : out Complex;
                       Width : in  Field := 0);

7
        procedure Put (File : in File_Type;
                       Item : in Complex;
                       Fore : in Field := Default_Fore;
                       Aft  : in Field := Default_Aft;
                       Exp  : in Field := Default_Exp);
        procedure Put (Item : in Complex;
                       Fore : in Field := Default_Fore;
                       Aft  : in Field := Default_Aft;
                       Exp  : in Field := Default_Exp);

8
        procedure Get (From : in  String;
                       Item : out Complex;
                       Last : out Positive);
        procedure Put (To   : out String;
                       Item : in  Complex;
                       Aft  : in  Field := Default_Aft;
                       Exp  : in  Field := Default_Exp);

9
     end Ada.Text_IO.Complex_IO;

9.1/2
The library package Complex_Text_IO defines the same subprograms as
Text_IO.Complex_IO, except that the predefined type Float is
systematically substituted for Real, and the type
Numerics.Complex_Types.Complex is systematically substituted for Complex
throughout.  Nongeneric equivalents of Text_IO.Complex_IO corresponding
to each of the other predefined floating point types are defined
similarly, with the names Short_Complex_Text_IO, Long_Complex_Text_IO,
etc.

10
The semantics of the Get and Put procedures are as follows:

11
     procedure Get (File  : in  File_Type;
                    Item  : out Complex;
                    Width : in  Field := 0);
     procedure Get (Item  : out Complex;
                    Width : in  Field := 0);

12/1
          The input sequence is a pair of optionally signed real
          literals representing the real and imaginary components of a
          complex value.  These components have the format defined for
          the corresponding Get procedure of an instance of
          Text_IO.Float_IO (see *note A.10.9::) for the base subtype of
          Complex_Types.Real.  The pair of components may be separated
          by a comma or surrounded by a pair of parentheses or both.
          Blanks are freely allowed before each of the components and
          before the parentheses and comma, if either is used.  If the
          value of the parameter Width is zero, then

13
             * line and page terminators are also allowed in these
               places;

14
             * the components shall be separated by at least one blank
               or line terminator if the comma is omitted; and

15
             * reading stops when the right parenthesis has been read,
               if the input sequence includes a left parenthesis, or
               when the imaginary component has been read, otherwise.

15.1
          If a nonzero value of Width is supplied, then

16
             * the components shall be separated by at least one blank
               if the comma is omitted; and

17
             * exactly Width characters are read, or the characters
               (possibly none) up to a line terminator, whichever comes
               first (blanks are included in the count).

18
          Returns, in the parameter Item, the value of type Complex that
          corresponds to the input sequence.

19
          The exception Text_IO.Data_Error is raised if the input
          sequence does not have the required syntax or if the
          components of the complex value obtained are not of the base
          subtype of Complex_Types.Real.

20
     procedure Put (File : in File_Type;
                    Item : in Complex;
                    Fore : in Field := Default_Fore;
                    Aft  : in Field := Default_Aft;
                    Exp  : in Field := Default_Exp);
     procedure Put (Item : in Complex;
                    Fore : in Field := Default_Fore;
                    Aft  : in Field := Default_Aft;
                    Exp  : in Field := Default_Exp);

21
          Outputs the value of the parameter Item as a pair of decimal
          literals representing the real and imaginary components of the
          complex value, using the syntax of an aggregate.  More
          specifically,

22
             * outputs a left parenthesis;

23
             * outputs the value of the real component of the parameter
               Item with the format defined by the corresponding Put
               procedure of an instance of Text_IO.Float_IO for the base
               subtype of Complex_Types.Real, using the given values of
               Fore, Aft, and Exp;

24
             * outputs a comma;

25
             * outputs the value of the imaginary component of the
               parameter Item with the format defined by the
               corresponding Put procedure of an instance of
               Text_IO.Float_IO for the base subtype of
               Complex_Types.Real, using the given values of Fore, Aft,
               and Exp;

26
             * outputs a right parenthesis.

27
     procedure Get (From : in  String;
                    Item : out Complex;
                    Last : out Positive);

28/2
          Reads a complex value from the beginning of the given string,
          following the same rule as the Get procedure that reads a
          complex value from a file, but treating the end of the string
          as a file terminator.  Returns, in the parameter Item, the
          value of type Complex that corresponds to the input sequence.
          Returns in Last the index value such that From(Last) is the
          last character read.

29
          The exception Text_IO.Data_Error is raised if the input
          sequence does not have the required syntax or if the
          components of the complex value obtained are not of the base
          subtype of Complex_Types.Real.

30
     procedure Put (To   : out String;
                    Item : in  Complex;
                    Aft  : in  Field := Default_Aft;
                    Exp  : in  Field := Default_Exp);

31
          Outputs the value of the parameter Item to the given string as
          a pair of decimal literals representing the real and imaginary
          components of the complex value, using the syntax of an
          aggregate.  More specifically,

32
             * a left parenthesis, the real component, and a comma are
               left justified in the given string, with the real
               component having the format defined by the Put procedure
               (for output to a file) of an instance of Text_IO.Float_IO
               for the base subtype of Complex_Types.Real, using a value
               of zero for Fore and the given values of Aft and Exp;

33
             * the imaginary component and a right parenthesis are right
               justified in the given string, with the imaginary
               component having the format defined by the Put procedure
               (for output to a file) of an instance of Text_IO.Float_IO
               for the base subtype of Complex_Types.Real, using a value
               for Fore that completely fills the remainder of the
               string, together with the given values of Aft and Exp.

34
          The exception Text_IO.Layout_Error is raised if the given
          string is too short to hold the formatted output.

                     _Implementation Permissions_

35
Other exceptions declared (by renaming) in Text_IO may be raised by the
preceding procedures in the appropriate circumstances, as for the
corresponding procedures of Text_IO.Float_IO.


File: arm2012.info,  Node: G.1.4,  Next: G.1.5,  Prev: G.1.3,  Up: G.1

G.1.4 The Package Wide_Text_IO.Complex_IO
-----------------------------------------

                          _Static Semantics_

1
Implementations shall also provide the generic library package
Wide_Text_IO.Complex_IO. Its declaration is obtained from that of
Text_IO.Complex_IO by systematically replacing Text_IO by Wide_Text_IO
and String by Wide_String; the description of its behavior is obtained
by additionally replacing references to particular characters (commas,
parentheses, etc.)  by those for the corresponding wide characters.


File: arm2012.info,  Node: G.1.5,  Prev: G.1.4,  Up: G.1

G.1.5 The Package Wide_Wide_Text_IO.Complex_IO
----------------------------------------------

                          _Static Semantics_

1/2
Implementations shall also provide the generic library package
Wide_Wide_Text_IO.Complex_IO. Its declaration is obtained from that of
Text_IO.Complex_IO by systematically replacing Text_IO by
Wide_Wide_Text_IO and String by Wide_Wide_String; the description of its
behavior is obtained by additionally replacing references to particular
characters (commas, parentheses, etc.)  by those for the corresponding
wide wide characters.


File: arm2012.info,  Node: G.2,  Next: G.3,  Prev: G.1,  Up: Annex G

G.2 Numeric Performance Requirements
====================================

                     _Implementation Requirements_

1
Implementations shall provide a user-selectable mode in which the
accuracy and other numeric performance requirements detailed in the
following subclauses are observed.  This mode, referred to as the strict
mode, may or may not be the default mode; it directly affects the
results of the predefined arithmetic operations of real types and the
results of the subprograms in children of the Numerics package, and
indirectly affects the operations in other language defined packages.
Implementations shall also provide the opposing mode, which is known as
the relaxed mode.

                     _Implementation Permissions_

2
Either mode may be the default mode.

3
The two modes need not actually be different.

* Menu:

* G.2.1 ::    Model of Floating Point Arithmetic
* G.2.2 ::    Model-Oriented Attributes of Floating Point Types
* G.2.3 ::    Model of Fixed Point Arithmetic
* G.2.4 ::    Accuracy Requirements for the Elementary Functions
* G.2.5 ::    Performance Requirements for Random Number Generation
* G.2.6 ::    Accuracy Requirements for Complex Arithmetic


File: arm2012.info,  Node: G.2.1,  Next: G.2.2,  Up: G.2

G.2.1 Model of Floating Point Arithmetic
----------------------------------------

1
In the strict mode, the predefined operations of a floating point type
shall satisfy the accuracy requirements specified here and shall avoid
or signal overflow in the situations described.  This behavior is
presented in terms of a model of floating point arithmetic that builds
on the concept of the canonical form (see *note A.5.3::).

                          _Static Semantics_

2
Associated with each floating point type is an infinite set of model
numbers.  The model numbers of a type are used to define the accuracy
requirements that have to be satisfied by certain predefined operations
of the type; through certain attributes of the model numbers, they are
also used to explain the meaning of a user-declared floating point type
declaration.  The model numbers of a derived type are those of the
parent type; the model numbers of a subtype are those of its type.

3
The model numbers of a floating point type T are zero and all the values
expressible in the canonical form (for the type T), in which mantissa
has T'Model_Mantissa digits and exponent has a value greater than or
equal to T'Model_Emin.  (These attributes are defined in *note G.2.2::.)

4
A model interval of a floating point type is any interval whose bounds
are model numbers of the type. The model interval of a type T associated
with a value v is the smallest model interval of T that includes v.
(The model interval associated with a model number of a type consists of
that number only.)

                     _Implementation Requirements_

5
The accuracy requirements for the evaluation of certain predefined
operations of floating point types are as follows.

6
An operand interval is the model interval, of the type specified for the
operand of an operation, associated with the value of the operand.

7
For any predefined arithmetic operation that yields a result of a
floating point type T, the required bounds on the result are given by a
model interval of T (called the result interval) defined in terms of the
operand values as follows:

8
   * The result interval is the smallest model interval of T that
     includes the minimum and the maximum of all the values obtained by
     applying the (exact) mathematical operation to values arbitrarily
     selected from the respective operand intervals.

9
The result interval of an exponentiation is obtained by applying the
above rule to the sequence of multiplications defined by the exponent,
assuming arbitrary association of the factors, and to the final division
in the case of a negative exponent.

10
The result interval of a conversion of a numeric value to a floating
point type T is the model interval of T associated with the operand
value, except when the source expression is of a fixed point type with a
small that is not a power of T'Machine_Radix or is a fixed point
multiplication or division either of whose operands has a small that is
not a power of T'Machine_Radix; in these cases, the result interval is
implementation defined.

11
For any of the foregoing operations, the implementation shall deliver a
value that belongs to the result interval when both bounds of the result
interval are in the safe range of the result type T, as determined by
the values of T'Safe_First and T'Safe_Last; otherwise,

12
   * if T'Machine_Overflows is True, the implementation shall either
     deliver a value that belongs to the result interval or raise
     Constraint_Error;

13
   * if T'Machine_Overflows is False, the result is implementation
     defined.

14
For any predefined relation on operands of a floating point type T, the
implementation may deliver any value (i.e., either True or False)
obtained by applying the (exact) mathematical comparison to values
arbitrarily chosen from the respective operand intervals.

15
The result of a membership test is defined in terms of comparisons of
the operand value with the lower and upper bounds of the given range or
type mark (the usual rules apply to these comparisons).

                     _Implementation Permissions_

16
If the underlying floating point hardware implements division as
multiplication by a reciprocal, the result interval for division (and
exponentiation by a negative exponent) is implementation defined.


File: arm2012.info,  Node: G.2.2,  Next: G.2.3,  Prev: G.2.1,  Up: G.2

G.2.2 Model-Oriented Attributes of Floating Point Types
-------------------------------------------------------

1
In implementations that support the Numerics Annex, the model-oriented
attributes of floating point types shall yield the values defined here,
in both the strict and the relaxed modes.  These definitions add
conditions to those in *note A.5.3::.

                          _Static Semantics_

2
For every subtype S of a floating point type T:

3/2
S'Model_Mantissa
               Yields the number of digits in the mantissa of the
               canonical form of the model numbers of T (see *note
               A.5.3::).  The value of this attribute shall be greater
               than or equal to

3.1/2
                    'ceiling(d · log(10) / log(T'Machine_Radix))' + g

3.2/2
               where d is the requested decimal precision of T, and g is
               0 if T'Machine_Radix is a positive power of 10 and 1
               otherwise.  In addition, T'Model_Mantissa shall be less
               than or equal to the value of T'Machine_Mantissa.  This
               attribute yields a value of the type universal_integer.

4
S'Model_Emin
               Yields the minimum exponent of the canonical form of the
               model numbers of T (see *note A.5.3::).  The value of
               this attribute shall be greater than or equal to the
               value of T'Machine_Emin.  This attribute yields a value
               of the type universal_integer.

5
S'Safe_First
               Yields the lower bound of the safe range of T. The value
               of this attribute shall be a model number of T and
               greater than or equal to the lower bound of the base
               range of T. In addition, if T is declared by a
               floating_point_definition or is derived from such a type,
               and the floating_point_definition includes a
               real_range_specification specifying a lower bound of lb,
               then the value of this attribute shall be less than or
               equal to lb; otherwise, it shall be less than or equal to
               -10.0 4 · d, where d is the requested decimal precision
               of T. This attribute yields a value of the type
               universal_real.

6
S'Safe_Last
               Yields the upper bound of the safe range of T. The value
               of this attribute shall be a model number of T and less
               than or equal to the upper bound of the base range of T.
               In addition, if T is declared by a
               floating_point_definition or is derived from such a type,
               and the floating_point_definition includes a
               real_range_specification specifying an upper bound of ub,
               then the value of this attribute shall be greater than or
               equal to ub; otherwise, it shall be greater than or equal
               to 10.0 4 · d, where d is the requested decimal precision
               of T. This attribute yields a value of the type
               universal_real.

7
S'Model
               Denotes a function (of a parameter X) whose specification
               is given in *note A.5.3::.  If X is a model number of T,
               the function yields X; otherwise, it yields the value
               obtained by rounding or truncating X to either one of the
               adjacent model numbers of T. Constraint_Error is raised
               if the resulting model number is outside the safe range
               of S. A zero result has the sign of X when S'Signed_Zeros
               is True.

8
Subject to the constraints given above, the values of S'Model_Mantissa
and S'Safe_Last are to be maximized, and the values of S'Model_Emin and
S'Safe_First minimized, by the implementation as follows:

9
   * First, S'Model_Mantissa is set to the largest value for which
     values of S'Model_Emin, S'Safe_First, and S'Safe_Last can be chosen
     so that the implementation satisfies the strict-mode requirements
     of *note G.2.1:: in terms of the model numbers and safe range
     induced by these attributes.

10
   * Next, S'Model_Emin is set to the smallest value for which values of
     S'Safe_First and S'Safe_Last can be chosen so that the
     implementation satisfies the strict-mode requirements of *note
     G.2.1:: in terms of the model numbers and safe range induced by
     these attributes and the previously determined value of
     S'Model_Mantissa.

11/3
   * Finally, S'Safe_First and S'Safe_Last are set (in either order) to
     the smallest and largest values, respectively, for which the
     implementation satisfies the strict-mode requirements of *note
     G.2.1:: in terms of the model numbers and safe range induced by
     these attributes and the previously determined values of
     S'Model_Mantissa and S'Model_Emin.


File: arm2012.info,  Node: G.2.3,  Next: G.2.4,  Prev: G.2.2,  Up: G.2

G.2.3 Model of Fixed Point Arithmetic
-------------------------------------

1
In the strict mode, the predefined arithmetic operations of a fixed
point type shall satisfy the accuracy requirements specified here and
shall avoid or signal overflow in the situations described.

                     _Implementation Requirements_

2
The accuracy requirements for the predefined fixed point arithmetic
operations and conversions, and the results of relations on fixed point
operands, are given below.

3
The operands of the fixed point adding operators, absolute value, and
comparisons have the same type.  These operations are required to yield
exact results, unless they overflow.

4
Multiplications and divisions are allowed between operands of any two
fixed point types; the result has to be (implicitly or explicitly)
converted to some other numeric type.  For purposes of defining the
accuracy rules, the multiplication or division and the conversion are
treated as a single operation whose accuracy depends on three types
(those of the operands and the result).  For decimal fixed point types,
the attribute T'Round may be used to imply explicit conversion with
rounding (see *note 3.5.10::).

5
When the result type is a floating point type, the accuracy is as given
in *note G.2.1::. For some combinations of the operand and result types
in the remaining cases, the result is required to belong to a small set
of values called the perfect result set; for other combinations, it is
required merely to belong to a generally larger and
implementation-defined set of values called the close result set.  When
the result type is a decimal fixed point type, the perfect result set
contains a single value; thus, operations on decimal types are always
fully specified.

6
When one operand of a fixed-fixed multiplication or division is of type
universal_real, that operand is not implicitly converted in the usual
sense, since the context does not determine a unique target type, but
the accuracy of the result of the multiplication or division (i.e.,
whether the result has to belong to the perfect result set or merely the
close result set) depends on the value of the operand of type
universal_real and on the types of the other operand and of the result.

7
For a fixed point multiplication or division whose (exact) mathematical
result is v, and for the conversion of a value v to a fixed point type,
the perfect result set and close result set are defined as follows:

8
   * If the result type is an ordinary fixed point type with a small of
     s,

9
             * if v is an integer multiple of s, then the perfect result
               set contains only the value v;

10
             * otherwise, it contains the integer multiple of s just
               below v and the integer multiple of s just above v.

11
     The close result set is an implementation-defined set of
     consecutive integer multiples of s containing the perfect result
     set as a subset.

12
   * If the result type is a decimal type with a small of s,

13
             * if v is an integer multiple of s, then the perfect result
               set contains only the value v;

14/3
             * otherwise, if truncation applies, then it contains only
               the integer multiple of s in the direction toward zero,
               whereas if rounding applies, then it contains only the
               nearest integer multiple of s (with ties broken by
               rounding away from zero).

15
     The close result set is an implementation-defined set of
     consecutive integer multiples of s containing the perfect result
     set as a subset.

16
   * If the result type is an integer type,

17
             * if v is an integer, then the perfect result set contains
               only the value v;

18
             * otherwise, it contains the integer nearest to the value v
               (if v lies equally distant from two consecutive integers,
               the perfect result set contains the one that is further
               from zero).

19
     The close result set is an implementation-defined set of
     consecutive integers containing the perfect result set as a subset.

20
The result of a fixed point multiplication or division shall belong
either to the perfect result set or to the close result set, as
described below, if overflow does not occur.  In the following cases, if
the result type is a fixed point type, let s be its small; otherwise,
i.e.  when the result type is an integer type, let s be 1.0.

21
   * For a multiplication or division neither of whose operands is of
     type universal_real, let l and r be the smalls of the left and
     right operands.  For a multiplication, if (l · r) / s is an integer
     or the reciprocal of an integer (the smalls are said to be
     "compatible" in this case), the result shall belong to the perfect
     result set; otherwise, it belongs to the close result set.  For a
     division, if l / (r · s) is an integer or the reciprocal of an
     integer (i.e., the smalls are compatible), the result shall belong
     to the perfect result set; otherwise, it belongs to the close
     result set.

22
   * For a multiplication or division having one universal_real operand
     with a value of v, note that it is always possible to factor v as
     an integer multiple of a "compatible" small, but the integer
     multiple may be "too big."  If there exists a factorization in
     which that multiple is less than some implementation-defined limit,
     the result shall belong to the perfect result set; otherwise, it
     belongs to the close result set.

23
A multiplication P * Q of an operand of a fixed point type F by an
operand of an integer type I, or vice-versa, and a division P / Q of an
operand of a fixed point type F by an operand of an integer type I, are
also allowed.  In these cases, the result has a type of F; explicit
conversion of the result is never required.  The accuracy required in
these cases is the same as that required for a multiplication F(P * Q)
or a division F(P / Q) obtained by interpreting the operand of the
integer type to have a fixed point type with a small of 1.0.

24
The accuracy of the result of a conversion from an integer or fixed
point type to a fixed point type, or from a fixed point type to an
integer type, is the same as that of a fixed point multiplication of the
source value by a fixed point operand having a small of 1.0 and a value
of 1.0, as given by the foregoing rules.  The result of a conversion
from a floating point type to a fixed point type shall belong to the
close result set.  The result of a conversion of a universal_real
operand to a fixed point type shall belong to the perfect result set.

25
The possibility of overflow in the result of a predefined arithmetic
operation or conversion yielding a result of a fixed point type T is
analogous to that for floating point types, except for being related to
the base range instead of the safe range. If all of the permitted
results belong to the base range of T, then the implementation shall
deliver one of the permitted results; otherwise,

26
   * if T'Machine_Overflows is True, the implementation shall either
     deliver one of the permitted results or raise Constraint_Error;

27
   * if T'Machine_Overflows is False, the result is implementation
     defined.


File: arm2012.info,  Node: G.2.4,  Next: G.2.5,  Prev: G.2.3,  Up: G.2

G.2.4 Accuracy Requirements for the Elementary Functions
--------------------------------------------------------

1
In the strict mode, the performance of
Numerics.Generic_Elementary_Functions shall be as specified here.

                     _Implementation Requirements_

2
When an exception is not raised, the result of evaluating a function in
an instance EF of Numerics.Generic_Elementary_Functions belongs to a
result interval, defined as the smallest model interval of EF.Float_Type
that contains all the values of the form f · (1.0 + d), where f is the
exact value of the corresponding mathematical function at the given
parameter values, d is a real number, and |d| is less than or equal to
the function's maximum relative error. The function delivers a value
that belongs to the result interval when both of its bounds belong to
the safe range of EF.Float_Type; otherwise,

3
   * if EF.Float_Type'Machine_Overflows is True, the function either
     delivers a value that belongs to the result interval or raises
     Constraint_Error, signaling overflow;

4
   * if EF.Float_Type'Machine_Overflows is False, the result is
     implementation defined.

5
The maximum relative error exhibited by each function is as follows:

6
   * 2.0 · EF.Float_Type'Model_Epsilon, in the case of the Sqrt, Sin,
     and Cos functions;

7
   * 4.0 · EF.Float_Type'Model_Epsilon, in the case of the Log, Exp,
     Tan, Cot, and inverse trigonometric functions; and

8
   * 8.0 · EF.Float_Type'Model_Epsilon, in the case of the forward and
     inverse hyperbolic functions.

9
The maximum relative error exhibited by the exponentiation operator,
which depends on the values of the operands, is (4.0 + |Right ·
log(Left)| / 32.0) · EF.Float_Type'Model_Epsilon.

10
The maximum relative error given above applies throughout the domain of
the forward trigonometric functions when the Cycle parameter is
specified. When the Cycle parameter is omitted, the maximum relative
error given above applies only when the absolute value of the angle
parameter X is less than or equal to some implementation-defined angle
threshold, which shall be at least EF.Float_Type'Machine_Radix
'floor(EF.Float_Type'Machine_Mantissa/2)'.  Beyond the angle threshold,
the accuracy of the forward trigonometric functions is implementation
defined.

11/2
The prescribed results specified in *note A.5.1:: for certain functions
at particular parameter values take precedence over the maximum relative
error bounds; effectively, they narrow to a single value the result
interval allowed by the maximum relative error bounds.  Additional rules
with a similar effect are given by table G-1 for the inverse
trigonometric functions, at particular parameter values for which the
mathematical result is possibly not a model number of EF.Float_Type (or
is, indeed, even transcendental).  In each table entry, the values of
the parameters are such that the result lies on the axis between two
quadrants; the corresponding accuracy rule, which takes precedence over
the maximum relative error bounds, is that the result interval is the
model interval of EF.Float_Type associated with the exact mathematical
result given in the table.

12/1
This paragraph was deleted.

13
The last line of the table is meant to apply when
EF.Float_Type'Signed_Zeros is False; the two lines just above it, when
EF.Float_Type'Signed_Zeros is True and the parameter Y has a zero value
with the indicated sign.

Table G-1: Tightly Approximated Elementary Function Results
Function   Value of X   Value of Y   Exact Result Exact Result 
                                     when Cycle  when Cycle 
                                     Specified   Omitted
Arcsin     1.0          n.a.         Cycle/4.0   PI/2.0
Arcsin     -1.0         n.a.         -Cycle/4.0  -PI/2.0
Arccos     0.0          n.a.         Cycle/4.0   PI/2.0
Arccos     -1.0         n.a.         Cycle/2.0   PI
Arctan     0.0          positive     Cycle/4.0   PI/2.0
and
Arccot
Arctan     0.0          negative     -Cycle/4.0  -PI/2.0
and
Arccot
Arctan     negative     +0.0         Cycle/2.0   PI
and
Arccot
Arctan     negative     -0.0         -Cycle/2.0  -PI
and
Arccot
Arctan     negative     0.0          Cycle/2.0   PI
and
Arccot
14
The amount by which the result of an inverse trigonometric function is
allowed to spill over into a quadrant adjacent to the one corresponding
to the principal branch, as given in *note A.5.1::, is limited.  The
rule is that the result belongs to the smallest model interval of
EF.Float_Type that contains both boundaries of the quadrant
corresponding to the principal branch.  This rule also takes precedence
over the maximum relative error bounds, effectively narrowing the result
interval allowed by them.

15
Finally, the following specifications also take precedence over the
maximum relative error bounds:

16
   * The absolute value of the result of the Sin, Cos, and Tanh
     functions never exceeds one.

17
   * The absolute value of the result of the Coth function is never less
     than one.

18
   * The result of the Cosh function is never less than one.

                        _Implementation Advice_

19
The versions of the forward trigonometric functions without a Cycle
parameter should not be implemented by calling the corresponding version
with a Cycle parameter of 2.0*Numerics.Pi, since this will not provide
the required accuracy in some portions of the domain.  For the same
reason, the version of Log without a Base parameter should not be
implemented by calling the corresponding version with a Base parameter
of Numerics.e.


File: arm2012.info,  Node: G.2.5,  Next: G.2.6,  Prev: G.2.4,  Up: G.2

G.2.5 Performance Requirements for Random Number Generation
-----------------------------------------------------------

1
In the strict mode, the performance of Numerics.Float_Random and
Numerics.Discrete_Random shall be as specified here.

                     _Implementation Requirements_

2
Two different calls to the time-dependent Reset procedure shall reset
the generator to different states, provided that the calls are separated
in time by at least one second and not more than fifty years.

3
The implementation's representations of generator states and its
algorithms for generating random numbers shall yield a period of at
least 231-2; much longer periods are desirable but not required.

4
The implementations of Numerics.Float_Random.Random and
Numerics.Discrete_Random.Random shall pass at least 85% of the
individual trials in a suite of statistical tests.  For
Numerics.Float_Random, the tests are applied directly to the floating
point values generated (i.e., they are not converted to integers first),
while for Numerics.Discrete_Random they are applied to the generated
values of various discrete types.  Each test suite performs 6 different
tests, with each test repeated 10 times, yielding a total of 60
individual trials.  An individual trial is deemed to pass if the
chi-square value (or other statistic) calculated for the observed counts
or distribution falls within the range of values corresponding to the
2.5 and 97.5 percentage points for the relevant degrees of freedom
(i.e., it shall be neither too high nor too low).  For the purpose of
determining the degrees of freedom, measurement categories are combined
whenever the expected counts are fewer than 5.


File: arm2012.info,  Node: G.2.6,  Prev: G.2.5,  Up: G.2

G.2.6 Accuracy Requirements for Complex Arithmetic
--------------------------------------------------

1
In the strict mode, the performance of Numerics.Generic_Complex_Types
and Numerics.Generic_Complex_Elementary_Functions shall be as specified
here.

                     _Implementation Requirements_

2
When an exception is not raised, the result of evaluating a real
function of an instance CT of Numerics.Generic_Complex_Types (i.e., a
function that yields a value of subtype CT.Real'Base or CT.Imaginary)
belongs to a result interval defined as for a real elementary function
(see *note G.2.4::).

3
When an exception is not raised, each component of the result of
evaluating a complex function of such an instance, or of an instance of
Numerics.Generic_Complex_Elementary_Functions obtained by instantiating
the latter with CT (i.e., a function that yields a value of subtype
CT.Complex), also belongs to a result interval.  The result intervals
for the components of the result are either defined by a maximum
relative error bound or by a maximum box error bound. When the result
interval for the real (resp., imaginary) component is defined by maximum
relative error, it is defined as for that of a real function, relative
to the exact value of the real (resp., imaginary) part of the result of
the corresponding mathematical function. When defined by maximum box
error, the result interval for a component of the result is the smallest
model interval of CT.Real that contains all the values of the
corresponding part of f · (1.0 + d), where f is the exact complex value
of the corresponding mathematical function at the given parameter
values, d is complex, and |d| is less than or equal to the given maximum
box error. The function delivers a value that belongs to the result
interval (or a value both of whose components belong to their respective
result intervals) when both bounds of the result interval(s) belong to
the safe range of CT.Real; otherwise,

4
   * if CT.Real'Machine_Overflows is True, the function either delivers
     a value that belongs to the result interval (or a value both of
     whose components belong to their respective result intervals) or
     raises Constraint_Error, signaling overflow;

5
   * if CT.Real'Machine_Overflows is False, the result is implementation
     defined.

6/2
The error bounds for particular complex functions are tabulated in table
G-2.  In the table, the error bound is given as the coefficient of
CT.Real'Model_Epsilon.

7/1
This paragraph was deleted.

Table G-2: Error Bounds for Particular Complex Functions
Function or Operator   Nature of Nature of Error Bound
                       Result   Bound    
Modulus                real     max.    3.0
                                rel.
                                error
Argument               real     max.    4.0
                                rel.
                                error
Compose_From_Polar     complex  max.    3.0
                                rel.
                                error
"*" (both operands     complex  max.    5.0
complex)                        box
                                error
"/" (right operand     complex  max.    13.0
complex)                        box
                                error
Sqrt                   complex  max.    6.0
                                rel.
                                error
Log                    complex  max.    13.0
                                box
                                error
Exp (complex           complex  max.    7.0
parameter)                      rel.
                                error
Exp (imaginary         complex  max.    2.0
parameter)                      rel.
                                error
Sin, Cos, Sinh, and    complex  max.    11.0
Cosh                            rel.
                                error
Tan, Cot, Tanh, and    complex  max.    35.0
Coth                            rel.
                                error
inverse                complex  max.    14.0
trigonometric                   rel.
                                error
inverse hyperbolic     complex  max.    14.0
                                rel.
                                error
8
The maximum relative error given above applies throughout the domain of
the Compose_From_Polar function when the Cycle parameter is specified.
When the Cycle parameter is omitted, the maximum relative error applies
only when the absolute value of the parameter Argument is less than or
equal to the angle threshold (see *note G.2.4::).  For the Exp function,
and for the forward hyperbolic (resp., trigonometric) functions, the
maximum relative error given above likewise applies only when the
absolute value of the imaginary (resp., real) component of the parameter
X (or the absolute value of the parameter itself, in the case of the Exp
function with a parameter of pure-imaginary type) is less than or equal
to the angle threshold.  For larger angles, the accuracy is
implementation defined.

9
The prescribed results specified in *note G.1.2:: for certain functions
at particular parameter values take precedence over the error bounds;
effectively, they narrow to a single value the result interval allowed
by the error bounds for a component of the result.  Additional rules
with a similar effect are given below for certain inverse trigonometric
and inverse hyperbolic functions, at particular parameter values for
which a component of the mathematical result is transcendental.  In each
case, the accuracy rule, which takes precedence over the error bounds,
is that the result interval for the stated result component is the model
interval of CT.Real associated with the component's exact mathematical
value.  The cases in question are as follows:

10
   * When the parameter X has the value zero, the real (resp.,
     imaginary) component of the result of the Arccot (resp., Arccoth)
     function is in the model interval of CT.Real associated with the
     value PI/2.0.

11
   * When the parameter X has the value one, the real component of the
     result of the Arcsin function is in the model interval of CT.Real
     associated with the value PI/2.0.

12
   * When the parameter X has the value -1.0, the real component of the
     result of the Arcsin (resp., Arccos) function is in the model
     interval of CT.Real associated with the value -PI/2.0 (resp., PI).

13/2
The amount by which a component of the result of an inverse
trigonometric or inverse hyperbolic function is allowed to spill over
into a quadrant adjacent to the one corresponding to the principal
branch, as given in *note G.1.2::, is limited.  The rule is that the
result belongs to the smallest model interval of CT.Real that contains
both boundaries of the quadrant corresponding to the principal branch.
This rule also takes precedence over the maximum error bounds,
effectively narrowing the result interval allowed by them.

14
Finally, the results allowed by the error bounds are narrowed by one
further rule: The absolute value of each component of the result of the
Exp function, for a pure-imaginary parameter, never exceeds one.

                        _Implementation Advice_

15
The version of the Compose_From_Polar function without a Cycle parameter
should not be implemented by calling the corresponding version with a
Cycle parameter of 2.0*Numerics.Pi, since this will not provide the
required accuracy in some portions of the domain.


File: arm2012.info,  Node: G.3,  Prev: G.2,  Up: Annex G

G.3 Vector and Matrix Manipulation
==================================

1/2
Types and operations for the manipulation of real vectors and matrices
are provided in Generic_Real_Arrays, which is defined in *note G.3.1::.
Types and operations for the manipulation of complex vectors and
matrices are provided in Generic_Complex_Arrays, which is defined in
*note G.3.2::.  Both of these library units are generic children of the
predefined package Numerics (see *note A.5::).  Nongeneric equivalents
of these packages for each of the predefined floating point types are
also provided as children of Numerics.

* Menu:

* G.3.1 ::    Real Vectors and Matrices
* G.3.2 ::    Complex Vectors and Matrices


File: arm2012.info,  Node: G.3.1,  Next: G.3.2,  Up: G.3

G.3.1 Real Vectors and Matrices
-------------------------------

                          _Static Semantics_

1/2
The generic library package Numerics.Generic_Real_Arrays has the
following declaration:

2/2
     generic
        type Real is digits <>;
     package Ada.Numerics.Generic_Real_Arrays is
        pragma Pure(Generic_Real_Arrays);

3/2
        -- Types

4/2
        type Real_Vector is array (Integer range <>) of Real'Base;
        type Real_Matrix is array (Integer range <>, Integer range <>)
                                                        of Real'Base;

5/2
        -- Subprograms for Real_Vector types

6/2
        -- Real_Vector arithmetic operations

7/2
        function "+"   (Right : Real_Vector)       return Real_Vector;
        function "-"   (Right : Real_Vector)       return Real_Vector;
        function "abs" (Right : Real_Vector)       return Real_Vector;

8/2
        function "+"   (Left, Right : Real_Vector) return Real_Vector;
        function "-"   (Left, Right : Real_Vector) return Real_Vector;

9/2
        function "*"   (Left, Right : Real_Vector) return Real'Base;

10/2
        function "abs" (Right : Real_Vector)       return Real'Base;

11/2
        -- Real_Vector scaling operations

12/2
        function "*" (Left : Real'Base;   Right : Real_Vector)
           return Real_Vector;
        function "*" (Left : Real_Vector; Right : Real'Base)
           return Real_Vector;
        function "/" (Left : Real_Vector; Right : Real'Base)
           return Real_Vector;

13/2
        -- Other Real_Vector operations

14/2
        function Unit_Vector (Index : Integer;
                              Order : Positive;
                              First : Integer := 1) return Real_Vector;

15/2
        -- Subprograms for Real_Matrix types

16/2
        -- Real_Matrix arithmetic operations

17/2
        function "+"       (Right : Real_Matrix) return Real_Matrix;
        function "-"       (Right : Real_Matrix) return Real_Matrix;
        function "abs"     (Right : Real_Matrix) return Real_Matrix;
        function Transpose (X     : Real_Matrix) return Real_Matrix;

18/2
        function "+" (Left, Right : Real_Matrix) return Real_Matrix;
        function "-" (Left, Right : Real_Matrix) return Real_Matrix;
        function "*" (Left, Right : Real_Matrix) return Real_Matrix;

19/2
        function "*" (Left, Right : Real_Vector) return Real_Matrix;

20/2
        function "*" (Left : Real_Vector; Right : Real_Matrix)
           return Real_Vector;
        function "*" (Left : Real_Matrix; Right : Real_Vector)
           return Real_Vector;

21/2
        -- Real_Matrix scaling operations

22/2
        function "*" (Left : Real'Base;   Right : Real_Matrix)
           return Real_Matrix;
        function "*" (Left : Real_Matrix; Right : Real'Base)
           return Real_Matrix;
        function "/" (Left : Real_Matrix; Right : Real'Base)
           return Real_Matrix;

23/2
        -- Real_Matrix inversion and related operations

24/2
        function Solve (A : Real_Matrix; X : Real_Vector) return Real_Vector;
        function Solve (A, X : Real_Matrix) return Real_Matrix;
        function Inverse (A : Real_Matrix) return Real_Matrix;
        function Determinant (A : Real_Matrix) return Real'Base;

25/2
        -- Eigenvalues and vectors of a real symmetric matrix

26/2
        function Eigenvalues (A : Real_Matrix) return Real_Vector;

27/2
        procedure Eigensystem (A       : in  Real_Matrix;
                               Values  : out Real_Vector;
                               Vectors : out Real_Matrix);

28/2
        -- Other Real_Matrix operations

29/2
        function Unit_Matrix (Order            : Positive;
                              First_1, First_2 : Integer := 1)
                                                 return Real_Matrix;

30/2
     end Ada.Numerics.Generic_Real_Arrays;

31/2
The library package Numerics.Real_Arrays is declared pure and defines
the same types and subprograms as Numerics.Generic_Real_Arrays, except
that the predefined type Float is systematically substituted for
Real'Base throughout.  Nongeneric equivalents for each of the other
predefined floating point types are defined similarly, with the names
Numerics.Short_Real_Arrays, Numerics.Long_Real_Arrays, etc.

32/2
Two types are defined and exported by Numerics.Generic_Real_Arrays.  The
composite type Real_Vector is provided to represent a vector with
components of type Real; it is defined as an unconstrained,
one-dimensional array with an index of type Integer.  The composite type
Real_Matrix is provided to represent a matrix with components of type
Real; it is defined as an unconstrained, two-dimensional array with
indices of type Integer.

33/2
The effect of the various subprograms is as described below.  In most
cases the subprograms are described in terms of corresponding scalar
operations of the type Real; any exception raised by those operations is
propagated by the array operation.  Moreover, the accuracy of the result
for each individual component is as defined for the scalar operation
unless stated otherwise.

34/2
In the case of those operations which are defined to involve an inner
product, Constraint_Error may be raised if an intermediate result is
outside the range of Real'Base even though the mathematical final result
would not be.

35/2
     function "+"   (Right : Real_Vector) return Real_Vector;
     function "-"   (Right : Real_Vector) return Real_Vector;
     function "abs" (Right : Real_Vector) return Real_Vector;

36/2
          Each operation returns the result of applying the
          corresponding operation of the type Real to each component of
          Right.  The index range of the result is Right'Range.

37/2
     function "+" (Left, Right : Real_Vector) return Real_Vector;
     function "-" (Left, Right : Real_Vector) return Real_Vector;

38/2
          Each operation returns the result of applying the
          corresponding operation of the type Real to each component of
          Left and the matching component of Right.  The index range of
          the result is Left'Range.  Constraint_Error is raised if
          Left'Length is not equal to Right'Length.

39/2
     function "*" (Left, Right : Real_Vector) return Real'Base;

40/2
          This operation returns the inner product of Left and Right.
          Constraint_Error is raised if Left'Length is not equal to
          Right'Length.  This operation involves an inner product.

41/2
     function "abs" (Right : Real_Vector) return Real'Base;

42/2
          This operation returns the L2-norm of Right (the square root
          of the inner product of the vector with itself).

43/2
     function "*" (Left : Real'Base; Right : Real_Vector) return Real_Vector;

44/2
          This operation returns the result of multiplying each
          component of Right by the scalar Left using the "*" operation
          of the type Real.  The index range of the result is
          Right'Range.

45/2
     function "*" (Left : Real_Vector; Right : Real'Base) return Real_Vector;
     function "/" (Left : Real_Vector; Right : Real'Base) return Real_Vector;

46/2
          Each operation returns the result of applying the
          corresponding operation of the type Real to each component of
          Left and to the scalar Right.  The index range of the result
          is Left'Range.

47/2
     function Unit_Vector (Index : Integer;
                           Order : Positive;
                           First : Integer := 1) return Real_Vector;

48/2
          This function returns a unit vector with Order components and
          a lower bound of First.  All components are set to 0.0 except
          for the Index component which is set to 1.0.  Constraint_Error
          is raised if Index < First, Index > First + Order - 1 or if
          First + Order - 1 > Integer'Last.

49/2
     function "+"   (Right : Real_Matrix) return Real_Matrix;
     function "-"   (Right : Real_Matrix) return Real_Matrix;
     function "abs" (Right : Real_Matrix) return Real_Matrix;

50/2
          Each operation returns the result of applying the
          corresponding operation of the type Real to each component of
          Right.  The index ranges of the result are those of Right.

51/2
     function Transpose (X : Real_Matrix) return Real_Matrix;

52/2
          This function returns the transpose of a matrix X. The first
          and second index ranges of the result are X'Range(2) and
          X'Range(1) respectively.

53/2
     function "+" (Left, Right : Real_Matrix) return Real_Matrix;
     function "-" (Left, Right : Real_Matrix) return Real_Matrix;

54/2
          Each operation returns the result of applying the
          corresponding operation of the type Real to each component of
          Left and the matching component of Right.  The index ranges of
          the result are those of Left.  Constraint_Error is raised if
          Left'Length(1) is not equal to Right'Length(1) or
          Left'Length(2) is not equal to Right'Length(2).

55/2
     function "*" (Left, Right : Real_Matrix) return Real_Matrix;

56/2
          This operation provides the standard mathematical operation
          for matrix multiplication.  The first and second index ranges
          of the result are Left'Range(1) and Right'Range(2)
          respectively.  Constraint_Error is raised if Left'Length(2) is
          not equal to Right'Length(1).  This operation involves inner
          products.

57/2
     function "*" (Left, Right : Real_Vector) return Real_Matrix;

58/2
          This operation returns the outer product of a (column) vector
          Left by a (row) vector Right using the operation "*" of the
          type Real for computing the individual components.  The first
          and second index ranges of the result are Left'Range and
          Right'Range respectively.

59/2
     function "*" (Left : Real_Vector; Right : Real_Matrix) return Real_Vector;

60/2
          This operation provides the standard mathematical operation
          for multiplication of a (row) vector Left by a matrix Right.
          The index range of the (row) vector result is Right'Range(2).
          Constraint_Error is raised if Left'Length is not equal to
          Right'Length(1).  This operation involves inner products.

61/2
     function "*" (Left : Real_Matrix; Right : Real_Vector) return Real_Vector;

62/2
          This operation provides the standard mathematical operation
          for multiplication of a matrix Left by a (column) vector
          Right.  The index range of the (column) vector result is
          Left'Range(1).  Constraint_Error is raised if Left'Length(2)
          is not equal to Right'Length.  This operation involves inner
          products.

63/2
     function "*" (Left : Real'Base; Right : Real_Matrix) return Real_Matrix;

64/2
          This operation returns the result of multiplying each
          component of Right by the scalar Left using the "*" operation
          of the type Real.  The index ranges of the result are those of
          Right.

65/2
     function "*" (Left : Real_Matrix; Right : Real'Base) return Real_Matrix;
     function "/" (Left : Real_Matrix; Right : Real'Base) return Real_Matrix;

66/2
          Each operation returns the result of applying the
          corresponding operation of the type Real to each component of
          Left and to the scalar Right.  The index ranges of the result
          are those of Left.

67/2
     function Solve (A : Real_Matrix; X : Real_Vector) return Real_Vector;

68/2
          This function returns a vector Y such that X is (nearly) equal
          to A * Y. This is the standard mathematical operation for
          solving a single set of linear equations.  The index range of
          the result is A'Range(2).  Constraint_Error is raised if
          A'Length(1), A'Length(2), and X'Length are not equal.
          Constraint_Error is raised if the matrix A is ill-conditioned.

69/2
     function Solve (A, X : Real_Matrix) return Real_Matrix;

70/2
          This function returns a matrix Y such that X is (nearly) equal
          to A * Y. This is the standard mathematical operation for
          solving several sets of linear equations.  The index ranges of
          the result are A'Range(2) and X'Range(2).  Constraint_Error is
          raised if A'Length(1), A'Length(2), and X'Length(1) are not
          equal.  Constraint_Error is raised if the matrix A is
          ill-conditioned.

71/2
     function Inverse (A : Real_Matrix) return Real_Matrix;

72/2
          This function returns a matrix B such that A * B is (nearly)
          equal to the unit matrix.  The index ranges of the result are
          A'Range(2) and A'Range(1).  Constraint_Error is raised if
          A'Length(1) is not equal to A'Length(2).  Constraint_Error is
          raised if the matrix A is ill-conditioned.

73/2
     function Determinant (A : Real_Matrix) return Real'Base;

74/2
          This function returns the determinant of the matrix A.
          Constraint_Error is raised if A'Length(1) is not equal to
          A'Length(2).

75/2
     function Eigenvalues(A : Real_Matrix) return Real_Vector;

76/2
          This function returns the eigenvalues of the symmetric matrix
          A as a vector sorted into order with the largest first.
          Constraint_Error is raised if A'Length(1) is not equal to
          A'Length(2).  The index range of the result is A'Range(1).
          Argument_Error is raised if the matrix A is not symmetric.

77/2
     procedure Eigensystem(A       : in  Real_Matrix;
                           Values  : out Real_Vector;
                           Vectors : out Real_Matrix);

78/3
          This procedure computes both the eigenvalues and eigenvectors
          of the symmetric matrix A. The out parameter Values is the
          same as that obtained by calling the function Eigenvalues.
          The out parameter Vectors is a matrix whose columns are the
          eigenvectors of the matrix A. The order of the columns
          corresponds to the order of the eigenvalues.  The eigenvectors
          are normalized and mutually orthogonal (they are orthonormal),
          including when there are repeated eigenvalues.
          Constraint_Error is raised if A'Length(1) is not equal to
          A'Length(2), or if Values'Range is not equal to A'Range(1), or
          if the index ranges of the parameter Vectors are not equal to
          those of A. Argument_Error is raised if the matrix A is not
          symmetric.  Constraint_Error is also raised in
          implementation-defined circumstances if the algorithm used
          does not converge quickly enough.

79/2
     function Unit_Matrix (Order            : Positive;
                           First_1, First_2 : Integer := 1) return Real_Matrix;

80/2
          This function returns a square unit matrix with Order**2
          components and lower bounds of First_1 and First_2 (for the
          first and second index ranges respectively).  All components
          are set to 0.0 except for the main diagonal, whose components
          are set to 1.0.  Constraint_Error is raised if First_1 + Order
          - 1 > Integer'Last or First_2 + Order - 1 > Integer'Last.

                     _Implementation Requirements_

81/2
Accuracy requirements for the subprograms Solve, Inverse, Determinant,
Eigenvalues and Eigensystem are implementation defined.

82/2
For operations not involving an inner product, the accuracy requirements
are those of the corresponding operations of the type Real in both the
strict mode and the relaxed mode (see *note G.2::).

83/2
For operations involving an inner product, no requirements are specified
in the relaxed mode.  In the strict mode the modulus of the absolute
error of the inner product X*Y shall not exceed g*abs(X)*abs(Y) where g
is defined as

84/2
     g = X'Length * Real'Machine_Radix**(1 - Real'Model_Mantissa)

85/2
For the L2-norm, no accuracy requirements are specified in the relaxed
mode.  In the strict mode the relative error on the norm shall not
exceed g / 2.0 + 3.0 * Real'Model_Epsilon where g is defined as above.

                     _Documentation Requirements_

86/2
Implementations shall document any techniques used to reduce
cancellation errors such as extended precision arithmetic.

                     _Implementation Permissions_

87/2
The nongeneric equivalent packages may, but need not, be actual
instantiations of the generic package for the appropriate predefined
type.

                        _Implementation Advice_

88/3
Implementations should implement the Solve and Inverse functions using
established techniques such as LU decomposition with row interchanges
followed by back and forward substitution.  Implementations are
recommended to refine the result by performing an iteration on the
residuals; if this is done, then it should be documented.

89/2
It is not the intention that any special provision should be made to
determine whether a matrix is ill-conditioned or not.  The naturally
occurring overflow (including division by zero) which will result from
executing these functions with an ill-conditioned matrix and thus raise
Constraint_Error is sufficient.

90/2
The test that a matrix is symmetric should be performed by using the
equality operator to compare the relevant components.

91/3
An implementation should minimize the circumstances under which the
algorithm used for Eigenvalues and Eigensystem fails to converge.


File: arm2012.info,  Node: G.3.2,  Prev: G.3.1,  Up: G.3

G.3.2 Complex Vectors and Matrices
----------------------------------

                          _Static Semantics_

1/2
The generic library package Numerics.Generic_Complex_Arrays has the
following declaration:

2/2
     with Ada.Numerics.Generic_Real_Arrays, Ada.Numerics.Generic_Complex_Types;
     generic
        with package Real_Arrays   is new
           Ada.Numerics.Generic_Real_Arrays   (<>);
        use Real_Arrays;
        with package Complex_Types is new
           Ada.Numerics.Generic_Complex_Types (Real);
        use Complex_Types;
     package Ada.Numerics.Generic_Complex_Arrays is
        pragma Pure(Generic_Complex_Arrays);

3/2
        -- Types

4/2
        type Complex_Vector is array (Integer range <>) of Complex;
        type Complex_Matrix is array (Integer range <>,
                                      Integer range <>) of Complex;

5/2
        -- Subprograms for Complex_Vector types

6/2
        -- Complex_Vector selection, conversion and composition operations

7/2
        function Re (X : Complex_Vector) return Real_Vector;
        function Im (X : Complex_Vector) return Real_Vector;

8/2
        procedure Set_Re (X  : in out Complex_Vector;
                          Re : in     Real_Vector);
        procedure Set_Im (X  : in out Complex_Vector;
                          Im : in     Real_Vector);

9/2
        function Compose_From_Cartesian (Re     : Real_Vector)
           return Complex_Vector;
        function Compose_From_Cartesian (Re, Im : Real_Vector)
           return Complex_Vector;

10/2
        function Modulus  (X     : Complex_Vector) return Real_Vector;
        function "abs"    (Right : Complex_Vector) return Real_Vector
                                                      renames Modulus;
        function Argument (X     : Complex_Vector) return Real_Vector;
        function Argument (X     : Complex_Vector;
                           Cycle : Real'Base)      return Real_Vector;

11/2
        function Compose_From_Polar (Modulus, Argument : Real_Vector)
           return Complex_Vector;
        function Compose_From_Polar (Modulus, Argument : Real_Vector;
                                     Cycle             : Real'Base)
           return Complex_Vector;

12/2
        -- Complex_Vector arithmetic operations

13/2
        function "+"       (Right  : Complex_Vector) return Complex_Vector;
        function "-"       (Right  : Complex_Vector) return Complex_Vector;
        function Conjugate (X      : Complex_Vector) return Complex_Vector;

14/2
        function "+"  (Left, Right : Complex_Vector) return Complex_Vector;
        function "-"  (Left, Right : Complex_Vector) return Complex_Vector;

15/2
        function "*"  (Left, Right : Complex_Vector) return Complex;

16/3
        function "abs"     (Right : Complex_Vector) return Real'Base;

17/2
        -- Mixed Real_Vector and Complex_Vector arithmetic operations

18/2
        function "+" (Left  : Real_Vector;
                      Right : Complex_Vector) return Complex_Vector;
        function "+" (Left  : Complex_Vector;
                      Right : Real_Vector)    return Complex_Vector;
        function "-" (Left  : Real_Vector;
                      Right : Complex_Vector) return Complex_Vector;
        function "-" (Left  : Complex_Vector;
                      Right : Real_Vector)    return Complex_Vector;

19/2
        function "*" (Left  : Real_Vector;    Right : Complex_Vector)
           return Complex;
        function "*" (Left  : Complex_Vector; Right : Real_Vector)
           return Complex;

20/2
        -- Complex_Vector scaling operations

21/2
        function "*" (Left  : Complex;
                      Right : Complex_Vector) return Complex_Vector;
        function "*" (Left  : Complex_Vector;
                      Right : Complex)        return Complex_Vector;
        function "/" (Left  : Complex_Vector;
                      Right : Complex)        return Complex_Vector;

22/2
        function "*" (Left  : Real'Base;
                      Right : Complex_Vector) return Complex_Vector;
        function "*" (Left  : Complex_Vector;
                      Right : Real'Base)      return Complex_Vector;
        function "/" (Left  : Complex_Vector;
                      Right : Real'Base)      return Complex_Vector;

23/2
        -- Other Complex_Vector operations

24/2
        function Unit_Vector (Index : Integer;
                              Order : Positive;
                              First : Integer := 1) return Complex_Vector;

25/2
        -- Subprograms for Complex_Matrix types

26/2
        -- Complex_Matrix selection, conversion and composition operations

27/2
        function Re (X : Complex_Matrix) return Real_Matrix;
        function Im (X : Complex_Matrix) return Real_Matrix;

28/2
        procedure Set_Re (X  : in out Complex_Matrix;
                          Re : in     Real_Matrix);
        procedure Set_Im (X  : in out Complex_Matrix;
                          Im : in     Real_Matrix);

29/2
        function Compose_From_Cartesian (Re     : Real_Matrix)
           return Complex_Matrix;
        function Compose_From_Cartesian (Re, Im : Real_Matrix)
           return Complex_Matrix;

30/2
        function Modulus  (X     : Complex_Matrix) return Real_Matrix;
        function "abs"    (Right : Complex_Matrix) return Real_Matrix
                                                      renames Modulus;

31/2
        function Argument (X     : Complex_Matrix) return Real_Matrix;
        function Argument (X     : Complex_Matrix;
                           Cycle : Real'Base)      return Real_Matrix;

32/2
        function Compose_From_Polar (Modulus, Argument : Real_Matrix)
           return Complex_Matrix;
        function Compose_From_Polar (Modulus, Argument : Real_Matrix;
                                     Cycle             : Real'Base)
           return Complex_Matrix;

33/2
        -- Complex_Matrix arithmetic operations

34/2
        function "+"       (Right : Complex_Matrix) return Complex_Matrix;
        function "-"       (Right : Complex_Matrix) return Complex_Matrix;
        function Conjugate (X     : Complex_Matrix) return Complex_Matrix;
        function Transpose (X     : Complex_Matrix) return Complex_Matrix;

35/2
        function "+" (Left, Right : Complex_Matrix) return Complex_Matrix;
        function "-" (Left, Right : Complex_Matrix) return Complex_Matrix;
        function "*" (Left, Right : Complex_Matrix) return Complex_Matrix;

36/2
        function "*" (Left, Right : Complex_Vector) return Complex_Matrix;

37/2
        function "*" (Left  : Complex_Vector;
                      Right : Complex_Matrix) return Complex_Vector;
        function "*" (Left  : Complex_Matrix;
                      Right : Complex_Vector) return Complex_Vector;

38/2
        -- Mixed Real_Matrix and Complex_Matrix arithmetic operations

39/2
        function "+" (Left  : Real_Matrix;
                      Right : Complex_Matrix) return Complex_Matrix;
        function "+" (Left  : Complex_Matrix;
                      Right : Real_Matrix)    return Complex_Matrix;
        function "-" (Left  : Real_Matrix;
                      Right : Complex_Matrix) return Complex_Matrix;
        function "-" (Left  : Complex_Matrix;
                      Right : Real_Matrix)    return Complex_Matrix;
        function "*" (Left  : Real_Matrix;
                      Right : Complex_Matrix) return Complex_Matrix;
        function "*" (Left  : Complex_Matrix;
                      Right : Real_Matrix)    return Complex_Matrix;

40/2
        function "*" (Left  : Real_Vector;
                      Right : Complex_Vector) return Complex_Matrix;
        function "*" (Left  : Complex_Vector;
                      Right : Real_Vector)    return Complex_Matrix;

41/2
        function "*" (Left  : Real_Vector;
                      Right : Complex_Matrix) return Complex_Vector;
        function "*" (Left  : Complex_Vector;
                      Right : Real_Matrix)    return Complex_Vector;
        function "*" (Left  : Real_Matrix;
                      Right : Complex_Vector) return Complex_Vector;
        function "*" (Left  : Complex_Matrix;
                      Right : Real_Vector)    return Complex_Vector;

42/2
        -- Complex_Matrix scaling operations

43/2
        function "*" (Left  : Complex;
                      Right : Complex_Matrix) return Complex_Matrix;
        function "*" (Left  : Complex_Matrix;
                      Right : Complex)        return Complex_Matrix;
        function "/" (Left  : Complex_Matrix;
                      Right : Complex)        return Complex_Matrix;

44/2
        function "*" (Left  : Real'Base;
                      Right : Complex_Matrix) return Complex_Matrix;
        function "*" (Left  : Complex_Matrix;
                      Right : Real'Base)      return Complex_Matrix;
        function "/" (Left  : Complex_Matrix;
                      Right : Real'Base)      return Complex_Matrix;

45/2
        -- Complex_Matrix inversion and related operations

46/2
        function Solve (A : Complex_Matrix; X : Complex_Vector)
           return Complex_Vector;
        function Solve (A, X : Complex_Matrix) return Complex_Matrix;
        function Inverse (A : Complex_Matrix) return Complex_Matrix;
        function Determinant (A : Complex_Matrix) return Complex;

47/2
        -- Eigenvalues and vectors of a Hermitian matrix

48/2
        function Eigenvalues(A : Complex_Matrix) return Real_Vector;

49/2
        procedure Eigensystem(A       : in  Complex_Matrix;
                              Values  : out Real_Vector;
                              Vectors : out Complex_Matrix);

50/2
        -- Other Complex_Matrix operations

51/2
        function Unit_Matrix (Order            : Positive;
                              First_1, First_2 : Integer := 1)
                                                 return Complex_Matrix;

52/2
     end Ada.Numerics.Generic_Complex_Arrays;

53/2
The library package Numerics.Complex_Arrays is declared pure and defines
the same types and subprograms as Numerics.Generic_Complex_Arrays,
except that the predefined type Float is systematically substituted for
Real'Base, and the Real_Vector and Real_Matrix types exported by
Numerics.Real_Arrays are systematically substituted for Real_Vector and
Real_Matrix, and the Complex type exported by Numerics.Complex_Types is
systematically substituted for Complex, throughout.  Nongeneric
equivalents for each of the other predefined floating point types are
defined similarly, with the names Numerics.Short_Complex_Arrays,
Numerics.Long_Complex_Arrays, etc.

54/2
Two types are defined and exported by Numerics.Generic_Complex_Arrays.
The composite type Complex_Vector is provided to represent a vector with
components of type Complex; it is defined as an unconstrained
one-dimensional array with an index of type Integer.  The composite type
Complex_Matrix is provided to represent a matrix with components of type
Complex; it is defined as an unconstrained, two-dimensional array with
indices of type Integer.

55/2
The effect of the various subprograms is as described below.  In many
cases they are described in terms of corresponding scalar operations in
Numerics.Generic_Complex_Types.  Any exception raised by those
operations is propagated by the array subprogram.  Moreover, any
constraints on the parameters and the accuracy of the result for each
individual component are as defined for the scalar operation.

56/2
In the case of those operations which are defined to involve an inner
product, Constraint_Error may be raised if an intermediate result has a
component outside the range of Real'Base even though the final
mathematical result would not.

57/2
     function Re (X : Complex_Vector) return Real_Vector;
     function Im (X : Complex_Vector) return Real_Vector;

58/2
          Each function returns a vector of the specified Cartesian
          components of X. The index range of the result is X'Range.

59/2
     procedure Set_Re (X  : in out Complex_Vector; Re : in Real_Vector);
     procedure Set_Im (X  : in out Complex_Vector; Im : in Real_Vector);

60/2
          Each procedure replaces the specified (Cartesian) component of
          each of the components of X by the value of the matching
          component of Re or Im; the other (Cartesian) component of each
          of the components is unchanged.  Constraint_Error is raised if
          X'Length is not equal to Re'Length or Im'Length.

61/2
     function Compose_From_Cartesian (Re     : Real_Vector)
        return Complex_Vector;
     function Compose_From_Cartesian (Re, Im : Real_Vector)
        return Complex_Vector;

62/2
          Each function constructs a vector of Complex results (in
          Cartesian representation) formed from given vectors of
          Cartesian components; when only the real components are given,
          imaginary components of zero are assumed.  The index range of
          the result is Re'Range.  Constraint_Error is raised if
          Re'Length is not equal to Im'Length.

63/2
     function Modulus  (X     : Complex_Vector) return Real_Vector;
     function "abs"    (Right : Complex_Vector) return Real_Vector
                                                   renames Modulus;
     function Argument (X     : Complex_Vector) return Real_Vector;
     function Argument (X     : Complex_Vector;
                        Cycle : Real'Base)      return Real_Vector;

64/2
          Each function calculates and returns a vector of the specified
          polar components of X or Right using the corresponding
          function in numerics.generic_complex_types.  The index range
          of the result is X'Range or Right'Range.

65/2
     function Compose_From_Polar (Modulus, Argument : Real_Vector)
        return Complex_Vector;
     function Compose_From_Polar (Modulus, Argument : Real_Vector;
                                  Cycle             : Real'Base)
        return Complex_Vector;

66/2
          Each function constructs a vector of Complex results (in
          Cartesian representation) formed from given vectors of polar
          components using the corresponding function in
          numerics.generic_complex_types on matching components of
          Modulus and Argument.  The index range of the result is
          Modulus'Range.  Constraint_Error is raised if Modulus'Length
          is not equal to Argument'Length.

67/2
     function "+" (Right : Complex_Vector) return Complex_Vector;
     function "-" (Right : Complex_Vector) return Complex_Vector;

68/2
          Each operation returns the result of applying the
          corresponding operation in numerics.generic_complex_types to
          each component of Right.  The index range of the result is
          Right'Range.

69/2
     function Conjugate (X : Complex_Vector) return Complex_Vector;

70/2
          This function returns the result of applying the appropriate
          function Conjugate in numerics.generic_complex_types to each
          component of X. The index range of the result is X'Range.

71/2
     function "+" (Left, Right : Complex_Vector) return Complex_Vector;
     function "-" (Left, Right : Complex_Vector) return Complex_Vector;

72/2
          Each operation returns the result of applying the
          corresponding operation in numerics.generic_complex_types to
          each component of Left and the matching component of Right.
          The index range of the result is Left'Range.  Constraint_Error
          is raised if Left'Length is not equal to Right'Length.

73/2
     function "*" (Left, Right : Complex_Vector) return Complex;

74/2
          This operation returns the inner product of Left and Right.
          Constraint_Error is raised if Left'Length is not equal to
          Right'Length.  This operation involves an inner product.

75/3
     function "abs" (Right : Complex_Vector) return Real'Base;

76/2
          This operation returns the Hermitian L2-norm of Right (the
          square root of the inner product of the vector with its
          conjugate).

77/2
     function "+" (Left  : Real_Vector;
                   Right : Complex_Vector) return Complex_Vector;
     function "+" (Left  : Complex_Vector;
                   Right : Real_Vector)    return Complex_Vector;
     function "-" (Left  : Real_Vector;
                   Right : Complex_Vector) return Complex_Vector;
     function "-" (Left  : Complex_Vector;
                   Right : Real_Vector)    return Complex_Vector;

78/2
          Each operation returns the result of applying the
          corresponding operation in numerics.generic_complex_types to
          each component of Left and the matching component of Right.
          The index range of the result is Left'Range.  Constraint_Error
          is raised if Left'Length is not equal to Right'Length.

79/2
     function "*" (Left : Real_Vector;    Right : Complex_Vector) return Complex;
     function "*" (Left : Complex_Vector; Right : Real_Vector)    return Complex;

80/2
          Each operation returns the inner product of Left and Right.
          Constraint_Error is raised if Left'Length is not equal to
          Right'Length.  These operations involve an inner product.

81/2
     function "*" (Left : Complex; Right : Complex_Vector) return Complex_Vector;

82/2
          This operation returns the result of multiplying each
          component of Right by the complex number Left using the
          appropriate operation "*" in numerics.generic_complex_types.
          The index range of the result is Right'Range.

83/2
     function "*" (Left : Complex_Vector; Right : Complex) return Complex_Vector;
     function "/" (Left : Complex_Vector; Right : Complex) return Complex_Vector;

84/2
          Each operation returns the result of applying the
          corresponding operation in numerics.generic_complex_types to
          each component of the vector Left and the complex number
          Right.  The index range of the result is Left'Range.

85/2
     function "*" (Left : Real'Base;
                   Right : Complex_Vector) return Complex_Vector;

86/2
          This operation returns the result of multiplying each
          component of Right by the real number Left using the
          appropriate operation "*" in numerics.generic_complex_types.
          The index range of the result is Right'Range.

87/2
     function "*" (Left : Complex_Vector;
                   Right : Real'Base) return Complex_Vector;
     function "/" (Left : Complex_Vector;
                   Right : Real'Base) return Complex_Vector;

88/2
          Each operation returns the result of applying the
          corresponding operation in numerics.generic_complex_types to
          each component of the vector Left and the real number Right.
          The index range of the result is Left'Range.

89/2
     function Unit_Vector (Index : Integer;
                           Order : Positive;
                           First : Integer := 1) return Complex_Vector;

90/2
          This function returns a unit vector with Order components and
          a lower bound of First.  All components are set to (0.0, 0.0)
          except for the Index component which is set to (1.0, 0.0).
          Constraint_Error is raised if Index < First, Index > First +
          Order - 1, or if First + Order - 1 > Integer'Last.

91/2
     function Re (X : Complex_Matrix) return Real_Matrix;
     function Im (X : Complex_Matrix) return Real_Matrix;

92/2
          Each function returns a matrix of the specified Cartesian
          components of X. The index ranges of the result are those of
          X.

93/2
     procedure Set_Re (X : in out Complex_Matrix; Re : in Real_Matrix);
     procedure Set_Im (X : in out Complex_Matrix; Im : in Real_Matrix);

94/2
          Each procedure replaces the specified (Cartesian) component of
          each of the components of X by the value of the matching
          component of Re or Im; the other (Cartesian) component of each
          of the components is unchanged.  Constraint_Error is raised if
          X'Length(1) is not equal to Re'Length(1) or Im'Length(1) or if
          X'Length(2) is not equal to Re'Length(2) or Im'Length(2).

95/2
     function Compose_From_Cartesian (Re     : Real_Matrix)
        return Complex_Matrix;
     function Compose_From_Cartesian (Re, Im : Real_Matrix)
        return Complex_Matrix;

96/2
          Each function constructs a matrix of Complex results (in
          Cartesian representation) formed from given matrices of
          Cartesian components; when only the real components are given,
          imaginary components of zero are assumed.  The index ranges of
          the result are those of Re.  Constraint_Error is raised if
          Re'Length(1) is not equal to Im'Length(1) or Re'Length(2) is
          not equal to Im'Length(2).

97/2
     function Modulus  (X     : Complex_Matrix) return Real_Matrix;
     function "abs"    (Right : Complex_Matrix) return Real_Matrix
                                                   renames Modulus;
     function Argument (X     : Complex_Matrix) return Real_Matrix;
     function Argument (X     : Complex_Matrix;
                        Cycle : Real'Base)      return Real_Matrix;

98/2
          Each function calculates and returns a matrix of the specified
          polar components of X or Right using the corresponding
          function in numerics.generic_complex_types.  The index ranges
          of the result are those of X or Right.

99/2
     function Compose_From_Polar (Modulus, Argument : Real_Matrix)
        return Complex_Matrix;
     function Compose_From_Polar (Modulus, Argument : Real_Matrix;
                                  Cycle             : Real'Base)
        return Complex_Matrix;

100/2
          Each function constructs a matrix of Complex results (in
          Cartesian representation) formed from given matrices of polar
          components using the corresponding function in
          numerics.generic_complex_types on matching components of
          Modulus and Argument.  The index ranges of the result are
          those of Modulus.  Constraint_Error is raised if
          Modulus'Length(1) is not equal to Argument'Length(1) or
          Modulus'Length(2) is not equal to Argument'Length(2).

101/2
     function "+" (Right : Complex_Matrix) return Complex_Matrix;
     function "-" (Right : Complex_Matrix) return Complex_Matrix;

102/2
          Each operation returns the result of applying the
          corresponding operation in numerics.generic_complex_types to
          each component of Right.  The index ranges of the result are
          those of Right.

103/2
     function Conjugate (X : Complex_Matrix) return Complex_Matrix;

104/2
          This function returns the result of applying the appropriate
          function Conjugate in numerics.generic_complex_types to each
          component of X. The index ranges of the result are those of X.

105/2
     function Transpose (X : Complex_Matrix) return Complex_Matrix;

106/2
          This function returns the transpose of a matrix X. The first
          and second index ranges of the result are X'Range(2) and
          X'Range(1) respectively.

107/2
     function "+" (Left, Right : Complex_Matrix) return Complex_Matrix;
     function "-" (Left, Right : Complex_Matrix) return Complex_Matrix;

108/2
          Each operation returns the result of applying the
          corresponding operation in numerics.generic_complex_types to
          each component of Left and the matching component of Right.
          The index ranges of the result are those of Left.
          Constraint_Error is raised if Left'Length(1) is not equal to
          Right'Length(1) or Left'Length(2) is not equal to
          Right'Length(2).

109/2
     function "*" (Left, Right : Complex_Matrix) return Complex_Matrix;

110/2
          This operation provides the standard mathematical operation
          for matrix multiplication.  The first and second index ranges
          of the result are Left'Range(1) and Right'Range(2)
          respectively.  Constraint_Error is raised if Left'Length(2) is
          not equal to Right'Length(1).  This operation involves inner
          products.

111/2
     function "*" (Left, Right : Complex_Vector) return Complex_Matrix;

112/2
          This operation returns the outer product of a (column) vector
          Left by a (row) vector Right using the appropriate operation
          "*" in numerics.generic_complex_types for computing the
          individual components.  The first and second index ranges of
          the result are Left'Range and Right'Range respectively.

113/2
     function "*" (Left  : Complex_Vector;
                   Right : Complex_Matrix) return Complex_Vector;

114/2
          This operation provides the standard mathematical operation
          for multiplication of a (row) vector Left by a matrix Right.
          The index range of the (row) vector result is Right'Range(2).
          Constraint_Error is raised if Left'Length is not equal to
          Right'Length(1).  This operation involves inner products.

115/2
     function "*" (Left  : Complex_Matrix;
                   Right : Complex_Vector) return Complex_Vector;

116/2
          This operation provides the standard mathematical operation
          for multiplication of a matrix Left by a (column) vector
          Right.  The index range of the (column) vector result is
          Left'Range(1).  Constraint_Error is raised if Left'Length(2)
          is not equal to Right'Length.  This operation involves inner
          products.

117/2
     function "+" (Left  : Real_Matrix;
                   Right : Complex_Matrix) return Complex_Matrix;
     function "+" (Left  : Complex_Matrix;
                   Right : Real_Matrix)    return Complex_Matrix;
     function "-" (Left  : Real_Matrix;
                   Right : Complex_Matrix) return Complex_Matrix;
     function "-" (Left  : Complex_Matrix;
                   Right : Real_Matrix)    return Complex_Matrix;

118/2
          Each operation returns the result of applying the
          corresponding operation in numerics.generic_complex_types to
          each component of Left and the matching component of Right.
          The index ranges of the result are those of Left.
          Constraint_Error is raised if Left'Length(1) is not equal to
          Right'Length(1) or Left'Length(2) is not equal to
          Right'Length(2).

119/2
     function "*" (Left  : Real_Matrix;
                   Right : Complex_Matrix) return Complex_Matrix;
     function "*" (Left  : Complex_Matrix;
                   Right : Real_Matrix)    return Complex_Matrix;

120/2
          Each operation provides the standard mathematical operation
          for matrix multiplication.  The first and second index ranges
          of the result are Left'Range(1) and Right'Range(2)
          respectively.  Constraint_Error is raised if Left'Length(2) is
          not equal to Right'Length(1).  These operations involve inner
          products.

121/2
     function "*" (Left  : Real_Vector;
                   Right : Complex_Vector) return Complex_Matrix;
     function "*" (Left  : Complex_Vector;
                   Right : Real_Vector)    return Complex_Matrix;

122/2
          Each operation returns the outer product of a (column) vector
          Left by a (row) vector Right using the appropriate operation
          "*" in numerics.generic_complex_types for computing the
          individual components.  The first and second index ranges of
          the result are Left'Range and Right'Range respectively.

123/2
     function "*" (Left  : Real_Vector;
                   Right : Complex_Matrix) return Complex_Vector;
     function "*" (Left  : Complex_Vector;
                   Right : Real_Matrix)    return Complex_Vector;

124/2
          Each operation provides the standard mathematical operation
          for multiplication of a (row) vector Left by a matrix Right.
          The index range of the (row) vector result is Right'Range(2).
          Constraint_Error is raised if Left'Length is not equal to
          Right'Length(1).  These operations involve inner products.

125/2
     function "*" (Left  : Real_Matrix;
                   Right : Complex_Vector) return Complex_Vector;
     function "*" (Left  : Complex_Matrix;
                   Right : Real_Vector)    return Complex_Vector;

126/2
          Each operation provides the standard mathematical operation
          for multiplication of a matrix Left by a (column) vector
          Right.  The index range of the (column) vector result is
          Left'Range(1).  Constraint_Error is raised if Left'Length(2)
          is not equal to Right'Length.  These operations involve inner
          products.

127/2
     function "*" (Left : Complex; Right : Complex_Matrix) return Complex_Matrix;

128/2
          This operation returns the result of multiplying each
          component of Right by the complex number Left using the
          appropriate operation "*" in numerics.generic_complex_types.
          The index ranges of the result are those of Right.

129/2
     function "*" (Left : Complex_Matrix; Right : Complex) return Complex_Matrix;
     function "/" (Left : Complex_Matrix; Right : Complex) return Complex_Matrix;

130/2
          Each operation returns the result of applying the
          corresponding operation in numerics.generic_complex_types to
          each component of the matrix Left and the complex number
          Right.  The index ranges of the result are those of Left.

131/2
     function "*" (Left : Real'Base;
                   Right : Complex_Matrix) return Complex_Matrix;

132/2
          This operation returns the result of multiplying each
          component of Right by the real number Left using the
          appropriate operation "*" in numerics.generic_complex_types.
          The index ranges of the result are those of Right.

133/2
     function "*" (Left : Complex_Matrix;
                   Right : Real'Base) return Complex_Matrix;
     function "/" (Left : Complex_Matrix;
                   Right : Real'Base) return Complex_Matrix;

134/2
          Each operation returns the result of applying the
          corresponding operation in numerics.generic_complex_types to
          each component of the matrix Left and the real number Right.
          The index ranges of the result are those of Left.

135/2
     function Solve (A : Complex_Matrix; X : Complex_Vector) return Complex_Vector;

136/2
          This function returns a vector Y such that X is (nearly) equal
          to A * Y. This is the standard mathematical operation for
          solving a single set of linear equations.  The index range of
          the result is A'Range(2).  Constraint_Error is raised if
          A'Length(1), A'Length(2), and X'Length are not equal.
          Constraint_Error is raised if the matrix A is ill-conditioned.

137/2
     function Solve (A, X : Complex_Matrix) return Complex_Matrix;

138/2
          This function returns a matrix Y such that X is (nearly) equal
          to A * Y. This is the standard mathematical operation for
          solving several sets of linear equations.  The index ranges of
          the result are A'Range(2) and X'Range(2).  Constraint_Error is
          raised if A'Length(1), A'Length(2), and X'Length(1) are not
          equal.  Constraint_Error is raised if the matrix A is
          ill-conditioned.

139/2
     function Inverse (A : Complex_Matrix) return Complex_Matrix;

140/2
          This function returns a matrix B such that A * B is (nearly)
          equal to the unit matrix.  The index ranges of the result are
          A'Range(2) and A'Range(1).  Constraint_Error is raised if
          A'Length(1) is not equal to A'Length(2).  Constraint_Error is
          raised if the matrix A is ill-conditioned.

141/2
     function Determinant (A : Complex_Matrix) return Complex;

142/2
          This function returns the determinant of the matrix A.
          Constraint_Error is raised if A'Length(1) is not equal to
          A'Length(2).

143/2
     function Eigenvalues(A : Complex_Matrix) return Real_Vector;

144/2
          This function returns the eigenvalues of the Hermitian matrix
          A as a vector sorted into order with the largest first.
          Constraint_Error is raised if A'Length(1) is not equal to
          A'Length(2).  The index range of the result is A'Range(1).
          Argument_Error is raised if the matrix A is not Hermitian.

145/2
     procedure Eigensystem(A       : in  Complex_Matrix;
                           Values  :  out Real_Vector;
                           Vectors :  out Complex_Matrix);

146/3
          This procedure computes both the eigenvalues and eigenvectors
          of the Hermitian matrix A. The out parameter Values is the
          same as that obtained by calling the function Eigenvalues.
          The out parameter Vectors is a matrix whose columns are the
          eigenvectors of the matrix A. The order of the columns
          corresponds to the order of the eigenvalues.  The eigenvectors
          are mutually orthonormal, including when there are repeated
          eigenvalues.  Constraint_Error is raised if A'Length(1) is not
          equal to A'Length(2), or if Values'Range is not equal to
          A'Range(1), or if the index ranges of the parameter Vectors
          are not equal to those of A. Argument_Error is raised if the
          matrix A is not Hermitian.  Constraint_Error is also raised in
          implementation-defined circumstances if the algorithm used
          does not converge quickly enough.

147/2
     function Unit_Matrix (Order            : Positive;
                           First_1, First_2 : Integer := 1)
                                              return Complex_Matrix;

148/2
          This function returns a square unit matrix with Order**2
          components and lower bounds of First_1 and First_2 (for the
          first and second index ranges respectively).  All components
          are set to (0.0, 0.0) except for the main diagonal, whose
          components are set to (1.0, 0.0).  Constraint_Error is raised
          if First_1 + Order - 1 > Integer'Last or First_2 + Order - 1 >
          Integer'Last.

                     _Implementation Requirements_

149/2
Accuracy requirements for the subprograms Solve, Inverse, Determinant,
Eigenvalues and Eigensystem are implementation defined.

150/2
For operations not involving an inner product, the accuracy requirements
are those of the corresponding operations of the type Real'Base and
Complex in both the strict mode and the relaxed mode (see *note G.2::).

151/2
For operations involving an inner product, no requirements are specified
in the relaxed mode.  In the strict mode the modulus of the absolute
error of the inner product X*Y shall not exceed g*abs(X)*abs(Y) where g
is defined as

152/2
     g = X'Length * Real'Machine_Radix**(1 - Real'Model_Mantissa)
         for mixed complex and real operands

153/2
     g = sqrt(2.0) * X'Length * Real'Machine_Radix**(1 - Real'Model_Mantissa)
         for two complex operands

154/2
For the L2-norm, no accuracy requirements are specified in the relaxed
mode.  In the strict mode the relative error on the norm shall not
exceed g / 2.0 + 3.0 * Real'Model_Epsilon where g has the definition
appropriate for two complex operands.

                     _Documentation Requirements_

155/2
Implementations shall document any techniques used to reduce
cancellation errors such as extended precision arithmetic.

                     _Implementation Permissions_

156/2
The nongeneric equivalent packages may, but need not, be actual
instantiations of the generic package for the appropriate predefined
type.

157/2
Although many operations are defined in terms of operations from
numerics.generic_complex_types, they need not be implemented by calling
those operations provided that the effect is the same.

                        _Implementation Advice_

158/3
Implementations should implement the Solve and Inverse functions using
established techniques.  Implementations are recommended to refine the
result by performing an iteration on the residuals; if this is done,
then it should be documented.

159/2
It is not the intention that any special provision should be made to
determine whether a matrix is ill-conditioned or not.  The naturally
occurring overflow (including division by zero) which will result from
executing these functions with an ill-conditioned matrix and thus raise
Constraint_Error is sufficient.

160/2
The test that a matrix is Hermitian should use the equality operator to
compare the real components and negation followed by equality to compare
the imaginary components (see *note G.2.1::).

160.1/3
An implementation should minimize the circumstances under which the
algorithm used for Eigenvalues and Eigensystem fails to converge.

161/2
Implementations should not perform operations on mixed complex and real
operands by first converting the real operand to complex.  See *note
G.1.1::.


File: arm2012.info,  Node: Annex H,  Next: Annex J,  Prev: Annex G,  Up: Top

Annex H High Integrity Systems
******************************

1/2
This Annex addresses requirements for high integrity systems (including
safety-critical systems and security-critical systems).  It provides
facilities and specifies documentation requirements that relate to
several needs:

2
   * Understanding program execution;

3
   * Reviewing object code;

4
   * Restricting language constructs whose usage might complicate the
     demonstration of program correctness

4.1
Execution understandability is supported by pragma Normalize_Scalars,
and also by requirements for the implementation to document the effect
of a program in the presence of a bounded error or where the language
rules leave the effect unspecified. 

5
The pragmas Reviewable and Restrictions relate to the other requirements
addressed by this Annex.

     NOTES

6
     1  The Valid attribute (see *note 13.9.2::) is also useful in
     addressing these needs, to avoid problems that could otherwise
     arise from scalars that have values outside their declared range
     constraints.

* Menu:

* H.1 ::      Pragma Normalize_Scalars
* H.2 ::      Documentation of Implementation Decisions
* H.3 ::      Reviewable Object Code
* H.4 ::      High Integrity Restrictions
* H.5 ::      Pragma Detect_Blocking
* H.6 ::      Pragma Partition_Elaboration_Policy


File: arm2012.info,  Node: H.1,  Next: H.2,  Up: Annex H

H.1 Pragma Normalize_Scalars
============================

1
This pragma ensures that an otherwise uninitialized scalar object is set
to a predictable value, but out of range if possible.

                               _Syntax_

2
     The form of a pragma Normalize_Scalars is as follows:

3
       pragma Normalize_Scalars;

                       _Post-Compilation Rules_

4
Pragma Normalize_Scalars is a configuration pragma.  It applies to all
compilation_units included in a partition.

                     _Documentation Requirements_

5/2
If a pragma Normalize_Scalars applies, the implementation shall document
the implicit initial values for scalar subtypes, and shall identify each
case in which such a value is used and is not an invalid representation.

                        _Implementation Advice_

6/2
Whenever possible, the implicit initial values for a scalar subtype
should be an invalid representation (see *note 13.9.1::).

     NOTES

7
     2  The initialization requirement applies to uninitialized scalar
     objects that are subcomponents of composite objects, to allocated
     objects, and to stand-alone objects.  It also applies to scalar out
     parameters.  Scalar subcomponents of composite out parameters are
     initialized to the corresponding part of the actual, by virtue of
     *note 6.4.1::.

8
     3  The initialization requirement does not apply to a scalar for
     which pragma Import has been specified, since initialization of an
     imported object is performed solely by the foreign language
     environment (see *note B.1::).

9
     4  The use of pragma Normalize_Scalars in conjunction with Pragma
     Restrictions(No_Exceptions) may result in erroneous execution (see
     *note H.4::).


File: arm2012.info,  Node: H.2,  Next: H.3,  Prev: H.1,  Up: Annex H

H.2 Documentation of Implementation Decisions
=============================================

                     _Documentation Requirements_

1
The implementation shall document the range of effects for each
situation that the language rules identify as either a bounded error or
as having an unspecified effect.  If the implementation can constrain
the effects of erroneous execution for a given construct, then it shall
document such constraints.  The documentation might be provided either
independently of any compilation unit or partition, or as part of an
annotated listing for a given unit or partition.  See also *note
1.1.3::, and *note 1.1.2::.

     NOTES

2
     5  Among the situations to be documented are the conventions chosen
     for parameter passing, the methods used for the management of
     run-time storage, and the method used to evaluate numeric
     expressions if this involves extended range or extra precision.


File: arm2012.info,  Node: H.3,  Next: H.4,  Prev: H.2,  Up: Annex H

H.3 Reviewable Object Code
==========================

1
Object code review and validation are supported by pragmas Reviewable
and Inspection_Point.

* Menu:

* H.3.1 ::    Pragma Reviewable
* H.3.2 ::    Pragma Inspection_Point


File: arm2012.info,  Node: H.3.1,  Next: H.3.2,  Up: H.3

H.3.1 Pragma Reviewable
-----------------------

1
This pragma directs the implementation to provide information to
facilitate analysis and review of a program's object code, in particular
to allow determination of execution time and storage usage and to
identify the correspondence between the source and object programs.

                               _Syntax_

2
     The form of a pragma Reviewable is as follows:

3
       pragma Reviewable;

                       _Post-Compilation Rules_

4
Pragma Reviewable is a configuration pragma.  It applies to all
compilation_units included in a partition.

                     _Implementation Requirements_

5
The implementation shall provide the following information for any
compilation unit to which such a pragma applies:

6
   * Where compiler-generated run-time checks remain;

7
   * An identification of any construct with a language-defined check
     that is recognized prior to run time as certain to fail if executed
     (even if the generation of run-time checks has been suppressed);

8/2
   * For each read of a scalar object, an identification of the read as
     either "known to be initialized," or "possibly uninitialized,"
     independent of whether pragma Normalize_Scalars applies;

9
   * Where run-time support routines are implicitly invoked;

10
   * An object code listing, including:

11
             * Machine instructions, with relative offsets;

12
             * Where each data object is stored during its lifetime;

13
             * Correspondence with the source program, including an
               identification of the code produced per declaration and
               per statement.

14
   * An identification of each construct for which the implementation
     detects the possibility of erroneous execution;

15
   * For each subprogram, block, task, or other construct implemented by
     reserving and subsequently freeing an area on a run-time stack, an
     identification of the length of the fixed-size portion of the area
     and an indication of whether the non-fixed size portion is reserved
     on the stack or in a dynamically-managed storage region.

16
The implementation shall provide the following information for any
partition to which the pragma applies:

17
   * An object code listing of the entire partition, including
     initialization and finalization code as well as run-time system
     components, and with an identification of those instructions and
     data that will be relocated at load time;

18
   * A description of the run-time model relevant to the partition.

18.1
The implementation shall provide control- and data-flow information,
both within each compilation unit and across the compilation units of
the partition.

                        _Implementation Advice_

19
The implementation should provide the above information in both a
human-readable and machine-readable form, and should document the latter
so as to ease further processing by automated tools.

20
Object code listings should be provided both in a symbolic format and
also in an appropriate numeric format (such as hexadecimal or octal).

     NOTES

21
     6  The order of elaboration of library units will be documented
     even in the absence of pragma Reviewable (see *note 10.2::).


File: arm2012.info,  Node: H.3.2,  Prev: H.3.1,  Up: H.3

H.3.2 Pragma Inspection_Point
-----------------------------

1
An occurrence of a pragma Inspection_Point identifies a set of objects
each of whose values is to be available at the point(s) during program
execution corresponding to the position of the pragma in the compilation
unit.  The purpose of such a pragma is to facilitate code validation.

                               _Syntax_

2
     The form of a pragma Inspection_Point is as follows:

3
       pragma Inspection_Point[(object_name {, object_name})];

                           _Legality Rules_

4
A pragma Inspection_Point is allowed wherever a declarative_item or
statement is allowed.  Each object_name shall statically denote the
declaration of an object.

                          _Static Semantics_

5/2
An inspection point is a point in the object code corresponding to the
occurrence of a pragma Inspection_Point in the compilation unit. An
object is inspectable at an inspection point if the corresponding pragma
Inspection_Point either has an argument denoting that object, or has no
arguments and the declaration of the object is visible at the inspection
point.

                          _Dynamic Semantics_

6
Execution of a pragma Inspection_Point has no effect.

                     _Implementation Requirements_

7
Reaching an inspection point is an external interaction with respect to
the values of the inspectable objects at that point (see *note 1.1.3::).

                     _Documentation Requirements_

8
For each inspection point, the implementation shall identify a mapping
between each inspectable object and the machine resources (such as
memory locations or registers) from which the object's value can be
obtained.

     NOTES

9/2
     7  The implementation is not allowed to perform "dead store
     elimination" on the last assignment to a variable prior to a point
     where the variable is inspectable.  Thus an inspection point has
     the effect of an implicit read of each of its inspectable objects.

10
     8  Inspection points are useful in maintaining a correspondence
     between the state of the program in source code terms, and the
     machine state during the program's execution.  Assertions about the
     values of program objects can be tested in machine terms at
     inspection points.  Object code between inspection points can be
     processed by automated tools to verify programs mechanically.

11
     9  The identification of the mapping from source program objects to
     machine resources is allowed to be in the form of an annotated
     object listing, in human-readable or tool-processable form.


File: arm2012.info,  Node: H.4,  Next: H.5,  Prev: H.3,  Up: Annex H

H.4 High Integrity Restrictions
===============================

1/3
This subclause defines restrictions that can be used with pragma
Restrictions (see *note 13.12::); these facilitate the demonstration of
program correctness by allowing tailored versions of the run-time
system.

                          _Static Semantics_

2/2
This paragraph was deleted.

3/2
The following restriction_identifiers are language defined:

4
Tasking-related restriction:

5
No_Protected_Types
               There are no declarations of protected types or protected
               objects.

6
Memory-management related restrictions:

7
No_Allocators
               There are no occurrences of an allocator.

8/1
No_Local_Allocators
               Allocators are prohibited in subprograms, generic
               subprograms, tasks, and entry bodies.

8.1/3
No_Anonymous_Allocators
               There are no allocators of anonymous access types.

8.2/3
No_Coextensions
               There are no coextensions.  See *note 3.10.2::.

8.3/3
No_Access_Parameter_Allocators
               Allocators are not permitted as the actual parameter to
               an access parameter.  See *note 6.1::.

9/2

               This paragraph was deleted.

10
Immediate_Reclamation
               Except for storage occupied by objects created by
               allocators and not deallocated via unchecked
               deallocation, any storage reserved at run time for an
               object is immediately reclaimed when the object no longer
               exists. 

11
Exception-related restriction:

12
No_Exceptions
               Raise_statements and exception_handlers are not allowed.
               No language-defined run-time checks are generated;
               however, a run-time check performed automatically by the
               hardware is permitted.

13
Other restrictions:

14
No_Floating_Point
               Uses of predefined floating point types and operations,
               and declarations of new floating point types, are not
               allowed.

15
No_Fixed_Point
               Uses of predefined fixed point types and operations, and
               declarations of new fixed point types, are not allowed.

16/2

               This paragraph was deleted.

17
No_Access_Subprograms
               The declaration of access-to-subprogram types is not
               allowed. 

18
No_Unchecked_Access
               The Unchecked_Access attribute is not allowed.

19
No_Dispatch
               Occurrences of T'Class are not allowed, for any (tagged)
               subtype T.

20/2
No_IO
               Semantic dependence on any of the library units
               Sequential_IO, Direct_IO, Text_IO, Wide_Text_IO,
               Wide_Wide_Text_IO, or Stream_IO is not allowed.

21
No_Delay
               Delay_Statements and semantic dependence on package
               Calendar are not allowed.

22
No_Recursion
               As part of the execution of a subprogram, the same
               subprogram is not invoked.

23
No_Reentrancy
               During the execution of a subprogram by a task, no other
               task invokes the same subprogram.

                     _Implementation Requirements_

23.1/2
An implementation of this Annex shall support:

23.2/2
   * the restrictions defined in this subclause; and

23.3/3
   * the following restrictions defined in *note D.7:::
     No_Task_Hierarchy, No_Abort_Statement, No_Implicit_Heap_Allocation,
     No_Standard_Allocators_After_Elaboration; and

23.4/2
   * the pragma Profile(Ravenscar); and

23.5/2
   * the following uses of restriction_parameter_identifiers defined in
     *note D.7::, which are checked prior to program execution:

23.6/2
             * Max_Task_Entries => 0,

23.7/2
             * Max_Asynchronous_Select_Nesting => 0, and

23.8/2
             * Max_Tasks => 0.

24/3
If an implementation supports pragma Restrictions for a particular
argument, then except for the restrictions No_Unchecked_Deallocation,
No_Unchecked_Conversion, No_Access_Subprograms, No_Unchecked_Access,
No_Specification_of_Aspect, No_Use_of_Attribute, No_Use_of_Pragma, and
the equivalent use of No_Dependence, the associated restriction applies
to the run-time system.

                     _Documentation Requirements_

25
If a pragma Restrictions(No_Exceptions) is specified, the implementation
shall document the effects of all constructs where language-defined
checks are still performed automatically (for example, an overflow check
performed by the processor).

                         _Erroneous Execution_

26
Program execution is erroneous if pragma Restrictions(No_Exceptions) has
been specified and the conditions arise under which a generated
language-defined run-time check would fail.

27
Program execution is erroneous if pragma Restrictions(No_Recursion) has
been specified and a subprogram is invoked as part of its own execution,
or if pragma Restrictions(No_Reentrancy) has been specified and during
the execution of a subprogram by a task, another task invokes the same
subprogram.

     NOTES

28/2
     10  Uses of restriction_parameter_identifier No_Dependence defined
     in *note 13.12.1::: No_Dependence => Ada.Unchecked_Deallocation and
     No_Dependence => Ada.Unchecked_Conversion may be appropriate for
     high-integrity systems.  Other uses of No_Dependence can also be
     appropriate for high-integrity systems.


File: arm2012.info,  Node: H.5,  Next: H.6,  Prev: H.4,  Up: Annex H

H.5 Pragma Detect_Blocking
==========================

1/2
The following pragma forces an implementation to detect potentially
blocking operations within a protected operation.

                               _Syntax_

2/2
     The form of a pragma Detect_Blocking is as follows:

3/2
       pragma Detect_Blocking;

                       _Post-Compilation Rules_

4/2
A pragma Detect_Blocking is a configuration pragma.

                          _Dynamic Semantics_

5/2
An implementation is required to detect a potentially blocking operation
within a protected operation, and to raise Program_Error (see *note
9.5.1::).

                     _Implementation Permissions_

6/2
An implementation is allowed to reject a compilation_unit if a
potentially blocking operation is present directly within an entry_body
or the body of a protected subprogram.

     NOTES

7/2
     11  An operation that causes a task to be blocked within a foreign
     language domain is not defined to be potentially blocking, and need
     not be detected.


File: arm2012.info,  Node: H.6,  Prev: H.5,  Up: Annex H

H.6 Pragma Partition_Elaboration_Policy
=======================================

1/3
This subclause defines a pragma for user control over elaboration
policy.

                               _Syntax_

2/2
     The form of a pragma Partition_Elaboration_Policy is as follows:

3/2
       pragma Partition_Elaboration_Policy (policy_identifier);

4/2
     The policy_identifier shall be either Sequential, Concurrent or an
     implementation-defined identifier.

                       _Post-Compilation Rules_

5/2
A pragma Partition_Elaboration_Policy is a configuration pragma.  It
specifies the elaboration policy for a partition.  At most one
elaboration policy shall be specified for a partition.

6/3
If the Sequential policy is specified for a partition, then pragma
Restrictions (No_Task_Hierarchy) shall also be specified for the
partition.

                          _Dynamic Semantics_

7/2
Notwithstanding what this International Standard says elsewhere, this
pragma allows partition elaboration rules concerning task activation and
interrupt attachment to be changed.  If the policy_identifier is
Concurrent, or if there is no pragma Partition_Elaboration_Policy
defined for the partition, then the rules defined elsewhere in this
Standard apply.

8/2
If the partition elaboration policy is Sequential, then task activation
and interrupt attachment are performed in the following sequence of
steps:

9/2
   * The activation of all library-level tasks and the attachment of
     interrupt handlers are deferred until all library units are
     elaborated.

10/2
   * The interrupt handlers are attached by the environment task.

11/2
   * The environment task is suspended while the library-level tasks are
     activated.

12/2
   * The environment task executes the main subprogram (if any)
     concurrently with these executing tasks.

13/2
If several dynamic interrupt handler attachments for the same interrupt
are deferred, then the most recent call of Attach_Handler or
Exchange_Handler determines which handler is attached.

14/2
If any deferred task activation fails, Tasking_Error is raised at the
beginning of the sequence of statements of the body of the environment
task prior to calling the main subprogram.

                        _Implementation Advice_

15/3
If the partition elaboration policy is Sequential and the Environment
task becomes permanently blocked during elaboration, then the partition
is deadlocked and it is recommended that the partition be immediately
terminated.

                     _Implementation Permissions_

16/3
If the partition elaboration policy is Sequential and any task
activation fails, then an implementation may immediately terminate the
active partition to mitigate the hazard posed by continuing to execute
with a subset of the tasks being active.

     NOTES

17/2
     12  If any deferred task activation fails, the environment task is
     unable to handle the Tasking_Error exception and completes
     immediately.  By contrast, if the partition elaboration policy is
     Concurrent, then this exception could be handled within a library
     unit.


File: arm2012.info,  Node: Annex J,  Next: Annex K,  Prev: Annex H,  Up: Top

Annex J Obsolescent Features
****************************

1/2
This Annex contains descriptions of features of the language whose
functionality is largely redundant with other features defined by this
International Standard.  Use of these features is not recommended in
newly written programs.  Use of these features can be prevented by using
pragma Restrictions (No_Obsolescent_Features), see *note 13.12.1::.

* Menu:

* J.1 ::      Renamings of Library Units
* J.2 ::      Allowed Replacements of Characters
* J.3 ::      Reduced Accuracy Subtypes
* J.4 ::      The Constrained Attribute
* J.5 ::      ASCII
* J.6 ::      Numeric_Error
* J.7 ::      At Clauses
* J.8 ::      Mod Clauses
* J.9 ::      The Storage_Size Attribute
* J.10 ::     Specific Suppression of Checks
* J.11 ::     The Class Attribute of Untagged Incomplete Types
* J.12 ::     Pragma Interface
* J.13 ::     Dependence Restriction Identifiers
* J.14 ::     Character and Wide_Character Conversion Functions
* J.15 ::     Aspect-related Pragmas


File: arm2012.info,  Node: J.1,  Next: J.2,  Up: Annex J

J.1 Renamings of Library Units
==============================

                          _Static Semantics_

1
The following library_unit_renaming_declarations exist:

2
     with Ada.Unchecked_Conversion;
     generic function Unchecked_Conversion renames Ada.Unchecked_Conversion;

3
     with Ada.Unchecked_Deallocation;
     generic procedure Unchecked_Deallocation renames Ada.Unchecked_Deallocation;

4
     with Ada.Sequential_IO;
     generic package Sequential_IO renames Ada.Sequential_IO;

5
     with Ada.Direct_IO;
     generic package Direct_IO renames Ada.Direct_IO;

6
     with Ada.Text_IO;
     package Text_IO renames Ada.Text_IO;

7
     with Ada.IO_Exceptions;
     package IO_Exceptions renames Ada.IO_Exceptions;

8
     with Ada.Calendar;
     package Calendar renames Ada.Calendar;

9
     with System.Machine_Code;
     package Machine_Code renames System.Machine_Code; -- If supported.

                     _Implementation Requirements_

10
The implementation shall allow the user to replace these renamings.


File: arm2012.info,  Node: J.2,  Next: J.3,  Prev: J.1,  Up: Annex J

J.2 Allowed Replacements of Characters
======================================

                               _Syntax_

1
     The following replacements are allowed for the vertical line,
     number sign, and quotation mark characters:

2
        * A vertical line character (|) can be replaced by an
          exclamation mark (!)  where used as a delimiter.

3
        * The number sign characters (#) of a based_literal can be
          replaced by colons (:) provided that the replacement is done
          for both occurrences.

4
        * The quotation marks (") used as string brackets at both ends
          of a string literal can be replaced by percent signs (%)
          provided that the enclosed sequence of characters contains no
          quotation mark, and provided that both string brackets are
          replaced.  Any percent sign within the sequence of characters
          shall then be doubled and each such doubled percent sign is
          interpreted as a single percent sign character value.

5
     These replacements do not change the meaning of the program.


File: arm2012.info,  Node: J.3,  Next: J.4,  Prev: J.2,  Up: Annex J

J.3 Reduced Accuracy Subtypes
=============================

1
A digits_constraint may be used to define a floating point subtype with
a new value for its requested decimal precision, as reflected by its
Digits attribute.  Similarly, a delta_constraint may be used to define
an ordinary fixed point subtype with a new value for its delta, as
reflected by its Delta attribute.

                               _Syntax_

2/4
     delta_constraint ::= delta static_simple_expression [
     range_constraint]

                        _Name Resolution Rules_

3/4
The simple_expression of a delta_constraint is expected to be of any
real type.

                           _Legality Rules_

4/4
The simple_expression of a delta_constraint shall be static.

5
For a subtype_indication with a delta_constraint, the subtype_mark shall
denote an ordinary fixed point subtype.

6
For a subtype_indication with a digits_constraint, the subtype_mark
shall denote either a decimal fixed point subtype or a floating point
subtype (notwithstanding the rule given in *note 3.5.9:: that only
allows a decimal fixed point subtype).

                          _Static Semantics_

7/4
A subtype_indication with a subtype_mark that denotes an ordinary fixed
point subtype and a delta_constraint defines an ordinary fixed point
subtype with a delta given by the value of the simple_expression of the
delta_constraint.  If the delta_constraint includes a range_constraint
(*note 3.5: S0036.), then the ordinary fixed point subtype is
constrained by the range_constraint (*note 3.5: S0036.).

8/4
A subtype_indication with a subtype_mark that denotes a floating point
subtype and a digits_constraint defines a floating point subtype with a
requested decimal precision (as reflected by its Digits attribute) given
by the value of the simple_expression of the digits_constraint.  If the
digits_constraint includes a range_constraint (*note 3.5: S0036.), then
the floating point subtype is constrained by the range_constraint (*note
3.5: S0036.).

                          _Dynamic Semantics_

9/4
A delta_constraint is compatible with an ordinary fixed point subtype if
the value of the simple_expression is no less than the delta of the
subtype, and the range_constraint, if any, is compatible with the
subtype.

10/4
A digits_constraint is compatible with a floating point subtype if the
value of the simple_expression is no greater than the requested decimal
precision of the subtype, and the range_constraint, if any, is
compatible with the subtype.

11
The elaboration of a delta_constraint consists of the elaboration of the
range_constraint, if any.


File: arm2012.info,  Node: J.4,  Next: J.5,  Prev: J.3,  Up: Annex J

J.4 The Constrained Attribute
=============================

                          _Static Semantics_

1
For every private subtype S, the following attribute is defined:

2
S'Constrained
               Yields the value False if S denotes an unconstrained
               nonformal private subtype with discriminants; also yields
               the value False if S denotes a generic formal private
               subtype, and the associated actual subtype is either an
               unconstrained subtype with discriminants or an
               unconstrained array subtype; yields the value True
               otherwise.  The value of this attribute is of the
               predefined subtype Boolean.


File: arm2012.info,  Node: J.5,  Next: J.6,  Prev: J.4,  Up: Annex J

J.5 ASCII
=========

                          _Static Semantics_

1
The following declaration exists in the declaration of package Standard:

2
     package ASCII is

3
       --  Control characters:

4
       NUL   : constant Character := nul;    SOH   : constant Character := soh;
       STX   : constant Character := stx;    ETX   : constant Character := etx;
       EOT   : constant Character := eot;    ENQ   : constant Character := enq;
       ACK   : constant Character := ack;    BEL   : constant Character := bel;
       BS    : constant Character := bs;    HT    : constant Character := ht;
       LF    : constant Character := lf;    VT    : constant Character := vt;
       FF    : constant Character := ff;    CR    : constant Character := cr;
       SO    : constant Character := so;    SI    : constant Character := si;
       DLE   : constant Character := dle;    DC1   : constant Character := dc1;
       DC2   : constant Character := dc2;    DC3   : constant Character := dc3;
       DC4   : constant Character := dc4;    NAK   : constant Character := nak;
       SYN   : constant Character := syn;    ETB   : constant Character := etb;
       CAN   : constant Character := can;    EM    : constant Character := em;
       SUB   : constant Character := sub;    ESC   : constant Character := esc;
       FS    : constant Character := fs;    GS    : constant Character := gs;
       RS    : constant Character := rs;    US    : constant Character := us;
       DEL   : constant Character := del;

5
       -- Other characters:

6
       Exclam   : constant Character:= '!';   Quotation : constant Character:= '"';
       Sharp    : constant Character:= '#';   Dollar    : constant Character:= '$';
       Percent  : constant Character:= '%';   Ampersand : constant Character:= '&';
       Colon    : constant Character:= ':';   Semicolon : constant Character:= ';';
       Query    : constant Character:= '?';   At_Sign   : constant Character:= '@';
       L_Bracket: constant Character:= '[';   Back_Slash: constant Character:= '\';
       R_Bracket: constant Character:= ']';   Circumflex: constant Character:= '^';
       Underline: constant Character:= '_';   Grave     : constant Character:= '`';
       L_Brace  : constant Character:= '{';   Bar       : constant Character:= '|';
       R_Brace  : constant Character:= '}';   Tilde     : constant Character:= '~';

7
       -- Lower case letters:

8
       LC_A: constant Character:= 'a';
       ...
       LC_Z: constant Character:= 'z';

9
     end ASCII;


File: arm2012.info,  Node: J.6,  Next: J.7,  Prev: J.5,  Up: Annex J

J.6 Numeric_Error
=================

                          _Static Semantics_

1
The following declaration exists in the declaration of package Standard:

2
     Numeric_Error : exception renames Constraint_Error;


File: arm2012.info,  Node: J.7,  Next: J.8,  Prev: J.6,  Up: Annex J

J.7 At Clauses
==============

                               _Syntax_

1
     at_clause ::= for direct_name use at expression;

                          _Static Semantics_

2
An at_clause of the form "for x use at y;" is equivalent to an
attribute_definition_clause of the form "for x'Address use y;".

* Menu:

* J.7.1 ::    Interrupt Entries


File: arm2012.info,  Node: J.7.1,  Up: J.7

J.7.1 Interrupt Entries
-----------------------

1
Implementations are permitted to allow the attachment of task entries to
interrupts via the address clause.  Such an entry is referred to as an
interrupt entry.

2
The address of the task entry corresponds to a hardware interrupt in an
implementation-defined manner.  (See Ada.Interrupts.Reference in *note
C.3.2::.)

                          _Static Semantics_

3
The following attribute is defined:

4
For any task entry X:

5
X'Address
               For a task entry whose address is specified (an interrupt
               entry), the value refers to the corresponding hardware
               interrupt.  For such an entry, as for any other task
               entry, the meaning of this value is implementation
               defined.  The value of this attribute is of the type of
               the subtype System.Address.

6
               Address may be specified for single entries via an
               attribute_definition_clause.

                          _Dynamic Semantics_

7
As part of the initialization of a task object, the address clause for
an interrupt entry is elaborated, which evaluates the expression of the
address clause.  A check is made that the address specified is
associated with some interrupt to which a task entry may be attached. If
this check fails, Program_Error is raised.  Otherwise, the interrupt
entry is attached to the interrupt associated with the specified
address.

8
Upon finalization of the task object, the interrupt entry, if any, is
detached from the corresponding interrupt and the default treatment is
restored.

9
While an interrupt entry is attached to an interrupt, the interrupt is
reserved (see *note C.3::).

10
An interrupt delivered to a task entry acts as a call to the entry
issued by a hardware task whose priority is in the
System.Interrupt_Priority range.  It is implementation defined whether
the call is performed as an ordinary entry call, a timed entry call, or
a conditional entry call; which kind of call is performed can depend on
the specific interrupt.

                      _Bounded (Run-Time) Errors_

11
It is a bounded error to evaluate E'Caller (see *note C.7.1::) in an
accept_statement for an interrupt entry.  The possible effects are the
same as for calling Current_Task from an entry body.

                     _Documentation Requirements_

12
The implementation shall document to which interrupts a task entry may
be attached.

13
The implementation shall document whether the invocation of an interrupt
entry has the effect of an ordinary entry call, conditional call, or a
timed call, and whether the effect varies in the presence of pending
interrupts.

                     _Implementation Permissions_

14
The support for this subclause is optional.

15
Interrupts to which the implementation allows a task entry to be
attached may be designated as reserved for the entire duration of
program execution; that is, not just when they have an interrupt entry
attached to them.

16/1
Interrupt entry calls may be implemented by having the hardware execute
directly the appropriate accept_statement.  Alternatively, the
implementation is allowed to provide an internal interrupt handler to
simulate the effect of a normal task calling the entry.

17
The implementation is allowed to impose restrictions on the
specifications and bodies of tasks that have interrupt entries.

18
It is implementation defined whether direct calls (from the program) to
interrupt entries are allowed.

19
If a select_statement contains both a terminate_alternative and an
accept_alternative for an interrupt entry, then an implementation is
allowed to impose further requirements for the selection of the
terminate_alternative in addition to those given in *note 9.3::.

     NOTES

20/1
     1  Queued interrupts correspond to ordinary entry calls.
     Interrupts that are lost if not immediately processed correspond to
     conditional entry calls.  It is a consequence of the priority rules
     that an accept_statement executed in response to an interrupt can
     be executed with the active priority at which the hardware
     generates the interrupt, taking precedence over lower priority
     tasks, without a scheduling action.

21
     2  Control information that is supplied upon an interrupt can be
     passed to an associated interrupt entry as one or more parameters
     of mode in.

                              _Examples_

22
Example of an interrupt entry:

23
     task Interrupt_Handler is
       entry Done;
       for Done'Address use Ada.Interrupts.Reference(Ada.Interrupts.Names.Device_Done);
     end Interrupt_Handler;


File: arm2012.info,  Node: J.8,  Next: J.9,  Prev: J.7,  Up: Annex J

J.8 Mod Clauses
===============

                               _Syntax_

1
     mod_clause ::= at mod static_expression;

                          _Static Semantics_

2
A record_representation_clause of the form:

3/3
     for r use
         record at mod a;
             ...
         end record;

4
is equivalent to:

5
     for r'Alignment use a;
     for r use
         record
             ...
         end record;


File: arm2012.info,  Node: J.9,  Next: J.10,  Prev: J.8,  Up: Annex J

J.9 The Storage_Size Attribute
==============================

                          _Static Semantics_

1
For any task subtype T, the following attribute is defined:

2
T'Storage_Size
               Denotes an implementation-defined value of type
               universal_integer representing the number of storage
               elements reserved for a task of the subtype T.

3/3
               Storage_Size may be specified for a task first subtype
               that is not an interface via an
               attribute_definition_clause.  When the attribute is
               specified, the Storage_Size aspect is specified to be the
               value of the given expression.


File: arm2012.info,  Node: J.10,  Next: J.11,  Prev: J.9,  Up: Annex J

J.10 Specific Suppression of Checks
===================================

1/2
Pragma Suppress can be used to suppress checks on specific entities.

                               _Syntax_

2/2
     The form of a specific Suppress pragma is as follows:

3/2
       pragma Suppress(identifier, [On =>] name);

                           _Legality Rules_

4/2
The identifier shall be the name of a check (see *note 11.5::).  The
name shall statically denote some entity.

5/2
For a specific Suppress pragma that is immediately within a
package_specification, the name shall denote an entity (or several
overloaded subprograms) declared immediately within the
package_specification (*note 7.1: S0191.).

                          _Static Semantics_

6/2
A specific Suppress pragma applies to the named check from the place of
the pragma to the end of the innermost enclosing declarative region, or,
if the pragma is given in a package_specification, to the end of the
scope of the named entity.  The pragma applies only to the named entity,
or, for a subtype, on objects and values of its type.  A specific
Suppress pragma suppresses the named check for any entities to which it
applies (see *note 11.5::).  Which checks are associated with a specific
entity is not defined by this International Standard.

                     _Implementation Permissions_

7/2
An implementation is allowed to place restrictions on specific Suppress
pragmas.

     NOTES

8/2
     3  An implementation may support a similar On parameter on pragma
     Unsuppress (see *note 11.5::).


File: arm2012.info,  Node: J.11,  Next: J.12,  Prev: J.10,  Up: Annex J

J.11 The Class Attribute of Untagged Incomplete Types
=====================================================

                          _Static Semantics_

1/2
For the first subtype S of a type T declared by an
incomplete_type_declaration that is not tagged, the following attribute
is defined:

2/2
S'Class
               Denotes the first subtype of the incomplete class-wide
               type rooted at T. The completion of T shall declare a
               tagged type.  Such an attribute reference shall occur in
               the same library unit as the incomplete_type_declaration.


File: arm2012.info,  Node: J.12,  Next: J.13,  Prev: J.11,  Up: Annex J

J.12 Pragma Interface
=====================

                               _Syntax_

1/2
     In addition to an identifier, the reserved word interface is
     allowed as a pragma name, to provide compatibility with a prior
     edition of this International Standard.


File: arm2012.info,  Node: J.13,  Next: J.14,  Prev: J.12,  Up: Annex J

J.13 Dependence Restriction Identifiers
=======================================

1/2
The following restrictions involve dependence on specific
language-defined units.  The more general restriction No_Dependence (see
*note 13.12.1::) should be used for this purpose.

                          _Static Semantics_

2/2
The following restriction_identifiers exist:

3/2
No_Asynchronous_Control
               Semantic dependence on the predefined package
               Asynchronous_Task_Control is not allowed.

4/2
No_Unchecked_Conversion
               Semantic dependence on the predefined generic function
               Unchecked_Conversion is not allowed.

5/2
No_Unchecked_Deallocation
               Semantic dependence on the predefined generic procedure
               Unchecked_Deallocation is not allowed.


File: arm2012.info,  Node: J.14,  Next: J.15,  Prev: J.13,  Up: Annex J

J.14 Character and Wide_Character Conversion Functions
======================================================

                          _Static Semantics_

1/2
The following declarations exist in the declaration of package
Ada.Characters.Handling:

2/2
        function Is_Character (Item : in Wide_Character) return Boolean
           renames Conversions.Is_Character;
        function Is_String    (Item : in Wide_String)    return Boolean
           renames Conversions.Is_String;

3/2
        function To_Character (Item       : in Wide_Character;
                              Substitute : in Character := ' ')
                              return Character
           renames Conversions.To_Character;

4/2
        function To_String    (Item       : in Wide_String;
                               Substitute : in Character := ' ')
                               return String
           renames Conversions.To_String;

5/2
        function To_Wide_Character (Item : in Character) return Wide_Character
           renames Conversions.To_Wide_Character;

6/2
        function To_Wide_String    (Item : in String)    return Wide_String
           renames Conversions.To_Wide_String;


File: arm2012.info,  Node: J.15,  Prev: J.14,  Up: Annex J

J.15 Aspect-related Pragmas
===========================

1/3
Pragmas can be used as an alternative to aspect_specifications to
specify certain aspects.

* Menu:

* J.15.1 ::   Pragma Inline
* J.15.2 ::   Pragma No_Return
* J.15.3 ::   Pragma Pack
* J.15.4 ::   Pragma Storage_Size
* J.15.5 ::   Interfacing Pragmas
* J.15.6 ::   Pragma Unchecked_Union
* J.15.7 ::   Pragmas Interrupt_Handler and Attach_Handler
* J.15.8 ::   Shared Variable Pragmas
* J.15.9 ::   Pragma CPU
* J.15.10 ::  Pragma Dispatching_Domain
* J.15.11 ::  Pragmas Priority and Interrupt_Priority
* J.15.12 ::  Pragma Relative_Deadline
* J.15.13 ::  Pragma Asynchronous


File: arm2012.info,  Node: J.15.1,  Next: J.15.2,  Up: J.15

J.15.1 Pragma Inline
--------------------

                               _Syntax_

1/3
     The form of a pragma Inline, which is a program unit pragma (see
     *note 10.1.5::), is as follows: 

2/3
       pragma Inline (name{, name});

                           _Legality Rules_

3/3
The pragma shall apply to one or more callable entities or generic
subprograms.

                          _Static Semantics_

4/3
Pragma Inline specifies that the Inline aspect (see *note 6.3.2::) for
each entity denoted by each name given in the pragma has the value True.

                     _Implementation Permissions_

5/3
An implementation may allow a pragma Inline that has an argument which
is a direct_name denoting a subprogram_body of the same
declarative_part.

     NOTES

6/3
     4  The name in a pragma Inline may denote more than one entity in
     the case of overloading.  Such a pragma applies to all of the
     denoted entities.


File: arm2012.info,  Node: J.15.2,  Next: J.15.3,  Prev: J.15.1,  Up: J.15

J.15.2 Pragma No_Return
-----------------------

                               _Syntax_

1/3
     The form of a pragma No_Return, which is a representation pragma
     (see *note 13.1::), is as follows: 

2/3
       pragma No_Return (procedure_local_name{, procedure_local_name});

                           _Legality Rules_

3/3
Each procedure_local_name shall denote one or more procedures or generic
procedures.  The procedure_local_name shall not denote a null procedure
nor an instance of a generic unit.

                          _Static Semantics_

4/3
Pragma No_Return specifies that the No_Return aspect (see *note 6.5.1::)
for each procedure denoted by each local_name given in the pragma has
the value True.


File: arm2012.info,  Node: J.15.3,  Next: J.15.4,  Prev: J.15.2,  Up: J.15

J.15.3 Pragma Pack
------------------

                               _Syntax_

1/3
     The form of a pragma Pack, which is a representation pragma (see
     *note 13.1::), is as follows: 

2/3
       pragma Pack (first_subtype_local_name);

                           _Legality Rules_

3/3
The first_subtype_local_name of a pragma Pack shall denote a composite
subtype.

                          _Static Semantics_

4/3
Pragma Pack specifies that the Pack aspect (see *note 13.2::) for the
type denoted by first_subtype_local_name has the value True.


File: arm2012.info,  Node: J.15.4,  Next: J.15.5,  Prev: J.15.3,  Up: J.15

J.15.4 Pragma Storage_Size
--------------------------

                               _Syntax_

1/3
     The form of a pragma Storage_Size is as follows:

2/3
       pragma Storage_Size (expression);

3/3
     A pragma Storage_Size is allowed only immediately within a
     task_definition.

                        _Name Resolution Rules_

4/3
The expression of a pragma Storage_Size is expected to be of any integer
type.

                          _Static Semantics_

5/3
The pragma Storage_Size sets the Storage_Size aspect (see *note 13.3::)
of the type defined by the immediately enclosing task_definition to the
value of the expression of the pragma.


File: arm2012.info,  Node: J.15.5,  Next: J.15.6,  Prev: J.15.4,  Up: J.15

J.15.5 Interfacing Pragmas
--------------------------

                               _Syntax_

1/3
     An interfacing pragma is a representation pragma that is one of the
     pragmas Import, Export, or Convention.  Their forms are as follows:

2/3
       pragma Import(
          [Convention =>] convention_identifier, [Entity =>] local_name
       [, [External_Name =>] external_name_string_expression]
       [, [Link_Name =>] link_name_string_expression]);

3/3
       pragma Export(
          [Convention =>] convention_identifier, [Entity =>] local_name
       [, [External_Name =>] external_name_string_expression]
       [, [Link_Name =>] link_name_string_expression]);

4/3
       pragma Convention([Convention =>] convention_identifier,[Entity
     =>] local_name);

5/3
     For pragmas Import and Export, the argument for Link_Name shall not
     be given without the pragma_argument_identifier unless the argument
     for External_Name is given.

                        _Name Resolution Rules_

6/3
The expected type for an external_name_string_expression and a
link_name_string_expression in an interfacing pragma is String.

                           _Legality Rules_

7/3
The convention_identifier of an interfacing pragma shall be the name of
a convention (see *note B.1::).

8/3
A pragma Import shall be the completion of a declaration.
Notwithstanding any rule to the contrary, a pragma Import may serve as
the completion of any kind of (explicit) declaration if supported by an
implementation for that kind of declaration.  If a completion is a
pragma Import, then it shall appear in the same declarative_part,
package_specification, task_definition, or protected_definition as the
declaration.  For a library unit, it shall appear in the same
compilation, before any subsequent compilation_units other than pragmas.
If the local_name denotes more than one entity, then the pragma Import
is the completion of all of them.

9/3
The external_name_string_expression and link_name_string_expression of a
pragma Import or Export shall be static.

10/3
The local_name of each of these pragmas shall denote a declaration that
may have the similarly named aspect specified.

                          _Static Semantics_

11/3
An interfacing pragma specifies various aspects of the entity denoted by
the local_name as follows:

12/3
   * The Convention aspect (see *note B.1::) is convention_identifier.

13/3
   * A pragma Import specifies that the Import aspect (see *note B.1::)
     is True.

14/3
   * A pragma Export specifies that the Export aspect (see *note B.1::)
     is True.

15/3
   * For both pragma Import and Export, if an external name is given in
     the pragma, the External_Name aspect (see *note B.1::) is specified
     to be external_name_string_expression.  If a link name is given in
     the pragma, the Link_Name aspect (see *note B.1::) is specified to
     be the link_name_string_expression.


File: arm2012.info,  Node: J.15.6,  Next: J.15.7,  Prev: J.15.5,  Up: J.15

J.15.6 Pragma Unchecked_Union
-----------------------------

                               _Syntax_

1/3
     The form of a pragma Unchecked_Union, which is a representation
     pragma (see *note 13.1::), is as follows: 

2/3
       pragma Unchecked_Union (first_subtype_local_name);

                           _Legality Rules_

3/3
The first_subtype_local_name of a pragma Unchecked_Union shall denote an
unconstrained discriminated record subtype having a variant_part.

                          _Static Semantics_

4/3
A pragma Unchecked_Union specifies that the Unchecked_Union aspect (see
*note B.3.3::) for the type denoted by first_subtype_local_name has the
value True.


File: arm2012.info,  Node: J.15.7,  Next: J.15.8,  Prev: J.15.6,  Up: J.15

J.15.7 Pragmas Interrupt_Handler and Attach_Handler
---------------------------------------------------

                               _Syntax_

1/3
     The form of a pragma Interrupt_Handler is as follows:

2/3
       pragma Interrupt_Handler (handler_name);

3/3
     The form of a pragma Attach_Handler is as follows:

4/3
       pragma Attach_Handler (handler_name, expression);

                        _Name Resolution Rules_

5/3
For the Interrupt_Handler and Attach_Handler pragmas, the handler_name
shall resolve to denote a protected procedure with a parameterless
profile.

6/3
For the Attach_Handler pragma, the expected type for the expression is
Interrupts.Interrupt_Id (see *note C.3.2::). 

                           _Legality Rules_

7/3
The Attach_Handler and Interrupt_Handler pragmas are only allowed
immediately within the protected_definition where the corresponding
subprogram is declared.  The corresponding protected_type_declaration or
single_protected_declaration shall be a library-level declaration, and
shall not be declared within a generic body. In addition to the places
where Legality Rules normally apply (see *note 12.3::), these rules also
apply in the private part of an instance of a generic unit.

                          _Static Semantics_

8/3
For an implementation that supports Annex C, a pragma Interrupt_Handler
specifies the Interrupt_Handler aspect (see *note C.3.1::) for the
protected procedure handler_name to have the value True.  For an
implementation that supports Annex C, a pragma Attach_Handler specifies
the Attach_Handler aspect (see *note C.3.1::) for the protected
procedure handler_name to have the value of the given expression as
evaluated at object creation time.


File: arm2012.info,  Node: J.15.8,  Next: J.15.9,  Prev: J.15.7,  Up: J.15

J.15.8 Shared Variable Pragmas
------------------------------

                               _Syntax_

1/3
     The form for pragmas Atomic, Volatile, Independent,
     Atomic_Components, and Volatile_Components, and
     Independent_Components is as follows:

2/3
       pragma Atomic (local_name);

3/3
       pragma Volatile (local_name);

4/3
       pragma Independent (component_local_name);

5/3
       pragma Atomic_Components (array_local_name);

6/3
       pragma Volatile_Components (array_local_name);

7/3
       pragma Independent_Components (local_name);

                        _Name Resolution Rules_

8/3
The local_name in an Atomic or Volatile pragma shall resolve to denote
either an object_declaration, a noninherited component_declaration, or a
full_type_declaration.  The component_local_name in an Independent
pragma shall resolve to denote a noninherited component_declaration.
The array_local_name in an Atomic_Components or Volatile_Components
pragma shall resolve to denote the declaration of an array type or an
array object of an anonymous type.  The local_name in an
Independent_Components pragma shall resolve to denote the declaration of
an array or record type or an array object of an anonymous type.

                          _Static Semantics_

9/3
These pragmas are representation pragmas (see *note 13.1::).  Each of
these pragmas specifies that the similarly named aspect (see *note
C.6::) of the type, object, or component denoted by its argument is
True. 

                           _Legality Rules_

10/3
The local_name of each of these pragmas shall denote a declaration that
may have the similarly named aspect specified.


File: arm2012.info,  Node: J.15.9,  Next: J.15.10,  Prev: J.15.8,  Up: J.15

J.15.9 Pragma CPU
-----------------

                               _Syntax_

1/3
     The form of a pragma CPU is as follows:

2/3
       pragma CPU (expression);

                        _Name Resolution Rules_

3/3
The expected type for the expression of a pragma CPU is
System.Multiprocessors.CPU_Range.

                           _Legality Rules_

4/3
A CPU pragma is allowed only immediately within a task_definition, or
the declarative_part of a subprogram_body.

5/3
For a CPU pragma that appears in the declarative_part of a
subprogram_body, the expression shall be static.

                          _Static Semantics_

6/3
For an implementation that supports Annex D, a pragma CPU specifies the
value of the CPU aspect (see *note D.16::).  If the pragma appears in a
task_definition, the expression is associated with the aspect for the
task type or single_task_declaration that contains the pragma;
otherwise, the expression is associated with the aspect for the
subprogram that contains the pragma.


File: arm2012.info,  Node: J.15.10,  Next: J.15.11,  Prev: J.15.9,  Up: J.15

J.15.10 Pragma Dispatching_Domain
---------------------------------

                               _Syntax_

1/3
     The form of a pragma Dispatching_Domain is as follows:

2/3
       pragma Dispatching_Domain (expression);

                        _Name Resolution Rules_

3/3
The expected type for the expression is
System.Multiprocessors.Dispatching_Domains.Dispatching_Domain. 

                           _Legality Rules_

4/3
A Dispatching_Domain pragma is allowed only immediately within a
task_definition.

                          _Static Semantics_

5/3
For an implementation that supports Annex D, a pragma Dispatching_Domain
specifies the value of the Dispatching_Domain aspect (see *note
D.16.1::).  The expression is associated with the aspect for the task
type or single_task_declaration that contains the pragma.


File: arm2012.info,  Node: J.15.11,  Next: J.15.12,  Prev: J.15.10,  Up: J.15

J.15.11 Pragmas Priority and Interrupt_Priority
-----------------------------------------------

                               _Syntax_

1/3
     The form of a pragma Priority is as follows:

2/3
       pragma Priority (expression);

3/3
     The form of a pragma Interrupt_Priority is as follows:

4/3
       pragma Interrupt_Priority [(expression);]

                        _Name Resolution Rules_

5/3
The expected type for the expression in a Priority or Interrupt_Priority
pragma is Integer. 

                           _Legality Rules_

6/3
A Priority pragma is allowed only immediately within a task_definition,
a protected_definition, or the declarative_part of a subprogram_body.
An Interrupt_Priority pragma is allowed only immediately within a
task_definition or a protected_definition.

7/3
For a Priority pragma that appears in the declarative_part of a
subprogram_body, the expression shall be static, and its value shall be
in the range of System.Priority.

                          _Static Semantics_

8/3
For an implementation that supports Annex D, a pragma Priority specifies
the value of the Priority aspect (see *note D.1::) and a pragma
Interrupt_Priority specifies the value of the Interrupt_Priority aspect
as follows:

9/3
   * If the pragma appears in a task_definition, the expression is
     associated with the aspect for the task type or
     single_task_declaration that contains the pragma;

10/3
   * If the pragma appears in a protected_definition, the expression is
     associated with the aspect for the protected type or
     single_protected_declaration that contains the pragma;

11/3
   * If the pragma appears in the declarative_part of a subprogram_body,
     the expression is associated with the aspect for the subprogram
     that contains the pragma.

12/3
If there is no expression in an Interrupt_Priority pragma, the
Interrupt_Priority aspect has the value Interrupt_Priority'Last.


File: arm2012.info,  Node: J.15.12,  Next: J.15.13,  Prev: J.15.11,  Up: J.15

J.15.12 Pragma Relative_Deadline
--------------------------------

                               _Syntax_

1/3
     The form of a pragma Relative_Deadline is as follows:

2/3
       pragma Relative_Deadline (relative_deadline_expression);

                        _Name Resolution Rules_

3/3
The expected type for a relative_deadline_expression is
Real_Time.Time_Span.

                           _Legality Rules_

4/3
A Relative_Deadline pragma is allowed only immediately within a
task_definition or the declarative_part of a subprogram_body.

                          _Static Semantics_

5/3
For an implementation that supports Annex D, a pragma Relative_Deadline
specifies the value of the Relative_Deadline aspect (see *note D.2.6::).
If the pragma appears in a task_definition, the expression is associated
with the aspect for the task type or single_task_declaration that
contains the pragma; otherwise, the expression is associated with the
aspect for the subprogram that contains the pragma.


File: arm2012.info,  Node: J.15.13,  Prev: J.15.12,  Up: J.15

J.15.13 Pragma Asynchronous
---------------------------

                               _Syntax_

1/3
     The form of a pragma Asynchronous, which is a representation pragma
     (see *note 13.1::), is as follows: 

2/3
       pragma Asynchronous (local_name);

                          _Static Semantics_

3/3
For an implementation that supports Annex E, a pragma Asynchronous
specifies that the Asynchronous aspect (see *note E.4.1::) for the
procedure or type denoted by local_name has the value True.

                           _Legality Rules_

4/3
The local_name of a pragma Asynchronous shall denote a declaration that
may have aspect Asynchronous specified.


File: arm2012.info,  Node: Annex K,  Next: Annex L,  Prev: Annex J,  Up: Top

Annex K Language-Defined Aspects and Attributes
***********************************************

1/3
This annex summarizes the definitions given elsewhere of the
language-defined aspects and attributes.  Some aspects have
corresponding attributes, as noted.

* Menu:

* K.1 ::      Language-Defined Aspects
* K.2 ::      Language-Defined Attributes


File: arm2012.info,  Node: K.1,  Next: K.2,  Up: Annex K

K.1 Language-Defined Aspects
============================

1/3
This subclause summarizes the definitions given elsewhere of the
language-defined aspects.  Aspects are properties of entities that can
be specified by the Ada program; unless otherwise specified below,
aspects can be specified using an aspect_specification.

2/3
Address
               Machine address of an entity.  See *note 13.3::.

3/3
Alignment (object)
               Alignment of an object.  See *note 13.3::.

4/3
Alignment (subtype)
               Alignment of a subtype.  See *note 13.3::.

5/4
All_Calls_Remote
               All indirect or dispatching remote subprogram calls and
               all direct remote subprogram calls should use the
               Partition Communication Subsystem.  See *note E.2.3::.

6/3
Asynchronous
               Remote procedure calls are asynchronous; the caller
               continues without waiting for the call to return.  See
               *note E.4.1::.

7/3
Atomic
               Declare that a type, object, or component is atomic.  See
               *note C.6::.

8/3
Atomic_Components
               Declare that the components of an array type or object
               are atomic.  See *note C.6::.

9/3
Attach_Handler
               Protected procedure is attached to an interrupt.  See
               *note C.3.1::.

10/3
Bit_Order
               Order of bit numbering in a record_representation_clause.
               See *note 13.5.3::.

11/3
Coding
               Internal representation of enumeration literals.
               Specified by an enumeration_representation_clause, not by
               an aspect_specification.  See *note 13.4::.

12/3
Component_Size
               Size in bits of a component of an array type.  See *note
               13.3::.

13/3
Constant_Indexing
               Defines function(s) to implement user-defined
               indexed_components.  See *note 4.1.6::.

14/3
Convention
               Calling convention or other convention used for
               interfacing to other languages.  See *note B.1::.

15/3
CPU
               Processor on which a given task should run.  See *note
               D.16::.

16/3
Default_Component_Value
               Default value for the components of an array-of-scalar
               subtype.  See *note 3.6::.

17/3
Default_Iterator
               Default iterator to be used in for loops.  See *note
               5.5.1::.

18/3
Default_Storage_Pool
               Default storage pool for a generic instance.  See *note
               13.11.3::.

19/3
Default_Value
               Default value for a scalar subtype.  See *note 3.5::.

19.1/4
Discard_Names
               Requests a reduction in storage for names associated with
               an entity.  See *note C.5::.

20/3
Dispatching_Domain
               Domain (group of processors) on which a given task should
               run.  See *note D.16.1::.

21/3
Dynamic_Predicate
               Condition that must hold true for objects of a given
               subtype; the subtype is not static.  See *note 3.2.4::.

22/3
Elaborate_Body
               A given package must have a body, and that body is
               elaborated immediately after the declaration.  See *note
               10.2.1::.

22.1/4
Exclusive_Functions
               Specifies mutual exclusion behavior of protected
               functions in a protected type.  See *note 9.5.1::.

23/3
Export
               Entity is exported to another language.  See *note B.1::.

24/3
External_Name
               Name used to identify an imported or exported entity.
               See *note B.1::.

25/3
External_Tag
               Unique identifier for a tagged type in streams.  See
               *note 13.3::.

26/3
Implicit_Dereference
               Mechanism for user-defined implicit .all.  See *note
               4.1.5::.

27/3
Import
               Entity is imported from another language.  See *note
               B.1::.

28/3
Independent
               Declare that a type, object, or component is
               independently addressable.  See *note C.6::.

29/3
Independent_Components
               Declare that the components of an array or record type,
               or an array object, are independently addressable.  See
               *note C.6::.

30/3
Inline
               For efficiency, Inline calls are requested for a
               subprogram.  See *note 6.3.2::.

31/3
Input
               Function to read a value from a stream for a given type,
               including any bounds and discriminants.  See *note
               13.13.2::.

31.1/4
Input'Class
               Function to read a value from a stream for a the
               class-wide type associated with a given type, including
               any bounds and discriminants.  See *note 13.13.2::.

32/3
Interrupt_Handler
               Protected procedure may be attached to interrupts.  See
               *note C.3.1::.

33/3
Interrupt_Priority
               Priority of a task object or type, or priority of a
               protected object or type; the priority is in the
               interrupt range.  See *note D.1::.

34/3
Iterator_Element
               Element type to be used for user-defined iterators.  See
               *note 5.5.1::.

35/3
Layout (record)
               Layout of record components.  Specified by a
               record_representation_clause, not by an
               aspect_specification.  See *note 13.5.1::.

36/3
Link_Name
               Linker symbol used to identify an imported or exported
               entity.  See *note B.1::.

37/3
Machine_Radix
               Radix (2 or 10) that is used to represent a decimal fixed
               point type.  See *note F.1::.

38/3
No_Return
               A procedure will not return normally.  See *note 6.5.1::.

39/3
Output
               Procedure to write a value to a stream for a given type,
               including any bounds and discriminants.  See *note
               13.13.2::.

39.1/4
Output'Class
               Procedure to write a value to a stream for a the
               class-wide type associated with a given type, including
               any bounds and discriminants.  See *note 13.13.2::.

40/3
Pack
               Minimize storage when laying out records and arrays.  See
               *note 13.2::.

41/3
Post
               Postcondition; a condition that must hold true after a
               call.  See *note 6.1.1::.

42/3
Post'Class
               Postcondition inherited on type derivation.  See *note
               6.1.1::.

43/3
Pre
               Precondition; a condition that must hold true before a
               call.  See *note 6.1.1::.

44/3
Pre'Class
               Precondition inherited on type derivation.  See *note
               6.1.1::.

44.1/4
Predicate_Failure
               Action to be performed when a predicate check fails.  See
               *note 3.2.4::.

45/3
Preelaborate
               Code execution during elaboration is avoided for a given
               package.  See *note 10.2.1::.

46/3
Priority
               Priority of a task object or type, or priority of a
               protected object or type; the priority is not in the
               interrupt range.  See *note D.1::.

47/3
Pure
               Side effects are avoided in the subprograms of a given
               package.  See *note 10.2.1::.

48/3
Read
               Procedure to read a value from a stream for a given type.
               See *note 13.13.2::.

48.1/4
Read'Class
               Procedure to read a value from a stream for the
               class-wide type associated with a given type.  See *note
               13.13.2::.

49/3
Record layout
               See Layout.  See *note 13.5.1::.

50/3
Relative_Deadline
               Task parameter used in Earliest Deadline First
               Dispatching.  See *note D.2.6::.

51/3
Remote_Call_Interface
               Subprograms in a given package may be used in remote
               procedure calls.  See *note E.2.3::.

52/3
Remote_Types
               Types in a given package may be used in remote procedure
               calls.  See *note E.2.2::.

53/3
Shared_Passive
               A given package is used to represent shared memory in a
               distributed system.  See *note E.2.1::.

54/3
Size (object)
               Size in bits of an object.  See *note 13.3::.

55/3
Size (subtype)
               Size in bits of a subtype.  See *note 13.3::.

56/3
Small
               Scale factor for a fixed point type.  See *note 3.5.10::.

57/3
Static_Predicate
               Condition that must hold true for objects of a given
               subtype; the subtype may be static.  See *note 3.2.4::.

58/3
Storage_Pool
               Pool of memory from which new will allocate for a given
               access type.  See *note 13.11::.

59/3
Storage_Size (access)
               Sets memory size for allocations for an access type.  See
               *note 13.11::.

60/3
Storage_Size (task)
               Size in storage elements reserved for a task type or
               single task object.  See *note 13.3::.

61/3
Stream_Size
               Size in bits used to represent elementary objects in a
               stream.  See *note 13.13.2::.

62/3
Synchronization
               Defines whether a given primitive operation of a
               synchronized interface must be implemented by an entry or
               protected procedure.  See *note 9.5::.

63/3
Type_Invariant
               A condition that must hold true for all objects of a
               type.  See *note 7.3.2::.

64/3
Type_Invariant'Class
               A condition that must hold true for all objects in a
               class of types.  See *note 7.3.2::.

65/3
Unchecked_Union
               Type is used to interface to a C union type.  See *note
               B.3.3::.

66/3
Variable_Indexing
               Defines function(s) to implement user-defined
               indexed_components.  See *note 4.1.6::.

67/3
Volatile
               Declare that a type, object, or component is volatile.
               See *note C.6::.

68/3
Volatile_Components
               Declare that the components of an array type or object
               are volatile.  See *note C.6::.

69/3
Write
               Procedure to write a value to a stream for a given type.
               See *note 13.13.2::.

69.1/4
Write'Class
               Procedure to write a value to a stream for a the
               class-wide type associated with a given type.  See *note
               13.13.2::.


File: arm2012.info,  Node: K.2,  Prev: K.1,  Up: Annex K

K.2 Language-Defined Attributes
===============================

1/3
This subclause summarizes the definitions given elsewhere of the
language-defined attributes.  Attributes are properties of entities that
can be queried by an Ada program.

2
P'Access
               For a prefix P that denotes a subprogram:

3
               P'Access yields an access value that designates the
               subprogram denoted by P. The type of P'Access is an
               access-to-subprogram type (S), as determined by the
               expected type.  See *note 3.10.2::.

4
X'Access
               For a prefix X that denotes an aliased view of an object:

5
               X'Access yields an access value that designates the
               object denoted by X. The type of X'Access is an
               access-to-object type, as determined by the expected
               type.  The expected type shall be a general access type.
               See *note 3.10.2::.

6/1
X'Address
               For a prefix X that denotes an object, program unit, or
               label:

7
               Denotes the address of the first of the storage elements
               allocated to X. For a program unit or label, this value
               refers to the machine code associated with the
               corresponding body or statement.  The value of this
               attribute is of type System.Address.  See *note 13.3::.

8
S'Adjacent
               For every subtype S of a floating point type T:

9
               S'Adjacent denotes a function with the following
               specification:

10
                    function S'Adjacent (X, Towards : T)
                      return T

11
               If Towards = X, the function yields X; otherwise, it
               yields the machine number of the type T adjacent to X in
               the direction of Towards, if that machine number exists. 
               If the result would be outside the base range of S,
               Constraint_Error is raised.  When T'Signed_Zeros is True,
               a zero result has the sign of X. When Towards is zero,
               its sign has no bearing on the result.  See *note
               A.5.3::.

12
S'Aft
               For every fixed point subtype S:

13
               S'Aft yields the number of decimal digits needed after
               the decimal point to accommodate the delta of the subtype
               S, unless the delta of the subtype S is greater than 0.1,
               in which case the attribute yields the value one.  (S'Aft
               is the smallest positive integer N for which
               (10**N)*S'Delta is greater than or equal to one.)  The
               value of this attribute is of the type universal_integer.
               See *note 3.5.10::.

13.1/2
S'Alignment
               For every subtype S:

13.2/2
               The value of this attribute is of type universal_integer,
               and nonnegative.

13.3/2
               For an object X of subtype S, if S'Alignment is not zero,
               then X'Alignment is a nonzero integral multiple of
               S'Alignment unless specified otherwise by a
               representation item.  See *note 13.3::.

14/1
X'Alignment
               For a prefix X that denotes an object:

15/2
               The value of this attribute is of type universal_integer,
               and nonnegative; zero means that the object is not
               necessarily aligned on a storage element boundary.  If
               X'Alignment is not zero, then X is aligned on a storage
               unit boundary and X'Address is an integral multiple of
               X'Alignment (that is, the Address modulo the Alignment is
               zero).

16/2

               This paragraph was deleted.  See *note 13.3::.

17
S'Base
               For every scalar subtype S:

18
               S'Base denotes an unconstrained subtype of the type of S.
               This unconstrained subtype is called the base subtype of
               the type.  See *note 3.5::.

19
S'Bit_Order
               For every specific record subtype S:

20
               Denotes the bit ordering for the type of S. The value of
               this attribute is of type System.Bit_Order.  See *note
               13.5.3::.

21/1
P'Body_Version
               For a prefix P that statically denotes a program unit:

22
               Yields a value of the predefined type String that
               identifies the version of the compilation unit that
               contains the body (but not any subunits) of the program
               unit.  See *note E.3::.

23
T'Callable
               For a prefix T that is of a task type (after any implicit
               dereference):

24
               Yields the value True when the task denoted by T is
               callable, and False otherwise; See *note 9.9::.

25
E'Caller
               For a prefix E that denotes an entry_declaration:

26/3
               Yields a value of the type Task_Id that identifies the
               task whose call is now being serviced.  Use of this
               attribute is allowed only inside an accept_statement, or
               entry_body after the entry_barrier, corresponding to the
               entry_declaration denoted by E. See *note C.7.1::.

27
S'Ceiling
               For every subtype S of a floating point type T:

28
               S'Ceiling denotes a function with the following
               specification:

29
                    function S'Ceiling (X : T)
                      return T

30
               The function yields the value 'ceiling(X)', i.e., the
               smallest (most negative) integral value greater than or
               equal to X. When X is zero, the result has the sign of X;
               a zero result otherwise has a negative sign when
               S'Signed_Zeros is True.  See *note A.5.3::.

31
S'Class
               For every subtype S of a tagged type T (specific or
               class-wide):

32
               S'Class denotes a subtype of the class-wide type (called
               T'Class in this International Standard) for the class
               rooted at T (or if S already denotes a class-wide
               subtype, then S'Class is the same as S).

33
               S'Class is unconstrained.  However, if S is constrained,
               then the values of S'Class are only those that when
               converted to the type T belong to S. See *note 3.9::.

34
S'Class
               For every subtype S of an untagged private type whose
               full view is tagged:

35
               Denotes the class-wide subtype corresponding to the full
               view of S. This attribute is allowed only from the
               beginning of the private part in which the full view is
               declared, until the declaration of the full view.  After
               the full view, the Class attribute of the full view can
               be used.  See *note 7.3.1::.

36/1
X'Component_Size
               For a prefix X that denotes an array subtype or array
               object (after any implicit dereference):

37
               Denotes the size in bits of components of the type of X.
               The value of this attribute is of type universal_integer.
               See *note 13.3::.

38
S'Compose
               For every subtype S of a floating point type T:

39
               S'Compose denotes a function with the following
               specification:

40
                    function S'Compose (Fraction : T;
                                        Exponent : universal_integer)
                      return T

41
               Let v be the value Fraction · T'Machine_RadixExponent-k,
               where k is the normalized exponent of Fraction.  If v is
               a machine number of the type T, or if |v| >=
               T'Model_Small, the function yields v; otherwise, it
               yields either one of the machine numbers of the type T
               adjacent to v. Constraint_Error is optionally raised if v
               is outside the base range of S. A zero result has the
               sign of Fraction when S'Signed_Zeros is True.  See *note
               A.5.3::.

42
A'Constrained
               For a prefix A that is of a discriminated type (after any
               implicit dereference):

43/3
               Yields the value True if A denotes a constant, a value, a
               tagged object, or a constrained variable, and False
               otherwise.  See *note 3.7.2::.

44
S'Copy_Sign
               For every subtype S of a floating point type T:

45
               S'Copy_Sign denotes a function with the following
               specification:

46
                    function S'Copy_Sign (Value, Sign : T)
                      return T

47
               If the value of Value is nonzero, the function yields a
               result whose magnitude is that of Value and whose sign is
               that of Sign; otherwise, it yields the value zero. 
               Constraint_Error is optionally raised if the result is
               outside the base range of S. A zero result has the sign
               of Sign when S'Signed_Zeros is True.  See *note A.5.3::.

48
E'Count
               For a prefix E that denotes an entry of a task or
               protected unit:

49
               Yields the number of calls presently queued on the entry
               E of the current instance of the unit.  The value of this
               attribute is of the type universal_integer.  See *note
               9.9::.

50/1
S'Definite
               For a prefix S that denotes a formal indefinite subtype:

51/3
               S'Definite yields True if the actual subtype
               corresponding to S is definite; otherwise, it yields
               False.  The value of this attribute is of the predefined
               type Boolean.  See *note 12.5.1::.

52
S'Delta
               For every fixed point subtype S:

53
               S'Delta denotes the delta of the fixed point subtype S.
               The value of this attribute is of the type
               universal_real.  See *note 3.5.10::.

54
S'Denorm
               For every subtype S of a floating point type T:

55
               Yields the value True if every value expressible in the
               form
                   ± mantissa · T'Machine_RadixT'Machine_Emin
               where mantissa is a nonzero T'Machine_Mantissa-digit
               fraction in the number base T'Machine_Radix, the first
               digit of which is zero, is a machine number (see *note
               3.5.7::) of the type T; yields the value False otherwise.
               The value of this attribute is of the predefined type
               Boolean.  See *note A.5.3::.

56
S'Digits
               For every floating point subtype S:

57
               S'Digits denotes the requested decimal precision for the
               subtype S. The value of this attribute is of the type
               universal_integer.  See *note 3.5.8::.

58
S'Digits
               For every decimal fixed point subtype S:

59
               S'Digits denotes the digits of the decimal fixed point
               subtype S, which corresponds to the number of decimal
               digits that are representable in objects of the subtype.
               The value of this attribute is of the type
               universal_integer.  See *note 3.5.10::.

60
S'Exponent
               For every subtype S of a floating point type T:

61
               S'Exponent denotes a function with the following
               specification:

62
                    function S'Exponent (X : T)
                      return universal_integer

63
               The function yields the normalized exponent of X. See
               *note A.5.3::.

64
S'External_Tag
               For every subtype S of a tagged type T (specific or
               class-wide):

65
               S'External_Tag denotes an external string representation
               for S'Tag; it is of the predefined type String.
               External_Tag may be specified for a specific tagged type
               via an attribute_definition_clause; the expression of
               such a clause shall be static.  The default external tag
               representation is implementation defined.  See *note
               13.13.2::.  See *note 13.3::.

66/1
A'First
               For a prefix A that is of an array type (after any
               implicit dereference), or denotes a constrained array
               subtype:

67
               A'First denotes the lower bound of the first index range;
               its type is the corresponding index type.  See *note
               3.6.2::.

68
S'First
               For every scalar subtype S:

69
               S'First denotes the lower bound of the range of S. The
               value of this attribute is of the type of S. See *note
               3.5::.

70/1
A'First(N)
               For a prefix A that is of an array type (after any
               implicit dereference), or denotes a constrained array
               subtype:

71
               A'First(N) denotes the lower bound of the N-th index
               range; its type is the corresponding index type.  See
               *note 3.6.2::.

72
R.C'First_Bit
               For a component C of a composite, non-array object R:

73/2
               If the nondefault bit ordering applies to the composite
               type, and if a component_clause specifies the placement
               of C, denotes the value given for the first_bit of the
               component_clause; otherwise, denotes the offset, from the
               start of the first of the storage elements occupied by C,
               of the first bit occupied by C. This offset is measured
               in bits.  The first bit of a storage element is numbered
               zero.  The value of this attribute is of the type
               universal_integer.  See *note 13.5.2::.

73.1/4
S'First_Valid
               For every static discrete subtype S for which there
               exists at least one value belonging to S that satisfies
               the predicates of S:

73.2/4
               S'First_Valid denotes the smallest value that belongs to
               S and satisfies the predicates of S. The value of this
               attribute is of the type of S. See *note 3.5.5::.

74
S'Floor
               For every subtype S of a floating point type T:

75
               S'Floor denotes a function with the following
               specification:

76
                    function S'Floor (X : T)
                      return T

77
               The function yields the value 'floor(X)', i.e., the
               largest (most positive) integral value less than or equal
               to X. When X is zero, the result has the sign of X; a
               zero result otherwise has a positive sign.  See *note
               A.5.3::.

78
S'Fore
               For every fixed point subtype S:

79
               S'Fore yields the minimum number of characters needed
               before the decimal point for the decimal representation
               of any value of the subtype S, assuming that the
               representation does not include an exponent, but includes
               a one-character prefix that is either a minus sign or a
               space.  (This minimum number does not include superfluous
               zeros or underlines, and is at least 2.)  The value of
               this attribute is of the type universal_integer.  See
               *note 3.5.10::.

80
S'Fraction
               For every subtype S of a floating point type T:

81
               S'Fraction denotes a function with the following
               specification:

82
                    function S'Fraction (X : T)
                      return T

83
               The function yields the value X · T'Machine_Radix-k,
               where k is the normalized exponent of X. A zero result,
               which can only occur when X is zero, has the sign of X.
               See *note A.5.3::.

83.1/3
X'Has_Same_Storage
               For a prefix X that denotes an object:

83.2/4
               X'Has_Same_Storage denotes a function with the following
               specification:

83.3/3
                    function X'Has_Same_Storage (Arg : any_type)
                      return Boolean

83.4/4
               The actual parameter shall be a name that denotes an
               object.  The object denoted by the actual parameter can
               be of any type.  This function evaluates the names of the
               objects involved.  It returns True if the representation
               of the object denoted by the actual parameter occupies
               exactly the same bits as the representation of the object
               denoted by X and the objects occupy at least one bit;
               otherwise, it returns False.  See *note 13.3::.

84/1
E'Identity
               For a prefix E that denotes an exception:

85
               E'Identity returns the unique identity of the exception.
               The type of this attribute is Exception_Id.  See *note
               11.4.1::.

86
T'Identity
               For a prefix T that is of a task type (after any implicit
               dereference):

87
               Yields a value of the type Task_Id that identifies the
               task denoted by T. See *note C.7.1::.

88
S'Image
               For every scalar subtype S:

89
               S'Image denotes a function with the following
               specification:

90
                    function S'Image(Arg : S'Base)
                      return String

91/3
               The function returns an image of the value of Arg as a
               String.  See *note 3.5::.

91.1/4
X'Image
               For a prefix X that denotes an object of a scalar type
               (after any implicit dereference):

91.2/4
               X'Image denotes the result of calling function S'Image
               with Arg being X, where S is the nominal subtype of X.
               See *note 3.5::.

92
S'Class'Input
               For every subtype S'Class of a class-wide type T'Class:

93
               S'Class'Input denotes a function with the following
               specification:

94/2
                    function S'Class'Input(
                       Stream : not null access Ada.Streams.Root_Stream_Type'Class)
                       return T'Class

95/3
               First reads the external tag from Stream and determines
               the corresponding internal tag (by calling
               Tags.Descendant_Tag(String'Input(Stream), S'Tag) which
               might raise Tag_Error -- see *note 3.9::) and then
               dispatches to the subprogram denoted by the Input
               attribute of the specific type identified by the internal
               tag; returns that result.  If the specific type
               identified by the internal tag is abstract,
               Constraint_Error is raised.  See *note 13.13.2::.

96
S'Input
               For every subtype S of a specific type T:

97
               S'Input denotes a function with the following
               specification:

98/2
                    function S'Input(
                       Stream : not null access Ada.Streams.Root_Stream_Type'Class)
                       return T

99
               S'Input reads and returns one value from Stream, using
               any bounds or discriminants written by a corresponding
               S'Output to determine how much to read.  See *note
               13.13.2::.

100/1
A'Last
               For a prefix A that is of an array type (after any
               implicit dereference), or denotes a constrained array
               subtype:

101
               A'Last denotes the upper bound of the first index range;
               its type is the corresponding index type.  See *note
               3.6.2::.

102
S'Last
               For every scalar subtype S:

103
               S'Last denotes the upper bound of the range of S. The
               value of this attribute is of the type of S. See *note
               3.5::.

104/1
A'Last(N)
               For a prefix A that is of an array type (after any
               implicit dereference), or denotes a constrained array
               subtype:

105
               A'Last(N) denotes the upper bound of the N-th index
               range; its type is the corresponding index type.  See
               *note 3.6.2::.

106
R.C'Last_Bit
               For a component C of a composite, non-array object R:

107/2
               If the nondefault bit ordering applies to the composite
               type, and if a component_clause specifies the placement
               of C, denotes the value given for the last_bit of the
               component_clause; otherwise, denotes the offset, from the
               start of the first of the storage elements occupied by C,
               of the last bit occupied by C. This offset is measured in
               bits.  The value of this attribute is of the type
               universal_integer.  See *note 13.5.2::.

107.1/4
S'Last_Valid
               For every static discrete subtype S for which there
               exists at least one value belonging to S that satisfies
               the predicates of S:

107.2/4
               S'Last_Valid denotes the largest value that belongs to S
               and satisfies the predicates of S. The value of this
               attribute is of the type of S. See *note 3.5.5::.

108
S'Leading_Part
               For every subtype S of a floating point type T:

109
               S'Leading_Part denotes a function with the following
               specification:

110
                    function S'Leading_Part (X : T;
                                             Radix_Digits : universal_integer)
                      return T

111
               Let v be the value T'Machine_Radixk-Radix_Digits, where k
               is the normalized exponent of X. The function yields the
               value

112
                  * 'floor(X/v)' · v, when X is nonnegative and
                    Radix_Digits is positive;

113
                  * 'ceiling(X/v)' · v, when X is negative and
                    Radix_Digits is positive.

114
               Constraint_Error is raised when Radix_Digits is zero or
               negative.  A zero result, which can only occur when X is
               zero, has the sign of X. See *note A.5.3::.

115/1
A'Length
               For a prefix A that is of an array type (after any
               implicit dereference), or denotes a constrained array
               subtype:

116
               A'Length denotes the number of values of the first index
               range (zero for a null range); its type is
               universal_integer.  See *note 3.6.2::.

117/1
A'Length(N)
               For a prefix A that is of an array type (after any
               implicit dereference), or denotes a constrained array
               subtype:

118
               A'Length(N) denotes the number of values of the N-th
               index range (zero for a null range); its type is
               universal_integer.  See *note 3.6.2::.

119
S'Machine
               For every subtype S of a floating point type T:

120
               S'Machine denotes a function with the following
               specification:

121
                    function S'Machine (X : T)
                      return T

122
               If X is a machine number of the type T, the function
               yields X; otherwise, it yields the value obtained by
               rounding or truncating X to either one of the adjacent
               machine numbers of the type T. Constraint_Error is raised
               if rounding or truncating X to the precision of the
               machine numbers results in a value outside the base range
               of S. A zero result has the sign of X when S'Signed_Zeros
               is True.  See *note A.5.3::.

123
S'Machine_Emax
               For every subtype S of a floating point type T:

124
               Yields the largest (most positive) value of exponent such
               that every value expressible in the canonical form (for
               the type T), having a mantissa of T'Machine_Mantissa
               digits, is a machine number (see *note 3.5.7::) of the
               type T. This attribute yields a value of the type
               universal_integer.  See *note A.5.3::.

125
S'Machine_Emin
               For every subtype S of a floating point type T:

126
               Yields the smallest (most negative) value of exponent
               such that every value expressible in the canonical form
               (for the type T), having a mantissa of T'Machine_Mantissa
               digits, is a machine number (see *note 3.5.7::) of the
               type T. This attribute yields a value of the type
               universal_integer.  See *note A.5.3::.

127
S'Machine_Mantissa
               For every subtype S of a floating point type T:

128
               Yields the largest value of p such that every value
               expressible in the canonical form (for the type T),
               having a p-digit mantissa and an exponent between
               T'Machine_Emin and T'Machine_Emax, is a machine number
               (see *note 3.5.7::) of the type T. This attribute yields
               a value of the type universal_integer.  See *note
               A.5.3::.

129
S'Machine_Overflows
               For every subtype S of a floating point type T:

130
               Yields the value True if overflow and divide-by-zero are
               detected and reported by raising Constraint_Error for
               every predefined operation that yields a result of the
               type T; yields the value False otherwise.  The value of
               this attribute is of the predefined type Boolean.  See
               *note A.5.3::.

131
S'Machine_Overflows
               For every subtype S of a fixed point type T:

132
               Yields the value True if overflow and divide-by-zero are
               detected and reported by raising Constraint_Error for
               every predefined operation that yields a result of the
               type T; yields the value False otherwise.  The value of
               this attribute is of the predefined type Boolean.  See
               *note A.5.4::.

133
S'Machine_Radix
               For every subtype S of a floating point type T:

134
               Yields the radix of the hardware representation of the
               type T. The value of this attribute is of the type
               universal_integer.  See *note A.5.3::.

135
S'Machine_Radix
               For every subtype S of a fixed point type T:

136
               Yields the radix of the hardware representation of the
               type T. The value of this attribute is of the type
               universal_integer.  See *note A.5.4::.

136.1/2
S'Machine_Rounding
               For every subtype S of a floating point type T:

136.2/2
               S'Machine_Rounding denotes a function with the following
               specification:

136.3/2
                    function S'Machine_Rounding (X : T)
                      return T

136.4/2
               The function yields the integral value nearest to X. If X
               lies exactly halfway between two integers, one of those
               integers is returned, but which of them is returned is
               unspecified.  A zero result has the sign of X when
               S'Signed_Zeros is True.  This function provides access to
               the rounding behavior which is most efficient on the
               target processor.  See *note A.5.3::.

137
S'Machine_Rounds
               For every subtype S of a floating point type T:

138
               Yields the value True if rounding is performed on inexact
               results of every predefined operation that yields a
               result of the type T; yields the value False otherwise.
               The value of this attribute is of the predefined type
               Boolean.  See *note A.5.3::.

139
S'Machine_Rounds
               For every subtype S of a fixed point type T:

140
               Yields the value True if rounding is performed on inexact
               results of every predefined operation that yields a
               result of the type T; yields the value False otherwise.
               The value of this attribute is of the predefined type
               Boolean.  See *note A.5.4::.

141
S'Max
               For every scalar subtype S:

142
               S'Max denotes a function with the following
               specification:

143
                    function S'Max(Left, Right : S'Base)
                      return S'Base

144
               The function returns the greater of the values of the two
               parameters.  See *note 3.5::.

144.1/3
S'Max_Alignment_For_Allocation
               For every subtype S:

144.2/3
               Denotes the maximum value for Alignment that could be
               requested by the implementation via Allocate for an
               access type whose designated subtype is S. The value of
               this attribute is of type universal_integer.  See *note
               13.11.1::.

145
S'Max_Size_In_Storage_Elements
               For every subtype S:

146/3
               Denotes the maximum value for Size_In_Storage_Elements
               that could be requested by the implementation via
               Allocate for an access type whose designated subtype is
               S. The value of this attribute is of type
               universal_integer.  See *note 13.11.1::.

147
S'Min
               For every scalar subtype S:

148
               S'Min denotes a function with the following
               specification:

149
                    function S'Min(Left, Right : S'Base)
                      return S'Base

150
               The function returns the lesser of the values of the two
               parameters.  See *note 3.5::.

150.1/2
S'Mod
               For every modular subtype S:

150.2/2
               S'Mod denotes a function with the following
               specification:

150.3/2
                    function S'Mod (Arg : universal_integer)
                      return S'Base

150.4/2
               This function returns Arg mod S'Modulus, as a value of
               the type of S. See *note 3.5.4::.

151
S'Model
               For every subtype S of a floating point type T:

152
               S'Model denotes a function with the following
               specification:

153
                    function S'Model (X : T)
                      return T

154
               If the Numerics Annex is not supported, the meaning of
               this attribute is implementation defined; see *note
               G.2.2:: for the definition that applies to
               implementations supporting the Numerics Annex.  See *note
               A.5.3::.

155
S'Model_Emin
               For every subtype S of a floating point type T:

156
               If the Numerics Annex is not supported, this attribute
               yields an implementation defined value that is greater
               than or equal to the value of T'Machine_Emin.  See *note
               G.2.2:: for further requirements that apply to
               implementations supporting the Numerics Annex.  The value
               of this attribute is of the type universal_integer.  See
               *note A.5.3::.

157
S'Model_Epsilon
               For every subtype S of a floating point type T:

158
               Yields the value T'Machine_Radix1 - T'Model_Mantissa.
               The value of this attribute is of the type
               universal_real.  See *note A.5.3::.

159
S'Model_Mantissa
               For every subtype S of a floating point type T:

160
               If the Numerics Annex is not supported, this attribute
               yields an implementation defined value that is greater
               than or equal to 'ceiling(d · log(10) /
               log(T'Machine_Radix))' + 1, where d is the requested
               decimal precision of T, and less than or equal to the
               value of T'Machine_Mantissa.  See *note G.2.2:: for
               further requirements that apply to implementations
               supporting the Numerics Annex.  The value of this
               attribute is of the type universal_integer.  See *note
               A.5.3::.

161
S'Model_Small
               For every subtype S of a floating point type T:

162
               Yields the value T'Machine_RadixT'Model_Emin - 1.  The
               value of this attribute is of the type universal_real.
               See *note A.5.3::.

163
S'Modulus
               For every modular subtype S:

164
               S'Modulus yields the modulus of the type of S, as a value
               of the type universal_integer.  See *note 3.5.4::.

164.1/3
X'Old
               For a prefix X that denotes an object of a nonlimited
               type:

164.2/4
               Each X'Old in a postcondition expression that is enabled
               denotes a constant that is implicitly declared at the
               beginning of the subprogram body, entry body, or accept
               statement.  See *note 6.1.1::.

165
S'Class'Output
               For every subtype S'Class of a class-wide type T'Class:

166
               S'Class'Output denotes a procedure with the following
               specification:

167/2
                    procedure S'Class'Output(
                       Stream : not null access Ada.Streams.Root_Stream_Type'Class;
                       Item   : in T'Class)

168/2
               First writes the external tag of Item to Stream (by
               calling String'Output(Stream,
               Tags.External_Tag(Item'Tag)) -- see *note 3.9::) and then
               dispatches to the subprogram denoted by the Output
               attribute of the specific type identified by the tag.
               Tag_Error is raised if the tag of Item identifies a type
               declared at an accessibility level deeper than that of S.
               See *note 13.13.2::.

169
S'Output
               For every subtype S of a specific type T:

170
               S'Output denotes a procedure with the following
               specification:

171/2
                    procedure S'Output(
                       Stream : not null access Ada.Streams.Root_Stream_Type'Class;
                       Item : in T)

172
               S'Output writes the value of Item to Stream, including
               any bounds or discriminants.  See *note 13.13.2::.

172.1/3
X'Overlaps_Storage
               For a prefix X that denotes an object:

172.2/3
               X'Overlaps_Storage denotes a function with the following
               specification:

172.3/3
                    function X'Overlaps_Storage (Arg : any_type)
                      return Boolean

172.4/3
               The actual parameter shall be a name that denotes an
               object.  The object denoted by the actual parameter can
               be of any type.  This function evaluates the names of the
               objects involved and returns True if the representation
               of the object denoted by the actual parameter shares at
               least one bit with the representation of the object
               denoted by X; otherwise, it returns False.  See *note
               13.3::.

173/1
D'Partition_Id
               For a prefix D that denotes a library-level declaration,
               excepting a declaration of or within a declared-pure
               library unit:

174
               Denotes a value of the type universal_integer that
               identifies the partition in which D was elaborated.  If D
               denotes the declaration of a remote call interface
               library unit (see *note E.2.3::) the given partition is
               the one where the body of D was elaborated.  See *note
               E.1::.

175
S'Pos
               For every discrete subtype S:

176
               S'Pos denotes a function with the following
               specification:

177
                    function S'Pos(Arg : S'Base)
                      return universal_integer

178
               This function returns the position number of the value of
               Arg, as a value of type universal_integer.  See *note
               3.5.5::.

179
R.C'Position
               For a component C of a composite, non-array object R:

180/2
               If the nondefault bit ordering applies to the composite
               type, and if a component_clause specifies the placement
               of C, denotes the value given for the position of the
               component_clause; otherwise, denotes the same value as
               R.C'Address - R'Address.  The value of this attribute is
               of the type universal_integer.  See *note 13.5.2::.

181
S'Pred
               For every scalar subtype S:

182
               S'Pred denotes a function with the following
               specification:

183
                    function S'Pred(Arg : S'Base)
                      return S'Base

184
               For an enumeration type, the function returns the value
               whose position number is one less than that of the value
               of Arg; Constraint_Error is raised if there is no such
               value of the type.  For an integer type, the function
               returns the result of subtracting one from the value of
               Arg.  For a fixed point type, the function returns the
               result of subtracting small from the value of Arg.  For a
               floating point type, the function returns the machine
               number (as defined in *note 3.5.7::) immediately below
               the value of Arg; Constraint_Error is raised if there is
               no such machine number.  See *note 3.5::.

184.1/2
P'Priority
               For a prefix P that denotes a protected object:

184.2/2
               Denotes a non-aliased component of the protected object
               P. This component is of type System.Any_Priority and its
               value is the priority of P. P'Priority denotes a variable
               if and only if P denotes a variable.  A reference to this
               attribute shall appear only within the body of P. See
               *note D.5.2::.

185/1
A'Range
               For a prefix A that is of an array type (after any
               implicit dereference), or denotes a constrained array
               subtype:

186
               A'Range is equivalent to the range A'First ..  A'Last,
               except that the prefix A is only evaluated once.  See
               *note 3.6.2::.

187
S'Range
               For every scalar subtype S:

188
               S'Range is equivalent to the range S'First ..  S'Last.
               See *note 3.5::.

189/1
A'Range(N)
               For a prefix A that is of an array type (after any
               implicit dereference), or denotes a constrained array
               subtype:

190
               A'Range(N) is equivalent to the range A'First(N) ..
               A'Last(N), except that the prefix A is only evaluated
               once.  See *note 3.6.2::.

191
S'Class'Read
               For every subtype S'Class of a class-wide type T'Class:

192
               S'Class'Read denotes a procedure with the following
               specification:

193/2
                    procedure S'Class'Read(
                       Stream : not null access Ada.Streams.Root_Stream_Type'Class;
                       Item : out T'Class)

194
               Dispatches to the subprogram denoted by the Read
               attribute of the specific type identified by the tag of
               Item.  See *note 13.13.2::.

195
S'Read
               For every subtype S of a specific type T:

196
               S'Read denotes a procedure with the following
               specification:

197/2
                    procedure S'Read(
                       Stream : not null access Ada.Streams.Root_Stream_Type'Class;
                       Item : out T)

198
               S'Read reads the value of Item from Stream.  See *note
               13.13.2::.

199
S'Remainder
               For every subtype S of a floating point type T:

200
               S'Remainder denotes a function with the following
               specification:

201
                    function S'Remainder (X, Y : T)
                      return T

202
               For nonzero Y, let v be the value X - n · Y, where n is
               the integer nearest to the exact value of X/Y; if |n -
               X/Y| = 1/2, then n is chosen to be even.  If v is a
               machine number of the type T, the function yields v;
               otherwise, it yields zero. Constraint_Error is raised if
               Y is zero.  A zero result has the sign of X when
               S'Signed_Zeros is True.  See *note A.5.3::.

202.1/3
F'Result
               For a prefix F that denotes a function declaration:

202.2/3
               Within a postcondition expression for function F, denotes
               the result object of the function.  The type of this
               attribute is that of the function result except within a
               Post'Class postcondition expression for a function with a
               controlling result or with a controlling access result.
               For a controlling result, the type of the attribute is
               T'Class, where T is the function result type.  For a
               controlling access result, the type of the attribute is
               an anonymous access type whose designated type is
               T'Class, where T is the designated type of the function
               result type.  See *note 6.1.1::.

203
S'Round
               For every decimal fixed point subtype S:

204
               S'Round denotes a function with the following
               specification:

205
                    function S'Round(X : universal_real)
                      return S'Base

206
               The function returns the value obtained by rounding X
               (away from 0, if X is midway between two values of the
               type of S). See *note 3.5.10::.

207
S'Rounding
               For every subtype S of a floating point type T:

208
               S'Rounding denotes a function with the following
               specification:

209
                    function S'Rounding (X : T)
                      return T

210
               The function yields the integral value nearest to X,
               rounding away from zero if X lies exactly halfway between
               two integers.  A zero result has the sign of X when
               S'Signed_Zeros is True.  See *note A.5.3::.

211
S'Safe_First
               For every subtype S of a floating point type T:

212
               Yields the lower bound of the safe range (see *note
               3.5.7::) of the type T. If the Numerics Annex is not
               supported, the value of this attribute is implementation
               defined; see *note G.2.2:: for the definition that
               applies to implementations supporting the Numerics Annex.
               The value of this attribute is of the type
               universal_real.  See *note A.5.3::.

213
S'Safe_Last
               For every subtype S of a floating point type T:

214
               Yields the upper bound of the safe range (see *note
               3.5.7::) of the type T. If the Numerics Annex is not
               supported, the value of this attribute is implementation
               defined; see *note G.2.2:: for the definition that
               applies to implementations supporting the Numerics Annex.
               The value of this attribute is of the type
               universal_real.  See *note A.5.3::.

215
S'Scale
               For every decimal fixed point subtype S:

216
               S'Scale denotes the scale of the subtype S, defined as
               the value N such that S'Delta = 10.0**(-N). The scale
               indicates the position of the point relative to the
               rightmost significant digits of values of subtype S. The
               value of this attribute is of the type universal_integer.
               See *note 3.5.10::.

217
S'Scaling
               For every subtype S of a floating point type T:

218
               S'Scaling denotes a function with the following
               specification:

219
                    function S'Scaling (X : T;
                                        Adjustment : universal_integer)
                      return T

220
               Let v be the value X · T'Machine_RadixAdjustment.  If v
               is a machine number of the type T, or if |v| >=
               T'Model_Small, the function yields v; otherwise, it
               yields either one of the machine numbers of the type T
               adjacent to v. Constraint_Error is optionally raised if v
               is outside the base range of S. A zero result has the
               sign of X when S'Signed_Zeros is True.  See *note
               A.5.3::.

221
S'Signed_Zeros
               For every subtype S of a floating point type T:

222
               Yields the value True if the hardware representation for
               the type T has the capability of representing both
               positively and negatively signed zeros, these being
               generated and used by the predefined operations of the
               type T as specified in IEC 559:1989; yields the value
               False otherwise.  The value of this attribute is of the
               predefined type Boolean.  See *note A.5.3::.

223
S'Size
               For every subtype S:

224
               If S is definite, denotes the size (in bits) that the
               implementation would choose for the following objects of
               subtype S:

225
                  * A record component of subtype S when the record type
                    is packed.

226
                  * The formal parameter of an instance of
                    Unchecked_Conversion that converts from subtype S to
                    some other subtype.

227
               If S is indefinite, the meaning is implementation
               defined.  The value of this attribute is of the type
               universal_integer.  See *note 13.3::.

228/1
X'Size
               For a prefix X that denotes an object:

229
               Denotes the size in bits of the representation of the
               object.  The value of this attribute is of the type
               universal_integer.  See *note 13.3::.

230
S'Small
               For every fixed point subtype S:

231
               S'Small denotes the small of the type of S. The value of
               this attribute is of the type universal_real.  See *note
               3.5.10::.

232
S'Storage_Pool
               For every access-to-object subtype S:

233
               Denotes the storage pool of the type of S. The type of
               this attribute is Root_Storage_Pool'Class.  See *note
               13.11::.

234
S'Storage_Size
               For every access-to-object subtype S:

235
               Yields the result of calling
               Storage_Size(S'Storage_Pool), which is intended to be a
               measure of the number of storage elements reserved for
               the pool.  The type of this attribute is
               universal_integer.  See *note 13.11::.

236/1
T'Storage_Size
               For a prefix T that denotes a task object (after any
               implicit dereference):

237
               Denotes the number of storage elements reserved for the
               task.  The value of this attribute is of the type
               universal_integer.  The Storage_Size includes the size of
               the task's stack, if any.  The language does not specify
               whether or not it includes other storage associated with
               the task (such as the "task control block" used by some
               implementations.)  See *note 13.3::.

237.1/2
S'Stream_Size
               For every subtype S of an elementary type T:

237.2/3
               Denotes the number of bits read from or written to a
               stream by the default implementations of S'Read and
               S'Write.  Hence, the number of stream elements required
               per item of elementary type T is:

237.3/2
                    T'Stream_Size / Ada.Streams.Stream_Element'Size

237.4/2
               The value of this attribute is of type universal_integer
               and is a multiple of Stream_Element'Size.  See *note
               13.13.2::.

238
S'Succ
               For every scalar subtype S:

239
               S'Succ denotes a function with the following
               specification:

240
                    function S'Succ(Arg : S'Base)
                      return S'Base

241
               For an enumeration type, the function returns the value
               whose position number is one more than that of the value
               of Arg; Constraint_Error is raised if there is no such
               value of the type.  For an integer type, the function
               returns the result of adding one to the value of Arg.
               For a fixed point type, the function returns the result
               of adding small to the value of Arg.  For a floating
               point type, the function returns the machine number (as
               defined in *note 3.5.7::) immediately above the value of
               Arg; Constraint_Error is raised if there is no such
               machine number.  See *note 3.5::.

242
S'Tag
               For every subtype S of a tagged type T (specific or
               class-wide):

243
               S'Tag denotes the tag of the type T (or if T is
               class-wide, the tag of the root type of the corresponding
               class).  The value of this attribute is of type Tag.  See
               *note 3.9::.

244
X'Tag
               For a prefix X that is of a class-wide tagged type (after
               any implicit dereference):

245
               X'Tag denotes the tag of X. The value of this attribute
               is of type Tag.  See *note 3.9::.

246
T'Terminated
               For a prefix T that is of a task type (after any implicit
               dereference):

247
               Yields the value True if the task denoted by T is
               terminated, and False otherwise.  The value of this
               attribute is of the predefined type Boolean.  See *note
               9.9::.

248
S'Truncation
               For every subtype S of a floating point type T:

249
               S'Truncation denotes a function with the following
               specification:

250
                    function S'Truncation (X : T)
                      return T

251
               The function yields the value 'ceiling(X)' when X is
               negative, and 'floor(X)' otherwise.  A zero result has
               the sign of X when S'Signed_Zeros is True.  See *note
               A.5.3::.

252
S'Unbiased_Rounding
               For every subtype S of a floating point type T:

253
               S'Unbiased_Rounding denotes a function with the following
               specification:

254
                    function S'Unbiased_Rounding (X : T)
                      return T

255
               The function yields the integral value nearest to X,
               rounding toward the even integer if X lies exactly
               halfway between two integers.  A zero result has the sign
               of X when S'Signed_Zeros is True.  See *note A.5.3::.

256
X'Unchecked_Access
               For a prefix X that denotes an aliased view of an object:

257
               All rules and semantics that apply to X'Access (see *note
               3.10.2::) apply also to X'Unchecked_Access, except that,
               for the purposes of accessibility rules and checks, it is
               as if X were declared immediately within a library
               package.  See *note 13.10::.

258
S'Val
               For every discrete subtype S:

259
               S'Val denotes a function with the following
               specification:

260
                    function S'Val(Arg : universal_integer)
                      return S'Base

261
               This function returns a value of the type of S whose
               position number equals the value of Arg.  See *note
               3.5.5::.

262
X'Valid
               For a prefix X that denotes a scalar object (after any
               implicit dereference):

263/4
               Yields True if and only if the object denoted by X is
               normal, has a valid representation, and then, if the
               preceding conditions hold, the value of X also satisfies
               the predicates of the nominal subtype of X. The value of
               this attribute is of the predefined type Boolean.  See
               *note 13.9.2::.

264
S'Value
               For every scalar subtype S:

265
               S'Value denotes a function with the following
               specification:

266
                    function S'Value(Arg : String)
                      return S'Base

267
               This function returns a value given an image of the value
               as a String, ignoring any leading or trailing spaces.
               See *note 3.5::.

268/1
P'Version
               For a prefix P that statically denotes a program unit:

269
               Yields a value of the predefined type String that
               identifies the version of the compilation unit that
               contains the declaration of the program unit.  See *note
               E.3::.

270
S'Wide_Image
               For every scalar subtype S:

271
               S'Wide_Image denotes a function with the following
               specification:

272
                    function S'Wide_Image(Arg : S'Base)
                      return Wide_String

273/3
               The function returns an image of the value of Arg as a
               Wide_String.  See *note 3.5::.

273.1/4
X'Wide_Image
               For a prefix X that denotes an object of a scalar type
               (after any implicit dereference):

273.2/4
               X'Wide_Image denotes the result of calling function
               S'Wide_Image with Arg being X, where S is the nominal
               subtype of X. See *note 3.5::.

274
S'Wide_Value
               For every scalar subtype S:

275
               S'Wide_Value denotes a function with the following
               specification:

276
                    function S'Wide_Value(Arg : Wide_String)
                      return S'Base

277
               This function returns a value given an image of the value
               as a Wide_String, ignoring any leading or trailing
               spaces.  See *note 3.5::.

277.1/2
S'Wide_Wide_Image
               For every scalar subtype S:

277.2/2
               S'Wide_Wide_Image denotes a function with the following
               specification:

277.3/2
                    function S'Wide_Wide_Image(Arg : S'Base)
                      return Wide_Wide_String

277.4/2
               The function returns an image of the value of Arg, that
               is, a sequence of characters representing the value in
               display form.  See *note 3.5::.

277.5/4
X'Wide_Wide_Image
               For a prefix X that denotes an object of a scalar type
               (after any implicit dereference):

277.6/4
               X'Wide_Wide_Image denotes the result of calling function
               S'Wide_Wide_Image with Arg being X, where S is the
               nominal subtype of X. See *note 3.5::.

277.7/2
S'Wide_Wide_Value
               For every scalar subtype S:

277.8/2
               S'Wide_Wide_Value denotes a function with the following
               specification:

277.9/2
                    function S'Wide_Wide_Value(Arg : Wide_Wide_String)
                      return S'Base

277.10/2
               This function returns a value given an image of the value
               as a Wide_Wide_String, ignoring any leading or trailing
               spaces.  See *note 3.5::.

277.11/2
S'Wide_Wide_Width
               For every scalar subtype S:

277.12/2
               S'Wide_Wide_Width denotes the maximum length of a
               Wide_Wide_String returned by S'Wide_Wide_Image over all
               values of the subtype S. It denotes zero for a subtype
               that has a null range.  Its type is universal_integer.
               See *note 3.5::.

278
S'Wide_Width
               For every scalar subtype S:

279
               S'Wide_Width denotes the maximum length of a Wide_String
               returned by S'Wide_Image over all values of the subtype
               S. It denotes zero for a subtype that has a null range.
               Its type is universal_integer.  See *note 3.5::.

280
S'Width
               For every scalar subtype S:

281
               S'Width denotes the maximum length of a String returned
               by S'Image over all values of the subtype S. It denotes
               zero for a subtype that has a null range.  Its type is
               universal_integer.  See *note 3.5::.

282
S'Class'Write
               For every subtype S'Class of a class-wide type T'Class:

283
               S'Class'Write denotes a procedure with the following
               specification:

284/2
                    procedure S'Class'Write(
                       Stream : not null access Ada.Streams.Root_Stream_Type'Class;
                       Item   : in T'Class)

285
               Dispatches to the subprogram denoted by the Write
               attribute of the specific type identified by the tag of
               Item.  See *note 13.13.2::.

286
S'Write
               For every subtype S of a specific type T:

287
               S'Write denotes a procedure with the following
               specification:

288/2
                    procedure S'Write(
                       Stream : not null access Ada.Streams.Root_Stream_Type'Class;
                       Item : in T)

289
               S'Write writes the value of Item to Stream.  See *note
               13.13.2::.


File: arm2012.info,  Node: Annex L,  Next: Annex M,  Prev: Annex K,  Up: Top

Annex L Language-Defined Pragmas
********************************

1
This Annex summarizes the definitions given elsewhere of the
language-defined pragmas.

2
pragma All_Calls_Remote[(library_unit_name)]; -- See *note E.2.3::.

2.1/2
pragma Assert([Check =>] boolean_expression[, [Message =>] string_
expression]); -- See *note 11.4.2::.

2.2/2
pragma Assertion_Policy(policy_identifier); -- See *note 11.4.2::.

2.3/3
pragma Assertion_Policy(
         assertion_aspect_mark => policy_identifier
     {, assertion_aspect_mark => policy_identifier}); -- See *note
11.4.2::.

3/3
This paragraph was deleted. 

3.1/3
pragma Asynchronous (local_name); -- See *note J.15.13::.

4/3
This paragraph was deleted. 

4.1/3
pragma Atomic (local_name); -- See *note J.15.8::.

5/3
This paragraph was deleted. 

5.1/3
pragma Atomic_Components (array_local_name); -- See *note J.15.8::.

6/3
This paragraph was deleted. 

6.1/3
pragma Attach_Handler (handler_name, expression); -- See *note J.15.7::.

7/3
This paragraph was deleted. 

8/3
This paragraph was deleted. 

8.1/3
pragma Convention([Convention =>] convention_identifier,[Entity =>]
local_name); -- See *note J.15.5::.

8.2/3
pragma CPU (expression); -- See *note J.15.9::.

8.3/3
pragma Default_Storage_Pool (storage_pool_indicator); -- See *note
13.11.3::.

8.4/2
pragma Detect_Blocking; -- See *note H.5::.

9
pragma Discard_Names[([On => ] local_name)]; -- See *note C.5::.

9.1/3
pragma Dispatching_Domain (expression); -- See *note J.15.10::.

10
pragma Elaborate(library_unit_name{, library_unit_name}); -- See *note
10.2.1::.

11
pragma Elaborate_All(library_unit_name{, library_unit_name}); -- See
*note 10.2.1::.

12
pragma Elaborate_Body[(library_unit_name)]; -- See *note 10.2.1::.

13/3
This paragraph was deleted. 

13.1/3
pragma Export(
     [Convention =>] convention_identifier, [Entity =>] local_name
  [, [External_Name =>] external_name_string_expression]
  [, [Link_Name =>] link_name_string_expression]); -- See *note
J.15.5::.

14/3
This paragraph was deleted. 

14.1/3
pragma Import(
     [Convention =>] convention_identifier, [Entity =>] local_name
  [, [External_Name =>] external_name_string_expression]
  [, [Link_Name =>] link_name_string_expression]); -- See *note
J.15.5::.

14.2/3
pragma Independent (component_local_name); -- See *note J.15.8::.

14.3/3
pragma Independent_Components (local_name); -- See *note J.15.8::.

15/3
This paragraph was deleted. 

15.1/3
pragma Inline (name{, name}); -- See *note J.15.1::.

16
pragma Inspection_Point[(object_name {, object_name})]; -- See *note
H.3.2::.

17/3
This paragraph was deleted. 

17.1/3
pragma Interrupt_Handler (handler_name); -- See *note J.15.7::.

18/3
This paragraph was deleted. 

18.1/3
pragma Interrupt_Priority [(expression);] -- See *note J.15.11::.

19
pragma Linker_Options(string_expression); -- See *note B.1::.

20
pragma List(identifier); -- See *note 2.8::.

21
pragma Locking_Policy(policy_identifier); -- See *note D.3::.

21.1/3
This paragraph was deleted. 

21.2/3
pragma No_Return (procedure_local_name{, procedure_local_name}); -- See
*note J.15.2::.

22
pragma Normalize_Scalars; -- See *note H.1::.

23
pragma Optimize(identifier); -- See *note 2.8::.

24/3
This paragraph was deleted. 

24.1/3
pragma Pack (first_subtype_local_name); -- See *note J.15.3::.

25
pragma Page; -- See *note 2.8::.

25.1/2
pragma Partition_Elaboration_Policy (policy_identifier); -- See *note
H.6::.

25.2/2
pragma Preelaborable_Initialization(direct_name); -- See *note 10.2.1::.

26
pragma Preelaborate[(library_unit_name)]; -- See *note 10.2.1::.

27/3
This paragraph was deleted. 

27.1/3
pragma Priority (expression); -- See *note J.15.11::.

27.2/2
pragma Priority_Specific_Dispatching (
     policy_identifier, first_priority_expression, last_priority_
expression); -- See *note D.2.2::.

27.3/3
pragma Profile (profile_identifier {, profile_
pragma_argument_association}); -- See *note 13.12::.

27.4/3
This paragraph was deleted. 

28
pragma Pure[(library_unit_name)]; -- See *note 10.2.1::.

29
pragma Queuing_Policy(policy_identifier); -- See *note D.4::.

29.1/3
This paragraph was deleted. 

29.2/3
pragma Relative_Deadline (relative_deadline_expression); -- See *note
J.15.12::.

30
pragma Remote_Call_Interface[(library_unit_name)]; -- See *note E.2.3::.

31
pragma Remote_Types[(library_unit_name)]; -- See *note E.2.2::.

32
pragma Restrictions(restriction{, restriction}); -- See *note 13.12::.

33
pragma Reviewable; -- See *note H.3.1::.

34
pragma Shared_Passive[(library_unit_name)]; -- See *note E.2.1::.

35/3
This paragraph was deleted. 

35.1/3
pragma Storage_Size (expression); -- See *note J.15.4::.

36
pragma Suppress(identifier); -- See *note 11.5::.

37
pragma Task_Dispatching_Policy(policy_identifier); -- See *note D.2.2::.

37.1/3
This paragraph was deleted. 

37.2/3
pragma Unchecked_Union (first_subtype_local_name); -- See *note
J.15.6::.

37.3/2
pragma Unsuppress(identifier); -- See *note 11.5::.

38/3
This paragraph was deleted. 

38.1/3
pragma Volatile (local_name); -- See *note J.15.8::.

39/3
This paragraph was deleted. 

39.1/3
pragma Volatile_Components (array_local_name); -- See *note J.15.8::.


File: arm2012.info,  Node: Annex M,  Next: Annex N,  Prev: Annex L,  Up: Top

Annex M Summary of Documentation Requirements
*********************************************

1/3
The Ada language allows for certain target machine dependences in a
controlled manner.  Each Ada implementation must document many
characteristics and properties of the target system.  This International
Standard contains specific documentation requirements.  In addition,
many characteristics that require documentation are identified
throughout this International Standard as being implementation defined.
Finally, this International Standard requires documentation of whether
implementation advice is followed.  The following subclauses provide
summaries of these documentation requirements.

* Menu:

* M.1 ::      Specific Documentation Requirements
* M.2 ::      Implementation-Defined Characteristics
* M.3 ::      Implementation Advice


File: arm2012.info,  Node: M.1,  Next: M.2,  Up: Annex M

M.1 Specific Documentation Requirements
=======================================

1/2
In addition to implementation-defined characteristics, each Ada
implementation must document various properties of the implementation:

2/2
   * The behavior of implementations in implementation-defined
     situations shall be documented -- see *note M.2::, "*note M.2::
     Implementation-Defined Characteristics" for a listing.  See *note
     1.1.3::(19).

3/2
   * The set of values that a user-defined Allocate procedure needs to
     accept for the Alignment parameter.  How the standard storage pool
     is chosen, and how storage is allocated by standard storage pools.
     See *note 13.11::(22).

4/2
   * The algorithm used for random number generation, including a
     description of its period.  See *note A.5.2::(44).

5/2
   * The minimum time interval between calls to the time-dependent Reset
     procedure that is guaranteed to initiate different random number
     sequences.  See *note A.5.2::(45).

6/2
   * The conditions under which Io_Exceptions.Name_Error,
     Io_Exceptions.Use_Error, and Io_Exceptions.Device_Error are
     propagated.  See *note A.13::(15).

7/2
   * The behavior of package Environment_Variables when environment
     variables are changed by external mechanisms.  See *note
     A.17::(30/2).

8/2
   * The overhead of calling machine-code or intrinsic subprograms.  See
     *note C.1::(6).

9/2
   * The types and attributes used in machine code insertions.  See
     *note C.1::(7).

10/2
   * The subprogram calling conventions for all supported convention
     identifiers.  See *note C.1::(8/3).

11/2
   * The mapping between the Link_Name or Ada designator and the
     external link name.  See *note C.1::(9).

12/2
   * The treatment of interrupts.  See *note C.3::(22).

13/2
   * The metrics for interrupt handlers.  See *note C.3.1::(16).

14/3
   * If the Ceiling_Locking policy is in effect, the default ceiling
     priority for a protected object that specifies an interrupt handler
     aspect.  See *note C.3.2::(24/3).

15/2
   * Any circumstances when the elaboration of a preelaborated package
     causes code to be executed.  See *note C.4::(12).

16/2
   * Whether a partition can be restarted without reloading.  See *note
     C.4::(13).

17/2
   * The effect of calling Current_Task from an entry body or interrupt
     handler.  See *note C.7.1::(19).

18/2
   * For package Task_Attributes, limits on the number and size of task
     attributes, and how to configure any limits.  See *note
     C.7.2::(19).

19/2
   * The metrics for the Task_Attributes package.  See *note
     C.7.2::(27).

20/2
   * The details of the configuration used to generate the values of all
     metrics.  See *note D::(2).

21/2
   * The maximum priority inversion a user task can experience from the
     implementation.  See *note D.2.3::(12/2).

22/2
   * The amount of time that a task can be preempted for processing on
     behalf of lower-priority tasks.  See *note D.2.3::(13/2).

23/2
   * The quantum values supported for round robin dispatching.  See
     *note D.2.5::(16/2).

24/2
   * The accuracy of the detection of the exhaustion of the budget of a
     task for round robin dispatching.  See *note D.2.5::(17/2).

25/2
   * Any conditions that cause the completion of the setting of the
     deadline of a task to be delayed for a multiprocessor.  See *note
     D.2.6::(32/2).

26/2
   * Any conditions that cause the completion of the setting of the
     priority of a task to be delayed for a multiprocessor.  See *note
     D.5.1::(12.1/2).

27/2
   * The metrics for Set_Priority.  See *note D.5.1::(14).

28/2
   * The metrics for setting the priority of a protected object.  See
     *note D.5.2::(10).

29/2
   * On a multiprocessor, any conditions that cause the completion of an
     aborted construct to be delayed later than what is specified for a
     single processor.  See *note D.6::(3).

30/2
   * The metrics for aborts.  See *note D.6::(8).

31/2
   * The values of Time_First, Time_Last, Time_Span_First,
     Time_Span_Last, Time_Span_Unit, and Tick for package Real_Time.
     See *note D.8::(33).

32/2
   * The properties of the underlying time base used in package
     Real_Time.  See *note D.8::(34).

33/2
   * Any synchronization of package Real_Time with external time
     references.  See *note D.8::(35).

34/2
   * Any aspects of the external environment that could interfere with
     package Real_Time.  See *note D.8::(36/3).

35/2
   * The metrics for package Real_Time.  See *note D.8::(45).

36/2
   * The minimum value of the delay expression of a
     delay_relative_statement that causes a task to actually be blocked.
     See *note D.9::(7).

37/2
   * The minimum difference between the value of the delay expression of
     a delay_until_statement and the value of Real_Time.Clock, that
     causes the task to actually be blocked.  See *note D.9::(8).

38/2
   * The metrics for delay statements.  See *note D.9::(13).

39/2
   * The upper bound on the duration of interrupt blocking caused by the
     implementation.  See *note D.12::(5).

40/2
   * The metrics for entry-less protected objects.  See *note
     D.12::(12).

41/2
   * The values of CPU_Time_First, CPU_Time_Last, CPU_Time_Unit, and
     CPU_Tick of package Execution_Time.  See *note D.14::(21/2).

42/3
   * The properties of the mechanism used to implement package
     Execution_Time, including the values of the constants defined in
     the package.  See *note D.14::(22/2).

43/2
   * The metrics for execution time.  See *note D.14::(27).

44/2
   * The metrics for timing events.  See *note D.15::(24).

44.1/3
   * The processor(s) on which the clock interrupt is handled; the
     processors on which each Interrupt_Id can be handled.  See *note
     D.16.1::(32).

45/2
   * Whether the RPC-receiver is invoked from concurrent tasks, and if
     so, the number of such tasks.  See *note E.5::(25).

46/2
   * Any techniques used to reduce cancellation errors in
     Numerics.Generic_Real_Arrays shall be documented.  See *note
     G.3.1::(86/2).

47/2
   * Any techniques used to reduce cancellation errors in
     Numerics.Generic_Complex_Arrays shall be documented.  See *note
     G.3.2::(155/2).

48/2
   * If a pragma Normalize_Scalars applies, the implicit initial values
     of scalar subtypes shall be documented.  Such a value should be an
     invalid representation when possible; any cases when is it not
     shall be documented.  See *note H.1::(5/2).

49/2
   * The range of effects for each bounded error and each unspecified
     effect.  If the effects of a given erroneous construct are
     constrained, the constraints shall be documented.  See *note
     H.2::(1).

50/2
   * For each inspection point, a mapping between each inspectable
     object and the machine resources where the object's value can be
     obtained shall be provided.  See *note H.3.2::(8).

51/2
   * If a pragma Restrictions(No_Exceptions) is specified, the effects
     of all constructs where language-defined checks are still
     performed.  See *note H.4::(25).

52/2
   * The interrupts to which a task entry may be attached.  See *note
     J.7.1::(12).

53/2
   * The type of entry call invoked for an interrupt entry.  See *note
     J.7.1::(13).


File: arm2012.info,  Node: M.2,  Next: M.3,  Prev: M.1,  Up: Annex M

M.2 Implementation-Defined Characteristics
==========================================

1/2
The Ada language allows for certain machine dependences in a controlled
manner. Each Ada implementation must document all implementation-defined
characteristics:

2/2
   * Whether or not each recommendation given in Implementation Advice
     is followed -- see *note M.3::, "*note M.3:: Implementation Advice"
     for a listing.  See *note 1.1.2::(37).

3
   * Capacity limitations of the implementation.  See *note 1.1.3::(3).

4
   * Variations from the standard that are impractical to avoid given
     the implementation's execution environment.  See *note 1.1.3::(6).

5
   * Which code_statements cause external interactions.  See *note
     1.1.3::(10).

6
   * The coded representation for the text of an Ada program.  See *note
     2.1::(4/3).

6.1/2
   * The semantics of an Ada program whose text is not in Normalization
     Form KC. See *note 2.1::(4.1/3).

7/2
   * This paragraph was deleted.

8
   * The representation for an end of line.  See *note 2.2::(2/3).

9
   * Maximum supported line length and lexical element length.  See
     *note 2.2::(14).

10
   * Implementation-defined pragmas.  See *note 2.8::(14).

11
   * Effect of pragma Optimize.  See *note 2.8::(27).

11.1/4
   * The message string associated with the Assertion_Error exception
     raised by the failure of a predicate check if there is no
     applicable Predicate_Failure aspect.  See *note 3.2.4::(31).

11.2/2
   * The sequence of characters of the value returned by S'Wide_Image
     when some of the graphic characters of S'Wide_Wide_Image are not
     defined in Wide_Character.  See *note 3.5::(30/3).

12/2
   * The sequence of characters of the value returned by S'Image when
     some of the graphic characters of S'Wide_Wide_Image are not defined
     in Character.  See *note 3.5::(37/3).

13
   * The predefined integer types declared in Standard.  See *note
     3.5.4::(25).

14
   * Any nonstandard integer types and the operators defined for them.
     See *note 3.5.4::(26).

15
   * Any nonstandard real types and the operators defined for them.  See
     *note 3.5.6::(8).

16
   * What combinations of requested decimal precision and range are
     supported for floating point types.  See *note 3.5.7::(7).

17
   * The predefined floating point types declared in Standard.  See
     *note 3.5.7::(16).

18
   * The small of an ordinary fixed point type.  See *note 3.5.9::(8/2).

19
   * What combinations of small, range, and digits are supported for
     fixed point types.  See *note 3.5.9::(10).

20/2
   * The result of Tags.Wide_Wide_Expanded_Name for types declared
     within an unnamed block_statement.  See *note 3.9::(10).

20.1/2
   * The sequence of characters of the value returned by
     Tags.Expanded_Name (respectively, Tags.Wide_Expanded_Name) when
     some of the graphic characters of Tags.Wide_Wide_Expanded_Name are
     not defined in Character (respectively, Wide_Character).  See *note
     3.9::(10.1/2).

21
   * Implementation-defined attributes.  See *note 4.1.4::(12/1).

21.1/2
   * Rounding of real static expressions which are exactly half-way
     between two machine numbers.  See *note 4.9::(38/2).

22
   * Any implementation-defined time types.  See *note 9.6::(6/3).

23
   * The time base associated with relative delays.  See *note
     9.6::(20).

24
   * The time base of the type Calendar.Time.  See *note 9.6::(23).

25/2
   * The time zone used for package Calendar operations.  See *note
     9.6::(24/2).

26
   * Any limit on delay_until_statements of select_statements.  See
     *note 9.6::(29).

26.1/2
   * The result of Calendar.Formating.Image if its argument represents
     more than 100 hours.  See *note 9.6.1::(86/2).

27/3
   * This paragraph was deleted.

28
   * The representation for a compilation.  See *note 10.1::(2).

29
   * Any restrictions on compilations that contain multiple
     compilation_units.  See *note 10.1::(4).

30
   * The mechanisms for creating an environment and for adding and
     replacing compilation units.  See *note 10.1.4::(3/2).

30.1/2
   * The mechanisms for adding a compilation unit mentioned in a
     limited_with_clause to an environment.  See *note 10.1.4::(3/2).

31
   * The manner of explicitly assigning library units to a partition.
     See *note 10.2::(2).

32
   * The implementation-defined means, if any, of specifying which
     compilation units are needed by a given compilation unit.  See
     *note 10.2::(2).

33
   * The manner of designating the main subprogram of a partition.  See
     *note 10.2::(7).

34
   * The order of elaboration of library_items.  See *note 10.2::(18).

35
   * Parameter passing and function return for the main subprogram.  See
     *note 10.2::(21).

36
   * The mechanisms for building and running partitions.  See *note
     10.2::(24).

37
   * The details of program execution, including program termination.
     See *note 10.2::(25).

38
   * The semantics of any nonactive partitions supported by the
     implementation.  See *note 10.2::(28/3).

39
   * The information returned by Exception_Message.  See *note
     11.4.1::(10.1/4).

40/2
   * The result of Exceptions.Wide_Wide_Exception_Name for exceptions
     declared within an unnamed block_statement.  See *note
     11.4.1::(12).

40.1/2
   * The sequence of characters of the value returned by
     Exceptions.Exception_Name (respectively,
     Exceptions.Wide_Exception_Name) when some of the graphic characters
     of Exceptions.Wide_Wide_Exception_Name are not defined in Character
     (respectively, Wide_Character).  See *note 11.4.1::(12.1/2).

41
   * The information returned by Exception_Information.  See *note
     11.4.1::(13/2).

41.1/3
   * Implementation-defined policy_identifiers and
     assertion_aspect_marks allowed in a pragma Assertion_Policy.  See
     *note 11.4.2::(9/3).

41.2/2
   * The default assertion policy.  See *note 11.4.2::(10).

42
   * Implementation-defined check names.  See *note 11.5::(27).

42.1/2
   * Existence and meaning of second parameter of pragma Unsuppress.
     See *note 11.5::(27.1/2).

42.2/2
   * The cases that cause conflicts between the representation of the
     ancestors of a type_declaration.  See *note 13.1::(13.1/3).

43/3
   * The interpretation of each representation aspect.  See *note
     13.1::(20).

44/3
   * Any restrictions placed upon the specification of representation
     aspects.  See *note 13.1::(20).

44.1/3
   * Implementation-defined aspects, inluding the syntax for specifying
     such aspects and the legality rules for such aspects.  See *note
     13.1.1::(38).

44.2/2
   * The set of machine scalars.  See *note 13.3::(8.1/3).

45
   * The meaning of Size for indefinite subtypes.  See *note 13.3::(48).

46
   * The default external representation for a type tag.  See *note
     13.3::(75/3).

47
   * What determines whether a compilation unit is the same in two
     different partitions.  See *note 13.3::(76).

48
   * Implementation-defined components.  See *note 13.5.1::(15).

49
   * If Word_Size = Storage_Unit, the default bit ordering.  See *note
     13.5.3::(5).

50/2
   * The contents of the visible part of package System.  See *note
     13.7::(2).

50.1/2
   * The range of Storage_Elements.Storage_Offset, the modulus of
     Storage_Elements.Storage_Element, and the declaration of
     Storage_Elements.Integer_Address..  See *note 13.7.1::(11).

51
   * The contents of the visible part of package System.Machine_Code,
     and the meaning of code_statements.  See *note 13.8::(7).

51.1/2
   * The result of unchecked conversion for instances with scalar result
     types whose result is not defined by the language.  See *note
     13.9::(11).

52/2
   * The effect of unchecked conversion for instances with nonscalar
     result types whose effect is not defined by the language.  See
     *note 13.9::(11).

53/2
   * This paragraph was deleted.

54
   * Whether or not the implementation provides user-accessible names
     for the standard pool type(s).  See *note 13.11::(17).

55/2
   * The meaning of Storage_Size when neither the Storage_Size nor the
     Storage_Pool is specified for an access type.  See *note
     13.11::(18).

56/2
   * This paragraph was deleted.

56.1/4
   * The effect of specifying aspect Default_Storage_Pool on an instance
     of a language-defined generic unit.  See *note 13.11.3::(5).

57/3
   * This paragraph was deleted.

57.1/3
   * Implementation-defined restrictions allowed in a pragma
     Restrictions.  See *note 13.12::(8.7/3).

58
   * The consequences of violating limitations on Restrictions pragmas.
     See *note 13.12::(9).

58.1/3
   * Implementation-defined usage profiles allowed in a pragma Profile.
     See *note 13.12::(15).

59/2
   * The contents of the stream elements read and written by the Read
     and Write attributes of elementary types.  See *note 13.13.2::(9).

60
   * The names and characteristics of the numeric subtypes declared in
     the visible part of package Standard.  See *note A.1::(3).

60.1/2
   * The values returned by Strings.Hash.  See *note A.4.9::(3/2).

61
   * The accuracy actually achieved by the elementary functions.  See
     *note A.5.1::(1).

62
   * The sign of a zero result from some of the operators or functions
     in Numerics.Generic_Elementary_Functions, when
     Float_Type'Signed_Zeros is True.  See *note A.5.1::(46).

63
   * The value of Numerics.Float_Random.Max_Image_Width.  See *note
     A.5.2::(27).

64
   * The value of Numerics.Discrete_Random.Max_Image_Width.  See *note
     A.5.2::(27).

65/2
   * This paragraph was deleted.

66
   * The string representation of a random number generator's state.
     See *note A.5.2::(38).

67/2
   * This paragraph was deleted.

68
   * The values of the Model_Mantissa, Model_Emin, Model_Epsilon, Model,
     Safe_First, and Safe_Last attributes, if the Numerics Annex is not
     supported.  See *note A.5.3::(72).

69/2
   * This paragraph was deleted.

70
   * The value of Buffer_Size in Storage_IO. See *note A.9::(10).

71/2
   * The external files associated with the standard input, standard
     output, and standard error files.  See *note A.10::(5).

72
   * The accuracy of the value produced by Put.  See *note A.10.9::(36).

72.1/1
   * Current size for a stream file for which positioning is not
     supported.  See *note A.12.1::(1.1/1).

73/2
   * The meaning of Argument_Count, Argument, and Command_Name for
     package Command_Line.  The bounds of type Command_Line.Exit_Status.
     See *note A.15::(1).

73.1/2
   * The interpretation of file names and directory names.  See *note
     A.16::(46/2).

73.2/2
   * The maximum value for a file size in Directories.  See *note
     A.16::(87/2).

73.3/2
   * The result for Directories.Size for a directory or special file See
     *note A.16::(93/2).

73.4/2
   * The result for Directories.Modification_Time for a directory or
     special file.  See *note A.16::(95/2).

73.5/2
   * The interpretation of a nonnull search pattern in Directories.  See
     *note A.16::(104/3).

73.6/2
   * The results of a Directories search if the contents of the
     directory are altered while a search is in progress.  See *note
     A.16::(110/3).

73.7/2
   * The definition and meaning of an environment variable.  See *note
     A.17::(1/2).

73.8/2
   * The circumstances where an environment variable cannot be defined.
     See *note A.17::(16/2).

73.9/2
   * Environment names for which Set has the effect of Clear.  See *note
     A.17::(17/2).

73.10/2
   * The value of Containers.Hash_Type'Modulus.  The value of
     Containers.Count_Type'Last.  See *note A.18.1::(7/2).

74
   * Implementation-defined convention names.  See *note B.1::(11/3).

75
   * The meaning of link names.  See *note B.1::(36).

76
   * The manner of choosing link names when neither the link name nor
     the address of an imported or exported entity is specified.  See
     *note B.1::(36).

77
   * The effect of pragma Linker_Options.  See *note B.1::(37).

78
   * The contents of the visible part of package Interfaces and its
     language-defined descendants.  See *note B.2::(1).

79/2
   * Implementation-defined children of package Interfaces.  See *note
     B.2::(11).

79.1/2
   * The definitions of certain types and constants in Interfaces.C. See
     *note B.3::(41).

80/1
   * The types Floating, Long_Floating, Binary, Long_Binary,
     Decimal_Element, and COBOL_Character; and the initializations of
     the variables Ada_To_COBOL and COBOL_To_Ada, in Interfaces.COBOL.
     See *note B.4::(50).

80.1/1
   * The types Fortran_Integer, Real, Double_Precision, and
     Character_Set in Interfaces.Fortran.  See *note B.5::(17).

81/2
   * Implementation-defined intrinsic subprograms.  See *note
     C.1::(1/3).

82/2
   * This paragraph was deleted.

83/2
   * This paragraph was deleted.

83.1/3
   * Any restrictions on a protected procedure or its containing type
     when an aspect Attach_handler or Interrupt_Handler is specified.
     See *note C.3.1::(17).

83.2/3
   * Any other forms of interrupt handler supported by the
     Attach_Handler and Interrupt_Handler aspects.  See *note
     C.3.1::(19).

84/2
   * This paragraph was deleted.

85/4
   * The semantics of some attributes and functions of an entity for
     which aspect Discard_Names is True.  See *note C.5::(7).

86
   * The result of the Task_Identification.Image attribute.  See *note
     C.7.1::(7).

87/2
   * The value of Current_Task when in a protected entry, interrupt
     handler, or finalization of a task attribute.  See *note
     C.7.1::(17/3).

88/2
   * This paragraph was deleted.

88.1/1
   * Granularity of locking for Task_Attributes.  See *note
     C.7.2::(16/1).

89/2
   * This paragraph was deleted.

90/2
   * This paragraph was deleted.

91
   * The declarations of Any_Priority and Priority.  See *note
     D.1::(11).

92
   * Implementation-defined execution resources.  See *note D.1::(15).

93
   * Whether, on a multiprocessor, a task that is waiting for access to
     a protected object keeps its processor busy.  See *note D.2.1::(3).

94/2
   * The effect of implementation-defined execution resources on task
     dispatching.  See *note D.2.1::(9/2).

95/2
   * This paragraph was deleted.

96/2
   * This paragraph was deleted.

97/2
   * Implementation defined task dispatching policies.  See *note
     D.2.2::(19).

97.1/2
   * The value of Default_Quantum in Dispatching.Round_Robin.  See *note
     D.2.5::(4).

98
   * Implementation-defined policy_identifiers allowed in a pragma
     Locking_Policy.  See *note D.3::(4).

98.1/2
   * The locking policy if no Locking_Policy pragma applies to any unit
     of a partition.  See *note D.3::(6).

99
   * Default ceiling priorities.  See *note D.3::(10/4).

100
   * The ceiling of any protected object used internally by the
     implementation.  See *note D.3::(16).

101
   * Implementation-defined queuing policies.  See *note D.4::(1/3).

102/2
   * This paragraph was deleted.

103
   * Any operations that implicitly require heap storage allocation.
     See *note D.7::(8).

103.1/4
   * When restriction No_Dynamic_CPU_Assignment applies to a partition,
     the processor on which a task with a CPU value of a
     Not_A_Specific_CPU will execute.  See *note D.7::(10).

103.2/2
   * When restriction No_Task_Termination applies to a partition, what
     happens when a task terminates.  See *note D.7::(15.1/2).

103.3/2
   * The behavior when restriction Max_Storage_At_Blocking is violated.
     See *note D.7::(17/1).

103.4/2
   * The behavior when restriction Max_Asynchronous_Select_Nesting is
     violated.  See *note D.7::(18/1).

103.5/2
   * The behavior when restriction Max_Tasks is violated.  See *note
     D.7::(19).

104/2
   * Whether the use of pragma Restrictions results in a reduction in
     program code or data size or execution time.  See *note D.7::(20).

105/2
   * This paragraph was deleted.

106/2
   * This paragraph was deleted.

106.1/3
   * The value of Barrier_Limit'Last in Synchronous_Barriers.  See *note
     D.10.1::(4/3).

106.2/3
   * When an aborted task that is waiting on a Synchronous_Barrier is
     aborted.  See *note D.10.1::(13/3).

107/2
   * This paragraph was deleted.

107.1/3
   * The value of Min_Handler_Ceiling in Execution_Time.Group_Budgets.
     See *note D.14.2::(7/2).

107.2/3
   * The value of CPU_Range'Last in System.Multiprocessors.  See *note
     D.16::(4/3).

107.3/3
   * The processor on which the environment task executes in the absence
     of a value for the aspect CPU. See *note D.16::(13/3).

108
   * The means for creating and executing distributed programs.  See
     *note E::(5).

109
   * Any events that can result in a partition becoming inaccessible.
     See *note E.1::(7).

110
   * The scheduling policies, treatment of priorities, and management of
     shared resources between partitions in certain cases.  See *note
     E.1::(11).

111/1
   * This paragraph was deleted.

112
   * Whether the execution of the remote subprogram is immediately
     aborted as a result of cancellation.  See *note E.4::(13).

112.1/2
   * The range of type System.RPC.Partition_Id.  See *note E.5::(14).

113/2
   * This paragraph was deleted.

114
   * Implementation-defined interfaces in the PCS. See *note E.5::(26).

115
   * The values of named numbers in the package Decimal.  See *note
     F.2::(7).

116
   * The value of Max_Picture_Length in the package Text_IO.Editing See
     *note F.3.3::(16).

117
   * The value of Max_Picture_Length in the package Wide_Text_IO.Editing
     See *note F.3.4::(5).

117.1/2
   * The value of Max_Picture_Length in the package
     Wide_Wide_Text_IO.Editing See *note F.3.5::(5).

118
   * The accuracy actually achieved by the complex elementary functions
     and by other complex arithmetic operations.  See *note G.1::(1).

119
   * The sign of a zero result (or a component thereof) from any
     operator or function in Numerics.Generic_Complex_Types, when
     Real'Signed_Zeros is True.  See *note G.1.1::(53).

120
   * The sign of a zero result (or a component thereof) from any
     operator or function in
     Numerics.Generic_Complex_Elementary_Functions, when
     Complex_Types.Real'Signed_Zeros is True.  See *note G.1.2::(45).

121
   * Whether the strict mode or the relaxed mode is the default.  See
     *note G.2::(2).

122
   * The result interval in certain cases of fixed-to-float conversion.
     See *note G.2.1::(10).

123
   * The result of a floating point arithmetic operation in overflow
     situations, when the Machine_Overflows attribute of the result type
     is False.  See *note G.2.1::(13).

124
   * The result interval for division (or exponentiation by a negative
     exponent), when the floating point hardware implements division as
     multiplication by a reciprocal.  See *note G.2.1::(16).

125
   * The definition of close result set, which determines the accuracy
     of certain fixed point multiplications and divisions.  See *note
     G.2.3::(5).

126
   * Conditions on a universal_real operand of a fixed point
     multiplication or division for which the result shall be in the
     perfect result set.  See *note G.2.3::(22).

127
   * The result of a fixed point arithmetic operation in overflow
     situations, when the Machine_Overflows attribute of the result type
     is False.  See *note G.2.3::(27).

128
   * The result of an elementary function reference in overflow
     situations, when the Machine_Overflows attribute of the result type
     is False.  See *note G.2.4::(4).

129
   * The value of the angle threshold, within which certain elementary
     functions, complex arithmetic operations, and complex elementary
     functions yield results conforming to a maximum relative error
     bound.  See *note G.2.4::(10).

130
   * The accuracy of certain elementary functions for parameters beyond
     the angle threshold.  See *note G.2.4::(10).

131
   * The result of a complex arithmetic operation or complex elementary
     function reference in overflow situations, when the
     Machine_Overflows attribute of the corresponding real type is
     False.  See *note G.2.6::(5).

132
   * The accuracy of certain complex arithmetic operations and certain
     complex elementary functions for parameters (or components thereof)
     beyond the angle threshold.  See *note G.2.6::(8).

132.1/2
   * The accuracy requirements for the subprograms Solve, Inverse,
     Determinant, Eigenvalues and Eigensystem for type Real_Matrix.  See
     *note G.3.1::(81/2).

132.2/2
   * The accuracy requirements for the subprograms Solve, Inverse,
     Determinant, Eigenvalues and Eigensystem for type Complex_Matrix.
     See *note G.3.2::(149/2).

133/2
   * This paragraph was deleted.

134/2
   * This paragraph was deleted.

135/2
   * This paragraph was deleted.

136/2
   * This paragraph was deleted.

136.1/2
   * Implementation-defined policy_identifiers allowed in a pragma
     Partition_Elaboration_Policy.  See *note H.6::(4/2).


File: arm2012.info,  Node: M.3,  Prev: M.2,  Up: Annex M

M.3 Implementation Advice
=========================

1/2
This International Standard sometimes gives advice about handling
certain target machine dependences.  Each Ada implementation must
document whether that advice is followed:

2/2
   * Program_Error should be raised when an unsupported Specialized
     Needs Annex feature is used at run time.  See *note 1.1.3::(20).

3/2
   * Implementation-defined extensions to the functionality of a
     language-defined library unit should be provided by adding children
     to the library unit.  See *note 1.1.3::(21).

4/2
   * If a bounded error or erroneous execution is detected,
     Program_Error should be raised.  See *note 1.1.5::(12).

5/2
   * Implementation-defined pragmas should have no semantic effect for
     error-free programs.  See *note 2.8::(16/3).

6/2
   * Implementation-defined pragmas should not make an illegal program
     legal, unless they complete a declaration or configure the
     library_items in an environment.  See *note 2.8::(19).

7/2
   * Long_Integer should be declared in Standard if the target supports
     32-bit arithmetic.  No other named integer subtypes should be
     declared in Standard.  See *note 3.5.4::(28).

8/2
   * For a two's complement target, modular types with a binary modulus
     up to System.Max_Int*2+2 should be supported.  A nonbinary modulus
     up to Integer'Last should be supported.  See *note 3.5.4::(29).

9/2
   * Program_Error should be raised for the evaluation of S'Pos for an
     enumeration type, if the value of the operand does not correspond
     to the internal code for any enumeration literal of the type.  See
     *note 3.5.5::(8).

10/2
   * Long_Float should be declared in Standard if the target supports 11
     or more digits of precision.  No other named float subtypes should
     be declared in Standard.  See *note 3.5.7::(17).

11/2
   * Multidimensional arrays should be represented in row-major order,
     unless the array has convention Fortran.  See *note 3.6.2::(11/3).

12/3
   * Tags.Internal_Tag should return the tag of a type, if one exists,
     whose innermost master is a master of the point of the function
     call..  See *note 3.9::(26.1/3).

13/2
   * A real static expression with a nonformal type that is not part of
     a larger static expression should be rounded the same as the target
     system.  See *note 4.9::(38.1/2).

14/2
   * The value of Duration'Small should be no greater than 100
     microseconds.  See *note 9.6::(30).

15/2
   * The time base for delay_relative_statements should be monotonic.
     See *note 9.6::(31).

16/2
   * Leap seconds should be supported if the target system supports
     them.  Otherwise, operations in Calendar.Formatting should return
     results consistent with no leap seconds.  See *note 9.6.1::(89/2).

17/2
   * When applied to a generic unit, a program unit pragma that is not a
     library unit pragma should apply to each instance of the generic
     unit for which there is not an overriding pragma applied directly
     to the instance.  See *note 10.1.5::(10/1).

18/2
   * A type declared in a preelaborated package should have the same
     representation in every elaboration of a given version of the
     package.  See *note 10.2.1::(12).

19/2
   * Exception_Information should provide information useful for
     debugging, and should include the Exception_Name and
     Exception_Message.  See *note 11.4.1::(19).

20/2
   * Exception_Message by default should be short, provide information
     useful for debugging, and should not include the Exception_Name.
     See *note 11.4.1::(19).

21/2
   * Code executed for checks that have been suppressed should be
     minimized.  See *note 11.5::(28).

22/2
   * The recommended level of support for all representation items
     should be followed.  See *note 13.1::(28/3).

23/2
   * Storage allocated to objects of a packed type should be minimized.
     See *note 13.2::(6).

24/3
   * The recommended level of support for the Pack aspect should be
     followed.  See *note 13.2::(9).

25/2
   * For an array X, X'Address should point at the first component of
     the array rather than the array bounds.  See *note 13.3::(14).

26/2
   * The recommended level of support for the Address attribute should
     be followed.  See *note 13.3::(19).

26.1/3
   * For any tagged specific subtype S, S'Class'Alignment should equal
     S'Alignment.  See *note 13.3::(28).

27/2
   * The recommended level of support for the Alignment attribute should
     be followed.  See *note 13.3::(35).

28/2
   * The Size of an array object should not include its bounds.  See
     *note 13.3::(41.1/2).

29/2
   * If the Size of a subtype allows for efficient independent
     addressability, then the Size of most objects of the subtype should
     equal the Size of the subtype.  See *note 13.3::(52).

30/2
   * A Size clause on a composite subtype should not affect the internal
     layout of components.  See *note 13.3::(53).

31/2
   * The recommended level of support for the Size attribute should be
     followed.  See *note 13.3::(56).

32/2
   * The recommended level of support for the Component_Size attribute
     should be followed.  See *note 13.3::(73).

33/2
   * The recommended level of support for
     enumeration_representation_clauses should be followed.  See *note
     13.4::(10).

34/2
   * The recommended level of support for record_representation_clauses
     should be followed.  See *note 13.5.1::(22).

35/2
   * If a component is represented using a pointer to the actual data of
     the component which is contiguous with the rest of the object, then
     the storage place attributes should reflect the place of the actual
     data.  If a component is allocated discontiguously from the rest of
     the object, then a warning should be generated upon reference to
     one of its storage place attributes.  See *note 13.5.2::(5).

36/2
   * The recommended level of support for the nondefault bit ordering
     should be followed.  See *note 13.5.3::(8).

37/2
   * Type System.Address should be a private type.  See *note
     13.7::(37).

38/2
   * Operations in System and its children should reflect the target
     environment; operations that do not make sense should raise
     Program_Error.  See *note 13.7.1::(16).

39/2
   * Since the Size of an array object generally does not include its
     bounds, the bounds should not be part of the converted data in an
     instance of Unchecked_Conversion.  See *note 13.9::(14/2).

40/2
   * There should not be unnecessary run-time checks on the result of an
     Unchecked_Conversion; the result should be returned by reference
     when possible.  Restrictions on Unchecked_Conversions should be
     avoided.  See *note 13.9::(15).

41/2
   * The recommended level of support for Unchecked_Conversion should be
     followed.  See *note 13.9::(17).

42/2
   * Any cases in which heap storage is dynamically allocated other than
     as part of the evaluation of an allocator should be documented.
     See *note 13.11::(23).

43/2
   * A default storage pool for an access-to-constant type should not
     have overhead to support deallocation of individual objects.  See
     *note 13.11::(24).

44/2
   * Usually, a storage pool for an access discriminant or access
     parameter should be created at the point of an allocator, and be
     reclaimed when the designated object becomes inaccessible.  For
     other anonymous access types, the pool should be created at the
     point where the type is elaborated and need not support
     deallocation of individual objects.  See *note 13.11::(25).

45/2
   * For a standard storage pool, an instance of Unchecked_Deallocation
     should actually reclaim the storage.  See *note 13.11.2::(17).

45.1/3
   * A call on an instance of Unchecked_Deallocation with a nonnull
     access value should raise Program_Error if the actual access type
     of the instance is a type for which the Storage_Size has been
     specified to be zero or is defined by the language to be zero.  See
     *note 13.11.2::(17.1/3).

46/2
   * If not specified, the value of Stream_Size for an elementary type
     should be the number of bits that corresponds to the minimum number
     of stream elements required by the first subtype of the type,
     rounded up to the nearest factor or multiple of the word size that
     is also a multiple of the stream element size.  See *note
     13.13.2::(1.6/2).

47/2
   * The recommended level of support for the Stream_Size attribute
     should be followed.  See *note 13.13.2::(1.8/2).

48/2
   * If an implementation provides additional named predefined integer
     types, then the names should end with "Integer".  If an
     implementation provides additional named predefined floating point
     types, then the names should end with "Float".  See *note
     A.1::(52).

49/2
   * Implementation-defined operations on Wide_Character, Wide_String,
     Wide_Wide_Character, and Wide_Wide_String should be child units of
     Wide_Characters or Wide_Wide_Characters.  See *note A.3.1::(7/3).

49.1/3
   * The string returned by
     Wide_Characters.Handling.Character_Set_Version should include
     either "10646:" or "Unicode".  See *note A.3.5::(62).

50/2
   * Bounded string objects should not be implemented by implicit
     pointers and dynamic allocation.  See *note A.4.4::(106).

51/2
   * Strings.Hash should be good a hash function, returning a wide
     spread of values for different string values, and similar strings
     should rarely return the same value.  See *note A.4.9::(12/2).

51.1/3
   * If an implementation supports other string encoding schemes, a
     child of Ada.Strings similar to UTF_Encoding should be defined.
     See *note A.4.11::(107/3).

52/2
   * Any storage associated with an object of type Generator of the
     random number packages should be reclaimed on exit from the scope
     of the object.  See *note A.5.2::(46).

53/2
   * Each value of Initiator passed to Reset for the random number
     packages should initiate a distinct sequence of random numbers, or,
     if that is not possible, be at least a rapidly varying function of
     the initiator value.  See *note A.5.2::(47).

54/2
   * Get_Immediate should be implemented with unbuffered input; input
     should be available immediately; line-editing should be disabled.
     See *note A.10.7::(23).

55/2
   * Package Directories.Information should be provided to retrieve
     other information about a file.  See *note A.16::(124/2).

56/3
   * Directories.Start_Search and Directories.Search should raise
     Name_Error for malformed patterns.  See *note A.16::(125).

57/2
   * Directories.Rename should be supported at least when both New_Name
     and Old_Name are simple names and New_Name does not identify an
     existing external file.  See *note A.16::(126/2).

57.1/3
   * Directories.Hierarchical_File_Names should be provided for systems
     with hierarchical file naming, and should not be provided on other
     systems.  See *note A.16.1::(36/3).

58/2
   * If the execution environment supports subprocesses, the current
     environment variables should be used to initialize the environment
     variables of a subprocess.  See *note A.17::(32/2).

59/2
   * Changes to the environment variables made outside the control of
     Environment_Variables should be reflected immediately.  See *note
     A.17::(33/2).

60/2
   * Containers.Hash_Type'Modulus should be at least 2**32.
     Containers.Count_Type'Last should be at least 2**31-1.  See *note
     A.18.1::(8/2).

61/2
   * The worst-case time complexity of Element for Containers.Vector
     should be O(log N). See *note A.18.2::(256/2).

62/2
   * The worst-case time complexity of Append with Count = 1 when N is
     less than the capacity for Containers.Vector should be O(log N).
     See *note A.18.2::(257/2).

63/2
   * The worst-case time complexity of Prepend with Count = 1 and
     Delete_First with Count=1 for Containers.Vectors should be O(N log
     N). See *note A.18.2::(258/2).

64/2
   * The worst-case time complexity of a call on procedure Sort of an
     instance of Containers.Vectors.Generic_Sorting should be O(N**2),
     and the average time complexity should be better than O(N**2).  See
     *note A.18.2::(259/2).

65/2
   * Containers.Vectors.Generic_Sorting.Sort and
     Containers.Vectors.Generic_Sorting.Merge should minimize copying of
     elements.  See *note A.18.2::(260/2).

66/2
   * Containers.Vectors.Move should not copy elements, and should
     minimize copying of internal data structures.  See *note
     A.18.2::(261/2).

67/2
   * If an exception is propagated from a vector operation, no storage
     should be lost, nor any elements removed from a vector unless
     specified by the operation.  See *note A.18.2::(262/2).

68/2
   * The worst-case time complexity of Element, Insert with Count=1, and
     Delete with Count=1 for Containers.Doubly_Linked_Lists should be
     O(log N). See *note A.18.3::(160/2).

69/2
   * A call on procedure Sort of an instance of
     Containers.Doubly_Linked_Lists.Generic_Sorting should have an
     average time complexity better than O(N**2) and worst case no worse
     than O(N**2).  See *note A.18.3::(161/2).

70/2
   * Containers.Doubly_Linked_Lists.Move should not copy elements, and
     should minimize copying of internal data structures.  See *note
     A.18.3::(162/2).

71/2
   * If an exception is propagated from a list operation, no storage
     should be lost, nor any elements removed from a list unless
     specified by the operation.  See *note A.18.3::(163/2).

72/2
   * Move for a map should not copy elements, and should minimize
     copying of internal data structures.  See *note A.18.4::(83/2).

73/2
   * If an exception is propagated from a map operation, no storage
     should be lost, nor any elements removed from a map unless
     specified by the operation.  See *note A.18.4::(84/2).

74/2
   * The average time complexity of Element, Insert, Include, Replace,
     Delete, Exclude and Find operations that take a key parameter for
     Containers.Hashed_Maps should be O(log N). The average time
     complexity of the subprograms of Containers.Hashed_Maps that take a
     cursor parameter should be O(1).  The average time complexity of
     Containers.Hashed_Maps.Reserve_Capacity should be O(N). See *note
     A.18.5::(62/2).

75/2
   * The worst-case time complexity of Element, Insert, Include,
     Replace, Delete, Exclude and Find operations that take a key
     parameter for Containers.Ordered_Maps should be O((log N)**2) or
     better.  The worst-case time complexity of the subprograms of
     Containers.Ordered_Maps that take a cursor parameter should be
     O(1).  See *note A.18.6::(95/2).

76/2
   * Move for sets should not copy elements, and should minimize copying
     of internal data structures.  See *note A.18.7::(104/2).

77/2
   * If an exception is propagated from a set operation, no storage
     should be lost, nor any elements removed from a set unless
     specified by the operation.  See *note A.18.7::(105/2).

78/2
   * The average time complexity of the Insert, Include, Replace,
     Delete, Exclude and Find operations of Containers.Hashed_Sets that
     take an element parameter should be O(log N). The average time
     complexity of the subprograms of Containers.Hashed_Sets that take a
     cursor parameter should be O(1).  The average time complexity of
     Containers.Hashed_Sets.Reserve_Capacity should be O(N). See *note
     A.18.8::(88/2).

79/2
   * The worst-case time complexity of the Insert, Include, Replace,
     Delete, Exclude and Find operations of Containers.Ordered_Sets that
     take an element parameter should be O((log N)**2).  The worst-case
     time complexity of the subprograms of Containers.Ordered_Sets that
     take a cursor parameter should be O(1).  See *note A.18.9::(116/2).

79.1/3
   * The worst-case time complexity of the Element, Parent, First_Child,
     Last_Child, Next_Sibling, Previous_Sibling, Insert_Child with
     Count=1, and Delete operations of Containers.Multiway_Trees should
     be O(log N). See *note A.18.10::(231/3).

79.2/3
   * Containers.Multiway_Trees.Move should not copy elements, and should
     minimize copying of internal data structures.  See *note
     A.18.10::(232/3).

79.3/3
   * If an exception is propagated from a tree operation, no storage
     should be lost, nor any elements removed from a tree unless
     specified by the operation.  See *note A.18.10::(233/3).

79.4/3
   * Containers.Indefinite_Holders.Move should not copy the element, and
     should minimize copying of internal data structures.  See *note
     A.18.18::(73/3).

79.5/3
   * If an exception is propagated from a holder operation, no storage
     should be lost, nor should the element be removed from a holder
     container unless specified by the operation.  See *note
     A.18.18::(74/3).

79.6/3
   * Bounded vector objects should be implemented without implicit
     pointers or dynamic allocation.  See *note A.18.19::(16/3).

79.7/3
   * The implementation advice for procedure Move to minimize copying
     does not apply to bounded vectors.  See *note A.18.19::(17/3).

79.8/3
   * Bounded list objects should be implemented without implicit
     pointers or dynamic allocation.  See *note A.18.20::(19/3).

79.9/3
   * The implementation advice for procedure Move to minimize copying
     does not apply to bounded lists.  See *note A.18.20::(20/3).

79.10/3
   * Bounded hashed map objects should be implemented without implicit
     pointers or dynamic allocation.  See *note A.18.21::(21/3).

79.11/3
   * The implementation advice for procedure Move to minimize copying
     does not apply to bounded hashed maps.  See *note A.18.21::(22/3).

79.12/3
   * Bounded ordered map objects should be implemented without implicit
     pointers or dynamic allocation.  See *note A.18.22::(18/3).

79.13/3
   * The implementation advice for procedure Move to minimize copying
     does not apply to bounded ordered maps.  See *note A.18.22::(19/3).

79.14/3
   * Bounded hashed set objects should be implemented without implicit
     pointers or dynamic allocation.  See *note A.18.23::(20/3).

79.15/3
   * The implementation advice for procedure Move to minimize copying
     does not apply to bounded hashed sets.  See *note A.18.23::(21/3).

79.16/3
   * Bounded ordered set objects should be implemented without implicit
     pointers or dynamic allocation.  See *note A.18.24::(17/3).

79.17/3
   * The implementation advice for procedure Move to minimize copying
     does not apply to bounded ordered sets.  See *note A.18.24::(18/3).

79.18/3
   * Bounded tree objects should be implemented without implicit
     pointers or dynamic allocation.  See *note A.18.25::(19/3).

79.19/3
   * The implementation advice for procedure Move to minimize copying
     does not apply to bounded trees.  See *note A.18.25::(20/3).

80/2
   * Containers.Generic_Array_Sort and
     Containers.Generic_Constrained_Array_Sort should have an average
     time complexity better than O(N**2) and worst case no worse than
     O(N**2).  See *note A.18.26::(10/2).

81/2
   * Containers.Generic_Array_Sort and
     Containers.Generic_Constrained_Array_Sort should minimize copying
     of elements.  See *note A.18.26::(11/2).

81.1/3
   * Containers.Generic_Sort should have an average time complexity
     better than O(N**2) and worst case no worse than O(N**2).  See
     *note A.18.26::(12/3).

81.2/3
   * Containers.Generic_Sort should minimize calls to the generic formal
     Swap.  See *note A.18.26::(13/3).

81.3/3
   * Bounded queue objects should be implemented without implicit
     pointers or dynamic allocation.  See *note A.18.29::(13/3).

81.4/3
   * Bounded priority queue objects should be implemented without
     implicit pointers or dynamic allocation.  See *note
     A.18.31::(14/3).

82/3
   * If Export is supported for a language, the main program should be
     able to be written in that language.  Subprograms named "adainit"
     and "adafinal" should be provided for elaboration and finalization
     of the environment task.  See *note B.1::(39/3).

83/3
   * Automatic elaboration of preelaborated packages should be provided
     when specifying the Export aspect as True is supported.  See *note
     B.1::(40/3).

84/3
   * For each supported convention L other than Intrinsic, specifying
     the aspects Import and Export should be supported for objects of
     L-compatible types and for subprograms, and aspect Convention
     should be supported for L-eligible types and for subprograms.  See
     *note B.1::(41/4).

85/2
   * If an interface to C, COBOL, or Fortran is provided, the
     corresponding package or packages described in *note Annex B::,
     "*note Annex B:: Interface to Other Languages" should also be
     provided.  See *note B.2::(13/3).

86/2
   * The constants nul, wide_nul, char16_nul, and char32_nul in package
     Interfaces.C should have a representation of zero.  See *note
     B.3::(62.5/3).

87/2
   * If C interfacing is supported, the interface correspondences
     between Ada and C should be supported.  See *note B.3::(71).

88/2
   * If COBOL interfacing is supported, the interface correspondences
     between Ada and COBOL should be supported.  See *note B.4::(98).

89/2
   * If Fortran interfacing is supported, the interface correspondences
     between Ada and Fortran should be supported.  See *note B.5::(26).

90/2
   * The machine code or intrinsics support should allow access to all
     operations normally available to assembly language programmers for
     the target environment.  See *note C.1::(3).

91/2
   * Interface to assembler should be supported; the default assembler
     should be associated with the convention identifier Assembler.  See
     *note C.1::(4/3).

92/2
   * If an entity is exported to assembly language, then the
     implementation should allocate it at an addressable location even
     if not otherwise referenced from the Ada code.  A call to a machine
     code or assembler subprogram should be treated as if it could read
     or update every object that is specified as exported.  See *note
     C.1::(5).

93/2
   * Little or no overhead should be associated with calling intrinsic
     and machine-code subprograms.  See *note C.1::(10).

94/2
   * Intrinsic subprograms should be provided to access any machine
     operations that provide special capabilities or efficiency not
     normally available.  See *note C.1::(16).

95/2
   * If the Ceiling_Locking policy is not in effect and the target
     system allows for finer-grained control of interrupt blocking, a
     means for the application to specify which interrupts are to be
     blocked during protected actions should be provided.  See *note
     C.3::(28/2).

96/2
   * Interrupt handlers should be called directly by the hardware.  See
     *note C.3.1::(20).

97/2
   * Violations of any implementation-defined restrictions on interrupt
     handlers should be detected before run time.  See *note
     C.3.1::(21).

98/2
   * If implementation-defined forms of interrupt handler procedures are
     supported, then for each such form of a handler, a type analogous
     to Parameterless_Handler should be specified in a child package of
     Interrupts, with the same operations as in the predefined package
     Interrupts.  See *note C.3.2::(25).

99/2
   * Preelaborated packages should be implemented such that little or no
     code is executed at run time for the elaboration of entities.  See
     *note C.4::(14).

100/4
   * If aspect Discard_Names is True for an entity, then the amount of
     storage used for storing names associated with that entity should
     be reduced.  See *note C.5::(8/4).

101/2
   * A load or store of a volatile object whose size is a multiple of
     System.Storage_Unit and whose alignment is nonzero, should be
     implemented by accessing exactly the bits of the object and no
     others.  See *note C.6::(22/2).

102/2
   * A load or store of an atomic object should be implemented by a
     single load or store instruction.  See *note C.6::(23/2).

103/2
   * If the target domain requires deterministic memory use at run time,
     storage for task attributes should be pre-allocated statically and
     the number of attributes pre-allocated should be documented.  See
     *note C.7.2::(30).

104/2
   * Finalization of task attributes and reclamation of associated
     storage should be performed as soon as possible after task
     termination.  See *note C.7.2::(30.1/2).

105/2
   * Names that end with "_Locking" should be used for
     implementation-defined locking policies.  See *note D.3::(17).

106/2
   * Names that end with "_Queuing" should be used for
     implementation-defined queuing policies.  See *note D.4::(16).

107/2
   * The abort_statement should not require the task executing the
     statement to block.  See *note D.6::(9).

108/2
   * On a multi-processor, the delay associated with aborting a task on
     another processor should be bounded.  See *note D.6::(10).

109/2
   * When feasible, specified restrictions should be used to produce a
     more efficient implementation.  See *note D.7::(21).

110/2
   * When appropriate, mechanisms to change the value of Tick should be
     provided.  See *note D.8::(47).

111/2
   * Calendar.Clock and Real_Time.Clock should be transformations of the
     same time base.  See *note D.8::(48).

112/2
   * The "best" time base which exists in the underlying system should
     be available to the application through Real_Time.Clock.  See *note
     D.8::(49).

112.1/3
   * On a multiprocessor system, each processor should have a separate
     and disjoint ready queue.  See *note D.13::(9).

113/2
   * When appropriate, implementations should provide configuration
     mechanisms to change the value of Execution_Time.CPU_Tick.  See
     *note D.14::(29/2).

114/2
   * For a timing event, the handler should be executed directly by the
     real-time clock interrupt mechanism.  See *note D.15::(25).

114.1/3
   * Each dispatching domain should have separate and disjoint ready
     queues.  See *note D.16.1::(31).

115/2
   * The PCS should allow for multiple tasks to call the RPC-receiver.
     See *note E.5::(28).

116/2
   * The System.RPC.Write operation should raise Storage_Error if it
     runs out of space when writing an item.  See *note E.5::(29).

117/2
   * If COBOL (respectively, C) is supported in the target environment,
     then interfacing to COBOL (respectively, C) should be supported as
     specified in *note Annex B::.  See *note F::(7/3).

118/2
   * Packed decimal should be used as the internal representation for
     objects of subtype S when S'Machine_Radix = 10.  See *note
     F.1::(2).

119/2
   * If Fortran (respectively, C) is supported in the target
     environment, then interfacing to Fortran (respectively, C) should
     be supported as specified in *note Annex B::.  See *note G::(7/3).

120/2
   * Mixed real and complex operations (as well as pure-imaginary and
     complex operations) should not be performed by converting the real
     (resp.  pure-imaginary) operand to complex.  See *note G.1.1::(56).

121/3
   * If Real'Signed_Zeros is True for Numerics.Generic_Complex_Types, a
     rational treatment of the signs of zero results and result
     components should be provided.  See *note G.1.1::(58).

122/3
   * If Complex_Types.Real'Signed_Zeros is True for
     Numerics.Generic_Complex_Elementary_Functions, a rational treatment
     of the signs of zero results and result components should be
     provided.  See *note G.1.2::(49).

123/2
   * For elementary functions, the forward trigonometric functions
     without a Cycle parameter should not be implemented by calling the
     corresponding version with a Cycle parameter.  Log without a Base
     parameter should not be implemented by calling Log with a Base
     parameter.  See *note G.2.4::(19).

124/2
   * For complex arithmetic, the Compose_From_Polar function without a
     Cycle parameter should not be implemented by calling
     Compose_From_Polar with a Cycle parameter.  See *note G.2.6::(15).

125/2
   * Solve and Inverse for Numerics.Generic_Real_Arrays should be
     implemented using established techniques such as LU decomposition
     and the result should be refined by an iteration on the residuals.
     See *note G.3.1::(88/3).

126/2
   * The equality operator should be used to test that a matrix in
     Numerics.Generic_Real_Arrays is symmetric.  See *note
     G.3.1::(90/2).

126.1/3
   * An implementation should minimize the circumstances under which the
     algorithm used for Numerics.Generic_Real_Arrays.Eigenvalues and
     Numerics.Generic_Real_Arrays.Eigensystem fails to converge.  See
     *note G.3.1::(91/3).

127/2
   * Solve and Inverse for Numerics.Generic_Complex_Arrays should be
     implemented using established techniques and the result should be
     refined by an iteration on the residuals.  See *note
     G.3.2::(158/3).

128/2
   * The equality and negation operators should be used to test that a
     matrix is Hermitian.  See *note G.3.2::(160/2).

128.1/3
   * An implementation should minimize the circumstances under which the
     algorithm used for Numerics.Generic_Complex_Arrays.Eigenvalues and
     Numerics.Generic_Complex_Arrays.Eigensystem fails to converge.  See
     *note G.3.2::(160.1/3).

129/2
   * Mixed real and complex operations should not be performed by
     converting the real operand to complex.  See *note G.3.2::(161/2).

130/2
   * The information produced by pragma Reviewable should be provided in
     both a human-readable and machine-readable form, and the latter
     form should be documented.  See *note H.3.1::(19).

131/2
   * Object code listings should be provided both in a symbolic format
     and in a numeric format.  See *note H.3.1::(20).

132/3
   * If the partition elaboration policy is Sequential and the
     Environment task becomes permanently blocked during elaboration,
     then the partition should be immediately terminated.  See *note
     H.6::(15/3).


File: arm2012.info,  Node: Annex N,  Next: Annex P,  Prev: Annex M,  Up: Top

Annex N Glossary
****************

1/2
This Annex contains informal descriptions of some of the terms used in
this International Standard.  The index provides references to more
formal definitions of all of the terms used in this International
Standard.

1.1/2
Abstract type.  An abstract type is a tagged type intended for use as an
ancestor of other types, but which is not allowed to have objects of its
own.

2
Access type.  An access type has values that designate aliased objects.
Access types correspond to "pointer types" or "reference types" in some
other languages.

3
Aliased.  An aliased view of an object is one that can be designated by
an access value.  Objects allocated by allocators are aliased.  Objects
can also be explicitly declared as aliased with the reserved word
aliased.  The Access attribute can be used to create an access value
designating an aliased object.

3.1/2
Ancestor.  An ancestor of a type is the type itself or, in the case of a
type derived from other types, its parent type or one of its progenitor
types or one of their ancestors.  Note that ancestor and descendant are
inverse relationships.

4
Array type.  An array type is a composite type whose components are all
of the same type.  Components are selected by indexing.

4.1/3
Aspect.  An aspect is a specifiable property of an entity.  An aspect
may be specified by an aspect_specification on the declaration of the
entity.  Some aspects may be queried via attributes.

4.2/3
Assertion.  An assertion is a boolean expression that appears in any of
the following: a pragma Assert, a predicate, a precondition, a
postcondition, an invariant, a constraint, or a null exclusion.  An
assertion is expected to be True at run time at certain specified
places.

4.3/2
Category (of types).  A category of types is a set of types with one or
more common properties, such as primitive operations.  A category of
types that is closed under derivation is also known as a class.

5
Character type.  A character type is an enumeration type whose values
include characters.

6/2
Class (of types). A class is a set of types that is closed under
derivation, which means that if a given type is in the class, then all
types derived from that type are also in the class.  The set of types of
a class share common properties, such as their primitive operations.

7
Compilation unit.  The text of a program can be submitted to the
compiler in one or more compilations.  Each compilation is a succession
of compilation_units.  A compilation_unit contains either the
declaration, the body, or a renaming of a program unit.

8/2
Composite type.  A composite type may have components.

9
Construct.  A construct is a piece of text (explicit or implicit) that
is an instance of a syntactic category defined under "Syntax".

9.1/3
Container.  A container is an object that contain other objects all of
the same type, which could be class-wide.  Several predefined container
types are provided by the children of package Ada.Containers (see *note
A.18.1::).

10
Controlled type.  A controlled type supports user-defined assignment and
finalization.  Objects are always finalized before being destroyed.

11
Declaration.  A declaration is a language construct that associates a
name with (a view of) an entity. A declaration may appear explicitly in
the program text (an explicit declaration), or may be supposed to occur
at a given place in the text as a consequence of the semantics of
another construct (an implicit declaration).

12/2
This paragraph was deleted.

13/2
Derived type.  A derived type is a type defined in terms of one or more
other types given in a derived type definition.  The first of those
types is the parent type of the derived type and any others are
progenitor types.  Each class containing the parent type or a progenitor
type also contains the derived type.  The derived type inherits
properties such as components and primitive operations from the parent
and progenitors.  A type together with the types derived from it
(directly or indirectly) form a derivation class.

13.1/2
Descendant.  A type is a descendant of itself, its parent and progenitor
types, and their ancestors.  Note that descendant and ancestor are
inverse relationships.

14
Discrete type.  A discrete type is either an integer type or an
enumeration type.  Discrete types may be used, for example, in
case_statements and as array indices.

15/2
Discriminant.  A discriminant is a parameter for a composite type.  It
can control, for example, the bounds of a component of the type if the
component is an array.  A discriminant for a task type can be used to
pass data to a task of the type upon creation.

15.1/2
Elaboration.  The process by which a declaration achieves its run-time
effect is called elaboration.  Elaboration is one of the forms of
execution.

16
Elementary type.  An elementary type does not have components.

17
Enumeration type.  An enumeration type is defined by an enumeration of
its values, which may be named by identifiers or character literals.

17.1/2
Evaluation.  The process by which an expression achieves its run-time
effect is called evaluation.  Evaluation is one of the forms of
execution.

18
Exception.  An exception represents a kind of exceptional situation; an
occurrence of such a situation (at run time) is called an exception
occurrence. To raise an exception is to abandon normal program execution
so as to draw attention to the fact that the corresponding situation has
arisen. Performing some actions in response to the arising of an
exception is called handling the exception.

19
Execution.  The process by which a construct achieves its run-time
effect is called execution. Execution of a declaration is also called
elaboration.  Execution of an expression is also called evaluation.

19.1/2
Function.  A function is a form of subprogram that returns a result and
can be called as part of an expression.

20
Generic unit.  A generic unit is a template for a (nongeneric) program
unit; the template can be parameterized by objects, types, subprograms,
and packages.  An instance of a generic unit is created by a
generic_instantiation.  The rules of the language are enforced when a
generic unit is compiled, using a generic contract model; additional
checks are performed upon instantiation to verify the contract is met.
That is, the declaration of a generic unit represents a contract between
the body of the generic and instances of the generic.  Generic units can
be used to perform the role that macros sometimes play in other
languages.

20.1/2
Incomplete type.  An incomplete type gives a view of a type that reveals
only some of its properties.  The remaining properties are provided by
the full view given elsewhere.  Incomplete types can be used for
defining recursive data structures.

20.2/3
Indexable container type.  An indexable container type is one that has
user-defined behavior for indexing, via the Constant_Indexing or
Variable_Indexing aspects.

21
Integer type.  Integer types comprise the signed integer types and the
modular types.  A signed integer type has a base range that includes
both positive and negative numbers, and has operations that may raise an
exception when the result is outside the base range.  A modular type has
a base range whose lower bound is zero, and has operations with
"wraparound" semantics.  Modular types subsume what are called "unsigned
types" in some other languages.

21.1/2
Interface type.  An interface type is a form of abstract tagged type
which has no components or concrete operations except possibly null
procedures.  Interface types are used for composing other interfaces and
tagged types and thereby provide multiple inheritance.  Only an
interface type can be used as a progenitor of another type.

21.2/4
Invariant.  An invariant is an assertion that is expected to be True for
all objects of a given private type when viewed from outside the
defining package.

21.3/3
Iterable container type.  An iterable container type is one that has
user-defined behavior for iteration, via the Default_Iterator and
Iterator_Element aspects.

21.4/3
Iterator.  An iterator is a construct that is used to loop over the
elements of an array or container.  Iterators may be user defined, and
may perform arbitrary computations to access elements from a container.

22
Library unit.  A library unit is a separately compiled program unit, and
is always a package, subprogram, or generic unit.  Library units may
have other (logically nested) library units as children, and may have
other program units physically nested within them. A root library unit,
together with its children and grandchildren and so on, form a
subsystem.

23/2
Limited type.  A limited type is a type for which copying (such as in an
assignment_statement) is not allowed.  A nonlimited type is a type for
which copying is allowed.

24
Object.  An object is either a constant or a variable.  An object
contains a value.  An object is created by an object_declaration or by
an allocator.  A formal parameter is (a view of) an object.  A
subcomponent of an object is an object.

24.1/2
Overriding operation.  An overriding operation is one that replaces an
inherited primitive operation.  Operations may be marked explicitly as
overriding or not overriding.

25
Package.  Packages are program units that allow the specification of
groups of logically related entities.  Typically, a package contains the
declaration of a type (often a private type or private extension) along
with the declarations of primitive subprograms of the type, which can be
called from outside the package, while their inner workings remain
hidden from outside users.

25.1/2
Parent.  The parent of a derived type is the first type given in the
definition of the derived type.  The parent can be almost any kind of
type, including an interface type.

26
Partition.  A partition is a part of a program.  Each partition consists
of a set of library units.  Each partition may run in a separate address
space, possibly on a separate computer.  A program may contain just one
partition.  A distributed program typically contains multiple
partitions, which can execute concurrently.

26.1/3
Postcondition.  A postcondition is an assertion that is expected to be
True when a given subprogram returns normally.

27
Pragma.  A pragma is a compiler directive.  There are language-defined
pragmas that give instructions for optimization, listing control, etc.
An implementation may support additional (implementation-defined)
pragmas.

27.1/3
Precondition.  A precondition is an assertion that is expected to be
True when a given subprogram is called.

27.2/3
Predicate.  A predicate is an assertion that is expected to be True for
all objects of a given subtype.

28
Primitive operations.  The primitive operations of a type are the
operations (such as subprograms) declared together with the type
declaration.  They are inherited by other types in the same class of
types.  For a tagged type, the primitive subprograms are dispatching
subprograms, providing run-time polymorphism.  A dispatching subprogram
may be called with statically tagged operands, in which case the
subprogram body invoked is determined at compile time.  Alternatively, a
dispatching subprogram may be called using a dispatching call, in which
case the subprogram body invoked is determined at run time.

29/2
Private extension.  A private extension is a type that extends another
type, with the additional properties hidden from its clients.

30/2
Private type.  A private type gives a view of a type that reveals only
some of its properties.  The remaining properties are provided by the
full view given elsewhere.  Private types can be used for defining
abstractions that hide unnecessary details from their clients.

30.1/2
Procedure.  A procedure is a form of subprogram that does not return a
result and can only be called by a statement.

30.2/2
Progenitor.  A progenitor of a derived type is one of the types given in
the definition of the derived type other than the first.  A progenitor
is always an interface type.  Interfaces, tasks, and protected types may
also have progenitors.

31
Program.  A program is a set of partitions, each of which may execute in
a separate address space, possibly on a separate computer.  A partition
consists of a set of library units.

32
Program unit.  A program unit is either a package, a task unit, a
protected unit, a protected entry, a generic unit, or an explicitly
declared subprogram other than an enumeration literal.  Certain kinds of
program units can be separately compiled.  Alternatively, they can
appear physically nested within other program units.

33/2
Protected type.  A protected type is a composite type whose components
are accessible only through one of its protected operations which
synchronize concurrent access by multiple tasks.

34
Real type.  A real type has values that are approximations of the real
numbers.  Floating point and fixed point types are real types.

35
Record extension.  A record extension is a type that extends another
type by adding additional components.

36
Record type.  A record type is a composite type consisting of zero or
more named components, possibly of different types.

36.1/3
Reference type.  A reference type is one that has user-defined behavior
for ".all", defined by the Implicit_Dereference aspect.

36.2/2
Renaming.  A renaming_declaration is a declaration that does not define
a new entity, but instead defines a view of an existing entity.

37
Scalar type.  A scalar type is either a discrete type or a real type.

37.1/3
Storage pool.  Each access-to-object type has an associated storage pool
object.  The storage for an object created by an allocator comes from
the storage pool of the type of the allocator.  Some storage pools may
be partitioned into subpools in order to support finer-grained storage
management.

37.2/3
Stream.  A stream is a sequence of elements that can be used, along with
the stream-oriented attributes, to support marshalling and unmarshalling
of values of most types.

37.3/2
Subprogram.  A subprogram is a section of a program that can be executed
in various contexts.  It is invoked by a subprogram call that may
qualify the effect of the subprogram through the passing of parameters.
There are two forms of subprograms: functions, which return values, and
procedures, which do not.

38/3
Subtype.  A subtype is a type together with optional constraints, null
exclusions, and predicates, which constrain the values of the subtype to
satisfy certain conditions.  The values of a subtype are a subset of the
values of its type.

38.1/2
Synchronized.  A synchronized entity is one that will work safely with
multiple tasks at one time.  A synchronized interface can be an ancestor
of a task or a protected type.  Such a task or protected type is called
a synchronized tagged type.

39
Tagged type.  The objects of a tagged type have a run-time type tag,
which indicates the specific type with which the object was originally
created.  An operand of a class-wide tagged type can be used in a
dispatching call; the tag indicates which subprogram body to invoke.
Nondispatching calls, in which the subprogram body to invoke is
determined at compile time, are also allowed.  Tagged types may be
extended with additional components.

40/2
Task type.  A task type is a composite type used to represent active
entities which execute concurrently and which can communicate via queued
task entries.  The top-level task of a partition is called the
environment task.

41/2
Type.  Each object has a type.  A type has an associated set of values,
and a set of primitive operations which implement the fundamental
aspects of its semantics.  Types are grouped into categories.  Most
language-defined categories of types are also classes of types.

41.1/4
Type Invariant.  See Invariant.

42/2
View.  A view of an entity reveals some or all of the properties of the
entity.  A single entity may have multiple views.


File: arm2012.info,  Node: Annex P,  Next: Annex Q,  Prev: Annex N,  Up: Top

Annex P Syntax Summary
**********************

This Annex summarizes the complete syntax of the language.  See *note
1.1.4:: for a description of the notation used.

     *note 2.3:::
     identifier ::= 
        identifier_start {identifier_start | identifier_extend}

     *note 2.3:::
     identifier_start ::= 
          letter_uppercase
        | letter_lowercase
        | letter_titlecase
        | letter_modifier
        | letter_other
        | number_letter

     *note 2.3:::
     identifier_extend ::= 
          mark_non_spacing
        | mark_spacing_combining
        | number_decimal
        | punctuation_connector

     *note 2.4:::
     numeric_literal ::= decimal_literal | based_literal

     *note 2.4.1:::
     decimal_literal ::= numeral [.numeral] [exponent]

     *note 2.4.1:::
     numeral ::= digit {[underline] digit}

     *note 2.4.1:::
     exponent ::= E [+] numeral | E - numeral

     *note 2.4.1:::
     digit ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

     *note 2.4.2:::
     based_literal ::= 
        base # based_numeral [.based_numeral] # [exponent]

     *note 2.4.2:::
     base ::= numeral

     *note 2.4.2:::
     based_numeral ::= 
        extended_digit {[underline] extended_digit}

     *note 2.4.2:::
     extended_digit ::= digit | A | B | C | D | E | F

     *note 2.5:::
     character_literal ::= 'graphic_character'

     *note 2.6:::
     string_literal ::= "{string_element}"

     *note 2.6:::
     string_element ::= "" | non_quotation_mark_graphic_character

     *note 2.7:::
     comment ::= --{non_end_of_line_character}

     *note 2.8:::
     pragma ::= 
        pragma identifier [(pragma_argument_association {, 
     pragma_argument_association})];

     *note 2.8:::
     pragma_argument_association ::= 
          [pragma_argument_identifier =>] name
        | [pragma_argument_identifier =>] expression
        | pragma_argument_aspect_mark =>  name
        | pragma_argument_aspect_mark =>  expression

     *note 3.1:::
     basic_declaration ::= 
          type_declaration   | subtype_declaration
        | object_declaration   | number_declaration
        | subprogram_declaration   | abstract_subprogram_declaration
        | null_procedure_declaration   | expression_function_declaration
        | package_declaration   | renaming_declaration
        | exception_declaration   | generic_declaration
        | generic_instantiation

     *note 3.1:::
     defining_identifier ::= identifier

     *note 3.2.1:::
     type_declaration ::=  full_type_declaration
        | incomplete_type_declaration
        | private_type_declaration
        | private_extension_declaration

     *note 3.2.1:::
     full_type_declaration ::= 
          type defining_identifier [known_discriminant_part] is 
     type_definition
             [aspect_specification];
        | task_type_declaration
        | protected_type_declaration

     *note 3.2.1:::
     type_definition ::= 
          enumeration_type_definition   | integer_type_definition
        | real_type_definition   | array_type_definition
        | record_type_definition   | access_type_definition
        | derived_type_definition   | interface_type_definition

     *note 3.2.2:::
     subtype_declaration ::= 
        subtype defining_identifier is subtype_indication
             [aspect_specification];

     *note 3.2.2:::
     subtype_indication ::=  [null_exclusion] subtype_mark [constraint]

     *note 3.2.2:::
     subtype_mark ::= subtype_name

     *note 3.2.2:::
     constraint ::= scalar_constraint | composite_constraint

     *note 3.2.2:::
     scalar_constraint ::= 
          range_constraint | digits_constraint | delta_constraint

     *note 3.2.2:::
     composite_constraint ::= 
          index_constraint | discriminant_constraint

     *note 3.3.1:::
     object_declaration ::= 
         defining_identifier_list : [aliased] [constant] 
     subtype_indication [:= expression]
             [aspect_specification];
       | defining_identifier_list : [aliased] [constant] 
     access_definition [:= expression]
             [aspect_specification];
       | defining_identifier_list : [aliased] [constant] 
     array_type_definition [:= expression]
             [aspect_specification];
       | single_task_declaration
       | single_protected_declaration

     *note 3.3.1:::
     defining_identifier_list ::= 
       defining_identifier {, defining_identifier}

     *note 3.3.2:::
     number_declaration ::= 
          defining_identifier_list : constant := static_expression;

     *note 3.4:::
     derived_type_definition ::= 
         [abstract] [limited] new parent_subtype_indication [[and 
     interface_list] record_extension_part]

     *note 3.5:::
     range_constraint ::=  range range

     *note 3.5:::
     range ::=  range_attribute_reference
        | simple_expression .. simple_expression

     *note 3.5.1:::
     enumeration_type_definition ::= 
        (enumeration_literal_specification {, 
     enumeration_literal_specification})

     *note 3.5.1:::
     enumeration_literal_specification ::=  defining_identifier | 
     defining_character_literal

     *note 3.5.1:::
     defining_character_literal ::= character_literal

     *note 3.5.4:::
     integer_type_definition ::= signed_integer_type_definition | 
     modular_type_definition

     *note 3.5.4:::
     signed_integer_type_definition ::= range static_
     simple_expression .. static_simple_expression

     *note 3.5.4:::
     modular_type_definition ::= mod static_expression

     *note 3.5.6:::
     real_type_definition ::= 
        floating_point_definition | fixed_point_definition

     *note 3.5.7:::
     floating_point_definition ::= 
       digits static_expression [real_range_specification]

     *note 3.5.7:::
     real_range_specification ::= 
       range static_simple_expression .. static_simple_expression

     *note 3.5.9:::
     fixed_point_definition ::= ordinary_fixed_point_definition | 
     decimal_fixed_point_definition

     *note 3.5.9:::
     ordinary_fixed_point_definition ::= 
        delta static_expression  real_range_specification

     *note 3.5.9:::
     decimal_fixed_point_definition ::= 
        delta static_expression digits static_expression [
     real_range_specification]

     *note 3.5.9:::
     digits_constraint ::= 
        digits static_simple_expression [range_constraint]

     *note 3.6:::
     array_type_definition ::= 
        unconstrained_array_definition | constrained_array_definition

     *note 3.6:::
     unconstrained_array_definition ::= 
        array(index_subtype_definition {, index_subtype_definition}) of 
     component_definition

     *note 3.6:::
     index_subtype_definition ::= subtype_mark range <>

     *note 3.6:::
     constrained_array_definition ::= 
        array (discrete_subtype_definition {, 
     discrete_subtype_definition}) of component_definition

     *note 3.6:::
     discrete_subtype_definition ::= discrete_subtype_indication | range

     *note 3.6:::
     component_definition ::= 
        [aliased] subtype_indication
      | [aliased] access_definition

     *note 3.6.1:::
     index_constraint ::=  (discrete_range {, discrete_range})

     *note 3.6.1:::
     discrete_range ::= discrete_subtype_indication | range

     *note 3.7:::
     discriminant_part ::= unknown_discriminant_part | 
     known_discriminant_part

     *note 3.7:::
     unknown_discriminant_part ::= (<>)

     *note 3.7:::
     known_discriminant_part ::= 
        (discriminant_specification {; discriminant_specification})

     *note 3.7:::
     discriminant_specification ::= 
        defining_identifier_list : [null_exclusion] subtype_mark [:= 
     default_expression]
      | defining_identifier_list : access_definition [:= 
     default_expression]

     *note 3.7:::
     default_expression ::= expression

     *note 3.7.1:::
     discriminant_constraint ::= 
        (discriminant_association {, discriminant_association})

     *note 3.7.1:::
     discriminant_association ::= 
        [discriminant_selector_name {| discriminant_selector_name} =>] 
     expression

     *note 3.8:::
     record_type_definition ::= [[abstract] tagged] [limited] 
     record_definition

     *note 3.8:::
     record_definition ::= 
         record
            component_list
         end record
       | null record

     *note 3.8:::
     component_list ::= 
           component_item {component_item}
        | {component_item} variant_part
        |  null;

     *note 3.8:::
     component_item ::= component_declaration | aspect_clause

     *note 3.8:::
     component_declaration ::= 
        defining_identifier_list : component_definition [:= 
     default_expression]
             [aspect_specification];

     *note 3.8.1:::
     variant_part ::= 
        case discriminant_direct_name is
            variant
           {variant}
        end case;

     *note 3.8.1:::
     variant ::= 
        when discrete_choice_list =>
           component_list

     *note 3.8.1:::
     discrete_choice_list ::= discrete_choice {| discrete_choice}

     *note 3.8.1:::
     discrete_choice ::= choice_expression | discrete_
     subtype_indication | range | others

     *note 3.9.1:::
     record_extension_part ::= with record_definition

     *note 3.9.3:::
     abstract_subprogram_declaration ::= 
         [overriding_indicator]
         subprogram_specification is abstract
             [aspect_specification];

     *note 3.9.4:::
     interface_type_definition ::= 
         [limited | task | protected | synchronized] interface [and 
     interface_list]

     *note 3.9.4:::
     interface_list ::= interface_subtype_mark {and interface_
     subtype_mark}

     *note 3.10:::
     access_type_definition ::= 
         [null_exclusion] access_to_object_definition
       | [null_exclusion] access_to_subprogram_definition

     *note 3.10:::
     access_to_object_definition ::= 
         access [general_access_modifier] subtype_indication

     *note 3.10:::
     general_access_modifier ::= all | constant

     *note 3.10:::
     access_to_subprogram_definition ::= 
         access [protected] procedure parameter_profile
       | access [protected] function  parameter_and_result_profile

     *note 3.10:::
     null_exclusion ::= not null

     *note 3.10:::
     access_definition ::= 
         [null_exclusion] access [constant] subtype_mark
       | [null_exclusion] access [protected] procedure parameter_profile
       | [null_exclusion] access [protected] function 
     parameter_and_result_profile

     *note 3.10.1:::
     incomplete_type_declaration ::= type defining_identifier [
     discriminant_part] [is tagged];

     *note 3.11:::
     declarative_part ::= {declarative_item}

     *note 3.11:::
     declarative_item ::= 
         basic_declarative_item | body

     *note 3.11:::
     basic_declarative_item ::= 
         basic_declaration | aspect_clause | use_clause

     *note 3.11:::
     body ::= proper_body | body_stub

     *note 3.11:::
     proper_body ::= 
         subprogram_body | package_body | task_body | protected_body

     *note 4.1:::
     name ::= 
          direct_name   | explicit_dereference
        | indexed_component   | slice
        | selected_component   | attribute_reference
        | type_conversion   | function_call
        | character_literal   | qualified_expression
        | generalized_reference   | generalized_indexing

     *note 4.1:::
     direct_name ::= identifier | operator_symbol

     *note 4.1:::
     prefix ::= name | implicit_dereference

     *note 4.1:::
     explicit_dereference ::= name.all

     *note 4.1:::
     implicit_dereference ::= name

     *note 4.1.1:::
     indexed_component ::= prefix(expression {, expression})

     *note 4.1.2:::
     slice ::= prefix(discrete_range)

     *note 4.1.3:::
     selected_component ::= prefix . selector_name

     *note 4.1.3:::
     selector_name ::= identifier | character_literal | operator_symbol

     *note 4.1.4:::
     attribute_reference ::= prefix'attribute_designator

     *note 4.1.4:::
     attribute_designator ::= 
         identifier[(static_expression)]
       | Access | Delta | Digits | Mod

     *note 4.1.4:::
     range_attribute_reference ::= prefix'range_attribute_designator

     *note 4.1.4:::
     range_attribute_designator ::= Range[(static_expression)]

     *note 4.1.5:::
     generalized_reference ::= reference_object_name

     *note 4.1.6:::
     generalized_indexing ::= indexable_container_object_prefix 
     actual_parameter_part

     *note 4.3:::
     aggregate ::= record_aggregate | extension_aggregate | 
     array_aggregate

     *note 4.3.1:::
     record_aggregate ::= (record_component_association_list)

     *note 4.3.1:::
     record_component_association_list ::= 
         record_component_association {, record_component_association}
       | null record

     *note 4.3.1:::
     record_component_association ::= 
         [component_choice_list =>] expression
        | component_choice_list => <>

     *note 4.3.1:::
     component_choice_list ::= 
          component_selector_name {| component_selector_name}
        | others

     *note 4.3.2:::
     extension_aggregate ::= 
         (ancestor_part with record_component_association_list)

     *note 4.3.2:::
     ancestor_part ::= expression | subtype_mark

     *note 4.3.3:::
     array_aggregate ::= 
       positional_array_aggregate | named_array_aggregate

     *note 4.3.3:::
     positional_array_aggregate ::= 
         (expression, expression {, expression})
       | (expression {, expression}, others => expression)
       | (expression {, expression}, others => <>)

     *note 4.3.3:::
     named_array_aggregate ::= 
         (array_component_association {, array_component_association})

     *note 4.3.3:::
     array_component_association ::= 
         discrete_choice_list => expression
       | discrete_choice_list => <>

     *note 4.4:::
     expression ::= 
          relation {and relation}    | relation {and then relation}
        | relation {or relation}    | relation {or else relation}
        | relation {xor relation}

     *note 4.4:::
     choice_expression ::= 
          choice_relation {and choice_relation}
        | choice_relation {or choice_relation}
        | choice_relation {xor choice_relation}
        | choice_relation {and then choice_relation}
        | choice_relation {or else choice_relation}

     *note 4.4:::
     choice_relation ::= 
          simple_expression [relational_operator simple_expression]

     *note 4.4:::
     relation ::= 
          simple_expression [relational_operator simple_expression]
        | tested_simple_expression [not] in membership_choice_list
        | raise_expression

     *note 4.4:::
     membership_choice_list ::= membership_choice {| membership_choice}

     *note 4.4:::
     membership_choice ::= choice_simple_expression | range | 
     subtype_mark

     *note 4.4:::
     simple_expression ::= [unary_adding_operator] term {
     binary_adding_operator term}

     *note 4.4:::
     term ::= factor {multiplying_operator factor}

     *note 4.4:::
     factor ::= primary [** primary] | abs primary | not primary

     *note 4.4:::
     primary ::= 
        numeric_literal | null | string_literal | aggregate
      | name | allocator | (expression)
      | (conditional_expression) | (quantified_expression)

     *note 4.5:::
     logical_operator ::=     and | or  | xor

     *note 4.5:::
     relational_operator ::=     =   | /=  | <   | <= | > | >=

     *note 4.5:::
     binary_adding_operator ::=     +   | -   | &

     *note 4.5:::
     unary_adding_operator ::=     +   | -

     *note 4.5:::
     multiplying_operator ::=     *   | /   | mod | rem

     *note 4.5:::
     highest_precedence_operator ::=     **  | abs | not

     *note 4.5.7:::
     conditional_expression ::= if_expression | case_expression

     *note 4.5.7:::
     if_expression ::= 
        if condition then dependent_expression
        {elsif condition then dependent_expression}
        [else dependent_expression]

     *note 4.5.7:::
     condition ::= boolean_expression

     *note 4.5.7:::
     case_expression ::= 
         case selecting_expression is
         case_expression_alternative {,
         case_expression_alternative}

     *note 4.5.7:::
     case_expression_alternative ::= 
         when discrete_choice_list =>
             dependent_expression

     *note 4.5.8:::
     quantified_expression ::= for quantifier 
     loop_parameter_specification => predicate
       | for quantifier iterator_specification => predicate

     *note 4.5.8:::
     quantifier ::= all | some

     *note 4.5.8:::
     predicate ::= boolean_expression

     *note 4.6:::
     type_conversion ::= 
         subtype_mark(expression)
       | subtype_mark(name)

     *note 4.7:::
     qualified_expression ::= 
        subtype_mark'(expression) | subtype_mark'aggregate

     *note 4.8:::
     allocator ::= 
        new [subpool_specification] subtype_indication
      | new [subpool_specification] qualified_expression

     *note 4.8:::
     subpool_specification ::= (subpool_handle_name)

     *note 5.1:::
     sequence_of_statements ::= statement {statement} {label}

     *note 5.1:::
     statement ::= 
        {label} simple_statement | {label} compound_statement

     *note 5.1:::
     simple_statement ::= null_statement
        | assignment_statement   | exit_statement
        | goto_statement   | procedure_call_statement
        | simple_return_statement   | entry_call_statement
        | requeue_statement   | delay_statement
        | abort_statement   | raise_statement
        | code_statement

     *note 5.1:::
     compound_statement ::= 
          if_statement   | case_statement
        | loop_statement   | block_statement
        | extended_return_statement
        | accept_statement   | select_statement

     *note 5.1:::
     null_statement ::= null;

     *note 5.1:::
     label ::= <<label_statement_identifier>>

     *note 5.1:::
     statement_identifier ::= direct_name

     *note 5.2:::
     assignment_statement ::= 
        variable_name := expression;

     *note 5.3:::
     if_statement ::= 
         if condition then
           sequence_of_statements
        {elsif condition then
           sequence_of_statements}
        [else
           sequence_of_statements]
         end if;

     *note 5.4:::
     case_statement ::= 
        case selecting_expression is
            case_statement_alternative
           {case_statement_alternative}
        end case;

     *note 5.4:::
     case_statement_alternative ::= 
        when discrete_choice_list =>
           sequence_of_statements

     *note 5.5:::
     loop_statement ::= 
        [loop_statement_identifier:]
           [iteration_scheme] loop
              sequence_of_statements
            end loop [loop_identifier];

     *note 5.5:::
     iteration_scheme ::= while condition
        | for loop_parameter_specification
        | for iterator_specification

     *note 5.5:::
     loop_parameter_specification ::= 
        defining_identifier in [reverse] discrete_subtype_definition

     *note 5.5.2:::
     iterator_specification ::= 
         defining_identifier in [reverse] iterator_name
       | defining_identifier [: 
     subtype_indication] of [reverse] iterable_name

     *note 5.6:::
     block_statement ::= 
        [block_statement_identifier:]
            [declare
                 declarative_part]
             begin
                 handled_sequence_of_statements
             end [block_identifier];

     *note 5.7:::
     exit_statement ::= 
        exit [loop_name] [when condition];

     *note 5.8:::
     goto_statement ::= goto label_name;

     *note 6.1:::
     subprogram_declaration ::= 
         [overriding_indicator]
         subprogram_specification
             [aspect_specification];

     *note 6.1:::
     subprogram_specification ::= 
         procedure_specification
       | function_specification

     *note 6.1:::
     procedure_specification ::= procedure defining_program_unit_name 
     parameter_profile

     *note 6.1:::
     function_specification ::= function defining_designator 
     parameter_and_result_profile

     *note 6.1:::
     designator ::= [parent_unit_name . ]identifier | operator_symbol

     *note 6.1:::
     defining_designator ::= defining_program_unit_name | 
     defining_operator_symbol

     *note 6.1:::
     defining_program_unit_name ::= [parent_unit_name . ]
     defining_identifier

     *note 6.1:::
     operator_symbol ::= string_literal

     *note 6.1:::
     defining_operator_symbol ::= operator_symbol

     *note 6.1:::
     parameter_profile ::= [formal_part]

     *note 6.1:::
     parameter_and_result_profile ::= 
         [formal_part] return [null_exclusion] subtype_mark
       | [formal_part] return access_definition

     *note 6.1:::
     formal_part ::= 
        (parameter_specification {; parameter_specification})

     *note 6.1:::
     parameter_specification ::= 
         defining_identifier_list : [aliased] mode [null_exclusion] 
     subtype_mark [:= default_expression]
       | defining_identifier_list : access_definition [:= 
     default_expression]

     *note 6.1:::
     mode ::= [in] | in out | out

     *note 6.3:::
     subprogram_body ::= 
         [overriding_indicator]
         subprogram_specification
            [aspect_specification] is
            declarative_part
         begin
             handled_sequence_of_statements
         end [designator];

     *note 6.4:::
     procedure_call_statement ::= 
         procedure_name;
       | procedure_prefix actual_parameter_part;

     *note 6.4:::
     function_call ::= 
         function_name
       | function_prefix actual_parameter_part

     *note 6.4:::
     actual_parameter_part ::= 
         (parameter_association {, parameter_association})

     *note 6.4:::
     parameter_association ::= 
        [formal_parameter_selector_name =>] explicit_actual_parameter

     *note 6.4:::
     explicit_actual_parameter ::= expression | variable_name

     *note 6.5:::
     simple_return_statement ::= return [expression];

     *note 6.5:::
     extended_return_object_declaration ::= 
         defining_identifier : [aliased][constant] 
     return_subtype_indication [:= expression]

     *note 6.5:::
     extended_return_statement ::= 
         return extended_return_object_declaration [do
             handled_sequence_of_statements
         end return];

     *note 6.5:::
     return_subtype_indication ::= subtype_indication | 
     access_definition

     *note 6.7:::
     null_procedure_declaration ::= 
        [overriding_indicator]
        procedure_specification is null
            [aspect_specification];

     *note 6.8:::
     expression_function_declaration ::= 
        [overriding_indicator]
        function_specification is
            (expression)
            [aspect_specification];
      | [overriding_indicator]
        function_specification is
            aggregate
            [aspect_specification];

     *note 7.1:::
     package_declaration ::= package_specification;

     *note 7.1:::
     package_specification ::= 
         package defining_program_unit_name
             [aspect_specification] is
           {basic_declarative_item}
        [private
           {basic_declarative_item}]
         end [[parent_unit_name.]identifier]

     *note 7.2:::
     package_body ::= 
         package body defining_program_unit_name
             [aspect_specification] is
            declarative_part
        [begin
             handled_sequence_of_statements]
         end [[parent_unit_name.]identifier];

     *note 7.3:::
     private_type_declaration ::= 
        type defining_identifier [
     discriminant_part] is [[abstract] tagged] [limited] private
           [aspect_specification];

     *note 7.3:::
     private_extension_declaration ::= 
        type defining_identifier [discriminant_part] is
          [abstract] [limited | synchronized] new ancestor_
     subtype_indication
          [and interface_list] with private
            [aspect_specification];

     *note 8.3.1:::
     overriding_indicator ::= [not] overriding

     *note 8.4:::
     use_clause ::= use_package_clause | use_type_clause

     *note 8.4:::
     use_package_clause ::= use package_name {, package_name};

     *note 8.4:::
     use_type_clause ::= use [all] type subtype_mark {, subtype_mark};

     *note 8.5:::
     renaming_declaration ::= 
           object_renaming_declaration
         | exception_renaming_declaration
         | package_renaming_declaration
         | subprogram_renaming_declaration
         | generic_renaming_declaration

     *note 8.5.1:::
     object_renaming_declaration ::= 
         defining_identifier : [null_exclusion] 
     subtype_mark renames object_name
             [aspect_specification];
       | defining_identifier : access_definition renames object_name
             [aspect_specification];

     *note 8.5.2:::
     exception_renaming_declaration ::= 
     defining_identifier : exception renames exception_name
        [aspect_specification];

     *note 8.5.3:::
     package_renaming_declaration ::= package 
     defining_program_unit_name renames package_name
        [aspect_specification];

     *note 8.5.4:::
     subprogram_renaming_declaration ::= 
         [overriding_indicator]
         subprogram_specification renames callable_entity_name
             [aspect_specification];

     *note 8.5.5:::
     generic_renaming_declaration ::= 
         generic package   
     defining_program_unit_name renames generic_package_name
             [aspect_specification];
       | generic procedure   
     defining_program_unit_name renames generic_procedure_name
             [aspect_specification];
       | generic function   
     defining_program_unit_name renames generic_function_name
             [aspect_specification];

     *note 9.1:::
     task_type_declaration ::= 
        task type defining_identifier [known_discriminant_part]
             [aspect_specification] [is
          [new interface_list with]
          task_definition];

     *note 9.1:::
     single_task_declaration ::= 
        task defining_identifier 
             [aspect_specification][is
          [new interface_list with]
          task_definition];

     *note 9.1:::
     task_definition ::= 
          {task_item}
       [ private
          {task_item}]
       end [task_identifier]

     *note 9.1:::
     task_item ::= entry_declaration | aspect_clause

     *note 9.1:::
     task_body ::= 
        task body defining_identifier
             [aspect_specification] is
          declarative_part
        begin
          handled_sequence_of_statements
        end [task_identifier];

     *note 9.4:::
     protected_type_declaration ::= 
       protected type defining_identifier [known_discriminant_part]
             [aspect_specification] is
          [new interface_list with]
          protected_definition;

     *note 9.4:::
     single_protected_declaration ::= 
       protected defining_identifier
             [aspect_specification] is
          [new interface_list with]
          protected_definition;

     *note 9.4:::
     protected_definition ::= 
         { protected_operation_declaration }
     [ private
         { protected_element_declaration } ]
       end [protected_identifier]

     *note 9.4:::
     protected_operation_declaration ::= subprogram_declaration
          | entry_declaration
          | aspect_clause

     *note 9.4:::
     protected_element_declaration ::= protected_operation_declaration
          | component_declaration

     *note 9.4:::
     protected_body ::= 
       protected body defining_identifier
             [aspect_specification] is
        { protected_operation_item }
       end [protected_identifier];

     *note 9.4:::
     protected_operation_item ::= subprogram_declaration
          | subprogram_body
          | null_procedure_declaration
          | expression_function_declaration
          | entry_body
          | aspect_clause

     *note 9.5:::
     synchronization_kind ::= By_Entry | By_Protected_Procedure | Optional

     *note 9.5.2:::
     entry_declaration ::= 
        [overriding_indicator]
        entry defining_identifier [(discrete_subtype_definition)] 
     parameter_profile
           [aspect_specification];

     *note 9.5.2:::
     accept_statement ::= 
        accept entry_direct_name [(entry_index)] parameter_profile [do
          handled_sequence_of_statements
        end [entry_identifier]];

     *note 9.5.2:::
     entry_index ::= expression

     *note 9.5.2:::
     entry_body ::= 
       entry defining_identifier  entry_body_formal_part  
     entry_barrier is
         declarative_part
       begin
         handled_sequence_of_statements
       end [entry_identifier];

     *note 9.5.2:::
     entry_body_formal_part ::= [(entry_index_specification)] 
     parameter_profile

     *note 9.5.2:::
     entry_barrier ::= when condition

     *note 9.5.2:::
     entry_index_specification ::= for defining_identifier in 
     discrete_subtype_definition

     *note 9.5.3:::
     entry_call_statement ::= entry_name [actual_parameter_part];

     *note 9.5.4:::
     requeue_statement ::= requeue procedure_or_entry_name [with abort];

     *note 9.6:::
     delay_statement ::= delay_until_statement | 
     delay_relative_statement

     *note 9.6:::
     delay_until_statement ::= delay until delay_expression;

     *note 9.6:::
     delay_relative_statement ::= delay delay_expression;

     *note 9.7:::
     select_statement ::= 
        selective_accept
       | timed_entry_call
       | conditional_entry_call
       | asynchronous_select

     *note 9.7.1:::
     selective_accept ::= 
       select
        [guard]
          select_alternative
     { or
        [guard]
          select_alternative }
     [ else
        sequence_of_statements ]
       end select;

     *note 9.7.1:::
     guard ::= when condition =>

     *note 9.7.1:::
     select_alternative ::= 
        accept_alternative
       | delay_alternative
       | terminate_alternative

     *note 9.7.1:::
     accept_alternative ::= 
       accept_statement [sequence_of_statements]

     *note 9.7.1:::
     delay_alternative ::= 
       delay_statement [sequence_of_statements]

     *note 9.7.1:::
     terminate_alternative ::= terminate;

     *note 9.7.2:::
     timed_entry_call ::= 
       select
        entry_call_alternative
       or
        delay_alternative
       end select;

     *note 9.7.2:::
     entry_call_alternative ::= 
       procedure_or_entry_call [sequence_of_statements]

     *note 9.7.2:::
     procedure_or_entry_call ::= 
       procedure_call_statement | entry_call_statement

     *note 9.7.3:::
     conditional_entry_call ::= 
       select
        entry_call_alternative
       else
        sequence_of_statements
       end select;

     *note 9.7.4:::
     asynchronous_select ::= 
       select
        triggering_alternative
       then abort
        abortable_part
       end select;

     *note 9.7.4:::
     triggering_alternative ::= triggering_statement [
     sequence_of_statements]

     *note 9.7.4:::
     triggering_statement ::= procedure_or_entry_call | delay_statement

     *note 9.7.4:::
     abortable_part ::= sequence_of_statements

     *note 9.8:::
     abort_statement ::= abort task_name {, task_name};

     *note 10.1.1:::
     compilation ::= {compilation_unit}

     *note 10.1.1:::
     compilation_unit ::= 
         context_clause library_item
       | context_clause subunit

     *note 10.1.1:::
     library_item ::= [private] library_unit_declaration
       | library_unit_body
       | [private] library_unit_renaming_declaration

     *note 10.1.1:::
     library_unit_declaration ::= 
          subprogram_declaration   | package_declaration
        | generic_declaration   | generic_instantiation

     *note 10.1.1:::
     library_unit_renaming_declaration ::= 
        package_renaming_declaration
      | generic_renaming_declaration
      | subprogram_renaming_declaration

     *note 10.1.1:::
     library_unit_body ::= subprogram_body | package_body

     *note 10.1.1:::
     parent_unit_name ::= name

     *note 10.1.2:::
     context_clause ::= {context_item}

     *note 10.1.2:::
     context_item ::= with_clause | use_clause

     *note 10.1.2:::
     with_clause ::= limited_with_clause | nonlimited_with_clause

     *note 10.1.2:::
     limited_with_clause ::= limited [private] with library_unit_
     name {, library_unit_name};

     *note 10.1.2:::
     nonlimited_with_clause ::= [private] with library_unit_
     name {, library_unit_name};

     *note 10.1.3:::
     body_stub ::= subprogram_body_stub | package_body_stub | 
     task_body_stub | protected_body_stub

     *note 10.1.3:::
     subprogram_body_stub ::= 
        [overriding_indicator]
        subprogram_specification is separate
           [aspect_specification];

     *note 10.1.3:::
     package_body_stub ::= 
        package body defining_identifier is separate
           [aspect_specification];

     *note 10.1.3:::
     task_body_stub ::= 
        task body defining_identifier is separate
           [aspect_specification];

     *note 10.1.3:::
     protected_body_stub ::= 
        protected body defining_identifier is separate
           [aspect_specification];

     *note 10.1.3:::
     subunit ::= separate (parent_unit_name) proper_body

     *note 11.1:::
     exception_declaration ::= defining_identifier_list : exception
        [aspect_specification];

     *note 11.2:::
     handled_sequence_of_statements ::= 
          sequence_of_statements
       [exception
          exception_handler
         {exception_handler}]

     *note 11.2:::
     exception_handler ::= 
       when [choice_parameter_specification:] exception_choice {| 
     exception_choice} =>
          sequence_of_statements

     *note 11.2:::
     choice_parameter_specification ::= defining_identifier

     *note 11.2:::
     exception_choice ::= exception_name | others

     *note 11.3:::
     raise_statement ::= raise;
           | raise exception_name [with string_expression];

     *note 11.3:::
     raise_expression ::= raise exception_name [with string_
     simple_expression]

     *note 12.1:::
     generic_declaration ::= generic_subprogram_declaration | 
     generic_package_declaration

     *note 12.1:::
     generic_subprogram_declaration ::= 
          generic_formal_part  subprogram_specification
             [aspect_specification];

     *note 12.1:::
     generic_package_declaration ::= 
          generic_formal_part  package_specification;

     *note 12.1:::
     generic_formal_part ::= generic {
     generic_formal_parameter_declaration | use_clause}

     *note 12.1:::
     generic_formal_parameter_declaration ::= 
           formal_object_declaration
         | formal_type_declaration
         | formal_subprogram_declaration
         | formal_package_declaration

     *note 12.3:::
     generic_instantiation ::= 
          package defining_program_unit_name is
              new generic_package_name [generic_actual_part]
                 [aspect_specification];
        | [overriding_indicator]
          procedure defining_program_unit_name is
              new generic_procedure_name [generic_actual_part]
                 [aspect_specification];
        | [overriding_indicator]
          function defining_designator is
              new generic_function_name [generic_actual_part]
                 [aspect_specification];

     *note 12.3:::
     generic_actual_part ::= 
        (generic_association {, generic_association})

     *note 12.3:::
     generic_association ::= 
        [generic_formal_parameter_selector_name =>] 
     explicit_generic_actual_parameter

     *note 12.3:::
     explicit_generic_actual_parameter ::= expression | variable_name
        | subprogram_name | entry_name | subtype_mark
        | package_instance_name

     *note 12.4:::
     formal_object_declaration ::= 
         defining_identifier_list : mode [null_exclusion] 
     subtype_mark [:= default_expression]
             [aspect_specification];
       |  defining_identifier_list : mode access_definition [:= 
     default_expression]
             [aspect_specification];

     *note 12.5:::
     formal_type_declaration ::= 
           formal_complete_type_declaration
         | formal_incomplete_type_declaration

     *note 12.5:::
     formal_complete_type_declaration ::= 
         type defining_identifier[discriminant_part] is 
     formal_type_definition
             [aspect_specification];

     *note 12.5:::
     formal_incomplete_type_declaration ::= 
         type defining_identifier[discriminant_part] [is tagged];

     *note 12.5:::
     formal_type_definition ::= 
           formal_private_type_definition
         | formal_derived_type_definition
         | formal_discrete_type_definition
         | formal_signed_integer_type_definition
         | formal_modular_type_definition
         | formal_floating_point_definition
         | formal_ordinary_fixed_point_definition
         | formal_decimal_fixed_point_definition
         | formal_array_type_definition
         | formal_access_type_definition
         | formal_interface_type_definition

     *note 12.5.1:::
     formal_private_type_definition ::= [[abstract] tagged] [limited] private

     *note 12.5.1:::
     formal_derived_type_definition ::= 
          [abstract] [limited | synchronized] new subtype_mark [[and 
     interface_list]with private]

     *note 12.5.2:::
     formal_discrete_type_definition ::= (<>)

     *note 12.5.2:::
     formal_signed_integer_type_definition ::= range <>

     *note 12.5.2:::
     formal_modular_type_definition ::= mod <>

     *note 12.5.2:::
     formal_floating_point_definition ::= digits <>

     *note 12.5.2:::
     formal_ordinary_fixed_point_definition ::= delta <>

     *note 12.5.2:::
     formal_decimal_fixed_point_definition ::= delta <> digits <>

     *note 12.5.3:::
     formal_array_type_definition ::= array_type_definition

     *note 12.5.4:::
     formal_access_type_definition ::= access_type_definition

     *note 12.5.5:::
     formal_interface_type_definition ::= interface_type_definition

     *note 12.6:::
     formal_subprogram_declaration ::= 
     formal_concrete_subprogram_declaration
         | formal_abstract_subprogram_declaration

     *note 12.6:::
     formal_concrete_subprogram_declaration ::= 
          with subprogram_specification [is subprogram_default]
             [aspect_specification];

     *note 12.6:::
     formal_abstract_subprogram_declaration ::= 
          with subprogram_specification is abstract [subprogram_default]
             [aspect_specification];

     *note 12.6:::
     subprogram_default ::= default_name | <> | null

     *note 12.6:::
     default_name ::= name

     *note 12.7:::
     formal_package_declaration ::= 
         with package defining_identifier is new generic_package_name  
     formal_package_actual_part
             [aspect_specification];

     *note 12.7:::
     formal_package_actual_part ::= 
         ([others =>] <>)
       | [generic_actual_part]
       | (formal_package_association {, 
     formal_package_association} [, others => <>])

     *note 12.7:::
     formal_package_association ::= 
         generic_association
       | generic_formal_parameter_selector_name => <>

     *note 13.1:::
     aspect_clause ::= attribute_definition_clause
           | enumeration_representation_clause
           | record_representation_clause
           | at_clause

     *note 13.1:::
     local_name ::= direct_name
           | direct_name'attribute_designator
           | library_unit_name

     *note 13.1.1:::
     aspect_specification ::= 
        with aspect_mark [=> aspect_definition] {,
                aspect_mark [=> aspect_definition] }

     *note 13.1.1:::
     aspect_mark ::= aspect_identifier['Class]

     *note 13.1.1:::
     aspect_definition ::= name | expression | identifier

     *note 13.3:::
     attribute_definition_clause ::= 
           for local_name'attribute_designator use expression;
         | for local_name'attribute_designator use name;

     *note 13.4:::
     enumeration_representation_clause ::= 
         for first_subtype_local_name use enumeration_aggregate;

     *note 13.4:::
     enumeration_aggregate ::= array_aggregate

     *note 13.5.1:::
     record_representation_clause ::= 
         for first_subtype_local_name use
           record [mod_clause]
             {component_clause}
           end record;

     *note 13.5.1:::
     component_clause ::= 
         component_local_name at position range first_bit .. last_bit;

     *note 13.5.1:::
     position ::= static_expression

     *note 13.5.1:::
     first_bit ::= static_simple_expression

     *note 13.5.1:::
     last_bit ::= static_simple_expression

     *note 13.8:::
     code_statement ::= qualified_expression;

     *note 13.11.3:::
     storage_pool_indicator ::= storage_pool_name | null | Standard

     *note 13.12:::
     restriction ::= restriction_identifier
         | restriction_parameter_identifier => 
     restriction_parameter_argument

     *note 13.12:::
     restriction_parameter_argument ::= name | expression

     *note J.3:::
     delta_constraint ::= delta static_simple_expression [
     range_constraint]

     *note J.7:::
     at_clause ::= for direct_name use at expression;

     *note J.8:::
     mod_clause ::= at mod static_expression;

Syntax Cross Reference


1/3
In the following syntax cross reference, each syntactic category is
followed by the subclause number where it is defined.  In addition, each
syntactic category S is followed by a list of the categories that use S
in their definitions.  For example, the first listing below shows that
abort_statement appears in the definition of simple_statement.

     abort_statement   *note 9.8::
        simple_statement   *note 5.1::

     abortable_part   *note 9.7.4::
        asynchronous_select   *note 9.7.4::

     abstract_subprogram_declaration   *note 3.9.3::
        basic_declaration   *note 3.1::

     accept_alternative   *note 9.7.1::
        select_alternative   *note 9.7.1::

     accept_statement   *note 9.5.2::
        accept_alternative   *note 9.7.1::
        compound_statement   *note 5.1::

     access_definition   *note 3.10::
        component_definition   *note 3.6::
        discriminant_specification   *note 3.7::
        formal_object_declaration   *note 12.4::
        object_declaration   *note 3.3.1::
        object_renaming_declaration   *note 8.5.1::
        parameter_and_result_profile   *note 6.1::
        parameter_specification   *note 6.1::
        return_subtype_indication   *note 6.5::

     access_to_object_definition   *note 3.10::
        access_type_definition   *note 3.10::

     access_to_subprogram_definition   *note 3.10::
        access_type_definition   *note 3.10::

     access_type_definition   *note 3.10::
        formal_access_type_definition   *note 12.5.4::
        type_definition   *note 3.2.1::

     actual_parameter_part   *note 6.4::
        entry_call_statement   *note 9.5.3::
        function_call   *note 6.4::
        generalized_indexing   *note 4.1.6::
        procedure_call_statement   *note 6.4::

     aggregate   *note 4.3::
        expression_function_declaration   *note 6.8::
        primary   *note 4.4::
        qualified_expression   *note 4.7::

     allocator   *note 4.8::
        primary   *note 4.4::

     ancestor_part   *note 4.3.2::
        extension_aggregate   *note 4.3.2::

     array_aggregate   *note 4.3.3::
        aggregate   *note 4.3::
        enumeration_aggregate   *note 13.4::

     array_component_association   *note 4.3.3::
        named_array_aggregate   *note 4.3.3::

     array_type_definition   *note 3.6::
        formal_array_type_definition   *note 12.5.3::
        object_declaration   *note 3.3.1::
        type_definition   *note 3.2.1::

     aspect_clause   *note 13.1::
        basic_declarative_item   *note 3.11::
        component_item   *note 3.8::
        protected_operation_declaration   *note 9.4::
        protected_operation_item   *note 9.4::
        task_item   *note 9.1::

     aspect_definition   *note 13.1.1::
        aspect_specification   *note 13.1.1::

     aspect_mark   *note 13.1.1::
        aspect_specification   *note 13.1.1::
        pragma_argument_association   *note 2.8::

     aspect_specification   *note 13.1.1::
        abstract_subprogram_declaration   *note 3.9.3::
        component_declaration   *note 3.8::
        entry_declaration   *note 9.5.2::
        exception_declaration   *note 11.1::
        exception_renaming_declaration   *note 8.5.2::
        expression_function_declaration   *note 6.8::
        formal_abstract_subprogram_declaration   *note 12.6::
        formal_complete_type_declaration   *note 12.5::
        formal_concrete_subprogram_declaration   *note 12.6::
        formal_object_declaration   *note 12.4::
        formal_package_declaration   *note 12.7::
        full_type_declaration   *note 3.2.1::
        generic_instantiation   *note 12.3::
        generic_renaming_declaration   *note 8.5.5::
        generic_subprogram_declaration   *note 12.1::
        null_procedure_declaration   *note 6.7::
        object_declaration   *note 3.3.1::
        object_renaming_declaration   *note 8.5.1::
        package_body   *note 7.2::
        package_body_stub   *note 10.1.3::
        package_renaming_declaration   *note 8.5.3::
        package_specification   *note 7.1::
        private_extension_declaration   *note 7.3::
        private_type_declaration   *note 7.3::
        protected_body   *note 9.4::
        protected_body_stub   *note 10.1.3::
        protected_type_declaration   *note 9.4::
        single_protected_declaration   *note 9.4::
        single_task_declaration   *note 9.1::
        subprogram_body   *note 6.3::
        subprogram_body_stub   *note 10.1.3::
        subprogram_declaration   *note 6.1::
        subprogram_renaming_declaration   *note 8.5.4::
        subtype_declaration   *note 3.2.2::
        task_body   *note 9.1::
        task_body_stub   *note 10.1.3::
        task_type_declaration   *note 9.1::

     assignment_statement   *note 5.2::
        simple_statement   *note 5.1::

     asynchronous_select   *note 9.7.4::
        select_statement   *note 9.7::

     at_clause   *note J.7::
        aspect_clause   *note 13.1::

     attribute_definition_clause   *note 13.3::
        aspect_clause   *note 13.1::

     attribute_designator   *note 4.1.4::
        attribute_definition_clause   *note 13.3::
        attribute_reference   *note 4.1.4::
        local_name   *note 13.1::

     attribute_reference   *note 4.1.4::
        name   *note 4.1::

     base   *note 2.4.2::
        based_literal   *note 2.4.2::

     based_literal   *note 2.4.2::
        numeric_literal   *note 2.4::

     based_numeral   *note 2.4.2::
        based_literal   *note 2.4.2::

     basic_declaration   *note 3.1::
        basic_declarative_item   *note 3.11::

     basic_declarative_item   *note 3.11::
        declarative_item   *note 3.11::
        package_specification   *note 7.1::

     binary_adding_operator   *note 4.5::
        simple_expression   *note 4.4::

     block_statement   *note 5.6::
        compound_statement   *note 5.1::

     body   *note 3.11::
        declarative_item   *note 3.11::

     body_stub   *note 10.1.3::
        body   *note 3.11::

     case_expression   *note 4.5.7::
        conditional_expression   *note 4.5.7::

     case_expression_alternative   *note 4.5.7::
        case_expression   *note 4.5.7::

     case_statement   *note 5.4::
        compound_statement   *note 5.1::

     case_statement_alternative   *note 5.4::
        case_statement   *note 5.4::

     character   *note 2.1::
        comment   *note 2.7::

     character_literal   *note 2.5::
        defining_character_literal   *note 3.5.1::
        name   *note 4.1::
        selector_name   *note 4.1.3::

     choice_expression   *note 4.4::
        discrete_choice   *note 3.8.1::

     choice_parameter_specification   *note 11.2::
        exception_handler   *note 11.2::

     choice_relation   *note 4.4::
        choice_expression   *note 4.4::

     code_statement   *note 13.8::
        simple_statement   *note 5.1::

     compilation_unit   *note 10.1.1::
        compilation   *note 10.1.1::

     component_choice_list   *note 4.3.1::
        record_component_association   *note 4.3.1::

     component_clause   *note 13.5.1::
        record_representation_clause   *note 13.5.1::

     component_declaration   *note 3.8::
        component_item   *note 3.8::
        protected_element_declaration   *note 9.4::

     component_definition   *note 3.6::
        component_declaration   *note 3.8::
        constrained_array_definition   *note 3.6::
        unconstrained_array_definition   *note 3.6::

     component_item   *note 3.8::
        component_list   *note 3.8::

     component_list   *note 3.8::
        record_definition   *note 3.8::
        variant   *note 3.8.1::

     composite_constraint   *note 3.2.2::
        constraint   *note 3.2.2::

     compound_statement   *note 5.1::
        statement   *note 5.1::

     condition   *note 4.5.7::
        entry_barrier   *note 9.5.2::
        exit_statement   *note 5.7::
        guard   *note 9.7.1::
        if_expression   *note 4.5.7::
        if_statement   *note 5.3::
        iteration_scheme   *note 5.5::

     conditional_entry_call   *note 9.7.3::
        select_statement   *note 9.7::

     conditional_expression   *note 4.5.7::
        primary   *note 4.4::

     constrained_array_definition   *note 3.6::
        array_type_definition   *note 3.6::

     constraint   *note 3.2.2::
        subtype_indication   *note 3.2.2::

     context_clause   *note 10.1.2::
        compilation_unit   *note 10.1.1::

     context_item   *note 10.1.2::
        context_clause   *note 10.1.2::

     decimal_fixed_point_definition   *note 3.5.9::
        fixed_point_definition   *note 3.5.9::

     decimal_literal   *note 2.4.1::
        numeric_literal   *note 2.4::

     declarative_item   *note 3.11::
        declarative_part   *note 3.11::

     declarative_part   *note 3.11::
        block_statement   *note 5.6::
        entry_body   *note 9.5.2::
        package_body   *note 7.2::
        subprogram_body   *note 6.3::
        task_body   *note 9.1::

     default_expression   *note 3.7::
        component_declaration   *note 3.8::
        discriminant_specification   *note 3.7::
        formal_object_declaration   *note 12.4::
        parameter_specification   *note 6.1::

     default_name   *note 12.6::
        subprogram_default   *note 12.6::

     defining_character_literal   *note 3.5.1::
        enumeration_literal_specification   *note 3.5.1::

     defining_designator   *note 6.1::
        function_specification   *note 6.1::
        generic_instantiation   *note 12.3::

     defining_identifier   *note 3.1::
        choice_parameter_specification   *note 11.2::
        defining_identifier_list   *note 3.3.1::
        defining_program_unit_name   *note 6.1::
        entry_body   *note 9.5.2::
        entry_declaration   *note 9.5.2::
        entry_index_specification   *note 9.5.2::
        enumeration_literal_specification   *note 3.5.1::
        exception_renaming_declaration   *note 8.5.2::
        extended_return_object_declaration   *note 6.5::
        formal_complete_type_declaration   *note 12.5::
        formal_incomplete_type_declaration   *note 12.5::
        formal_package_declaration   *note 12.7::
        full_type_declaration   *note 3.2.1::
        incomplete_type_declaration   *note 3.10.1::
        iterator_specification   *note 5.5.2::
        loop_parameter_specification   *note 5.5::
        object_renaming_declaration   *note 8.5.1::
        package_body_stub   *note 10.1.3::
        private_extension_declaration   *note 7.3::
        private_type_declaration   *note 7.3::
        protected_body   *note 9.4::
        protected_body_stub   *note 10.1.3::
        protected_type_declaration   *note 9.4::
        single_protected_declaration   *note 9.4::
        single_task_declaration   *note 9.1::
        subtype_declaration   *note 3.2.2::
        task_body   *note 9.1::
        task_body_stub   *note 10.1.3::
        task_type_declaration   *note 9.1::

     defining_identifier_list   *note 3.3.1::
        component_declaration   *note 3.8::
        discriminant_specification   *note 3.7::
        exception_declaration   *note 11.1::
        formal_object_declaration   *note 12.4::
        number_declaration   *note 3.3.2::
        object_declaration   *note 3.3.1::
        parameter_specification   *note 6.1::

     defining_operator_symbol   *note 6.1::
        defining_designator   *note 6.1::

     defining_program_unit_name   *note 6.1::
        defining_designator   *note 6.1::
        generic_instantiation   *note 12.3::
        generic_renaming_declaration   *note 8.5.5::
        package_body   *note 7.2::
        package_renaming_declaration   *note 8.5.3::
        package_specification   *note 7.1::
        procedure_specification   *note 6.1::

     delay_alternative   *note 9.7.1::
        select_alternative   *note 9.7.1::
        timed_entry_call   *note 9.7.2::

     delay_relative_statement   *note 9.6::
        delay_statement   *note 9.6::

     delay_statement   *note 9.6::
        delay_alternative   *note 9.7.1::
        simple_statement   *note 5.1::
        triggering_statement   *note 9.7.4::

     delay_until_statement   *note 9.6::
        delay_statement   *note 9.6::

     delta_constraint   *note J.3::
        scalar_constraint   *note 3.2.2::

     derived_type_definition   *note 3.4::
        type_definition   *note 3.2.1::

     designator   *note 6.1::
        subprogram_body   *note 6.3::

     digit   *note 2.4.1::
        extended_digit   *note 2.4.2::
        numeral   *note 2.4.1::

     digits_constraint   *note 3.5.9::
        scalar_constraint   *note 3.2.2::

     direct_name   *note 4.1::
        accept_statement   *note 9.5.2::
        at_clause   *note J.7::
        local_name   *note 13.1::
        name   *note 4.1::
        statement_identifier   *note 5.1::
        variant_part   *note 3.8.1::

     discrete_choice   *note 3.8.1::
        discrete_choice_list   *note 3.8.1::

     discrete_choice_list   *note 3.8.1::
        array_component_association   *note 4.3.3::
        case_expression_alternative   *note 4.5.7::
        case_statement_alternative   *note 5.4::
        variant   *note 3.8.1::

     discrete_range   *note 3.6.1::
        index_constraint   *note 3.6.1::
        slice   *note 4.1.2::

     discrete_subtype_definition   *note 3.6::
        constrained_array_definition   *note 3.6::
        entry_declaration   *note 9.5.2::
        entry_index_specification   *note 9.5.2::
        loop_parameter_specification   *note 5.5::

     discriminant_association   *note 3.7.1::
        discriminant_constraint   *note 3.7.1::

     discriminant_constraint   *note 3.7.1::
        composite_constraint   *note 3.2.2::

     discriminant_part   *note 3.7::
        formal_complete_type_declaration   *note 12.5::
        formal_incomplete_type_declaration   *note 12.5::
        incomplete_type_declaration   *note 3.10.1::
        private_extension_declaration   *note 7.3::
        private_type_declaration   *note 7.3::

     discriminant_specification   *note 3.7::
        known_discriminant_part   *note 3.7::

     entry_barrier   *note 9.5.2::
        entry_body   *note 9.5.2::

     entry_body   *note 9.5.2::
        protected_operation_item   *note 9.4::

     entry_body_formal_part   *note 9.5.2::
        entry_body   *note 9.5.2::

     entry_call_alternative   *note 9.7.2::
        conditional_entry_call   *note 9.7.3::
        timed_entry_call   *note 9.7.2::

     entry_call_statement   *note 9.5.3::
        procedure_or_entry_call   *note 9.7.2::
        simple_statement   *note 5.1::

     entry_declaration   *note 9.5.2::
        protected_operation_declaration   *note 9.4::
        task_item   *note 9.1::

     entry_index   *note 9.5.2::
        accept_statement   *note 9.5.2::

     entry_index_specification   *note 9.5.2::
        entry_body_formal_part   *note 9.5.2::

     enumeration_aggregate   *note 13.4::
        enumeration_representation_clause   *note 13.4::

     enumeration_literal_specification   *note 3.5.1::
        enumeration_type_definition   *note 3.5.1::

     enumeration_representation_clause   *note 13.4::
        aspect_clause   *note 13.1::

     enumeration_type_definition   *note 3.5.1::
        type_definition   *note 3.2.1::

     exception_choice   *note 11.2::
        exception_handler   *note 11.2::

     exception_declaration   *note 11.1::
        basic_declaration   *note 3.1::

     exception_handler   *note 11.2::
        handled_sequence_of_statements   *note 11.2::

     exception_renaming_declaration   *note 8.5.2::
        renaming_declaration   *note 8.5::

     exit_statement   *note 5.7::
        simple_statement   *note 5.1::

     explicit_actual_parameter   *note 6.4::
        parameter_association   *note 6.4::

     explicit_dereference   *note 4.1::
        name   *note 4.1::

     explicit_generic_actual_parameter   *note 12.3::
        generic_association   *note 12.3::

     exponent   *note 2.4.1::
        based_literal   *note 2.4.2::
        decimal_literal   *note 2.4.1::

     expression   *note 4.4::
        ancestor_part   *note 4.3.2::
        array_component_association   *note 4.3.3::
        aspect_definition   *note 13.1.1::
        assignment_statement   *note 5.2::
        at_clause   *note J.7::
        attribute_definition_clause   *note 13.3::
        attribute_designator   *note 4.1.4::
        case_expression   *note 4.5.7::
        case_expression_alternative   *note 4.5.7::
        case_statement   *note 5.4::
        condition   *note 4.5.7::
        decimal_fixed_point_definition   *note 3.5.9::
        default_expression   *note 3.7::
        delay_relative_statement   *note 9.6::
        delay_until_statement   *note 9.6::
        discriminant_association   *note 3.7.1::
        entry_index   *note 9.5.2::
        explicit_actual_parameter   *note 6.4::
        explicit_generic_actual_parameter   *note 12.3::
        expression_function_declaration   *note 6.8::
        extended_return_object_declaration   *note 6.5::
        floating_point_definition   *note 3.5.7::
        if_expression   *note 4.5.7::
        indexed_component   *note 4.1.1::
        mod_clause   *note J.8::
        modular_type_definition   *note 3.5.4::
        number_declaration   *note 3.3.2::
        object_declaration   *note 3.3.1::
        ordinary_fixed_point_definition   *note 3.5.9::
        position   *note 13.5.1::
        positional_array_aggregate   *note 4.3.3::
        pragma_argument_association   *note 2.8::
        predicate   *note 4.5.8::
        primary   *note 4.4::
        qualified_expression   *note 4.7::
        raise_statement   *note 11.3::
        range_attribute_designator   *note 4.1.4::
        record_component_association   *note 4.3.1::
        restriction_parameter_argument   *note 13.12::
        simple_return_statement   *note 6.5::
        type_conversion   *note 4.6::

     expression_function_declaration   *note 6.8::
        basic_declaration   *note 3.1::
        protected_operation_item   *note 9.4::

     extended_digit   *note 2.4.2::
        based_numeral   *note 2.4.2::

     extended_return_object_declaration   *note 6.5::
        extended_return_statement   *note 6.5::

     extended_return_statement   *note 6.5::
        compound_statement   *note 5.1::

     extension_aggregate   *note 4.3.2::
        aggregate   *note 4.3::

     factor   *note 4.4::
        term   *note 4.4::

     first_bit   *note 13.5.1::
        component_clause   *note 13.5.1::

     fixed_point_definition   *note 3.5.9::
        real_type_definition   *note 3.5.6::

     floating_point_definition   *note 3.5.7::
        real_type_definition   *note 3.5.6::

     formal_abstract_subprogram_declaration   *note 12.6::
        formal_subprogram_declaration   *note 12.6::

     formal_access_type_definition   *note 12.5.4::
        formal_type_definition   *note 12.5::

     formal_array_type_definition   *note 12.5.3::
        formal_type_definition   *note 12.5::

     formal_complete_type_declaration   *note 12.5::
        formal_type_declaration   *note 12.5::

     formal_concrete_subprogram_declaration   *note 12.6::
        formal_subprogram_declaration   *note 12.6::

     formal_decimal_fixed_point_definition   *note 12.5.2::
        formal_type_definition   *note 12.5::

     formal_derived_type_definition   *note 12.5.1::
        formal_type_definition   *note 12.5::

     formal_discrete_type_definition   *note 12.5.2::
        formal_type_definition   *note 12.5::

     formal_floating_point_definition   *note 12.5.2::
        formal_type_definition   *note 12.5::

     formal_incomplete_type_declaration   *note 12.5::
        formal_type_declaration   *note 12.5::

     formal_interface_type_definition   *note 12.5.5::
        formal_type_definition   *note 12.5::

     formal_modular_type_definition   *note 12.5.2::
        formal_type_definition   *note 12.5::

     formal_object_declaration   *note 12.4::
        generic_formal_parameter_declaration   *note 12.1::

     formal_ordinary_fixed_point_definition   *note 12.5.2::
        formal_type_definition   *note 12.5::

     formal_package_actual_part   *note 12.7::
        formal_package_declaration   *note 12.7::

     formal_package_association   *note 12.7::
        formal_package_actual_part   *note 12.7::

     formal_package_declaration   *note 12.7::
        generic_formal_parameter_declaration   *note 12.1::

     formal_part   *note 6.1::
        parameter_and_result_profile   *note 6.1::
        parameter_profile   *note 6.1::

     formal_private_type_definition   *note 12.5.1::
        formal_type_definition   *note 12.5::

     formal_signed_integer_type_definition   *note 12.5.2::
        formal_type_definition   *note 12.5::

     formal_subprogram_declaration   *note 12.6::
        generic_formal_parameter_declaration   *note 12.1::

     formal_type_declaration   *note 12.5::
        generic_formal_parameter_declaration   *note 12.1::

     formal_type_definition   *note 12.5::
        formal_complete_type_declaration   *note 12.5::

     full_type_declaration   *note 3.2.1::
        type_declaration   *note 3.2.1::

     function_call   *note 6.4::
        name   *note 4.1::

     function_specification   *note 6.1::
        expression_function_declaration   *note 6.8::
        subprogram_specification   *note 6.1::

     general_access_modifier   *note 3.10::
        access_to_object_definition   *note 3.10::

     generalized_indexing   *note 4.1.6::
        name   *note 4.1::

     generalized_reference   *note 4.1.5::
        name   *note 4.1::

     generic_actual_part   *note 12.3::
        formal_package_actual_part   *note 12.7::
        generic_instantiation   *note 12.3::

     generic_association   *note 12.3::
        formal_package_association   *note 12.7::
        generic_actual_part   *note 12.3::

     generic_declaration   *note 12.1::
        basic_declaration   *note 3.1::
        library_unit_declaration   *note 10.1.1::

     generic_formal_parameter_declaration   *note 12.1::
        generic_formal_part   *note 12.1::

     generic_formal_part   *note 12.1::
        generic_package_declaration   *note 12.1::
        generic_subprogram_declaration   *note 12.1::

     generic_instantiation   *note 12.3::
        basic_declaration   *note 3.1::
        library_unit_declaration   *note 10.1.1::

     generic_package_declaration   *note 12.1::
        generic_declaration   *note 12.1::

     generic_renaming_declaration   *note 8.5.5::
        library_unit_renaming_declaration   *note 10.1.1::
        renaming_declaration   *note 8.5::

     generic_subprogram_declaration   *note 12.1::
        generic_declaration   *note 12.1::

     goto_statement   *note 5.8::
        simple_statement   *note 5.1::

     graphic_character   *note 2.1::
        character_literal   *note 2.5::
        string_element   *note 2.6::

     guard   *note 9.7.1::
        selective_accept   *note 9.7.1::

     handled_sequence_of_statements   *note 11.2::
        accept_statement   *note 9.5.2::
        block_statement   *note 5.6::
        entry_body   *note 9.5.2::
        extended_return_statement   *note 6.5::
        package_body   *note 7.2::
        subprogram_body   *note 6.3::
        task_body   *note 9.1::

     identifier   *note 2.3::
        accept_statement   *note 9.5.2::
        aspect_definition   *note 13.1.1::
        aspect_mark   *note 13.1.1::
        attribute_designator   *note 4.1.4::
        block_statement   *note 5.6::
        defining_identifier   *note 3.1::
        designator   *note 6.1::
        direct_name   *note 4.1::
        entry_body   *note 9.5.2::
        loop_statement   *note 5.5::
        package_body   *note 7.2::
        package_specification   *note 7.1::
        pragma   *note 2.8::
        pragma_argument_association   *note 2.8::
        protected_body   *note 9.4::
        protected_definition   *note 9.4::
        restriction   *note 13.12::
        selector_name   *note 4.1.3::
        task_body   *note 9.1::
        task_definition   *note 9.1::

     identifier_extend   *note 2.3::
        identifier   *note 2.3::

     identifier_start   *note 2.3::
        identifier   *note 2.3::

     if_expression   *note 4.5.7::
        conditional_expression   *note 4.5.7::

     if_statement   *note 5.3::
        compound_statement   *note 5.1::

     implicit_dereference   *note 4.1::
        prefix   *note 4.1::

     incomplete_type_declaration   *note 3.10.1::
        type_declaration   *note 3.2.1::

     index_constraint   *note 3.6.1::
        composite_constraint   *note 3.2.2::

     index_subtype_definition   *note 3.6::
        unconstrained_array_definition   *note 3.6::

     indexed_component   *note 4.1.1::
        name   *note 4.1::

     integer_type_definition   *note 3.5.4::
        type_definition   *note 3.2.1::

     interface_list   *note 3.9.4::
        derived_type_definition   *note 3.4::
        formal_derived_type_definition   *note 12.5.1::
        interface_type_definition   *note 3.9.4::
        private_extension_declaration   *note 7.3::
        protected_type_declaration   *note 9.4::
        single_protected_declaration   *note 9.4::
        single_task_declaration   *note 9.1::
        task_type_declaration   *note 9.1::

     interface_type_definition   *note 3.9.4::
        formal_interface_type_definition   *note 12.5.5::
        type_definition   *note 3.2.1::

     iteration_scheme   *note 5.5::
        loop_statement   *note 5.5::

     iterator_specification   *note 5.5.2::
        iteration_scheme   *note 5.5::
        quantified_expression   *note 4.5.8::

     known_discriminant_part   *note 3.7::
        discriminant_part   *note 3.7::
        full_type_declaration   *note 3.2.1::
        protected_type_declaration   *note 9.4::
        task_type_declaration   *note 9.1::

     label   *note 5.1::
        sequence_of_statements   *note 5.1::
        statement   *note 5.1::

     last_bit   *note 13.5.1::
        component_clause   *note 13.5.1::

     letter_lowercase   ...
        identifier_start   *note 2.3::

     letter_modifier   ...
        identifier_start   *note 2.3::

     letter_other   ...
        identifier_start   *note 2.3::

     letter_titlecase   ...
        identifier_start   *note 2.3::

     letter_uppercase   ...
        identifier_start   *note 2.3::

     library_item   *note 10.1.1::
        compilation_unit   *note 10.1.1::

     library_unit_body   *note 10.1.1::
        library_item   *note 10.1.1::

     library_unit_declaration   *note 10.1.1::
        library_item   *note 10.1.1::

     library_unit_renaming_declaration   *note 10.1.1::
        library_item   *note 10.1.1::

     limited_with_clause   *note 10.1.2::
        with_clause   *note 10.1.2::

     local_name   *note 13.1::
        attribute_definition_clause   *note 13.3::
        component_clause   *note 13.5.1::
        enumeration_representation_clause   *note 13.4::
        record_representation_clause   *note 13.5.1::

     loop_parameter_specification   *note 5.5::
        iteration_scheme   *note 5.5::
        quantified_expression   *note 4.5.8::

     loop_statement   *note 5.5::
        compound_statement   *note 5.1::

     mark_non_spacing   ...
        identifier_extend   *note 2.3::

     mark_spacing_combining   ...
        identifier_extend   *note 2.3::

     membership_choice   *note 4.4::
        membership_choice_list   *note 4.4::

     membership_choice_list   *note 4.4::
        relation   *note 4.4::

     mod_clause   *note J.8::
        record_representation_clause   *note 13.5.1::

     mode   *note 6.1::
        formal_object_declaration   *note 12.4::
        parameter_specification   *note 6.1::

     modular_type_definition   *note 3.5.4::
        integer_type_definition   *note 3.5.4::

     multiplying_operator   *note 4.5::
        term   *note 4.4::

     name   *note 4.1::
        abort_statement   *note 9.8::
        aspect_definition   *note 13.1.1::
        assignment_statement   *note 5.2::
        attribute_definition_clause   *note 13.3::
        default_name   *note 12.6::
        entry_call_statement   *note 9.5.3::
        exception_choice   *note 11.2::
        exception_renaming_declaration   *note 8.5.2::
        exit_statement   *note 5.7::
        explicit_actual_parameter   *note 6.4::
        explicit_dereference   *note 4.1::
        explicit_generic_actual_parameter   *note 12.3::
        formal_package_declaration   *note 12.7::
        function_call   *note 6.4::
        generalized_reference   *note 4.1.5::
        generic_instantiation   *note 12.3::
        generic_renaming_declaration   *note 8.5.5::
        goto_statement   *note 5.8::
        implicit_dereference   *note 4.1::
        iterator_specification   *note 5.5.2::
        limited_with_clause   *note 10.1.2::
        local_name   *note 13.1::
        nonlimited_with_clause   *note 10.1.2::
        object_renaming_declaration   *note 8.5.1::
        package_renaming_declaration   *note 8.5.3::
        parent_unit_name   *note 10.1.1::
        pragma_argument_association   *note 2.8::
        prefix   *note 4.1::
        primary   *note 4.4::
        procedure_call_statement   *note 6.4::
        raise_expression   *note 11.3::
        raise_statement   *note 11.3::
        requeue_statement   *note 9.5.4::
        restriction_parameter_argument   *note 13.12::
        storage_pool_indicator   *note 13.11.3::
        subpool_specification   *note 4.8::
        subprogram_renaming_declaration   *note 8.5.4::
        subtype_mark   *note 3.2.2::
        type_conversion   *note 4.6::
        use_package_clause   *note 8.4::

     named_array_aggregate   *note 4.3.3::
        array_aggregate   *note 4.3.3::

     nonlimited_with_clause   *note 10.1.2::
        with_clause   *note 10.1.2::

     null_exclusion   *note 3.10::
        access_definition   *note 3.10::
        access_type_definition   *note 3.10::
        discriminant_specification   *note 3.7::
        formal_object_declaration   *note 12.4::
        object_renaming_declaration   *note 8.5.1::
        parameter_and_result_profile   *note 6.1::
        parameter_specification   *note 6.1::
        subtype_indication   *note 3.2.2::

     null_procedure_declaration   *note 6.7::
        basic_declaration   *note 3.1::
        protected_operation_item   *note 9.4::

     null_statement   *note 5.1::
        simple_statement   *note 5.1::

     number_decimal   ...
        identifier_extend   *note 2.3::

     number_declaration   *note 3.3.2::
        basic_declaration   *note 3.1::

     number_letter   ...
        identifier_start   *note 2.3::

     numeral   *note 2.4.1::
        base   *note 2.4.2::
        decimal_literal   *note 2.4.1::
        exponent   *note 2.4.1::

     numeric_literal   *note 2.4::
        primary   *note 4.4::

     object_declaration   *note 3.3.1::
        basic_declaration   *note 3.1::

     object_renaming_declaration   *note 8.5.1::
        renaming_declaration   *note 8.5::

     operator_symbol   *note 6.1::
        defining_operator_symbol   *note 6.1::
        designator   *note 6.1::
        direct_name   *note 4.1::
        selector_name   *note 4.1.3::

     ordinary_fixed_point_definition   *note 3.5.9::
        fixed_point_definition   *note 3.5.9::

     overriding_indicator   *note 8.3.1::
        abstract_subprogram_declaration   *note 3.9.3::
        entry_declaration   *note 9.5.2::
        expression_function_declaration   *note 6.8::
        generic_instantiation   *note 12.3::
        null_procedure_declaration   *note 6.7::
        subprogram_body   *note 6.3::
        subprogram_body_stub   *note 10.1.3::
        subprogram_declaration   *note 6.1::
        subprogram_renaming_declaration   *note 8.5.4::

     package_body   *note 7.2::
        library_unit_body   *note 10.1.1::
        proper_body   *note 3.11::

     package_body_stub   *note 10.1.3::
        body_stub   *note 10.1.3::

     package_declaration   *note 7.1::
        basic_declaration   *note 3.1::
        library_unit_declaration   *note 10.1.1::

     package_renaming_declaration   *note 8.5.3::
        library_unit_renaming_declaration   *note 10.1.1::
        renaming_declaration   *note 8.5::

     package_specification   *note 7.1::
        generic_package_declaration   *note 12.1::
        package_declaration   *note 7.1::

     parameter_and_result_profile   *note 6.1::
        access_definition   *note 3.10::
        access_to_subprogram_definition   *note 3.10::
        function_specification   *note 6.1::

     parameter_association   *note 6.4::
        actual_parameter_part   *note 6.4::

     parameter_profile   *note 6.1::
        accept_statement   *note 9.5.2::
        access_definition   *note 3.10::
        access_to_subprogram_definition   *note 3.10::
        entry_body_formal_part   *note 9.5.2::
        entry_declaration   *note 9.5.2::
        procedure_specification   *note 6.1::

     parameter_specification   *note 6.1::
        formal_part   *note 6.1::

     parent_unit_name   *note 10.1.1::
        defining_program_unit_name   *note 6.1::
        designator   *note 6.1::
        package_body   *note 7.2::
        package_specification   *note 7.1::
        subunit   *note 10.1.3::

     position   *note 13.5.1::
        component_clause   *note 13.5.1::

     positional_array_aggregate   *note 4.3.3::
        array_aggregate   *note 4.3.3::

     pragma_argument_association   *note 2.8::
        pragma   *note 2.8::

     predicate   *note 4.5.8::
        quantified_expression   *note 4.5.8::

     prefix   *note 4.1::
        attribute_reference   *note 4.1.4::
        function_call   *note 6.4::
        generalized_indexing   *note 4.1.6::
        indexed_component   *note 4.1.1::
        procedure_call_statement   *note 6.4::
        range_attribute_reference   *note 4.1.4::
        selected_component   *note 4.1.3::
        slice   *note 4.1.2::

     primary   *note 4.4::
        factor   *note 4.4::

     private_extension_declaration   *note 7.3::
        type_declaration   *note 3.2.1::

     private_type_declaration   *note 7.3::
        type_declaration   *note 3.2.1::

     procedure_call_statement   *note 6.4::
        procedure_or_entry_call   *note 9.7.2::
        simple_statement   *note 5.1::

     procedure_or_entry_call   *note 9.7.2::
        entry_call_alternative   *note 9.7.2::
        triggering_statement   *note 9.7.4::

     procedure_specification   *note 6.1::
        null_procedure_declaration   *note 6.7::
        subprogram_specification   *note 6.1::

     proper_body   *note 3.11::
        body   *note 3.11::
        subunit   *note 10.1.3::

     protected_body   *note 9.4::
        proper_body   *note 3.11::

     protected_body_stub   *note 10.1.3::
        body_stub   *note 10.1.3::

     protected_definition   *note 9.4::
        protected_type_declaration   *note 9.4::
        single_protected_declaration   *note 9.4::

     protected_element_declaration   *note 9.4::
        protected_definition   *note 9.4::

     protected_operation_declaration   *note 9.4::
        protected_definition   *note 9.4::
        protected_element_declaration   *note 9.4::

     protected_operation_item   *note 9.4::
        protected_body   *note 9.4::

     protected_type_declaration   *note 9.4::
        full_type_declaration   *note 3.2.1::

     punctuation_connector   ...
        identifier_extend   *note 2.3::

     qualified_expression   *note 4.7::
        allocator   *note 4.8::
        code_statement   *note 13.8::
        name   *note 4.1::

     quantified_expression   *note 4.5.8::
        primary   *note 4.4::

     quantifier   *note 4.5.8::
        quantified_expression   *note 4.5.8::

     raise_expression   *note 11.3::
        relation   *note 4.4::

     raise_statement   *note 11.3::
        simple_statement   *note 5.1::

     range   *note 3.5::
        discrete_choice   *note 3.8.1::
        discrete_range   *note 3.6.1::
        discrete_subtype_definition   *note 3.6::
        membership_choice   *note 4.4::
        range_constraint   *note 3.5::

     range_attribute_designator   *note 4.1.4::
        range_attribute_reference   *note 4.1.4::

     range_attribute_reference   *note 4.1.4::
        range   *note 3.5::

     range_constraint   *note 3.5::
        delta_constraint   *note J.3::
        digits_constraint   *note 3.5.9::
        scalar_constraint   *note 3.2.2::

     real_range_specification   *note 3.5.7::
        decimal_fixed_point_definition   *note 3.5.9::
        floating_point_definition   *note 3.5.7::
        ordinary_fixed_point_definition   *note 3.5.9::

     real_type_definition   *note 3.5.6::
        type_definition   *note 3.2.1::

     record_aggregate   *note 4.3.1::
        aggregate   *note 4.3::

     record_component_association   *note 4.3.1::
        record_component_association_list   *note 4.3.1::

     record_component_association_list   *note 4.3.1::
        extension_aggregate   *note 4.3.2::
        record_aggregate   *note 4.3.1::

     record_definition   *note 3.8::
        record_extension_part   *note 3.9.1::
        record_type_definition   *note 3.8::

     record_extension_part   *note 3.9.1::
        derived_type_definition   *note 3.4::

     record_representation_clause   *note 13.5.1::
        aspect_clause   *note 13.1::

     record_type_definition   *note 3.8::
        type_definition   *note 3.2.1::

     relation   *note 4.4::
        expression   *note 4.4::

     relational_operator   *note 4.5::
        choice_relation   *note 4.4::
        relation   *note 4.4::

     renaming_declaration   *note 8.5::
        basic_declaration   *note 3.1::

     requeue_statement   *note 9.5.4::
        simple_statement   *note 5.1::

     restriction_parameter_argument   *note 13.12::
        restriction   *note 13.12::

     return_subtype_indication   *note 6.5::
        extended_return_object_declaration   *note 6.5::

     scalar_constraint   *note 3.2.2::
        constraint   *note 3.2.2::

     select_alternative   *note 9.7.1::
        selective_accept   *note 9.7.1::

     select_statement   *note 9.7::
        compound_statement   *note 5.1::

     selected_component   *note 4.1.3::
        name   *note 4.1::

     selective_accept   *note 9.7.1::
        select_statement   *note 9.7::

     selector_name   *note 4.1.3::
        component_choice_list   *note 4.3.1::
        discriminant_association   *note 3.7.1::
        formal_package_association   *note 12.7::
        generic_association   *note 12.3::
        parameter_association   *note 6.4::
        selected_component   *note 4.1.3::

     sequence_of_statements   *note 5.1::
        abortable_part   *note 9.7.4::
        accept_alternative   *note 9.7.1::
        case_statement_alternative   *note 5.4::
        conditional_entry_call   *note 9.7.3::
        delay_alternative   *note 9.7.1::
        entry_call_alternative   *note 9.7.2::
        exception_handler   *note 11.2::
        handled_sequence_of_statements   *note 11.2::
        if_statement   *note 5.3::
        loop_statement   *note 5.5::
        selective_accept   *note 9.7.1::
        triggering_alternative   *note 9.7.4::

     signed_integer_type_definition   *note 3.5.4::
        integer_type_definition   *note 3.5.4::

     simple_expression   *note 4.4::
        choice_relation   *note 4.4::
        delta_constraint   *note J.3::
        digits_constraint   *note 3.5.9::
        first_bit   *note 13.5.1::
        last_bit   *note 13.5.1::
        membership_choice   *note 4.4::
        raise_expression   *note 11.3::
        range   *note 3.5::
        real_range_specification   *note 3.5.7::
        relation   *note 4.4::
        signed_integer_type_definition   *note 3.5.4::

     simple_return_statement   *note 6.5::
        simple_statement   *note 5.1::

     simple_statement   *note 5.1::
        statement   *note 5.1::

     single_protected_declaration   *note 9.4::
        object_declaration   *note 3.3.1::

     single_task_declaration   *note 9.1::
        object_declaration   *note 3.3.1::

     slice   *note 4.1.2::
        name   *note 4.1::

     statement   *note 5.1::
        sequence_of_statements   *note 5.1::

     statement_identifier   *note 5.1::
        block_statement   *note 5.6::
        label   *note 5.1::
        loop_statement   *note 5.5::

     string_element   *note 2.6::
        string_literal   *note 2.6::

     string_literal   *note 2.6::
        operator_symbol   *note 6.1::
        primary   *note 4.4::

     subpool_specification   *note 4.8::
        allocator   *note 4.8::

     subprogram_body   *note 6.3::
        library_unit_body   *note 10.1.1::
        proper_body   *note 3.11::
        protected_operation_item   *note 9.4::

     subprogram_body_stub   *note 10.1.3::
        body_stub   *note 10.1.3::

     subprogram_declaration   *note 6.1::
        basic_declaration   *note 3.1::
        library_unit_declaration   *note 10.1.1::
        protected_operation_declaration   *note 9.4::
        protected_operation_item   *note 9.4::

     subprogram_default   *note 12.6::
        formal_abstract_subprogram_declaration   *note 12.6::
        formal_concrete_subprogram_declaration   *note 12.6::

     subprogram_renaming_declaration   *note 8.5.4::
        library_unit_renaming_declaration   *note 10.1.1::
        renaming_declaration   *note 8.5::

     subprogram_specification   *note 6.1::
        abstract_subprogram_declaration   *note 3.9.3::
        formal_abstract_subprogram_declaration   *note 12.6::
        formal_concrete_subprogram_declaration   *note 12.6::
        generic_subprogram_declaration   *note 12.1::
        subprogram_body   *note 6.3::
        subprogram_body_stub   *note 10.1.3::
        subprogram_declaration   *note 6.1::
        subprogram_renaming_declaration   *note 8.5.4::

     subtype_declaration   *note 3.2.2::
        basic_declaration   *note 3.1::

     subtype_indication   *note 3.2.2::
        access_to_object_definition   *note 3.10::
        allocator   *note 4.8::
        component_definition   *note 3.6::
        derived_type_definition   *note 3.4::
        discrete_choice   *note 3.8.1::
        discrete_range   *note 3.6.1::
        discrete_subtype_definition   *note 3.6::
        iterator_specification   *note 5.5.2::
        object_declaration   *note 3.3.1::
        private_extension_declaration   *note 7.3::
        return_subtype_indication   *note 6.5::
        subtype_declaration   *note 3.2.2::

     subtype_mark   *note 3.2.2::
        access_definition   *note 3.10::
        ancestor_part   *note 4.3.2::
        discriminant_specification   *note 3.7::
        explicit_generic_actual_parameter   *note 12.3::
        formal_derived_type_definition   *note 12.5.1::
        formal_object_declaration   *note 12.4::
        index_subtype_definition   *note 3.6::
        interface_list   *note 3.9.4::
        membership_choice   *note 4.4::
        object_renaming_declaration   *note 8.5.1::
        parameter_and_result_profile   *note 6.1::
        parameter_specification   *note 6.1::
        qualified_expression   *note 4.7::
        subtype_indication   *note 3.2.2::
        type_conversion   *note 4.6::
        use_type_clause   *note 8.4::

     subunit   *note 10.1.3::
        compilation_unit   *note 10.1.1::

     task_body   *note 9.1::
        proper_body   *note 3.11::

     task_body_stub   *note 10.1.3::
        body_stub   *note 10.1.3::

     task_definition   *note 9.1::
        single_task_declaration   *note 9.1::
        task_type_declaration   *note 9.1::

     task_item   *note 9.1::
        task_definition   *note 9.1::

     task_type_declaration   *note 9.1::
        full_type_declaration   *note 3.2.1::

     term   *note 4.4::
        simple_expression   *note 4.4::

     terminate_alternative   *note 9.7.1::
        select_alternative   *note 9.7.1::

     timed_entry_call   *note 9.7.2::
        select_statement   *note 9.7::

     triggering_alternative   *note 9.7.4::
        asynchronous_select   *note 9.7.4::

     triggering_statement   *note 9.7.4::
        triggering_alternative   *note 9.7.4::

     type_conversion   *note 4.6::
        name   *note 4.1::

     type_declaration   *note 3.2.1::
        basic_declaration   *note 3.1::

     type_definition   *note 3.2.1::
        full_type_declaration   *note 3.2.1::

     unary_adding_operator   *note 4.5::
        simple_expression   *note 4.4::

     unconstrained_array_definition   *note 3.6::
        array_type_definition   *note 3.6::

     underline   ...
        based_numeral   *note 2.4.2::
        numeral   *note 2.4.1::

     unknown_discriminant_part   *note 3.7::
        discriminant_part   *note 3.7::

     use_clause   *note 8.4::
        basic_declarative_item   *note 3.11::
        context_item   *note 10.1.2::
        generic_formal_part   *note 12.1::

     use_package_clause   *note 8.4::
        use_clause   *note 8.4::

     use_type_clause   *note 8.4::
        use_clause   *note 8.4::

     variant   *note 3.8.1::
        variant_part   *note 3.8.1::

     variant_part   *note 3.8.1::
        component_list   *note 3.8::

     with_clause   *note 10.1.2::
        context_item   *note 10.1.2::


File: arm2012.info,  Node: Annex Q,  Next: Index,  Prev: Annex P,  Up: Top

Annex Q Language-Defined Entities
*********************************

1/2
This annex lists the language-defined entities of the language.  A list
of language-defined library units can be found in *note Annex A::,
"*note Annex A:: Predefined Language Environment".

* Menu:

* Q.1 ::      Language-Defined Packages
* Q.2 ::      Language-Defined Types and Subtypes
* Q.3 ::      Language-Defined Subprograms
* Q.4 ::      Language-Defined Exceptions
* Q.5 ::      Language-Defined Objects


File: arm2012.info,  Node: Q.1,  Next: Q.2,  Up: Annex Q

Q.1 Language-Defined Packages
=============================

1/3
This subclause lists all language-defined packages.

 

Ada   *note A.2(2): 5456.

Address_To_Access_Conversions
   child of System   *note 13.7.2(2): 5144.

Arithmetic
   child of Ada.Calendar   *note 9.6.1(8/2): 4173.

ASCII
   in Standard   *note A.1(36.3/2): 5445.

Assertions
   child of Ada   *note 11.4.2(12/2): 4604.

Asynchronous_Task_Control
   child of Ada   *note D.11(3/2): 7988.

Bounded
   child of Ada.Strings   *note A.4.4(3): 5843.

Bounded_IO
   child of Ada.Text_IO   *note A.10.11(3/2): 6537.
   child of Ada.Wide_Text_IO   *note A.11(4/3): 6561.
   child of Ada.Wide_Wide_Text_IO   *note A.11(4/3): 6562.

Bounded_Priority_Queues
   child of Ada.Containers   *note A.18.31(2/3): 7362.

Bounded_Synchronized_Queues
   child of Ada.Containers   *note A.18.29(2/3): 7349.

C
   child of Interfaces   *note B.3(4): 7432.

Calendar
   child of Ada   *note 9.6(10): 4145.

Characters
   child of Ada   *note A.3.1(2): 5457.

COBOL
   child of Interfaces   *note B.4(7): 7545.

Command_Line
   child of Ada   *note A.15(3): 6626.

Complex_Arrays
   child of Ada.Numerics   *note G.3.2(53/2): 8422.

Complex_Elementary_Functions
   child of Ada.Numerics   *note G.1.2(9/1): 8306.

Complex_Text_IO
   child of Ada   *note G.1.3(9.1/2): 8324.

Complex_Types
   child of Ada.Numerics   *note G.1.1(25/1): 8279.

Complex_IO
   child of Ada.Text_IO   *note G.1.3(3): 8314.
   child of Ada.Wide_Text_IO   *note G.1.4(1): 8326.
   child of Ada.Wide_Wide_Text_IO   *note G.1.5(1/2): 8328.

Constants
   child of Ada.Strings.Maps   *note A.4.6(3/2): 5954.

Containers
   child of Ada   *note A.18.1(3/2): 6715.

Conversions
   child of Ada.Characters   *note A.3.4(2/2): 5729.
   child of Ada.Strings.UTF_Encoding   *note A.4.11(15/3): 6075.

Decimal
   child of Ada   *note F.2(2): 8223.

Decimal_Conversions
   in Interfaces.COBOL   *note B.4(31): 7579.

Decimal_IO
   in Ada.Text_IO   *note A.10.1(73): 6501.

Decimal_Output
   in Ada.Text_IO.Editing   *note F.3.3(11): 8246.

Direct_IO
   child of Ada   *note A.8.4(2): 6323.

Directories
   child of Ada   *note A.16(3/2): 6635.

Discrete_Random
   child of Ada.Numerics   *note A.5.2(17): 6160.

Dispatching
   child of Ada   *note D.2.1(1.2/3): 7769.

Dispatching_Domains
   child of System.Multiprocessors   *note D.16.1(3/3): 8077.

Doubly_Linked_Lists
   child of Ada.Containers   *note A.18.3(5/3): 6822.

Dynamic_Priorities
   child of Ada   *note D.5.1(3/2): 7865.

EDF
   child of Ada.Dispatching   *note D.2.6(9/2): 7821.
   child of Ada.Synchronous_Task_Control   *note D.10(5.2/3): 7979.

Editing
   child of Ada.Text_IO   *note F.3.3(3): 8234.
   child of Ada.Wide_Text_IO   *note F.3.4(1): 8254.
   child of Ada.Wide_Wide_Text_IO   *note F.3.5(1/2): 8256.

Elementary_Functions
   child of Ada.Numerics   *note A.5.1(9/1): 6139.

Enumeration_IO
   in Ada.Text_IO   *note A.10.1(79): 6511.

Environment_Variables
   child of Ada   *note A.17(3/2): 6699.

Exceptions
   child of Ada   *note 11.4.1(2/2): 4564.

Execution_Time
   child of Ada   *note D.14(3/2): 7999.

Finalization
   child of Ada   *note 7.6(4/3): 3661.

Fixed
   child of Ada.Strings   *note A.4.3(5): 5807.

Fixed_IO
   in Ada.Text_IO   *note A.10.1(68): 6491.

Float_Random
   child of Ada.Numerics   *note A.5.2(5): 6147.

Float_Text_IO
   child of Ada   *note A.10.9(33): 6536.

Float_Wide_Text_IO
   child of Ada   *note A.11(2/2): 6557.

Float_Wide_Wide_Text_IO
   child of Ada   *note A.11(3/2): 6560.

Float_IO
   in Ada.Text_IO   *note A.10.1(63): 6481.

Formatting
   child of Ada.Calendar   *note 9.6.1(15/2): 4177.

Fortran
   child of Interfaces   *note B.5(4): 7599.

Generic_Complex_Arrays
   child of Ada.Numerics   *note G.3.2(2/2): 8386.

Generic_Complex_Elementary_Functions
   child of Ada.Numerics   *note G.1.2(2/2): 8285.

Generic_Complex_Types
   child of Ada.Numerics   *note G.1.1(2/1): 8258.

Generic_Dispatching_Constructor
   child of Ada.Tags   *note 3.9(18.2/3): 2125.

Generic_Elementary_Functions
   child of Ada.Numerics   *note A.5.1(3): 6110.

Generic_Bounded_Length
   in Ada.Strings.Bounded   *note A.4.4(4): 5844.

Generic_Keys
   in Ada.Containers.Hashed_Sets   *note A.18.8(50/2): 7087.
   in Ada.Containers.Ordered_Sets   *note A.18.9(62/2): 7165.

Generic_Real_Arrays
   child of Ada.Numerics   *note G.3.1(2/2): 8370.

Generic_Sorting
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(47/2): 6869.
   in Ada.Containers.Vectors   *note A.18.2(75/2): 6797.

Group_Budgets
   child of Ada.Execution_Time   *note D.14.2(3/3): 8030.

Handling
   child of Ada.Characters   *note A.3.2(2/2): 5460.
   child of Ada.Wide_Characters   *note A.3.5(3/3): 5748.
   child of Ada.Wide_Wide_Characters   *note A.3.6(1/3): 5769.

Hashed_Maps
   child of Ada.Containers   *note A.18.5(2/3): 6908.

Hashed_Sets
   child of Ada.Containers   *note A.18.8(2/3): 7040.

Hierarchical_File_Names
   child of Ada.Directories   *note A.16.1(3/3): 6686.

Indefinite_Doubly_Linked_Lists
   child of Ada.Containers   *note A.18.12(2/3): 7277.

Indefinite_Hashed_Maps
   child of Ada.Containers   *note A.18.13(2/3): 7278.

Indefinite_Hashed_Sets
   child of Ada.Containers   *note A.18.15(2/3): 7280.

Indefinite_Holders
   child of Ada.Containers   *note A.18.18(5/3): 7284.

Indefinite_Multiway_Trees
   child of Ada.Containers   *note A.18.17(2/3): 7282.

Indefinite_Ordered_Maps
   child of Ada.Containers   *note A.18.14(2/3): 7279.

Indefinite_Ordered_Sets
   child of Ada.Containers   *note A.18.16(2/3): 7281.

Indefinite_Vectors
   child of Ada.Containers   *note A.18.11(2/3): 7276.

Information
   child of Ada.Directories   *note A.16(124/2): 6685.

Integer_Text_IO
   child of Ada   *note A.10.8(21): 6535.

Integer_Wide_Text_IO
   child of Ada   *note A.11(2/2): 6556.

Integer_Wide_Wide_Text_IO
   child of Ada   *note A.11(3/2): 6559.

Integer_IO
   in Ada.Text_IO   *note A.10.1(52): 6463.

Interfaces   *note B.2(3): 7420.

Interrupts
   child of Ada   *note C.3.2(2/3): 7659.
   child of Ada.Execution_Time   *note D.14.3(3/3): 8055.

IO_Exceptions
   child of Ada   *note A.13(3): 6613.

Iterator_Interfaces
   child of Ada   *note 5.5.1(2/3): 3209.

Latin_1
   child of Ada.Characters   *note A.3.3(3): 5498.

List_Iterator_Interfaces
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(9.2/3): 6828.

Locales
   child of Ada   *note A.19(3/3): 7370.

Machine_Code
   child of System   *note 13.8(7): 5153.

Map_Iterator_Interfaces
   in Ada.Containers.Hashed_Maps   *note A.18.5(6.2/3): 6914.
   in Ada.Containers.Ordered_Maps   *note A.18.6(7.2/3): 6967.

Maps
   child of Ada.Strings   *note A.4.2(3/2): 5783.

Modular_IO
   in Ada.Text_IO   *note A.10.1(57): 6472.

Multiprocessors
   child of System   *note D.16(3/3): 8070.

Multiway_Trees
   child of Ada.Containers   *note A.18.10(7/3): 7201.

Names
   child of Ada.Interrupts   *note C.3.2(12): 7670.

Non_Preemptive
   child of Ada.Dispatching   *note D.2.4(2.2/3): 7806.

Numerics
   child of Ada   *note A.5(3/2): 6106.

Ordered_Maps
   child of Ada.Containers   *note A.18.6(2/3): 6960.

Ordered_Sets
   child of Ada.Containers   *note A.18.9(2/3): 7112.

Pointers
   child of Interfaces.C   *note B.3.2(4): 7518.

Real_Arrays
   child of Ada.Numerics   *note G.3.1(31/2): 8382.

Real_Time
   child of Ada   *note D.8(3): 7941.

Round_Robin
   child of Ada.Dispatching   *note D.2.5(4/2): 7813.

RPC
   child of System   *note E.5(3): 8204.

Sequential_IO
   child of Ada   *note A.8.1(2): 6298.

Set_Iterator_Interfaces
   in Ada.Containers.Hashed_Sets   *note A.18.8(6.2/3): 7046.
   in Ada.Containers.Ordered_Sets   *note A.18.9(7.2/3): 7119.

Single_Precision_Complex_Types
   in Interfaces.Fortran   *note B.5(8): 7604.

Standard   *note A.1(4): 5436.

Storage_Elements
   child of System   *note 13.7.1(2/2): 5132.

Storage_IO
   child of Ada   *note A.9(3): 6355.

Storage_Pools
   child of System   *note 13.11(5): 5187.

Stream_IO
   child of Ada.Streams   *note A.12.1(3/3): 6568.

Streams
   child of Ada   *note 13.13.1(2): 5333.

Strings
   child of Ada   *note A.4.1(3): 5770.
   child of Ada.Strings.UTF_Encoding   *note A.4.11(22/3): 6081.
   child of Interfaces.C   *note B.3.1(3): 7496.

Subpools
   child of System.Storage_Pools   *note 13.11.4(3/3): 5256.

Synchronized_Queue_Interfaces
   child of Ada.Containers   *note A.18.27(3/3): 7336.

Synchronous_Barriers
   child of Ada   *note D.10.1(3/3): 7984.

Synchronous_Task_Control
   child of Ada   *note D.10(3/2): 7973.

System   *note 13.7(3/2): 5105.

Tags
   child of Ada   *note 3.9(6/2): 2100.

Task_Attributes
   child of Ada   *note C.7.2(2): 7728.

Task_Identification
   child of Ada   *note C.7.1(2/2): 7708.

Task_Termination
   child of Ada   *note C.7.3(2/2): 7740.

Text_Streams
   child of Ada.Text_IO   *note A.12.2(3): 6604.
   child of Ada.Wide_Text_IO   *note A.12.3(3): 6607.
   child of Ada.Wide_Wide_Text_IO   *note A.12.4(3/2): 6610.

Text_IO
   child of Ada   *note A.10.1(2): 6374.

Time_Zones
   child of Ada.Calendar   *note 9.6.1(2/2): 4169.

Timers
   child of Ada.Execution_Time   *note D.14.1(3/2): 8015.

Timing_Events
   child of Ada.Real_Time   *note D.15(3/2): 8058.

Tree_Iterator_Interfaces
   in Ada.Containers.Multiway_Trees   *note A.18.10(13/3): 7207.

Unbounded
   child of Ada.Strings   *note A.4.5(3): 5902.

Unbounded_IO
   child of Ada.Text_IO   *note A.10.12(3/2): 6546.
   child of Ada.Wide_Text_IO   *note A.11(5/3): 6563.
   child of Ada.Wide_Wide_Text_IO   *note A.11(5/3): 6564.

Unbounded_Priority_Queues
   child of Ada.Containers   *note A.18.30(2/3): 7355.

Unbounded_Synchronized_Queues
   child of Ada.Containers   *note A.18.28(2/3): 7343.

UTF_Encoding
   child of Ada.Strings   *note A.4.11(3/3): 6064.

Vector_Iterator_Interfaces
   in Ada.Containers.Vectors   *note A.18.2(11.2/3): 6732.

Vectors
   child of Ada.Containers   *note A.18.2(6/3): 6724.

Wide_Bounded
   child of Ada.Strings   *note A.4.7(1/3): 5970.

Wide_Constants
   child of Ada.Strings.Wide_Maps   *note A.4.7(1/3): 5984, *note
A.4.8(28/2): 6045.

Wide_Equal_Case_Insensitive
   child of Ada.Strings   *note A.4.7(1/3): 5976.

Wide_Fixed
   child of Ada.Strings   *note A.4.7(1/3): 5969.

Wide_Hash
   child of Ada.Strings   *note A.4.7(1/3): 5972.

Wide_Hash_Case_Insensitive
   child of Ada.Strings   *note A.4.7(1/3): 5980.

Wide_Maps
   child of Ada.Strings   *note A.4.7(3): 5985.

Wide_Text_IO
   child of Ada   *note A.11(2/2): 6555.

Wide_Unbounded
   child of Ada.Strings   *note A.4.7(1/3): 5971.

Wide_Characters
   child of Ada   *note A.3.1(4/2): 5458.

Wide_Strings
   child of Ada.Strings.UTF_Encoding   *note A.4.11(30/3): 6088.

Wide_Wide_Constants
   child of Ada.Strings.Wide_Wide_Maps   *note A.4.8(1/3): 6023.

Wide_Wide_Equal_Case_Insensitive
   child of Ada.Strings   *note A.4.8(1/3): 6015.

Wide_Wide_Hash
   child of Ada.Strings   *note A.4.8(1/3): 6011.

Wide_Wide_Hash_Case_Insensitive
   child of Ada.Strings   *note A.4.8(1/3): 6019.

Wide_Wide_Text_IO
   child of Ada   *note A.11(3/2): 6558.

Wide_Wide_Bounded
   child of Ada.Strings   *note A.4.8(1/3): 6009.

Wide_Wide_Characters
   child of Ada   *note A.3.1(6/2): 5459.

Wide_Wide_Fixed
   child of Ada.Strings   *note A.4.8(1/3): 6008.

Wide_Wide_Maps
   child of Ada.Strings   *note A.4.8(3/2): 6024.

Wide_Wide_Strings
   child of Ada.Strings.UTF_Encoding   *note A.4.11(38/3): 6095.

Wide_Wide_Unbounded
   child of Ada.Strings   *note A.4.8(1/3): 6010.


File: arm2012.info,  Node: Q.2,  Next: Q.3,  Prev: Q.1,  Up: Annex Q

Q.2 Language-Defined Types and Subtypes
=======================================

1/3
This subclause lists all language-defined types and subtypes.

 

Address
   in System   *note 13.7(12): 5117.

Alignment
   in Ada.Strings   *note A.4.1(6): 5778.

Alphanumeric
   in Interfaces.COBOL   *note B.4(16/3): 7557.

Any_Priority subtype of Integer
   in System   *note 13.7(16): 5127.

Attribute_Handle
   in Ada.Task_Attributes   *note C.7.2(3): 7729.

Barrier_Limit subtype of Positive
   in Ada.Synchronous_Barriers   *note D.10.1(4/3): 7985.

Binary
   in Interfaces.COBOL   *note B.4(10): 7548.

Binary_Format
   in Interfaces.COBOL   *note B.4(24): 7569.

Bit_Order
   in System   *note 13.7(15/2): 5123.

Boolean
   in Standard   *note A.1(5): 5437.

Bounded_String
   in Ada.Strings.Bounded   *note A.4.4(6): 5846.

Buffer_Type subtype of Storage_Array
   in Ada.Storage_IO   *note A.9(4): 6357.

Byte
   in Interfaces.COBOL   *note B.4(29/3): 7576.

Byte_Array
   in Interfaces.COBOL   *note B.4(29/3): 7577.

C_float
   in Interfaces.C   *note B.3(15): 7448.

Cause_Of_Termination
   in Ada.Task_Termination   *note C.7.3(3/2): 7741.

char
   in Interfaces.C   *note B.3(19): 7451.

char16_array
   in Interfaces.C   *note B.3(39.5/3): 7475.

char16_t
   in Interfaces.C   *note B.3(39.2/2): 7471.

char32_array
   in Interfaces.C   *note B.3(39.14/3): 7485.

char32_t
   in Interfaces.C   *note B.3(39.11/2): 7481.

char_array
   in Interfaces.C   *note B.3(23/3): 7455.

char_array_access
   in Interfaces.C.Strings   *note B.3.1(4): 7497.

Character
   in Standard   *note A.1(35/3): 5442.

Character_Mapping
   in Ada.Strings.Maps   *note A.4.2(20/2): 5797.

Character_Mapping_Function
   in Ada.Strings.Maps   *note A.4.2(25): 5803.

Character_Range
   in Ada.Strings.Maps   *note A.4.2(6): 5786.

Character_Ranges
   in Ada.Strings.Maps   *note A.4.2(7): 5787.

Character_Sequence subtype of String
   in Ada.Strings.Maps   *note A.4.2(16): 5793.

Character_Set
   in Ada.Strings.Maps   *note A.4.2(4/2): 5784.
   in Interfaces.Fortran   *note B.5(11): 7609.

chars_ptr
   in Interfaces.C.Strings   *note B.3.1(5/2): 7498.

chars_ptr_array
   in Interfaces.C.Strings   *note B.3.1(6/2): 7499.

COBOL_Character
   in Interfaces.COBOL   *note B.4(13): 7554.

Complex
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(3): 8259.
   in Interfaces.Fortran   *note B.5(9): 7605.

Complex_Matrix
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(4/2): 8388.

Complex_Vector
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(4/2): 8387.

Constant_Reference_Type
   in Ada.Containers.Indefinite_Holders   *note A.18.18(16/3): 7294.
   in Ada.Containers.Multiway_Trees   *note A.18.10(28/3): 7221.

Controlled
   in Ada.Finalization   *note 7.6(5/2): 3662.

Count
   in Ada.Direct_IO   *note A.8.4(4): 6326.
   in Ada.Streams.Stream_IO   *note A.12.1(7): 6572.
   in Ada.Text_IO   *note A.10.1(5): 6377.

Count_Type
   in Ada.Containers   *note A.18.1(5/2): 6717.

Country_Code
   in Ada.Locales   *note A.19(4/4): 7372.

CPU subtype of CPU_Range
   in System.Multiprocessors   *note D.16(4/3): 8073.

CPU_Range
   in System.Multiprocessors   *note D.16(4/3): 8071.

CPU_Set
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(9.1/4):
8084.

CPU_Time
   in Ada.Execution_Time   *note D.14(4/2): 8000.

Cursor
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(7/2): 6824.
   in Ada.Containers.Hashed_Maps   *note A.18.5(4/2): 6910.
   in Ada.Containers.Hashed_Sets   *note A.18.8(4/2): 7042.
   in Ada.Containers.Multiway_Trees   *note A.18.10(9/3): 7203.
   in Ada.Containers.Ordered_Maps   *note A.18.6(5/2): 6963.
   in Ada.Containers.Ordered_Sets   *note A.18.9(5/2): 7115.
   in Ada.Containers.Vectors   *note A.18.2(9/2): 6728.

Day_Count
   in Ada.Calendar.Arithmetic   *note 9.6.1(10/2): 4174.

Day_Duration subtype of Duration
   in Ada.Calendar   *note 9.6(11/2): 4150.

Day_Name
   in Ada.Calendar.Formatting   *note 9.6.1(17/2): 4178.

Day_Number subtype of Integer
   in Ada.Calendar   *note 9.6(11/2): 4149.

Deadline subtype of Time
   in Ada.Dispatching.EDF   *note D.2.6(9/2): 7822.

Decimal_Element
   in Interfaces.COBOL   *note B.4(12/3): 7552.

Direction
   in Ada.Strings   *note A.4.1(6): 5781.

Directory_Entry_Type
   in Ada.Directories   *note A.16(29/2): 6659.

Dispatching_Domain
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(5/3):
8079.

Display_Format
   in Interfaces.COBOL   *note B.4(22): 7563.

double
   in Interfaces.C   *note B.3(16): 7449.

Double_Precision
   in Interfaces.Fortran   *note B.5(6): 7602.

Duration
   in Standard   *note A.1(43): 5450.

Encoding_Scheme
   in Ada.Strings.UTF_Encoding   *note A.4.11(4/3): 6065.

Exception_Id
   in Ada.Exceptions   *note 11.4.1(2/2): 4565.

Exception_Occurrence
   in Ada.Exceptions   *note 11.4.1(3/2): 4570.

Exception_Occurrence_Access
   in Ada.Exceptions   *note 11.4.1(3/2): 4571.

Exit_Status
   in Ada.Command_Line   *note A.15(7): 6630.

Extended_Index subtype of Index_Type'Base
   in Ada.Containers.Vectors   *note A.18.2(7/2): 6725.

Field subtype of Integer
   in Ada.Text_IO   *note A.10.1(6): 6380.

File_Access
   in Ada.Text_IO   *note A.10.1(18): 6402.

File_Kind
   in Ada.Directories   *note A.16(22/2): 6653.

File_Mode
   in Ada.Direct_IO   *note A.8.4(4): 6325.
   in Ada.Sequential_IO   *note A.8.1(4): 6300.
   in Ada.Streams.Stream_IO   *note A.12.1(6): 6571.
   in Ada.Text_IO   *note A.10.1(4): 6376.

File_Size
   in Ada.Directories   *note A.16(23/2): 6654.

File_Type
   in Ada.Direct_IO   *note A.8.4(3): 6324.
   in Ada.Sequential_IO   *note A.8.1(3): 6299.
   in Ada.Streams.Stream_IO   *note A.12.1(5/4): 6570.
   in Ada.Text_IO   *note A.10.1(3): 6375.

Filter_Type
   in Ada.Directories   *note A.16(30/2): 6660.

Float
   in Standard   *note A.1(21): 5441.

Floating
   in Interfaces.COBOL   *note B.4(9): 7546.

Fortran_Character
   in Interfaces.Fortran   *note B.5(12/3): 7610.

Fortran_Integer
   in Interfaces.Fortran   *note B.5(5): 7600.

Forward_Iterator
   in Ada.Iterator_Interfaces   *note 5.5.1(3/3): 3210.

Generator
   in Ada.Numerics.Discrete_Random   *note A.5.2(19): 6161.
   in Ada.Numerics.Float_Random   *note A.5.2(7): 6148.

Group_Budget
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(4/3): 8031.

Group_Budget_Handler
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(5/2): 8032.

Hash_Type
   in Ada.Containers   *note A.18.1(4/2): 6716.

Holder
   in Ada.Containers.Indefinite_Holders   *note A.18.18(6/3): 7285.

Hour_Number subtype of Natural
   in Ada.Calendar.Formatting   *note 9.6.1(20/2): 4187.

Imaginary
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(4/2): 8260.

Imaginary subtype of Imaginary
   in Interfaces.Fortran   *note B.5(10): 7606.

int
   in Interfaces.C   *note B.3(7): 7437.

Integer
   in Standard   *note A.1(12): 5438.

Integer_Address
   in System.Storage_Elements   *note 13.7.1(10/3): 5138.

Interrupt_Id
   in Ada.Interrupts   *note C.3.2(2/3): 7660.

Interrupt_Priority subtype of Any_Priority
   in System   *note 13.7(16): 5129.

ISO_646 subtype of Character
   in Ada.Characters.Handling   *note A.3.2(9): 5483.

Language_Code
   in Ada.Locales   *note A.19(4/4): 7371.

Leap_Seconds_Count subtype of Integer
   in Ada.Calendar.Arithmetic   *note 9.6.1(11/2): 4175.

Length_Range subtype of Natural
   in Ada.Strings.Bounded   *note A.4.4(8): 5848.

Limited_Controlled
   in Ada.Finalization   *note 7.6(7/2): 3666.

List
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(6/3): 6823.

Logical
   in Interfaces.Fortran   *note B.5(7): 7603.

long
   in Interfaces.C   *note B.3(7): 7439.

Long_Binary
   in Interfaces.COBOL   *note B.4(10): 7549.

long_double
   in Interfaces.C   *note B.3(17): 7450.

Long_Floating
   in Interfaces.COBOL   *note B.4(9): 7547.

Map
   in Ada.Containers.Hashed_Maps   *note A.18.5(3/3): 6909.
   in Ada.Containers.Ordered_Maps   *note A.18.6(4/3): 6962.

Membership
   in Ada.Strings   *note A.4.1(6): 5780.

Minute_Number subtype of Natural
   in Ada.Calendar.Formatting   *note 9.6.1(20/2): 4188.

Month_Number subtype of Integer
   in Ada.Calendar   *note 9.6(11/2): 4148.

Name
   in System   *note 13.7(4): 5106.

Name_Case_Kind
   in Ada.Directories   *note A.16(20.1/3): 6651.

Natural subtype of Integer
   in Standard   *note A.1(13): 5439.

Number_Base subtype of Integer
   in Ada.Text_IO   *note A.10.1(6): 6381.

Numeric
   in Interfaces.COBOL   *note B.4(20/3): 7562.

Packed_Decimal
   in Interfaces.COBOL   *note B.4(12/3): 7553.

Packed_Format
   in Interfaces.COBOL   *note B.4(26): 7573.

Parameterless_Handler
   in Ada.Interrupts   *note C.3.2(2/3): 7661.

Params_Stream_Type
   in System.RPC   *note E.5(6): 8207.

Partition_Id
   in System.RPC   *note E.5(4): 8205.

Picture
   in Ada.Text_IO.Editing   *note F.3.3(4): 8235.

plain_char
   in Interfaces.C   *note B.3(11): 7445.

Pointer
   in Interfaces.C.Pointers   *note B.3.2(5): 7519.

Positive subtype of Integer
   in Standard   *note A.1(13): 5440.

Positive_Count subtype of Count
   in Ada.Direct_IO   *note A.8.4(4): 6327.
   in Ada.Streams.Stream_IO   *note A.12.1(7): 6573.
   in Ada.Text_IO   *note A.10.1(5): 6378.

Priority subtype of Any_Priority
   in System   *note 13.7(16): 5128.

ptrdiff_t
   in Interfaces.C   *note B.3(12): 7446.

Queue
   in Ada.Containers.Bounded_Priority_Queues   *note A.18.31(4/3): 7363.
   in Ada.Containers.Bounded_Synchronized_Queues   *note A.18.29(4/3):
7350.
   in Ada.Containers.Synchronized_Queue_Interfaces   *note A.18.27(4/3):
7337.
   in Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(4/3):
7356.
   in Ada.Containers.Unbounded_Synchronized_Queues   *note A.18.28(4/3):
7344.

Real
   in Interfaces.Fortran   *note B.5(6): 7601.

Real_Matrix
   in Ada.Numerics.Generic_Real_Arrays   *note G.3.1(4/2): 8372.

Real_Vector
   in Ada.Numerics.Generic_Real_Arrays   *note G.3.1(4/2): 8371.

Reference_Type
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(17.2/3): 6836.
   in Ada.Containers.Hashed_Maps   *note A.18.5(17.2/3): 6925.
   in Ada.Containers.Hashed_Sets   *note A.18.8(58.1/3): 7096.
   in Ada.Containers.Indefinite_Holders   *note A.18.18(17/3): 7295.
   in Ada.Containers.Multiway_Trees   *note A.18.10(29/3): 7222.
   in Ada.Containers.Ordered_Maps   *note A.18.6(16.2/3): 6976.
   in Ada.Containers.Ordered_Sets   *note A.18.9(73.1/3): 7177.
   in Ada.Containers.Vectors   *note A.18.2(34.2/3): 6751.

Reversible_Iterator
   in Ada.Iterator_Interfaces   *note 5.5.1(4/3): 3213.

Root_Storage_Pool
   in System.Storage_Pools   *note 13.11(6/2): 5188.

Root_Storage_Pool_With_Subpools
   in System.Storage_Pools.Subpools   *note 13.11.4(4/3): 5257.

Root_Stream_Type
   in Ada.Streams   *note 13.13.1(3/2): 5335.

Root_Subpool
   in System.Storage_Pools.Subpools   *note 13.11.4(5/3): 5258.

RPC_Receiver
   in System.RPC   *note E.5(11): 8212.

Search_Type
   in Ada.Directories   *note A.16(31/2): 6661.

Second_Duration subtype of Day_Duration
   in Ada.Calendar.Formatting   *note 9.6.1(20/2): 4190.

Second_Number subtype of Natural
   in Ada.Calendar.Formatting   *note 9.6.1(20/2): 4189.

Seconds_Count
   in Ada.Real_Time   *note D.8(15): 7960.

Set
   in Ada.Containers.Hashed_Sets   *note A.18.8(3/3): 7041.
   in Ada.Containers.Ordered_Sets   *note A.18.9(4/3): 7114.

short
   in Interfaces.C   *note B.3(7): 7438.

signed_char
   in Interfaces.C   *note B.3(8): 7440.

size_t
   in Interfaces.C   *note B.3(13): 7447.

State
   in Ada.Numerics.Discrete_Random   *note A.5.2(23): 6165.
   in Ada.Numerics.Float_Random   *note A.5.2(11): 6153.

Storage_Array
   in System.Storage_Elements   *note 13.7.1(5): 5136.

Storage_Count subtype of Storage_Offset
   in System.Storage_Elements   *note 13.7.1(4): 5134.

Storage_Element
   in System.Storage_Elements   *note 13.7.1(5): 5135.

Storage_Offset
   in System.Storage_Elements   *note 13.7.1(3): 5133.

Stream_Access
   in Ada.Streams.Stream_IO   *note A.12.1(4): 6569.
   in Ada.Text_IO.Text_Streams   *note A.12.2(3): 6605.
   in Ada.Wide_Text_IO.Text_Streams   *note A.12.3(3): 6608.
   in Ada.Wide_Wide_Text_IO.Text_Streams   *note A.12.4(3/2): 6611.

Stream_Element
   in Ada.Streams   *note 13.13.1(4/1): 5336.

Stream_Element_Array
   in Ada.Streams   *note 13.13.1(4/1): 5339.

Stream_Element_Count subtype of Stream_Element_Offset
   in Ada.Streams   *note 13.13.1(4/1): 5338.

Stream_Element_Offset
   in Ada.Streams   *note 13.13.1(4/1): 5337.

String
   in Standard   *note A.1(37/3): 5447.

String_Access
   in Ada.Strings.Unbounded   *note A.4.5(7): 5906.

Subpool_Handle
   in System.Storage_Pools.Subpools   *note 13.11.4(6/3): 5259.

Suspension_Object
   in Ada.Synchronous_Task_Control   *note D.10(4): 7974.

Synchronous_Barrier
   in Ada.Synchronous_Barriers   *note D.10.1(5/3): 7986.

Tag
   in Ada.Tags   *note 3.9(6/2): 2101.

Tag_Array
   in Ada.Tags   *note 3.9(7.3/2): 2111.

Task_Array
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(6/2): 8033.

Task_Id
   in Ada.Task_Identification   *note C.7.1(2/2): 7709.

Termination_Handler
   in Ada.Task_Termination   *note C.7.3(4/2): 7742.

Time
   in Ada.Calendar   *note 9.6(10): 4146.
   in Ada.Real_Time   *note D.8(4): 7942.

Time_Offset
   in Ada.Calendar.Time_Zones   *note 9.6.1(4/2): 4170.

Time_Span
   in Ada.Real_Time   *note D.8(5): 7946.

Timer
   in Ada.Execution_Time.Timers   *note D.14.1(4/2): 8016.

Timer_Handler
   in Ada.Execution_Time.Timers   *note D.14.1(5/2): 8017.

Timing_Event
   in Ada.Real_Time.Timing_Events   *note D.15(4/2): 8059.

Timing_Event_Handler
   in Ada.Real_Time.Timing_Events   *note D.15(4/2): 8060.

Tree
   in Ada.Containers.Multiway_Trees   *note A.18.10(8/3): 7202.

Trim_End
   in Ada.Strings   *note A.4.1(6): 5782.

Truncation
   in Ada.Strings   *note A.4.1(6): 5779.

Type_Set
   in Ada.Text_IO   *note A.10.1(7): 6382.

Unbounded_String
   in Ada.Strings.Unbounded   *note A.4.5(4/2): 5903.

Uniformly_Distributed subtype of Float
   in Ada.Numerics.Float_Random   *note A.5.2(8): 6149.

unsigned
   in Interfaces.C   *note B.3(9): 7441.

unsigned_char
   in Interfaces.C   *note B.3(10): 7444.

unsigned_long
   in Interfaces.C   *note B.3(9): 7443.

unsigned_short
   in Interfaces.C   *note B.3(9): 7442.

UTF_16_Wide_String subtype of Wide_String
   in Ada.Strings.UTF_Encoding   *note A.4.11(7/3): 6068.

UTF_8_String subtype of String
   in Ada.Strings.UTF_Encoding   *note A.4.11(6/3): 6067.

UTF_String subtype of String
   in Ada.Strings.UTF_Encoding   *note A.4.11(5/3): 6066.

Vector
   in Ada.Containers.Vectors   *note A.18.2(8/3): 6727.

wchar_array
   in Interfaces.C   *note B.3(33/3): 7465.

wchar_t
   in Interfaces.C   *note B.3(30/1): 7461.

Wide_Character
   in Standard   *note A.1(36.1/3): 5443.

Wide_Character_Mapping
   in Ada.Strings.Wide_Maps   *note A.4.7(20/2): 5999.

Wide_Character_Mapping_Function
   in Ada.Strings.Wide_Maps   *note A.4.7(26): 6005.

Wide_Character_Range
   in Ada.Strings.Wide_Maps   *note A.4.7(6): 5988.

Wide_Character_Ranges
   in Ada.Strings.Wide_Maps   *note A.4.7(7): 5989.

Wide_Character_Sequence subtype of Wide_String
   in Ada.Strings.Wide_Maps   *note A.4.7(16): 5995.

Wide_Character_Set
   in Ada.Strings.Wide_Maps   *note A.4.7(4/2): 5986.

Wide_String
   in Standard   *note A.1(41/3): 5448.

Wide_Wide_Character
   in Standard   *note A.1(36.2/3): 5444.

Wide_Wide_Character_Mapping
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(20/2): 6038.

Wide_Wide_Character_Mapping_Function
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(26/2): 6044.

Wide_Wide_Character_Range
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(6/2): 6027.

Wide_Wide_Character_Ranges
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(7/2): 6028.

Wide_Wide_Character_Sequence subtype of Wide_Wide_String
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(16/2): 6034.

Wide_Wide_Character_Set
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(4/2): 6025.

Wide_Wide_String
   in Standard   *note A.1(42.1/3): 5449.

Year_Number subtype of Integer
   in Ada.Calendar   *note 9.6(11/2): 4147.


File: arm2012.info,  Node: Q.3,  Next: Q.4,  Prev: Q.2,  Up: Annex Q

Q.3 Language-Defined Subprograms
================================

1/3
This subclause lists all language-defined subprograms.

 

Abort_Task in Ada.Task_Identification   *note C.7.1(3/3): 7714.

Activation_Is_Complete
   in Ada.Task_Identification   *note C.7.1(4/3): 7717.

Actual_Quantum
   in Ada.Dispatching.Round_Robin   *note D.2.5(4/2): 7817.

Ada.Unchecked_Deallocate_Subpool
   child of Ada   *note 13.11.5(3/3): 5287.

Add
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(9/2): 8041.

Add_Task
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(8/2): 8035.

Adjust in Ada.Finalization   *note 7.6(6/2): 3664.

Allocate
   in System.Storage_Pools   *note 13.11(7): 5189.
   in System.Storage_Pools.Subpools   *note 13.11.4(14/3): 5266.

Allocate_From_Subpool
   in System.Storage_Pools.Subpools   *note 13.11.4(11/3): 5263.

Ancestor_Find
   in Ada.Containers.Multiway_Trees   *note A.18.10(40/3): 7233.

Append
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(23/2): 6846.
   in Ada.Containers.Vectors   *note A.18.2(46/2): 6769, *note
A.18.2(47/2): 6770.
   in Ada.Strings.Bounded   *note A.4.4(13): 5853, *note A.4.4(14):
5854, *note A.4.4(15): 5855, *note A.4.4(16): 5856, *note A.4.4(17):
5857, *note A.4.4(18): 5858, *note A.4.4(19): 5859, *note A.4.4(20):
5860.
   in Ada.Strings.Unbounded   *note A.4.5(12): 5912, *note A.4.5(13):
5913, *note A.4.5(14): 5914.

Append_Child
   in Ada.Containers.Multiway_Trees   *note A.18.10(52/3): 7245.

Arccos
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(5): 8295.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(6): 6125.

Arccosh
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(7): 8303.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7): 6136.

Arccot
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(5): 8297.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(6): 6130.

Arccoth
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(7): 8305.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7): 6138.

Arcsin
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(5): 8294.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(6): 6124.

Arcsinh
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(7): 8302.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7): 6135.

Arctan
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(5): 8296.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(6): 6128.

Arctanh
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(7): 8304.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7): 6137.

Argument
   in Ada.Command_Line   *note A.15(5): 6628.
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(10/2): 8397,
*note G.3.2(31/2): 8409.
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(10): 8273.

Argument_Count in Ada.Command_Line   *note A.15(4): 6627.

Assert in Ada.Assertions   *note 11.4.2(14/2): 4606.

Assign
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(17.5/3): 6839.
   in Ada.Containers.Hashed_Maps   *note A.18.5(17.7/3): 6930.
   in Ada.Containers.Hashed_Sets   *note A.18.8(17.3/3): 7058.
   in Ada.Containers.Indefinite_Holders   *note A.18.18(20/3): 7298.
   in Ada.Containers.Multiway_Trees   *note A.18.10(32/3): 7225.
   in Ada.Containers.Ordered_Maps   *note A.18.6(16.7/3): 6981.
   in Ada.Containers.Ordered_Sets   *note A.18.9(16.3/3): 7129.
   in Ada.Containers.Vectors   *note A.18.2(34.7/3): 6756.

Assign_Task
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(11/3):
8088.

Attach_Handler in Ada.Interrupts   *note C.3.2(7): 7665.

Base_Name in Ada.Directories   *note A.16(19/2): 6649.

Blank_When_Zero
   in Ada.Text_IO.Editing   *note F.3.3(7): 8239.

Bounded_Slice in Ada.Strings.Bounded   *note A.4.4(28.1/2): 5864, *note
A.4.4(28.2/2): 5865.

Budget_Has_Expired
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(9/2): 8042.

Budget_Remaining
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(9/2): 8043.

Cancel_Handler
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(10/2): 8046.
   in Ada.Execution_Time.Timers   *note D.14.1(7/2): 8022.
   in Ada.Real_Time.Timing_Events   *note D.15(5/2): 8064.

Capacity
   in Ada.Containers.Hashed_Maps   *note A.18.5(8/2): 6915.
   in Ada.Containers.Hashed_Sets   *note A.18.8(10/2): 7049.
   in Ada.Containers.Vectors   *note A.18.2(19/2): 6735.

Ceiling
   in Ada.Containers.Ordered_Maps   *note A.18.6(41/2): 7007.
   in Ada.Containers.Ordered_Sets   *note A.18.9(51/2): 7161, *note
A.18.9(71/2): 7174.

Character_Set_Version
   in Ada.Wide_Characters.Handling   *note A.3.5(4/3): 5749.

Child_Count
   in Ada.Containers.Multiway_Trees   *note A.18.10(46/3): 7239.

Child_Depth
   in Ada.Containers.Multiway_Trees   *note A.18.10(47/3): 7240.

Clear
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(13/2): 6831.
   in Ada.Containers.Hashed_Maps   *note A.18.5(12/2): 6919.
   in Ada.Containers.Hashed_Sets   *note A.18.8(14/2): 7053.
   in Ada.Containers.Indefinite_Holders   *note A.18.18(11/3): 7289.
   in Ada.Containers.Multiway_Trees   *note A.18.10(23/3): 7216.
   in Ada.Containers.Ordered_Maps   *note A.18.6(11/2): 6970.
   in Ada.Containers.Ordered_Sets   *note A.18.9(13/2): 7124.
   in Ada.Containers.Vectors   *note A.18.2(24/2): 6740.
   in Ada.Environment_Variables   *note A.17(7/2): 6704.

Clock
   in Ada.Calendar   *note 9.6(12): 4151.
   in Ada.Execution_Time   *note D.14(5/2): 8005.
   in Ada.Execution_Time.Interrupts   *note D.14.3(3/3): 8056.
   in Ada.Real_Time   *note D.8(6): 7952.

Clock_For_Interrupts
   in Ada.Execution_Time   *note D.14(9.3/3): 8010.

Close
   in Ada.Direct_IO   *note A.8.4(8): 6330.
   in Ada.Sequential_IO   *note A.8.1(8): 6303.
   in Ada.Streams.Stream_IO   *note A.12.1(10): 6576.
   in Ada.Text_IO   *note A.10.1(11): 6385.

Col in Ada.Text_IO   *note A.10.1(37): 6438.

Command_Name in Ada.Command_Line   *note A.15(6): 6629.

Compose
   in Ada.Directories   *note A.16(20/2): 6650.
   in Ada.Directories.Hierarchical_File_Names   *note A.16.1(14/3):
6697.

Compose_From_Cartesian
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(9/2): 8394,
*note G.3.2(29/2): 8406.
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(8): 8270.

Compose_From_Polar
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(11/2): 8398,
*note G.3.2(32/2): 8411.
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(11): 8275.

Conjugate
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(13/2): 8400,
*note G.3.2(34/2): 8413.
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(12): 8277, *note
G.1.1(15): 8278.

Constant_Reference
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(17.3/3): 6837.
   in Ada.Containers.Hashed_Maps   *note A.18.5(17.3/3): 6926, *note
A.18.5(17.5/3): 6928.
   in Ada.Containers.Hashed_Sets   *note A.18.8(17.2/3): 7057, *note
A.18.8(58.3/3): 7098.
   in Ada.Containers.Indefinite_Holders   *note A.18.18(18/3): 7296.
   in Ada.Containers.Multiway_Trees   *note A.18.10(30/3): 7223.
   in Ada.Containers.Ordered_Maps   *note A.18.6(16.3/3): 6977, *note
A.18.6(16.5/3): 6979.
   in Ada.Containers.Ordered_Sets   *note A.18.9(16.2/3): 7128, *note
A.18.9(73.3/3): 7179.
   in Ada.Containers.Vectors   *note A.18.2(34.3/3): 6752, *note
A.18.2(34.5/3): 6754.

Containing_Directory
   in Ada.Directories   *note A.16(17/2): 6647.
   in Ada.Directories.Hierarchical_File_Names   *note A.16.1(11/3):
6694.

Contains
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(43/2): 6866.
   in Ada.Containers.Hashed_Maps   *note A.18.5(32/2): 6946.
   in Ada.Containers.Hashed_Sets   *note A.18.8(44/2): 7082, *note
A.18.8(57/2): 7094.
   in Ada.Containers.Multiway_Trees   *note A.18.10(41/3): 7234.
   in Ada.Containers.Ordered_Maps   *note A.18.6(42/2): 7008.
   in Ada.Containers.Ordered_Sets   *note A.18.9(52/2): 7162, *note
A.18.9(72/2): 7175.
   in Ada.Containers.Vectors   *note A.18.2(71/2): 6794.

Continue
   in Ada.Asynchronous_Task_Control   *note D.11(3/2): 7990.

Convert
   in Ada.Strings.UTF_Encoding.Conversions   *note A.4.11(16/3): 6076,
*note A.4.11(17/3): 6077, *note A.4.11(18/3): 6078, *note A.4.11(19/3):
6079, *note A.4.11(20/3): 6080.

Copy
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(17.6/3): 6840.
   in Ada.Containers.Hashed_Maps   *note A.18.5(17.8/3): 6931.
   in Ada.Containers.Hashed_Sets   *note A.18.8(17.4/3): 7059.
   in Ada.Containers.Indefinite_Holders   *note A.18.18(21/3): 7299,
*note A.18.20(10/3): 7311, *note A.18.21(13/3): 7315, *note
A.18.22(10/3): 7318, *note A.18.23(13/3): 7322, *note A.18.24(10/3):
7325.
   in Ada.Containers.Multiway_Trees   *note A.18.10(33/3): 7226.
   in Ada.Containers.Ordered_Maps   *note A.18.6(16.8/3): 6982.
   in Ada.Containers.Ordered_Sets   *note A.18.9(16.4/3): 7130.
   in Ada.Containers.Vectors   *note A.18.2(34.8/3): 6757.

Copy_Array in Interfaces.C.Pointers   *note B.3.2(15): 7527.

Copy_File in Ada.Directories   *note A.16(13/2): 6644.

Copy_Subtree
   in Ada.Containers.Multiway_Trees   *note A.18.10(54/3): 7247.

Copy_Terminated_Array
   in Interfaces.C.Pointers   *note B.3.2(14): 7526.

Cos
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(4): 8291.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(5): 6117.

Cosh
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(6): 8299.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7): 6132.

Cot
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(4): 8293.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(5): 6121.

Coth
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(6): 8301.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7): 6134.

Count
   in Ada.Strings.Bounded   *note A.4.4(48): 5874, *note A.4.4(49):
5875, *note A.4.4(50): 5876.
   in Ada.Strings.Fixed   *note A.4.3(13): 5817, *note A.4.3(14): 5818,
*note A.4.3(15): 5819.
   in Ada.Strings.Unbounded   *note A.4.5(43): 5928, *note A.4.5(44):
5929, *note A.4.5(45): 5930.

Country in Ada.Locales   *note A.19(6/3): 7376.

Create
   in Ada.Direct_IO   *note A.8.4(6): 6328.
   in Ada.Sequential_IO   *note A.8.1(6): 6301.
   in Ada.Streams.Stream_IO   *note A.12.1(8): 6574.
   in Ada.Text_IO   *note A.10.1(9): 6383.
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(7/4):
8081, *note D.16.1(9.2/4): 8085.

Create_Directory in Ada.Directories   *note A.16(7/2): 6638.

Create_Path in Ada.Directories   *note A.16(9/2): 6640.

Create_Subpool
   in System.Storage_Pools.Subpools   *note 13.11.4(7/3): 5260.

Current_Directory in Ada.Directories   *note A.16(5/2): 6636.

Current_Error in Ada.Text_IO   *note A.10.1(17): 6401, *note A.10.1(20):
6408.

Current_Handler
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(10/2): 8045.
   in Ada.Execution_Time.Timers   *note D.14.1(7/2): 8021.
   in Ada.Interrupts   *note C.3.2(6): 7664.
   in Ada.Real_Time.Timing_Events   *note D.15(5/2): 8063.

Current_Input in Ada.Text_IO   *note A.10.1(17): 6399, *note A.10.1(20):
6406.

Current_Output in Ada.Text_IO   *note A.10.1(17): 6400, *note
A.10.1(20): 6407.

Current_State
   in Ada.Synchronous_Task_Control   *note D.10(4): 7977.

Current_Task
   in Ada.Task_Identification   *note C.7.1(3/3): 7712.

Current_Task_Fallback_Handler
   in Ada.Task_Termination   *note C.7.3(5/2): 7744.

Current_Use
   in Ada.Containers.Bounded_Priority_Queues   *note A.18.31(7/3): 7367.
   in Ada.Containers.Bounded_Synchronized_Queues   *note A.18.29(6/3):
7353.
   in Ada.Containers.Synchronized_Queue_Interfaces   *note A.18.27(7/3):
7340.
   in Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(7/3):
7360.
   in Ada.Containers.Unbounded_Synchronized_Queues   *note A.18.28(6/3):
7347.

Day
   in Ada.Calendar   *note 9.6(13): 4154.
   in Ada.Calendar.Formatting   *note 9.6.1(23/2): 4193.

Day_of_Week
   in Ada.Calendar.Formatting   *note 9.6.1(18/2): 4186.

Deallocate
   in System.Storage_Pools   *note 13.11(8): 5190.
   in System.Storage_Pools.Subpools   *note 13.11.4(15/3): 5267.

Deallocate_Subpool
   in System.Storage_Pools.Subpools   *note 13.11.4(12/3): 5264.

Decode
   in Ada.Strings.UTF_Encoding.Strings   *note A.4.11(26/3): 6085, *note
A.4.11(27/3): 6086, *note A.4.11(28/3): 6087.
   in Ada.Strings.UTF_Encoding.Wide_Strings   *note A.4.11(34/3): 6092,
*note A.4.11(35/3): 6093, *note A.4.11(36/3): 6094.
   in Ada.Strings.UTF_Encoding.Wide_Wide_Strings   *note A.4.11(42/3):
6099, *note A.4.11(43/3): 6100, *note A.4.11(44/3): 6101.

Decrement in Interfaces.C.Pointers   *note B.3.2(11/3): 7524.

Default_Modulus
   in Ada.Containers.Indefinite_Holders   *note A.18.21(10/3): 7314,
*note A.18.23(10/3): 7321.

Default_Subpool_for_Pool
   in System.Storage_Pools.Subpools   *note 13.11.4(13/3): 5265.

Delay_Until_And_Set_CPU
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(14/3):
8091.

Delay_Until_And_Set_Deadline
   in Ada.Dispatching.EDF   *note D.2.6(9/2): 7825.

Delete
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(24/2): 6847.
   in Ada.Containers.Hashed_Maps   *note A.18.5(25/2): 6939, *note
A.18.5(26/2): 6940.
   in Ada.Containers.Hashed_Sets   *note A.18.8(24/2): 7066, *note
A.18.8(25/2): 7067, *note A.18.8(55/2): 7092.
   in Ada.Containers.Ordered_Maps   *note A.18.6(24/2): 6990, *note
A.18.6(25/2): 6991.
   in Ada.Containers.Ordered_Sets   *note A.18.9(23/2): 7137, *note
A.18.9(24/2): 7138, *note A.18.9(68/2): 7171.
   in Ada.Containers.Vectors   *note A.18.2(50/2): 6773, *note
A.18.2(51/2): 6774.
   in Ada.Direct_IO   *note A.8.4(8): 6331.
   in Ada.Sequential_IO   *note A.8.1(8): 6304.
   in Ada.Streams.Stream_IO   *note A.12.1(10): 6577.
   in Ada.Strings.Bounded   *note A.4.4(64): 5889, *note A.4.4(65):
5890.
   in Ada.Strings.Fixed   *note A.4.3(29): 5832, *note A.4.3(30): 5833.
   in Ada.Strings.Unbounded   *note A.4.5(59): 5943, *note A.4.5(60):
5944.
   in Ada.Text_IO   *note A.10.1(11): 6386.

Delete_Children
   in Ada.Containers.Multiway_Trees   *note A.18.10(53/3): 7246.

Delete_Directory in Ada.Directories   *note A.16(8/2): 6639.

Delete_File in Ada.Directories   *note A.16(11/2): 6642.

Delete_First
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(25/2): 6848.
   in Ada.Containers.Ordered_Maps   *note A.18.6(26/2): 6992.
   in Ada.Containers.Ordered_Sets   *note A.18.9(25/2): 7139.
   in Ada.Containers.Vectors   *note A.18.2(52/2): 6775.

Delete_Last
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(26/2): 6849.
   in Ada.Containers.Ordered_Maps   *note A.18.6(27/2): 6993.
   in Ada.Containers.Ordered_Sets   *note A.18.9(26/2): 7140.
   in Ada.Containers.Vectors   *note A.18.2(53/2): 6776.

Delete_Leaf
   in Ada.Containers.Multiway_Trees   *note A.18.10(35/3): 7228.

Delete_Subtree
   in Ada.Containers.Multiway_Trees   *note A.18.10(36/3): 7229.

Delete_Tree in Ada.Directories   *note A.16(10/2): 6641.

Depth
   in Ada.Containers.Multiway_Trees   *note A.18.10(19/3): 7212.

Dequeue
   in Ada.Containers.Bounded_Priority_Queues   *note A.18.31(5/3): 7365.
   in Ada.Containers.Bounded_Synchronized_Queues   *note A.18.29(5/3):
7352.
   in Ada.Containers.Synchronized_Queue_Interfaces   *note A.18.27(6/3):
7339.
   in Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(5/3):
7358.
   in Ada.Containers.Unbounded_Synchronized_Queues   *note A.18.28(5/3):
7346.

Dequeue_Only_High_Priority
   in Ada.Containers.Bounded_Priority_Queues   *note A.18.31(6/3): 7366.
   in Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(6/3):
7359.

Dereference_Error
   in Interfaces.C.Strings   *note B.3.1(12): 7505.

Descendant_Tag in Ada.Tags   *note 3.9(7.1/2): 2108.

Detach_Handler in Ada.Interrupts   *note C.3.2(9): 7667.

Determinant
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(46/2): 8418.
   in Ada.Numerics.Generic_Real_Arrays   *note G.3.1(24/2): 8378.

Difference
   in Ada.Calendar.Arithmetic   *note 9.6.1(12/2): 4176.
   in Ada.Containers.Hashed_Sets   *note A.18.8(32/2): 7072, *note
A.18.8(33/2): 7073.
   in Ada.Containers.Ordered_Sets   *note A.18.9(33/2): 7145, *note
A.18.9(34/2): 7146.

Divide in Ada.Decimal   *note F.2(6/3): 8229.

Do_APC in System.RPC   *note E.5(10): 8211.

Do_RPC in System.RPC   *note E.5(9): 8210.

Eigensystem
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(49/2): 8420.
   in Ada.Numerics.Generic_Real_Arrays   *note G.3.1(27/2): 8380.

Eigenvalues
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(48/2): 8419.
   in Ada.Numerics.Generic_Real_Arrays   *note G.3.1(26/2): 8379.

Element
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(14/2): 6832.
   in Ada.Containers.Hashed_Maps   *note A.18.5(14/2): 6921, *note
A.18.5(31/2): 6945.
   in Ada.Containers.Hashed_Sets   *note A.18.8(15/2): 7054, *note
A.18.8(52/2): 7089.
   in Ada.Containers.Indefinite_Holders   *note A.18.18(12/3): 7290.
   in Ada.Containers.Multiway_Trees   *note A.18.10(24/3): 7217.
   in Ada.Containers.Ordered_Maps   *note A.18.6(13/2): 6972, *note
A.18.6(39/2): 7005.
   in Ada.Containers.Ordered_Sets   *note A.18.9(14/2): 7125, *note
A.18.9(65/2): 7168.
   in Ada.Containers.Vectors   *note A.18.2(27/2): 6743, *note
A.18.2(28/2): 6744.
   in Ada.Strings.Bounded   *note A.4.4(26): 5861.
   in Ada.Strings.Unbounded   *note A.4.5(20): 5915.

Encode
   in Ada.Strings.UTF_Encoding.Strings   *note A.4.11(23/3): 6082, *note
A.4.11(24/3): 6083, *note A.4.11(25/3): 6084.
   in Ada.Strings.UTF_Encoding.Wide_Strings   *note A.4.11(31/3): 6089,
*note A.4.11(32/3): 6090, *note A.4.11(33/3): 6091.
   in Ada.Strings.UTF_Encoding.Wide_Wide_Strings   *note A.4.11(39/3):
6096, *note A.4.11(40/3): 6097, *note A.4.11(41/3): 6098.

Encoding in Ada.Strings.UTF_Encoding   *note A.4.11(13/3): 6074.

End_Of_File
   in Ada.Direct_IO   *note A.8.4(16): 6346.
   in Ada.Sequential_IO   *note A.8.1(13): 6314.
   in Ada.Streams.Stream_IO   *note A.12.1(12): 6584.
   in Ada.Text_IO   *note A.10.1(34): 6431.

End_Of_Line in Ada.Text_IO   *note A.10.1(30): 6424.

End_Of_Page in Ada.Text_IO   *note A.10.1(33): 6430.

End_Search in Ada.Directories   *note A.16(33/2): 6663.

Enqueue
   in Ada.Containers.Bounded_Priority_Queues   *note A.18.31(5/3): 7364.
   in Ada.Containers.Bounded_Synchronized_Queues   *note A.18.29(5/3):
7351.
   in Ada.Containers.Synchronized_Queue_Interfaces   *note A.18.27(5/3):
7338.
   in Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(5/3):
7357.
   in Ada.Containers.Unbounded_Synchronized_Queues   *note A.18.28(5/3):
7345.

Environment_Task
   in Ada.Task_Identification   *note C.7.1(3/3): 7713.

Equal_Case_Insensitive
   child of Ada.Strings   *note A.4.10(2/3): 6056.
   child of Ada.Strings.Bounded   *note A.4.10(7/3): 6058.
   child of Ada.Strings.Fixed   *note A.4.10(5/3): 6057.
   child of Ada.Strings.Unbounded   *note A.4.10(10/3): 6059.

Equal_Subtree
   in Ada.Containers.Multiway_Trees   *note A.18.10(14/3): 7208.

Equivalent_Elements
   in Ada.Containers.Hashed_Sets   *note A.18.8(46/2): 7083, *note
A.18.8(47/2): 7084, *note A.18.8(48/2): 7085.
   in Ada.Containers.Ordered_Sets   *note A.18.9(3/2): 7113.

Equivalent_Keys
   in Ada.Containers.Hashed_Maps   *note A.18.5(34/2): 6947, *note
A.18.5(35/2): 6948, *note A.18.5(36/2): 6949.
   in Ada.Containers.Ordered_Maps   *note A.18.6(3/2): 6961.
   in Ada.Containers.Ordered_Sets   *note A.18.9(63/2): 7166.

Equivalent_Sets
   in Ada.Containers.Hashed_Sets   *note A.18.8(8/2): 7047.
   in Ada.Containers.Ordered_Sets   *note A.18.9(9/2): 7120.

Establish_RPC_Receiver in System.RPC   *note E.5(12): 8213.

Exception_Identity in Ada.Exceptions   *note 11.4.1(5/2): 4576.

Exception_Information
   in Ada.Exceptions   *note 11.4.1(5/2): 4580.

Exception_Message in Ada.Exceptions   *note 11.4.1(4/3): 4574.

Exception_Name in Ada.Exceptions   *note 11.4.1(2/2): 4567, *note
11.4.1(5/2): 4577.

Exchange_Handler in Ada.Interrupts   *note C.3.2(8): 7666.

Exclude
   in Ada.Containers.Hashed_Maps   *note A.18.5(24/2): 6938.
   in Ada.Containers.Hashed_Sets   *note A.18.8(23/2): 7065, *note
A.18.8(54/2): 7091.
   in Ada.Containers.Ordered_Maps   *note A.18.6(23/2): 6989.
   in Ada.Containers.Ordered_Sets   *note A.18.9(22/2): 7136, *note
A.18.9(67/2): 7170.

Exists
   in Ada.Directories   *note A.16(24/2): 6655.
   in Ada.Environment_Variables   *note A.17(5/2): 6702.

Exp
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(3): 8288.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(4): 6114.

Expanded_Name in Ada.Tags   *note 3.9(7/2): 2103.

Extension in Ada.Directories   *note A.16(18/2): 6648.

External_Tag in Ada.Tags   *note 3.9(7/2): 2106.

Finalize in Ada.Finalization   *note 7.6(6/2): 3665, *note 7.6(8/2):
3668.

Find
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(41/2): 6864.
   in Ada.Containers.Hashed_Maps   *note A.18.5(30/2): 6944.
   in Ada.Containers.Hashed_Sets   *note A.18.8(43/2): 7081, *note
A.18.8(56/2): 7093.
   in Ada.Containers.Multiway_Trees   *note A.18.10(38/3): 7231.
   in Ada.Containers.Ordered_Maps   *note A.18.6(38/2): 7004.
   in Ada.Containers.Ordered_Sets   *note A.18.9(49/2): 7159, *note
A.18.9(69/2): 7172.
   in Ada.Containers.Vectors   *note A.18.2(68/2): 6791.

Find_In_Subtree
   in Ada.Containers.Multiway_Trees   *note A.18.10(39/3): 7232.

Find_Index in Ada.Containers.Vectors   *note A.18.2(67/2): 6790.

Find_Token
   in Ada.Strings.Bounded   *note A.4.4(50.1/3): 5877, *note A.4.4(51):
5878.
   in Ada.Strings.Fixed   *note A.4.3(15.1/3): 5820, *note A.4.3(16):
5821.
   in Ada.Strings.Unbounded   *note A.4.5(45.1/3): 5931, *note
A.4.5(46): 5932.

First
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(33/2): 6856.
   in Ada.Containers.Hashed_Maps   *note A.18.5(27/2): 6941.
   in Ada.Containers.Hashed_Sets   *note A.18.8(40/2): 7078.
   in Ada.Containers.Ordered_Maps   *note A.18.6(28/2): 6994.
   in Ada.Containers.Ordered_Sets   *note A.18.9(41/2): 7151.
   in Ada.Containers.Vectors   *note A.18.2(58/2): 6781.
   in Ada.Iterator_Interfaces   *note 5.5.1(3/3): 3211.

First_Child
   in Ada.Containers.Multiway_Trees   *note A.18.10(60/3): 7253.

First_Child_Element
   in Ada.Containers.Multiway_Trees   *note A.18.10(61/3): 7254.

First_Element
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(34/2): 6857.
   in Ada.Containers.Ordered_Maps   *note A.18.6(29/2): 6995.
   in Ada.Containers.Ordered_Sets   *note A.18.9(42/2): 7152.
   in Ada.Containers.Vectors   *note A.18.2(59/2): 6782.

First_Index in Ada.Containers.Vectors   *note A.18.2(57/2): 6780.

First_Key
   in Ada.Containers.Ordered_Maps   *note A.18.6(30/2): 6996.

Floor
   in Ada.Containers.Ordered_Maps   *note A.18.6(40/2): 7006.
   in Ada.Containers.Ordered_Sets   *note A.18.9(50/2): 7160, *note
A.18.9(70/2): 7173.

Flush
   in Ada.Direct_IO   *note A.8.4(10.1/4): 6338.
   in Ada.Sequential_IO   *note A.8.1(10.1/4): 6311.
   in Ada.Streams.Stream_IO   *note A.12.1(25/1): 6594.
   in Ada.Text_IO   *note A.10.1(21/1): 6410.

Form
   in Ada.Direct_IO   *note A.8.4(9): 6336.
   in Ada.Sequential_IO   *note A.8.1(9): 6309.
   in Ada.Streams.Stream_IO   *note A.12.1(11): 6582.
   in Ada.Text_IO   *note A.10.1(12): 6391.

Free
   in Ada.Strings.Unbounded   *note A.4.5(7): 5907.
   in Interfaces.C.Strings   *note B.3.1(11): 7504.

Full_Name in Ada.Directories   *note A.16(15/2): 6645, *note A.16(39/2):
6667.

Generic_Array_Sort
   child of Ada.Containers   *note A.18.26(3/2): 7330.

Generic_Constrained_Array_Sort
   child of Ada.Containers   *note A.18.26(7/2): 7332.

Generic_Sort
   child of Ada.Containers   *note A.18.26(9.2/4): 7334.

Get
   in Ada.Text_IO   *note A.10.1(41): 6444, *note A.10.1(47): 6453,
*note A.10.1(54): 6466, *note A.10.1(55): 6470, *note A.10.1(59): 6476,
*note A.10.1(60): 6479, *note A.10.1(65): 6486, *note A.10.1(67): 6489,
*note A.10.1(70): 6496, *note A.10.1(72): 6499, *note A.10.1(75): 6506,
*note A.10.1(77): 6509, *note A.10.1(81): 6515, *note A.10.1(83): 6518.
   in Ada.Text_IO.Complex_IO   *note G.1.3(6): 8319, *note G.1.3(8):
8322.

Get_CPU
   in Ada.Interrupts   *note C.3.2(10.1/3): 7669.
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(13/3):
8090.

Get_CPU_Set
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(9.3/4):
8086.

Get_Deadline in Ada.Dispatching.EDF   *note D.2.6(9/2): 7826.

Get_Dispatching_Domain
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(10/3):
8087.

Get_First_CPU
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(8/3):
8082.

Get_Immediate in Ada.Text_IO   *note A.10.1(44): 6450, *note A.10.1(45):
6451.

Get_Last_CPU
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(9/4):
8083.

Get_Line
   in Ada.Text_IO   *note A.10.1(49): 6458, *note A.10.1(49.1/2): 6459.
   in Ada.Text_IO.Bounded_IO   *note A.10.11(8/2): 6542, *note
A.10.11(9/2): 6543, *note A.10.11(10/2): 6544, *note A.10.11(11/2):
6545.
   in Ada.Text_IO.Unbounded_IO   *note A.10.12(8/2): 6551, *note
A.10.12(9/2): 6552, *note A.10.12(10/2): 6553, *note A.10.12(11/2):
6554.

Get_Next_Entry in Ada.Directories   *note A.16(35/2): 6665.

Get_Priority
   in Ada.Dynamic_Priorities   *note D.5.1(5): 7867.

Has_Element
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(9.1/3): 6827.
   in Ada.Containers.Hashed_Maps   *note A.18.5(6.1/3): 6913.
   in Ada.Containers.Hashed_Sets   *note A.18.8(6.1/3): 7045.
   in Ada.Containers.Multiway_Trees   *note A.18.10(12/3): 7206.
   in Ada.Containers.Ordered_Maps   *note A.18.6(7.1/3): 6966.
   in Ada.Containers.Ordered_Sets   *note A.18.9(7.1/3): 7118.
   in Ada.Containers.Vectors   *note A.18.2(11.1/3): 6731.

Hash
   child of Ada.Strings   *note A.4.9(2/3): 6049.
   child of Ada.Strings.Bounded   *note A.4.9(7/3): 6050.
   child of Ada.Strings.Unbounded   *note A.4.9(10/3): 6051.

Hash_Case_Insensitive
   child of Ada.Strings   *note A.4.9(11.2/3): 6052.
   child of Ada.Strings.Bounded   *note A.4.9(11.7/3): 6054.
   child of Ada.Strings.Fixed   *note A.4.9(11.5/3): 6053.
   child of Ada.Strings.Unbounded   *note A.4.9(11.10/3): 6055.

Head
   in Ada.Strings.Bounded   *note A.4.4(70): 5895, *note A.4.4(71):
5896.
   in Ada.Strings.Fixed   *note A.4.3(35): 5838, *note A.4.3(36): 5839.
   in Ada.Strings.Unbounded   *note A.4.5(65): 5949, *note A.4.5(66):
5950.

Hold in Ada.Asynchronous_Task_Control   *note D.11(3/2): 7989.

Hour in Ada.Calendar.Formatting   *note 9.6.1(24/2): 4194.

Im
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(7/2): 8390,
*note G.3.2(27/2): 8403.
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(6): 8264.

Image
   in Ada.Calendar.Formatting   *note 9.6.1(35/2): 4205, *note
9.6.1(37/2): 4207.
   in Ada.Numerics.Discrete_Random   *note A.5.2(26): 6169.
   in Ada.Numerics.Float_Random   *note A.5.2(14): 6157.
   in Ada.Task_Identification   *note C.7.1(3/3): 7711.
   in Ada.Text_IO.Editing   *note F.3.3(13): 8249.

Include
   in Ada.Containers.Hashed_Maps   *note A.18.5(22/2): 6936.
   in Ada.Containers.Hashed_Sets   *note A.18.8(21/2): 7063.
   in Ada.Containers.Ordered_Maps   *note A.18.6(21/2): 6987.
   in Ada.Containers.Ordered_Sets   *note A.18.9(20/2): 7134.

Increment in Interfaces.C.Pointers   *note B.3.2(11/3): 7523.

Index
   in Ada.Direct_IO   *note A.8.4(15): 6344.
   in Ada.Streams.Stream_IO   *note A.12.1(23): 6591.
   in Ada.Strings.Bounded   *note A.4.4(43.1/2): 5866, *note
A.4.4(43.2/2): 5867, *note A.4.4(44): 5868, *note A.4.4(45): 5869, *note
A.4.4(45.1/2): 5870, *note A.4.4(46): 5871.
   in Ada.Strings.Fixed   *note A.4.3(8.1/2): 5809, *note A.4.3(8.2/2):
5810, *note A.4.3(9): 5811, *note A.4.3(10): 5812, *note A.4.3(10.1/2):
5813, *note A.4.3(11): 5814.
   in Ada.Strings.Unbounded   *note A.4.5(38.1/2): 5920, *note
A.4.5(38.2/2): 5921, *note A.4.5(39): 5922, *note A.4.5(40): 5923, *note
A.4.5(40.1/2): 5924, *note A.4.5(41): 5925.

Index_Non_Blank
   in Ada.Strings.Bounded   *note A.4.4(46.1/2): 5872, *note A.4.4(47):
5873.
   in Ada.Strings.Fixed   *note A.4.3(11.1/2): 5815, *note A.4.3(12):
5816.
   in Ada.Strings.Unbounded   *note A.4.5(41.1/2): 5926, *note
A.4.5(42): 5927.

Initial_Directory
   in Ada.Directories.Hierarchical_File_Names   *note A.16.1(12/3):
6695.

Initialize in Ada.Finalization   *note 7.6(6/2): 3663, *note 7.6(8/2):
3667.

Insert
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(19/2): 6842,
*note A.18.3(20/2): 6843, *note A.18.3(21/2): 6844.
   in Ada.Containers.Hashed_Maps   *note A.18.5(19/2): 6933, *note
A.18.5(20/2): 6934, *note A.18.5(21/2): 6935.
   in Ada.Containers.Hashed_Sets   *note A.18.8(19/2): 7061, *note
A.18.8(20/2): 7062.
   in Ada.Containers.Ordered_Maps   *note A.18.6(18/2): 6984, *note
A.18.6(19/2): 6985, *note A.18.6(20/2): 6986.
   in Ada.Containers.Ordered_Sets   *note A.18.9(18/2): 7132, *note
A.18.9(19/2): 7133.
   in Ada.Containers.Vectors   *note A.18.2(36/2): 6759, *note
A.18.2(37/2): 6760, *note A.18.2(38/2): 6761, *note A.18.2(39/2): 6762,
*note A.18.2(40/2): 6763, *note A.18.2(41/2): 6764, *note A.18.2(42/2):
6765, *note A.18.2(43/2): 6766.
   in Ada.Strings.Bounded   *note A.4.4(60): 5885, *note A.4.4(61):
5886.
   in Ada.Strings.Fixed   *note A.4.3(25): 5828, *note A.4.3(26): 5829.
   in Ada.Strings.Unbounded   *note A.4.5(55): 5939, *note A.4.5(56):
5940.

Insert_Child
   in Ada.Containers.Multiway_Trees   *note A.18.10(48/3): 7241, *note
A.18.10(49/3): 7242, *note A.18.10(50/3): 7243.

Insert_Space
   in Ada.Containers.Vectors   *note A.18.2(48/2): 6771, *note
A.18.2(49/2): 6772.

Interface_Ancestor_Tags in Ada.Tags   *note 3.9(7.4/2): 2112.

Internal_Tag in Ada.Tags   *note 3.9(7/2): 2107.

Intersection
   in Ada.Containers.Hashed_Sets   *note A.18.8(29/2): 7070, *note
A.18.8(30/2): 7071.
   in Ada.Containers.Ordered_Sets   *note A.18.9(30/2): 7143, *note
A.18.9(31/2): 7144.

Inverse
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(46/2): 8417.
   in Ada.Numerics.Generic_Real_Arrays   *note G.3.1(24/2): 8377.

Is_A_Group_Member
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(8/2): 8038.

Is_Abstract in Ada.Tags   *note 3.9(7.5/3): 2113.

Is_Alphanumeric
   in Ada.Characters.Handling   *note A.3.2(4/3): 5470.
   in Ada.Wide_Characters.Handling   *note A.3.5(12/3): 5757.

Is_Attached in Ada.Interrupts   *note C.3.2(5): 7663.

Is_Basic in Ada.Characters.Handling   *note A.3.2(4/3): 5466.

Is_Callable
   in Ada.Task_Identification   *note C.7.1(4/3): 7716.

Is_Character
   in Ada.Characters.Conversions   *note A.3.4(3/2): 5732.

Is_Control
   in Ada.Characters.Handling   *note A.3.2(4/3): 5461.
   in Ada.Wide_Characters.Handling   *note A.3.5(5/3): 5750.

Is_Current_Directory_Name
   in Ada.Directories.Hierarchical_File_Names   *note A.16.1(7/3): 6690.

Is_Decimal_Digit
   in Ada.Characters.Handling   *note A.3.2(4/3): 5468.
   in Ada.Wide_Characters.Handling   *note A.3.5(10/3): 5755.

Is_Descendant_At_Same_Level
   in Ada.Tags   *note 3.9(7.1/2): 2109.

Is_Digit
   in Ada.Characters.Handling   *note A.3.2(4/3): 5467.
   in Ada.Wide_Characters.Handling   *note A.3.5(9/3): 5754.

Is_Empty
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(12/2): 6830.
   in Ada.Containers.Hashed_Maps   *note A.18.5(11/2): 6918.
   in Ada.Containers.Hashed_Sets   *note A.18.8(13/2): 7052.
   in Ada.Containers.Indefinite_Holders   *note A.18.18(10/3): 7288.
   in Ada.Containers.Multiway_Trees   *note A.18.10(16/3): 7209.
   in Ada.Containers.Ordered_Maps   *note A.18.6(10/2): 6969.
   in Ada.Containers.Ordered_Sets   *note A.18.9(12/2): 7123.
   in Ada.Containers.Vectors   *note A.18.2(23/2): 6739.

Is_Full_Name
   in Ada.Directories.Hierarchical_File_Names   *note A.16.1(8/3): 6691.

Is_Graphic
   in Ada.Characters.Handling   *note A.3.2(4/3): 5462.
   in Ada.Wide_Characters.Handling   *note A.3.5(19/3): 5764.

Is_Held
   in Ada.Asynchronous_Task_Control   *note D.11(3/2): 7991.

Is_Hexadecimal_Digit
   in Ada.Characters.Handling   *note A.3.2(4/3): 5469.
   in Ada.Wide_Characters.Handling   *note A.3.5(11/3): 5756.

Is_In
   in Ada.Strings.Maps   *note A.4.2(13): 5791.
   in Ada.Strings.Wide_Maps   *note A.4.7(13): 5993.
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(13/2): 6032.

Is_ISO_646 in Ada.Characters.Handling   *note A.3.2(10): 5485.

Is_Leaf
   in Ada.Containers.Multiway_Trees   *note A.18.10(21/3): 7214.

Is_Letter
   in Ada.Characters.Handling   *note A.3.2(4/3): 5463.
   in Ada.Wide_Characters.Handling   *note A.3.5(6/3): 5751.

Is_Line_Terminator
   in Ada.Characters.Handling   *note A.3.2(4/3): 5472.
   in Ada.Wide_Characters.Handling   *note A.3.5(14/3): 5759.

Is_Lower
   in Ada.Characters.Handling   *note A.3.2(4/3): 5464.
   in Ada.Wide_Characters.Handling   *note A.3.5(7/3): 5752.

Is_Mark
   in Ada.Characters.Handling   *note A.3.2(4/3): 5473.
   in Ada.Wide_Characters.Handling   *note A.3.5(15/3): 5760.

Is_Member
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(8/2): 8037.

Is_Nul_Terminated in Interfaces.C   *note B.3(24): 7456, *note B.3(35):
7466, *note B.3(39.16/2): 7486, *note B.3(39.7/2): 7476.

Is_Open
   in Ada.Direct_IO   *note A.8.4(10): 6337.
   in Ada.Sequential_IO   *note A.8.1(10): 6310.
   in Ada.Streams.Stream_IO   *note A.12.1(12): 6583.
   in Ada.Text_IO   *note A.10.1(13): 6392.

Is_Other_Format
   in Ada.Characters.Handling   *note A.3.2(4/3): 5474.
   in Ada.Wide_Characters.Handling   *note A.3.5(16/3): 5761.

Is_Parent_Directory_Name
   in Ada.Directories.Hierarchical_File_Names   *note A.16.1(6/3): 6689.

Is_Punctuation_Connector
   in Ada.Characters.Handling   *note A.3.2(4/3): 5475.
   in Ada.Wide_Characters.Handling   *note A.3.5(17/3): 5762.

Is_Relative_Name
   in Ada.Directories.Hierarchical_File_Names   *note A.16.1(9/3): 6692.

Is_Reserved in Ada.Interrupts   *note C.3.2(4): 7662.

Is_Root
   in Ada.Containers.Multiway_Trees   *note A.18.10(20/3): 7213.

Is_Root_Directory_Name
   in Ada.Directories.Hierarchical_File_Names   *note A.16.1(5/3): 6688.

Is_Round_Robin
   in Ada.Dispatching.Round_Robin   *note D.2.5(4/2): 7818.

Is_Simple_Name
   in Ada.Directories.Hierarchical_File_Names   *note A.16.1(4/3): 6687.

Is_Sorted
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(48/2): 6870.
   in Ada.Containers.Vectors   *note A.18.2(76/2): 6798.

Is_Space
   in Ada.Characters.Handling   *note A.3.2(4/3): 5476.
   in Ada.Wide_Characters.Handling   *note A.3.5(18/3): 5763.

Is_Special
   in Ada.Characters.Handling   *note A.3.2(4/3): 5471.
   in Ada.Wide_Characters.Handling   *note A.3.5(13/3): 5758.

Is_String
   in Ada.Characters.Conversions   *note A.3.4(3/2): 5731.

Is_Subset
   in Ada.Containers.Hashed_Sets   *note A.18.8(39/2): 7077.
   in Ada.Containers.Ordered_Sets   *note A.18.9(40/2): 7150.
   in Ada.Strings.Maps   *note A.4.2(14): 5792.
   in Ada.Strings.Wide_Maps   *note A.4.7(14): 5994.
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(14/2): 6033.

Is_Terminated
   in Ada.Task_Identification   *note C.7.1(4/3): 7715.

Is_Upper
   in Ada.Characters.Handling   *note A.3.2(4/3): 5465.
   in Ada.Wide_Characters.Handling   *note A.3.5(8/3): 5753.

Is_Wide_Character
   in Ada.Characters.Conversions   *note A.3.4(3/2): 5734.

Is_Wide_String
   in Ada.Characters.Conversions   *note A.3.4(3/2): 5735.

Iterate
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(45/2): 6867.
   in Ada.Containers.Hashed_Maps   *note A.18.5(37/2): 6950.
   in Ada.Containers.Hashed_Sets   *note A.18.8(49/2): 7086.
   in Ada.Containers.Multiway_Trees   *note A.18.10(42/3): 7235, *note
A.18.10(44/3): 7237.
   in Ada.Containers.Ordered_Maps   *note A.18.6(50/2): 7009.
   in Ada.Containers.Ordered_Sets   *note A.18.9(60/2): 7163.
   in Ada.Containers.Vectors   *note A.18.2(73/2): 6795.
   in Ada.Environment_Variables   *note A.17(8/3): 6706.

Iterate_Children
   in Ada.Containers.Multiway_Trees   *note A.18.10(68/3): 7261, *note
A.18.10(70/3): 7263.

Iterate_Subtree
   in Ada.Containers.Multiway_Trees   *note A.18.10(43/3): 7236, *note
A.18.10(45/3): 7238.

Key
   in Ada.Containers.Hashed_Maps   *note A.18.5(13/2): 6920.
   in Ada.Containers.Hashed_Sets   *note A.18.8(51/2): 7088.
   in Ada.Containers.Ordered_Maps   *note A.18.6(12/2): 6971.
   in Ada.Containers.Ordered_Sets   *note A.18.9(64/2): 7167.

Kind in Ada.Directories   *note A.16(25/2): 6656, *note A.16(40/2):
6668.

Language in Ada.Locales   *note A.19(6/3): 7375.

Last
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(35/2): 6858.
   in Ada.Containers.Ordered_Maps   *note A.18.6(31/2): 6997.
   in Ada.Containers.Ordered_Sets   *note A.18.9(43/2): 7153.
   in Ada.Containers.Vectors   *note A.18.2(61/2): 6784.
   in Ada.Iterator_Interfaces   *note 5.5.1(4/3): 3214.

Last_Child
   in Ada.Containers.Multiway_Trees   *note A.18.10(62/3): 7255.

Last_Child_Element
   in Ada.Containers.Multiway_Trees   *note A.18.10(63/3): 7256.

Last_Element
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(36/2): 6859.
   in Ada.Containers.Ordered_Maps   *note A.18.6(32/2): 6998.
   in Ada.Containers.Ordered_Sets   *note A.18.9(44/2): 7154.
   in Ada.Containers.Vectors   *note A.18.2(62/2): 6785.

Last_Index in Ada.Containers.Vectors   *note A.18.2(60/2): 6783.

Last_Key
   in Ada.Containers.Ordered_Maps   *note A.18.6(33/2): 6999.

Length
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(11/2): 6829.
   in Ada.Containers.Hashed_Maps   *note A.18.5(10/2): 6917.
   in Ada.Containers.Hashed_Sets   *note A.18.8(12/2): 7051.
   in Ada.Containers.Ordered_Maps   *note A.18.6(9/2): 6968.
   in Ada.Containers.Ordered_Sets   *note A.18.9(11/2): 7122.
   in Ada.Containers.Vectors   *note A.18.2(21/2): 6737.
   in Ada.Strings.Bounded   *note A.4.4(9): 5849.
   in Ada.Strings.Unbounded   *note A.4.5(6): 5905.
   in Ada.Text_IO.Editing   *note F.3.3(11): 8247.
   in Interfaces.COBOL   *note B.4(34): 7581, *note B.4(39): 7585, *note
B.4(44): 7589.

Less_Case_Insensitive
   child of Ada.Strings   *note A.4.10(13/3): 6060.
   child of Ada.Strings.Bounded   *note A.4.10(18/3): 6062.
   child of Ada.Strings.Fixed   *note A.4.10(16/3): 6061.
   child of Ada.Strings.Unbounded   *note A.4.10(21/3): 6063.

Line in Ada.Text_IO   *note A.10.1(38): 6440.

Line_Length in Ada.Text_IO   *note A.10.1(25): 6415.

Log
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(3): 8287.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(4): 6113.

Look_Ahead in Ada.Text_IO   *note A.10.1(43): 6448.

Members
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(8/2): 8039.

Merge
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(50/2): 6872.
   in Ada.Containers.Vectors   *note A.18.2(78/2): 6800.

Microseconds in Ada.Real_Time   *note D.8(14/2): 7956.

Milliseconds in Ada.Real_Time   *note D.8(14/2): 7957.

Minute in Ada.Calendar.Formatting   *note 9.6.1(25/2): 4195.

Minutes in Ada.Real_Time   *note D.8(14/2): 7959.

Mode
   in Ada.Direct_IO   *note A.8.4(9): 6334.
   in Ada.Sequential_IO   *note A.8.1(9): 6307.
   in Ada.Streams.Stream_IO   *note A.12.1(11): 6580.
   in Ada.Text_IO   *note A.10.1(12): 6389.

Modification_Time in Ada.Directories   *note A.16(27/2): 6658, *note
A.16(42/2): 6670.

Modulus
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(10/2): 8395,
*note G.3.2(30/2): 8408.
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(9): 8272.

Month
   in Ada.Calendar   *note 9.6(13): 4153.
   in Ada.Calendar.Formatting   *note 9.6.1(22/2): 4192.

More_Entries in Ada.Directories   *note A.16(34/2): 6664.

Move
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(18/2): 6841.
   in Ada.Containers.Hashed_Maps   *note A.18.5(18/2): 6932.
   in Ada.Containers.Hashed_Sets   *note A.18.8(18/2): 7060.
   in Ada.Containers.Indefinite_Holders   *note A.18.18(22/3): 7300.
   in Ada.Containers.Multiway_Trees   *note A.18.10(34/3): 7227.
   in Ada.Containers.Ordered_Maps   *note A.18.6(17/2): 6983.
   in Ada.Containers.Ordered_Sets   *note A.18.9(17/2): 7131.
   in Ada.Containers.Vectors   *note A.18.2(35/2): 6758.
   in Ada.Strings.Fixed   *note A.4.3(7): 5808.

Name
   in Ada.Direct_IO   *note A.8.4(9): 6335.
   in Ada.Sequential_IO   *note A.8.1(9): 6308.
   in Ada.Streams.Stream_IO   *note A.12.1(11): 6581.
   in Ada.Text_IO   *note A.10.1(12): 6390.

Name_Case_Equivalence
   in Ada.Directories   *note A.16(20.2/3): 6652.

Nanoseconds in Ada.Real_Time   *note D.8(14/2): 7955.

New_Char_Array
   in Interfaces.C.Strings   *note B.3.1(9): 7502.

New_Line in Ada.Text_IO   *note A.10.1(28): 6420.

New_Page in Ada.Text_IO   *note A.10.1(31): 6426.

New_String in Interfaces.C.Strings   *note B.3.1(10): 7503.

Next
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(37/2): 6860,
*note A.18.3(39/2): 6862.
   in Ada.Containers.Hashed_Maps   *note A.18.5(28/2): 6942, *note
A.18.5(29/2): 6943.
   in Ada.Containers.Hashed_Sets   *note A.18.8(41/2): 7079, *note
A.18.8(42/2): 7080.
   in Ada.Containers.Ordered_Maps   *note A.18.6(34/2): 7000, *note
A.18.6(35/2): 7001.
   in Ada.Containers.Ordered_Sets   *note A.18.9(45/2): 7155, *note
A.18.9(46/2): 7156.
   in Ada.Containers.Vectors   *note A.18.2(63/2): 6786, *note
A.18.2(64/2): 6787.
   in Ada.Iterator_Interfaces   *note 5.5.1(3/3): 3212.

Next_Sibling
   in Ada.Containers.Multiway_Trees   *note A.18.10(64/3): 7257, *note
A.18.10(66/3): 7259.

Node_Count
   in Ada.Containers.Multiway_Trees   *note A.18.10(17/3): 7210.

Null_Task_Id
   in Ada.Task_Identification   *note C.7.1(2/2): 7710.

Number_Of_CPUs
   in System.Multiprocessors   *note D.16(5/3): 8074.

Open
   in Ada.Direct_IO   *note A.8.4(7): 6329.
   in Ada.Sequential_IO   *note A.8.1(7): 6302.
   in Ada.Streams.Stream_IO   *note A.12.1(9): 6575.
   in Ada.Text_IO   *note A.10.1(10): 6384.

Overlap
   in Ada.Containers.Hashed_Sets   *note A.18.8(38/2): 7076.
   in Ada.Containers.Ordered_Sets   *note A.18.9(39/2): 7149.

Overwrite
   in Ada.Strings.Bounded   *note A.4.4(62): 5887, *note A.4.4(63):
5888.
   in Ada.Strings.Fixed   *note A.4.3(27): 5830, *note A.4.3(28): 5831.
   in Ada.Strings.Unbounded   *note A.4.5(57): 5941, *note A.4.5(58):
5942.

Page in Ada.Text_IO   *note A.10.1(39): 6441.

Page_Length in Ada.Text_IO   *note A.10.1(26): 6417.

Parent
   in Ada.Containers.Multiway_Trees   *note A.18.10(59/3): 7252.

Parent_Tag in Ada.Tags   *note 3.9(7.2/2): 2110.

Peak_Use
   in Ada.Containers.Bounded_Priority_Queues   *note A.18.31(7/3): 7368.
   in Ada.Containers.Bounded_Synchronized_Queues   *note A.18.29(6/3):
7354.
   in Ada.Containers.Synchronized_Queue_Interfaces   *note A.18.27(7/3):
7341.
   in Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(7/3):
7361.
   in Ada.Containers.Unbounded_Synchronized_Queues   *note A.18.28(6/3):
7348.

Pic_String in Ada.Text_IO.Editing   *note F.3.3(7): 8238.

Pool_of_Subpool
   in System.Storage_Pools.Subpools   *note 13.11.4(9/3): 5261.

Prepend
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(22/2): 6845.
   in Ada.Containers.Vectors   *note A.18.2(44/2): 6767, *note
A.18.2(45/2): 6768.

Prepend_Child
   in Ada.Containers.Multiway_Trees   *note A.18.10(51/3): 7244.

Previous
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(38/2): 6861,
*note A.18.3(40/2): 6863.
   in Ada.Containers.Ordered_Maps   *note A.18.6(36/2): 7002, *note
A.18.6(37/2): 7003.
   in Ada.Containers.Ordered_Sets   *note A.18.9(47/2): 7157, *note
A.18.9(48/2): 7158.
   in Ada.Containers.Vectors   *note A.18.2(65/2): 6788, *note
A.18.2(66/2): 6789.
   in Ada.Iterator_Interfaces   *note 5.5.1(4/3): 3215.

Previous_Sibling
   in Ada.Containers.Multiway_Trees   *note A.18.10(65/3): 7258, *note
A.18.10(67/3): 7260.

Put
   in Ada.Text_IO   *note A.10.1(42): 6446, *note A.10.1(48): 6456,
*note A.10.1(55): 6471, *note A.10.1(60): 6478, *note A.10.1(66): 6487,
*note A.10.1(67): 6490, *note A.10.1(71): 6498, *note A.10.1(72): 6500,
*note A.10.1(76): 6507, *note A.10.1(77): 6510, *note A.10.1(82): 6516,
*note A.10.1(83): 6519.
   in Ada.Text_IO.Bounded_IO   *note A.10.11(4/2): 6538, *note
A.10.11(5/2): 6539.
   in Ada.Text_IO.Complex_IO   *note G.1.3(7): 8321, *note G.1.3(8):
8323.
   in Ada.Text_IO.Editing   *note F.3.3(14): 8250, *note F.3.3(15):
8251, *note F.3.3(16): 8252.
   in Ada.Text_IO.Unbounded_IO   *note A.10.12(4/2): 6547, *note
A.10.12(5/2): 6548.

Put_Line
   in Ada.Text_IO   *note A.10.1(50): 6462.
   in Ada.Text_IO.Bounded_IO   *note A.10.11(6/2): 6540, *note
A.10.11(7/2): 6541.
   in Ada.Text_IO.Unbounded_IO   *note A.10.12(6/2): 6549, *note
A.10.12(7/2): 6550.

Query_Element
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(16/2): 6834.
   in Ada.Containers.Hashed_Maps   *note A.18.5(16/2): 6923.
   in Ada.Containers.Hashed_Sets   *note A.18.8(17/2): 7056.
   in Ada.Containers.Indefinite_Holders   *note A.18.18(14/3): 7292.
   in Ada.Containers.Multiway_Trees   *note A.18.10(26/3): 7219.
   in Ada.Containers.Ordered_Maps   *note A.18.6(15/2): 6974.
   in Ada.Containers.Ordered_Sets   *note A.18.9(16/2): 7127.
   in Ada.Containers.Vectors   *note A.18.2(31/2): 6747, *note
A.18.2(32/2): 6748.

Raise_Exception in Ada.Exceptions   *note 11.4.1(4/3): 4573.

Random
   in Ada.Numerics.Discrete_Random   *note A.5.2(20): 6162.
   in Ada.Numerics.Float_Random   *note A.5.2(8): 6150.

Re
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(7/2): 8389,
*note G.3.2(27/2): 8402.
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(6): 8263.

Read
   in Ada.Direct_IO   *note A.8.4(12): 6339.
   in Ada.Sequential_IO   *note A.8.1(12): 6312.
   in Ada.Storage_IO   *note A.9(6): 6358.
   in Ada.Streams   *note 13.13.1(5): 5340.
   in Ada.Streams.Stream_IO   *note A.12.1(15): 6586, *note A.12.1(16):
6587.
   in System.RPC   *note E.5(7): 8208.

Reference
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(17.4/3): 6838.
   in Ada.Containers.Hashed_Maps   *note A.18.5(17.4/3): 6927, *note
A.18.5(17.6/3): 6929.
   in Ada.Containers.Indefinite_Holders   *note A.18.18(19/3): 7297.
   in Ada.Containers.Multiway_Trees   *note A.18.10(31/3): 7224.
   in Ada.Containers.Ordered_Maps   *note A.18.6(16.4/3): 6978, *note
A.18.6(16.6/3): 6980.
   in Ada.Containers.Vectors   *note A.18.2(34.4/3): 6753, *note
A.18.2(34.6/3): 6755.
   in Ada.Interrupts   *note C.3.2(10): 7668.
   in Ada.Task_Attributes   *note C.7.2(5): 7731.

Reference_Preserving_Key
   in Ada.Containers.Hashed_Sets   *note A.18.8(58.2/3): 7097, *note
A.18.8(58.4/3): 7099.
   in Ada.Containers.Ordered_Sets   *note A.18.9(73.2/3): 7178, *note
A.18.9(73.4/3): 7180.

Reinitialize in Ada.Task_Attributes   *note C.7.2(6): 7733.

Relative_Name
   in Ada.Directories.Hierarchical_File_Names   *note A.16.1(13/3):
6696.

Remove_Task
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(8/2): 8036.

Rename in Ada.Directories   *note A.16(12/2): 6643.

Replace
   in Ada.Containers.Hashed_Maps   *note A.18.5(23/2): 6937.
   in Ada.Containers.Hashed_Sets   *note A.18.8(22/2): 7064, *note
A.18.8(53/2): 7090.
   in Ada.Containers.Ordered_Maps   *note A.18.6(22/2): 6988.
   in Ada.Containers.Ordered_Sets   *note A.18.9(21/2): 7135, *note
A.18.9(66/2): 7169.

Replace_Element
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(15/2): 6833.
   in Ada.Containers.Hashed_Maps   *note A.18.5(15/2): 6922.
   in Ada.Containers.Hashed_Sets   *note A.18.8(16/2): 7055.
   in Ada.Containers.Indefinite_Holders   *note A.18.18(13/3): 7291.
   in Ada.Containers.Multiway_Trees   *note A.18.10(25/3): 7218.
   in Ada.Containers.Ordered_Maps   *note A.18.6(14/2): 6973.
   in Ada.Containers.Ordered_Sets   *note A.18.9(15/2): 7126.
   in Ada.Containers.Vectors   *note A.18.2(29/2): 6745, *note
A.18.2(30/2): 6746.
   in Ada.Strings.Bounded   *note A.4.4(27): 5862.
   in Ada.Strings.Unbounded   *note A.4.5(21): 5916.

Replace_Slice
   in Ada.Strings.Bounded   *note A.4.4(58): 5883, *note A.4.4(59):
5884.
   in Ada.Strings.Fixed   *note A.4.3(23): 5826, *note A.4.3(24): 5827.
   in Ada.Strings.Unbounded   *note A.4.5(53): 5937, *note A.4.5(54):
5938.

Replenish
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(9/2): 8040.

Replicate in Ada.Strings.Bounded   *note A.4.4(78): 5899, *note
A.4.4(79): 5900, *note A.4.4(80): 5901.

Reraise_Occurrence in Ada.Exceptions   *note 11.4.1(4/3): 4575.

Reserve_Capacity
   in Ada.Containers.Hashed_Maps   *note A.18.5(9/2): 6916.
   in Ada.Containers.Hashed_Sets   *note A.18.8(11/2): 7050.
   in Ada.Containers.Vectors   *note A.18.2(20/2): 6736.

Reset
   in Ada.Direct_IO   *note A.8.4(8): 6333.
   in Ada.Numerics.Discrete_Random   *note A.5.2(21): 6164, *note
A.5.2(24): 6167.
   in Ada.Numerics.Float_Random   *note A.5.2(9): 6151, *note A.5.2(12):
6155.
   in Ada.Sequential_IO   *note A.8.1(8): 6306.
   in Ada.Streams.Stream_IO   *note A.12.1(10): 6578.
   in Ada.Text_IO   *note A.10.1(11): 6388.

Reverse_Elements
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(27/2): 6850.
   in Ada.Containers.Vectors   *note A.18.2(54/2): 6777.

Reverse_Find
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(42/2): 6865.
   in Ada.Containers.Vectors   *note A.18.2(70/2): 6793.

Reverse_Find_Index
   in Ada.Containers.Vectors   *note A.18.2(69/2): 6792.

Reverse_Iterate
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(46/2): 6868.
   in Ada.Containers.Ordered_Maps   *note A.18.6(51/2): 7010.
   in Ada.Containers.Ordered_Sets   *note A.18.9(61/2): 7164.
   in Ada.Containers.Vectors   *note A.18.2(74/2): 6796.

Reverse_Iterate_Children
   in Ada.Containers.Multiway_Trees   *note A.18.10(69/3): 7262.

Root in Ada.Containers.Multiway_Trees   *note A.18.10(22/3): 7215.

Save
   in Ada.Numerics.Discrete_Random   *note A.5.2(24): 6166.
   in Ada.Numerics.Float_Random   *note A.5.2(12): 6154.

Save_Occurrence in Ada.Exceptions   *note 11.4.1(6/2): 4582.

Second in Ada.Calendar.Formatting   *note 9.6.1(26/2): 4196.

Seconds
   in Ada.Calendar   *note 9.6(13): 4155.
   in Ada.Real_Time   *note D.8(14/2): 7958.

Seconds_Of in Ada.Calendar.Formatting   *note 9.6.1(28/2): 4198.

Set in Ada.Environment_Variables   *note A.17(6/2): 6703.

Set_Bounded_String
   in Ada.Strings.Bounded   *note A.4.4(12.1/2): 5852.

Set_Col in Ada.Text_IO   *note A.10.1(35): 6434.

Set_CPU
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(12/3):
8089.

Set_Deadline in Ada.Dispatching.EDF   *note D.2.6(9/2): 7824.

Set_Dependents_Fallback_Handler
   in Ada.Task_Termination   *note C.7.3(5/2): 7743.

Set_Directory in Ada.Directories   *note A.16(6/2): 6637.

Set_Error in Ada.Text_IO   *note A.10.1(15): 6395.

Set_Exit_Status in Ada.Command_Line   *note A.15(9): 6633.

Set_False
   in Ada.Synchronous_Task_Control   *note D.10(4): 7976.

Set_Handler
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(10/2): 8044.
   in Ada.Execution_Time.Timers   *note D.14.1(7/2): 8020.
   in Ada.Real_Time.Timing_Events   *note D.15(5/2): 8061.

Set_Im
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(8/2): 8392,
*note G.3.2(28/2): 8405.
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(7): 8267.

Set_Index
   in Ada.Direct_IO   *note A.8.4(14): 6343.
   in Ada.Streams.Stream_IO   *note A.12.1(22): 6590.

Set_Input in Ada.Text_IO   *note A.10.1(15): 6393.

Set_Length in Ada.Containers.Vectors   *note A.18.2(22/2): 6738.

Set_Line in Ada.Text_IO   *note A.10.1(36): 6436.

Set_Line_Length in Ada.Text_IO   *note A.10.1(23): 6411.

Set_Mode in Ada.Streams.Stream_IO   *note A.12.1(24): 6593.

Set_Output in Ada.Text_IO   *note A.10.1(15): 6394.

Set_Page_Length in Ada.Text_IO   *note A.10.1(24): 6414.

Set_Pool_of_Subpool
   in System.Storage_Pools.Subpools   *note 13.11.4(10/3): 5262.

Set_Priority
   in Ada.Dynamic_Priorities   *note D.5.1(4): 7866.

Set_Quantum
   in Ada.Dispatching.Round_Robin   *note D.2.5(4/2): 7815.

Set_Re
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(8/2): 8391,
*note G.3.2(28/2): 8404.
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(7): 8266.

Set_Specific_Handler
   in Ada.Task_Termination   *note C.7.3(6/2): 7745.

Set_True
   in Ada.Synchronous_Task_Control   *note D.10(4): 7975.

Set_Unbounded_String
   in Ada.Strings.Unbounded   *note A.4.5(11.1/2): 5911.

Set_Value in Ada.Task_Attributes   *note C.7.2(6): 7732.

Simple_Name
   in Ada.Directories   *note A.16(16/2): 6646, *note A.16(38/2): 6666.
   in Ada.Directories.Hierarchical_File_Names   *note A.16.1(10/3):
6693.

Sin
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(4): 8290.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(5): 6116.

Sinh
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(6): 8298.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7): 6131.

Size
   in Ada.Direct_IO   *note A.8.4(15): 6345.
   in Ada.Directories   *note A.16(26/2): 6657, *note A.16(41/2): 6669.
   in Ada.Streams.Stream_IO   *note A.12.1(23): 6592.

Skip_Line in Ada.Text_IO   *note A.10.1(29): 6422.

Skip_Page in Ada.Text_IO   *note A.10.1(32): 6428.

Slice
   in Ada.Strings.Bounded   *note A.4.4(28): 5863.
   in Ada.Strings.Unbounded   *note A.4.5(22): 5917.

Solve
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(46/2): 8415.
   in Ada.Numerics.Generic_Real_Arrays   *note G.3.1(24/2): 8376.

Sort
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(49/2): 6871.
   in Ada.Containers.Vectors   *note A.18.2(77/2): 6799.

Specific_Handler
   in Ada.Task_Termination   *note C.7.3(6/2): 7746.

Splice
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(30/2): 6853,
*note A.18.3(31/2): 6854, *note A.18.3(32/2): 6855.

Splice_Children
   in Ada.Containers.Multiway_Trees   *note A.18.10(57/3): 7250, *note
A.18.10(58/3): 7251.

Splice_Subtree
   in Ada.Containers.Multiway_Trees   *note A.18.10(55/3): 7248, *note
A.18.10(56/3): 7249.

Split
   in Ada.Calendar   *note 9.6(14): 4156.
   in Ada.Calendar.Formatting   *note 9.6.1(29/2): 4199, *note
9.6.1(32/2): 4202, *note 9.6.1(33/2): 4203, *note 9.6.1(34/2): 4204.
   in Ada.Execution_Time   *note D.14(8/2): 8006.
   in Ada.Real_Time   *note D.8(16): 7961.

Sqrt
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(3): 8286.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(4): 6111.

Standard_Error in Ada.Text_IO   *note A.10.1(16): 6398, *note
A.10.1(19): 6405.

Standard_Input in Ada.Text_IO   *note A.10.1(16): 6396, *note
A.10.1(19): 6403.

Standard_Output in Ada.Text_IO   *note A.10.1(16): 6397, *note
A.10.1(19): 6404.

Start_Search in Ada.Directories   *note A.16(32/2): 6662.

Storage_Size
   in System.Storage_Pools   *note 13.11(9): 5191.
   in System.Storage_Pools.Subpools   *note 13.11.4(16/3): 5268.

Stream
   in Ada.Streams.Stream_IO   *note A.12.1(13): 6585.
   in Ada.Text_IO.Text_Streams   *note A.12.2(4): 6606.
   in Ada.Wide_Text_IO.Text_Streams   *note A.12.3(4): 6609.
   in Ada.Wide_Wide_Text_IO.Text_Streams   *note A.12.4(4/2): 6612.

Strlen in Interfaces.C.Strings   *note B.3.1(17): 7510.

Sub_Second in Ada.Calendar.Formatting   *note 9.6.1(27/2): 4197.

Subtree_Node_Count
   in Ada.Containers.Multiway_Trees   *note A.18.10(18/3): 7211.

Supported
   in Ada.Execution_Time.Interrupts   *note D.14.3(3/3): 8057.

Suspend_Until_True
   in Ada.Synchronous_Task_Control   *note D.10(4): 7978.

Suspend_Until_True_And_Set_Deadline
   in Ada.Synchronous_Task_Control.EDF   *note D.10(5.2/3): 7980.

Swap
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(28/2): 6851.
   in Ada.Containers.Multiway_Trees   *note A.18.10(37/3): 7230.
   in Ada.Containers.Vectors   *note A.18.2(55/2): 6778, *note
A.18.2(56/2): 6779.

Swap_Links
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(29/2): 6852.

Symmetric_Difference
   in Ada.Containers.Hashed_Sets   *note A.18.8(35/2): 7074, *note
A.18.8(36/2): 7075.
   in Ada.Containers.Ordered_Sets   *note A.18.9(36/2): 7147, *note
A.18.9(37/2): 7148.

Tail
   in Ada.Strings.Bounded   *note A.4.4(72): 5897, *note A.4.4(73):
5898.
   in Ada.Strings.Fixed   *note A.4.3(37): 5840, *note A.4.3(38): 5841.
   in Ada.Strings.Unbounded   *note A.4.5(67): 5951, *note A.4.5(68):
5952.

Tan
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(4): 8292.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(5): 6119.

Tanh
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(6): 8300.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7): 6133.

Time_Of
   in Ada.Calendar   *note 9.6(15): 4157.
   in Ada.Calendar.Formatting   *note 9.6.1(30/2): 4200, *note
9.6.1(31/2): 4201.
   in Ada.Execution_Time   *note D.14(9/2): 8007.
   in Ada.Real_Time   *note D.8(16): 7962.

Time_Of_Event
   in Ada.Real_Time.Timing_Events   *note D.15(6/2): 8065.

Time_Remaining
   in Ada.Execution_Time.Timers   *note D.14.1(8/2): 8023.

To_Ada
   in Interfaces.C   *note B.3(22): 7454, *note B.3(26): 7458, *note
B.3(28): 7460, *note B.3(32): 7464, *note B.3(37): 7468, *note B.3(39):
7470, *note B.3(39.10/2): 7480, *note B.3(39.13/2): 7484, *note
B.3(39.17/2): 7488, *note B.3(39.19/2): 7490, *note B.3(39.4/2): 7474,
*note B.3(39.8/2): 7478.
   in Interfaces.COBOL   *note B.4(17): 7559, *note B.4(19): 7561.
   in Interfaces.Fortran   *note B.5(13): 7612, *note B.5(14): 7614,
*note B.5(16): 7616.

To_Address
   in System.Address_To_Access_Conversions   *note 13.7.2(3/3): 5146.
   in System.Storage_Elements   *note 13.7.1(10/3): 5139.

To_Basic in Ada.Characters.Handling   *note A.3.2(6): 5479, *note
A.3.2(7): 5482.

To_Binary in Interfaces.COBOL   *note B.4(45): 7591, *note B.4(48):
7594.

To_Bounded_String
   in Ada.Strings.Bounded   *note A.4.4(11): 5850.

To_C in Interfaces.C   *note B.3(21): 7453, *note B.3(25): 7457, *note
B.3(27): 7459, *note B.3(32): 7463, *note B.3(36): 7467, *note B.3(38):
7469, *note B.3(39.13/2): 7483, *note B.3(39.16/2): 7487, *note
B.3(39.18/2): 7489, *note B.3(39.4/2): 7473, *note B.3(39.7/2): 7477,
*note B.3(39.9/2): 7479.

To_Character
   in Ada.Characters.Conversions   *note A.3.4(5/2): 5744.

To_Chars_Ptr in Interfaces.C.Strings   *note B.3.1(8): 7501.

To_COBOL in Interfaces.COBOL   *note B.4(17): 7558, *note B.4(18): 7560.

To_Cursor in Ada.Containers.Vectors   *note A.18.2(25/2): 6741.

To_Decimal in Interfaces.COBOL   *note B.4(35): 7582, *note B.4(40):
7586, *note B.4(44): 7590, *note B.4(47): 7592.

To_Display in Interfaces.COBOL   *note B.4(36): 7583.

To_Domain
   in Ada.Strings.Maps   *note A.4.2(24): 5801.
   in Ada.Strings.Wide_Maps   *note A.4.7(24): 6003.
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(24/2): 6042.

To_Duration in Ada.Real_Time   *note D.8(13): 7953.

To_Fortran in Interfaces.Fortran   *note B.5(13): 7611, *note B.5(14):
7613, *note B.5(15): 7615.

To_Holder
   in Ada.Containers.Indefinite_Holders   *note A.18.18(9/3): 7287.

To_Index in Ada.Containers.Vectors   *note A.18.2(26/2): 6742.

To_Integer in System.Storage_Elements   *note 13.7.1(10/3): 5140.

To_ISO_646 in Ada.Characters.Handling   *note A.3.2(11): 5486, *note
A.3.2(12): 5487.

To_Long_Binary in Interfaces.COBOL   *note B.4(48): 7595.

To_Lower
   in Ada.Characters.Handling   *note A.3.2(6): 5477, *note A.3.2(7):
5480.
   in Ada.Wide_Characters.Handling   *note A.3.5(20/3): 5765, *note
A.3.5(21/3): 5767.

To_Mapping
   in Ada.Strings.Maps   *note A.4.2(23): 5800.
   in Ada.Strings.Wide_Maps   *note A.4.7(23): 6002.
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(23/2): 6041.

To_Packed in Interfaces.COBOL   *note B.4(41): 7587.

To_Picture in Ada.Text_IO.Editing   *note F.3.3(6): 8237.

To_Pointer
   in System.Address_To_Access_Conversions   *note 13.7.2(3/3): 5145.

To_Range
   in Ada.Strings.Maps   *note A.4.2(24): 5802.
   in Ada.Strings.Wide_Maps   *note A.4.7(25): 6004.
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(25/2): 6043.

To_Ranges
   in Ada.Strings.Maps   *note A.4.2(10): 5790.
   in Ada.Strings.Wide_Maps   *note A.4.7(10): 5992.
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(10/2): 6031.

To_Sequence
   in Ada.Strings.Maps   *note A.4.2(19): 5796.
   in Ada.Strings.Wide_Maps   *note A.4.7(19): 5998.
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(19/2): 6037.

To_Set
   in Ada.Containers.Hashed_Sets   *note A.18.8(9/2): 7048.
   in Ada.Containers.Ordered_Sets   *note A.18.9(10/2): 7121.
   in Ada.Strings.Maps   *note A.4.2(8): 5788, *note A.4.2(9): 5789,
*note A.4.2(17): 5794, *note A.4.2(18): 5795.
   in Ada.Strings.Wide_Maps   *note A.4.7(8): 5990, *note A.4.7(9):
5991, *note A.4.7(17): 5996, *note A.4.7(18): 5997.
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(8/2): 6029, *note
A.4.8(9/2): 6030, *note A.4.8(17/2): 6035, *note A.4.8(18/2): 6036.

To_String
   in Ada.Characters.Conversions   *note A.3.4(5/2): 5743.
   in Ada.Strings.Bounded   *note A.4.4(12): 5851.
   in Ada.Strings.Unbounded   *note A.4.5(11): 5910.

To_Time_Span in Ada.Real_Time   *note D.8(13): 7954.

To_Unbounded_String
   in Ada.Strings.Unbounded   *note A.4.5(9): 5908, *note A.4.5(10):
5909.

To_Upper
   in Ada.Characters.Handling   *note A.3.2(6): 5478, *note A.3.2(7):
5481.
   in Ada.Wide_Characters.Handling   *note A.3.5(20/3): 5766, *note
A.3.5(21/3): 5768.

To_Vector in Ada.Containers.Vectors   *note A.18.2(13/2): 6733, *note
A.18.2(14/2): 6734.

To_Wide_Character
   in Ada.Characters.Conversions   *note A.3.4(4/2): 5736, *note
A.3.4(5/2): 5746.

To_Wide_String
   in Ada.Characters.Conversions   *note A.3.4(4/2): 5737, *note
A.3.4(5/2): 5747.

To_Wide_Wide_Character
   in Ada.Characters.Conversions   *note A.3.4(4/2): 5740.

To_Wide_Wide_String
   in Ada.Characters.Conversions   *note A.3.4(4/2): 5741.

Translate
   in Ada.Strings.Bounded   *note A.4.4(53): 5879, *note A.4.4(54):
5880, *note A.4.4(55): 5881, *note A.4.4(56): 5882.
   in Ada.Strings.Fixed   *note A.4.3(18): 5822, *note A.4.3(19): 5823,
*note A.4.3(20): 5824, *note A.4.3(21): 5825.
   in Ada.Strings.Unbounded   *note A.4.5(48): 5933, *note A.4.5(49):
5934, *note A.4.5(50): 5935, *note A.4.5(51): 5936.

Transpose
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(34/2): 8414.
   in Ada.Numerics.Generic_Real_Arrays   *note G.3.1(17/2): 8374.

Trim
   in Ada.Strings.Bounded   *note A.4.4(67): 5891, *note A.4.4(68):
5893, *note A.4.4(69): 5894.
   in Ada.Strings.Fixed   *note A.4.3(31): 5834, *note A.4.3(32): 5835,
*note A.4.3(33): 5836, *note A.4.3(34): 5837.
   in Ada.Strings.Unbounded   *note A.4.5(61): 5945, *note A.4.5(62):
5946, *note A.4.5(63): 5947, *note A.4.5(64): 5948.

Unbounded_Slice
   in Ada.Strings.Unbounded   *note A.4.5(22.1/2): 5918, *note
A.4.5(22.2/2): 5919.

Unchecked_Conversion
   child of Ada   *note 13.9(3/3): 5159.

Unchecked_Deallocation
   child of Ada   *note 13.11.2(3/3): 5228.

Union
   in Ada.Containers.Hashed_Sets   *note A.18.8(26/2): 7068, *note
A.18.8(27/2): 7069.
   in Ada.Containers.Ordered_Sets   *note A.18.9(27/2): 7141, *note
A.18.9(28/2): 7142.

Unit_Matrix
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(51/2): 8421.
   in Ada.Numerics.Generic_Real_Arrays   *note G.3.1(29/2): 8381.

Unit_Vector
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(24/2): 8401.
   in Ada.Numerics.Generic_Real_Arrays   *note G.3.1(14/2): 8373.

Update in Interfaces.C.Strings   *note B.3.1(18): 7511, *note B.3.1(19):
7512.

Update_Element
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(17/2): 6835.
   in Ada.Containers.Hashed_Maps   *note A.18.5(17/2): 6924.
   in Ada.Containers.Indefinite_Holders   *note A.18.18(15/3): 7293.
   in Ada.Containers.Multiway_Trees   *note A.18.10(27/3): 7220.
   in Ada.Containers.Ordered_Maps   *note A.18.6(16/2): 6975.
   in Ada.Containers.Vectors   *note A.18.2(33/2): 6749, *note
A.18.2(34/2): 6750.

Update_Element_Preserving_Key
   in Ada.Containers.Hashed_Sets   *note A.18.8(58/2): 7095.
   in Ada.Containers.Ordered_Sets   *note A.18.9(73/2): 7176.

Update_Error in Interfaces.C.Strings   *note B.3.1(20): 7513.

UTC_Time_Offset
   in Ada.Calendar.Time_Zones   *note 9.6.1(6/2): 4172.

Valid
   in Ada.Text_IO.Editing   *note F.3.3(5): 8236, *note F.3.3(12): 8248.
   in Interfaces.COBOL   *note B.4(33): 7580, *note B.4(38): 7584, *note
B.4(43): 7588.

Value
   in Ada.Calendar.Formatting   *note 9.6.1(36/2): 4206, *note
9.6.1(38/2): 4208.
   in Ada.Environment_Variables   *note A.17(4.1/3): 6701, *note
A.17(4/2): 6700.
   in Ada.Numerics.Discrete_Random   *note A.5.2(26): 6170.
   in Ada.Numerics.Float_Random   *note A.5.2(14): 6158.
   in Ada.Strings.Maps   *note A.4.2(21): 5798.
   in Ada.Strings.Wide_Maps   *note A.4.7(21): 6000.
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(21/2): 6039.
   in Ada.Task_Attributes   *note C.7.2(4): 7730.
   in Interfaces.C.Pointers   *note B.3.2(6): 7520, *note B.3.2(7):
7521.
   in Interfaces.C.Strings   *note B.3.1(13): 7506, *note B.3.1(14):
7507, *note B.3.1(15): 7508, *note B.3.1(16): 7509.

Virtual_Length
   in Interfaces.C.Pointers   *note B.3.2(13): 7525.

Wait_For_Release
   in Ada.Synchronous_Barriers   *note D.10.1(6/3): 7987.

Wide_Equal_Case_Insensitive
   child of Ada.Strings.Wide_Bounded   *note A.4.7(1/3): 5978.
   child of Ada.Strings.Wide_Fixed   *note A.4.7(1/3): 5977.
   child of Ada.Strings.Wide_Unbounded   *note A.4.7(1/3): 5979.

Wide_Hash
   child of Ada.Strings.Wide_Bounded   *note A.4.7(1/3): 5974.
   child of Ada.Strings.Wide_Fixed   *note A.4.7(1/3): 5973.
   child of Ada.Strings.Wide_Unbounded   *note A.4.7(1/3): 5975.

Wide_Hash_Case_Insensitive
   child of Ada.Strings.Wide_Bounded   *note A.4.7(1/3): 5982.
   child of Ada.Strings.Wide_Fixed   *note A.4.7(1/3): 5981.
   child of Ada.Strings.Wide_Unbounded   *note A.4.7(1/3): 5983.

Wide_Exception_Name in Ada.Exceptions   *note 11.4.1(2/2): 4568, *note
11.4.1(5/2): 4578.

Wide_Expanded_Name in Ada.Tags   *note 3.9(7/2): 2104.

Wide_Wide_Equal_Case_Insensitive
   child of Ada.Strings.Wide_Wide_Bounded   *note A.4.8(1/3): 6017.
   child of Ada.Strings.Wide_Wide_Fixed   *note A.4.8(1/3): 6016.
   child of Ada.Strings.Wide_Wide_Unbounded   *note A.4.8(1/3): 6018.

Wide_Wide_Hash
   child of Ada.Strings.Wide_Wide_Bounded   *note A.4.8(1/3): 6013.
   child of Ada.Strings.Wide_Wide_Fixed   *note A.4.8(1/3): 6012.
   child of Ada.Strings.Wide_Wide_Unbounded   *note A.4.8(1/3): 6014.

Wide_Wide_Hash_Case_Insensitive
   child of Ada.Strings.Wide_Wide_Bounded   *note A.4.8(1/3): 6021.
   child of Ada.Strings.Wide_Wide_Fixed   *note A.4.8(1/3): 6020.
   child of Ada.Strings.Wide_Wide_Unbounded   *note A.4.8(1/3): 6022.

Wide_Wide_Exception_Name
   in Ada.Exceptions   *note 11.4.1(2/2): 4569, *note 11.4.1(5/2): 4579.

Wide_Wide_Expanded_Name in Ada.Tags   *note 3.9(7/2): 2105.

Write
   in Ada.Direct_IO   *note A.8.4(13): 6341.
   in Ada.Sequential_IO   *note A.8.1(12): 6313.
   in Ada.Storage_IO   *note A.9(7): 6359.
   in Ada.Streams   *note 13.13.1(6): 5341.
   in Ada.Streams.Stream_IO   *note A.12.1(18): 6588, *note A.12.1(19):
6589.
   in System.RPC   *note E.5(8): 8209.

Year
   in Ada.Calendar   *note 9.6(13): 4152.
   in Ada.Calendar.Formatting   *note 9.6.1(21/2): 4191.

Yield in Ada.Dispatching   *note D.2.1(1.3/3): 7770.

Yield_To_Higher
   in Ada.Dispatching.Non_Preemptive   *note D.2.4(2.2/3): 7807.

Yield_To_Same_Or_Higher
   in Ada.Dispatching.Non_Preemptive   *note D.2.4(2.2/3): 7808.


File: arm2012.info,  Node: Q.4,  Next: Q.5,  Prev: Q.3,  Up: Annex Q

Q.4 Language-Defined Exceptions
===============================

1/3
This subclause lists all language-defined exceptions.

 

Argument_Error
   in Ada.Numerics   *note A.5(3/2): 6107.

Assertion_Error
   in Ada.Assertions   *note 11.4.2(13/2): 4605.

Capacity_Error
   in Ada.Containers   *note A.18.1(5.1/3): 6718.

Communication_Error
   in System.RPC   *note E.5(5): 8206.

Constraint_Error
   in Standard   *note A.1(46): 5451.

Conversion_Error
   in Interfaces.COBOL   *note B.4(30): 7578.

Data_Error
   in Ada.Direct_IO   *note A.8.4(18): 6353.
   in Ada.IO_Exceptions   *note A.13(4): 6620.
   in Ada.Sequential_IO   *note A.8.1(15): 6321.
   in Ada.Storage_IO   *note A.9(9): 6360.
   in Ada.Streams.Stream_IO   *note A.12.1(26): 6601.
   in Ada.Text_IO   *note A.10.1(85): 6526.

Device_Error
   in Ada.Direct_IO   *note A.8.4(18): 6351.
   in Ada.Directories   *note A.16(43/2): 6674.
   in Ada.IO_Exceptions   *note A.13(4): 6618.
   in Ada.Sequential_IO   *note A.8.1(15): 6319.
   in Ada.Streams.Stream_IO   *note A.12.1(26): 6599.
   in Ada.Text_IO   *note A.10.1(85): 6524.

Dispatching_Domain_Error
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(4/3):
8078.

Dispatching_Policy_Error
   in Ada.Dispatching   *note D.2.1(1.4/3): 7771.

Encoding_Error
   in Ada.Strings.UTF_Encoding   *note A.4.11(8/3): 6069.

End_Error
   in Ada.Direct_IO   *note A.8.4(18): 6352.
   in Ada.IO_Exceptions   *note A.13(4): 6619.
   in Ada.Sequential_IO   *note A.8.1(15): 6320.
   in Ada.Streams.Stream_IO   *note A.12.1(26): 6600.
   in Ada.Text_IO   *note A.10.1(85): 6525.

Group_Budget_Error
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(11/2): 8047.

Index_Error
   in Ada.Strings   *note A.4.1(5): 5776.

Layout_Error
   in Ada.IO_Exceptions   *note A.13(4): 6621.
   in Ada.Text_IO   *note A.10.1(85): 6527.

Length_Error
   in Ada.Strings   *note A.4.1(5): 5774.

Mode_Error
   in Ada.Direct_IO   *note A.8.4(18): 6348.
   in Ada.IO_Exceptions   *note A.13(4): 6615.
   in Ada.Sequential_IO   *note A.8.1(15): 6316.
   in Ada.Streams.Stream_IO   *note A.12.1(26): 6596.
   in Ada.Text_IO   *note A.10.1(85): 6521.

Name_Error
   in Ada.Direct_IO   *note A.8.4(18): 6349.
   in Ada.Directories   *note A.16(43/2): 6672.
   in Ada.IO_Exceptions   *note A.13(4): 6616.
   in Ada.Sequential_IO   *note A.8.1(15): 6317.
   in Ada.Streams.Stream_IO   *note A.12.1(26): 6597.
   in Ada.Text_IO   *note A.10.1(85): 6522.

Pattern_Error
   in Ada.Strings   *note A.4.1(5): 5775.

Picture_Error
   in Ada.Text_IO.Editing   *note F.3.3(9): 8241.

Pointer_Error
   in Interfaces.C.Pointers   *note B.3.2(8): 7522.

Program_Error
   in Standard   *note A.1(46): 5452.

Status_Error
   in Ada.Direct_IO   *note A.8.4(18): 6347.
   in Ada.Directories   *note A.16(43/2): 6671.
   in Ada.IO_Exceptions   *note A.13(4): 6614.
   in Ada.Sequential_IO   *note A.8.1(15): 6315.
   in Ada.Streams.Stream_IO   *note A.12.1(26): 6595.
   in Ada.Text_IO   *note A.10.1(85): 6520.

Storage_Error
   in Standard   *note A.1(46): 5453.

Tag_Error
   in Ada.Tags   *note 3.9(8): 2114.

Tasking_Error
   in Standard   *note A.1(46): 5454.

Terminator_Error
   in Interfaces.C   *note B.3(40): 7491.

Time_Error
   in Ada.Calendar   *note 9.6(18): 4158.

Timer_Resource_Error
   in Ada.Execution_Time.Timers   *note D.14.1(9/2): 8024.

Translation_Error
   in Ada.Strings   *note A.4.1(5): 5777.

Unknown_Zone_Error
   in Ada.Calendar.Time_Zones   *note 9.6.1(5/2): 4171.

Use_Error
   in Ada.Direct_IO   *note A.8.4(18): 6350.
   in Ada.Directories   *note A.16(43/2): 6673.
   in Ada.IO_Exceptions   *note A.13(4): 6617.
   in Ada.Sequential_IO   *note A.8.1(15): 6318.
   in Ada.Streams.Stream_IO   *note A.12.1(26): 6598.
   in Ada.Text_IO   *note A.10.1(85): 6523.


File: arm2012.info,  Node: Q.5,  Prev: Q.4,  Up: Annex Q

Q.5 Language-Defined Objects
============================

1/3
This subclause lists all language-defined constants, variables, named
numbers, and enumeration literals.

 

ACK in Ada.Characters.Latin_1   *note A.3.3(5): 5506.

Acute in Ada.Characters.Latin_1   *note A.3.3(22): 5652.

Ada_To_COBOL in Interfaces.COBOL   *note B.4(14): 7555.

Alphanumeric_Set
   in Ada.Strings.Maps.Constants   *note A.4.6(4): 5963.

Ampersand in Ada.Characters.Latin_1   *note A.3.3(8): 5538.

APC in Ada.Characters.Latin_1   *note A.3.3(19): 5629.

Apostrophe in Ada.Characters.Latin_1   *note A.3.3(8): 5539.

Asterisk in Ada.Characters.Latin_1   *note A.3.3(8): 5542.

Basic_Map
   in Ada.Strings.Maps.Constants   *note A.4.6(5): 5968.

Basic_Set
   in Ada.Strings.Maps.Constants   *note A.4.6(4): 5960.

BEL in Ada.Characters.Latin_1   *note A.3.3(5): 5507.

BOM_16 in Ada.Strings.UTF_Encoding   *note A.4.11(12/3): 6073.

BOM_16BE in Ada.Strings.UTF_Encoding   *note A.4.11(10/3): 6071.

BOM_16LE in Ada.Strings.UTF_Encoding   *note A.4.11(11/3): 6072.

BOM_8 in Ada.Strings.UTF_Encoding   *note A.4.11(9/3): 6070.

BPH in Ada.Characters.Latin_1   *note A.3.3(17): 5600.

Broken_Bar in Ada.Characters.Latin_1   *note A.3.3(21/3): 5637.

BS in Ada.Characters.Latin_1   *note A.3.3(5): 5508.

Buffer_Size in Ada.Storage_IO   *note A.9(4): 6356.

CAN in Ada.Characters.Latin_1   *note A.3.3(6): 5524.

CCH in Ada.Characters.Latin_1   *note A.3.3(18): 5618.

Cedilla in Ada.Characters.Latin_1   *note A.3.3(22): 5657.

Cent_Sign in Ada.Characters.Latin_1   *note A.3.3(21/3): 5633.

char16_nul in Interfaces.C   *note B.3(39.3/2): 7472.

char32_nul in Interfaces.C   *note B.3(39.12/2): 7482.

CHAR_BIT in Interfaces.C   *note B.3(6): 7433.

Character_Set
   in Ada.Strings.Wide_Maps   *note A.4.7(46/2): 6006.
   in Ada.Strings.Wide_Maps.Wide_Constants   *note A.4.8(48/2): 6046.

Circumflex in Ada.Characters.Latin_1   *note A.3.3(12): 5559.

COBOL_To_Ada in Interfaces.COBOL   *note B.4(15): 7556.

Colon in Ada.Characters.Latin_1   *note A.3.3(10): 5549.

Comma in Ada.Characters.Latin_1   *note A.3.3(8): 5544.

Commercial_At
   in Ada.Characters.Latin_1   *note A.3.3(10): 5555.

Control_Set
   in Ada.Strings.Maps.Constants   *note A.4.6(4): 5955.

Copyright_Sign
   in Ada.Characters.Latin_1   *note A.3.3(21/3): 5640.

Country_Unknown in Ada.Locales   *note A.19(5/3): 7374.

CPU_Tick in Ada.Execution_Time   *note D.14(4/2): 8004.

CPU_Time_First in Ada.Execution_Time   *note D.14(4/2): 8001.

CPU_Time_Last in Ada.Execution_Time   *note D.14(4/2): 8002.

CPU_Time_Unit in Ada.Execution_Time   *note D.14(4/2): 8003.

CR in Ada.Characters.Latin_1   *note A.3.3(5): 5513.

CSI in Ada.Characters.Latin_1   *note A.3.3(19): 5625.

Currency_Sign
   in Ada.Characters.Latin_1   *note A.3.3(21/3): 5635.

DC1 in Ada.Characters.Latin_1   *note A.3.3(6): 5517.

DC2 in Ada.Characters.Latin_1   *note A.3.3(6): 5518.

DC3 in Ada.Characters.Latin_1   *note A.3.3(6): 5519.

DC4 in Ada.Characters.Latin_1   *note A.3.3(6): 5520.

DCS in Ada.Characters.Latin_1   *note A.3.3(18): 5614.

Decimal_Digit_Set
   in Ada.Strings.Maps.Constants   *note A.4.6(4): 5961.

Default_Aft
   in Ada.Text_IO   *note A.10.1(64): 6483, *note A.10.1(69): 6493,
*note A.10.1(74): 6503.
   in Ada.Text_IO.Complex_IO   *note G.1.3(5): 8316.

Default_Base in Ada.Text_IO   *note A.10.1(53): 6465, *note A.10.1(58):
6474.

Default_Bit_Order in System   *note 13.7(15/2): 5126.

Default_Currency
   in Ada.Text_IO.Editing   *note F.3.3(10): 8242.

Default_Deadline
   in Ada.Dispatching.EDF   *note D.2.6(9/2): 7823.

Default_Exp
   in Ada.Text_IO   *note A.10.1(64): 6484, *note A.10.1(69): 6494,
*note A.10.1(74): 6504.
   in Ada.Text_IO.Complex_IO   *note G.1.3(5): 8317.

Default_Fill in Ada.Text_IO.Editing   *note F.3.3(10): 8243.

Default_Fore
   in Ada.Text_IO   *note A.10.1(64): 6482, *note A.10.1(69): 6492,
*note A.10.1(74): 6502.
   in Ada.Text_IO.Complex_IO   *note G.1.3(5): 8315.

Default_Priority in System   *note 13.7(17): 5130.

Default_Quantum
   in Ada.Dispatching.Round_Robin   *note D.2.5(4/2): 7814.

Default_Radix_Mark
   in Ada.Text_IO.Editing   *note F.3.3(10): 8245.

Default_Separator
   in Ada.Text_IO.Editing   *note F.3.3(10): 8244.

Default_Setting in Ada.Text_IO   *note A.10.1(80): 6513.

Default_Width in Ada.Text_IO   *note A.10.1(53): 6464, *note A.10.1(58):
6473, *note A.10.1(80): 6512.

Degree_Sign in Ada.Characters.Latin_1   *note A.3.3(22): 5647.

DEL in Ada.Characters.Latin_1   *note A.3.3(14): 5592.

Diaeresis in Ada.Characters.Latin_1   *note A.3.3(21/3): 5639.

Division_Sign
   in Ada.Characters.Latin_1   *note A.3.3(26): 5720.

DLE in Ada.Characters.Latin_1   *note A.3.3(6): 5516.

Dollar_Sign in Ada.Characters.Latin_1   *note A.3.3(8): 5536.

e in Ada.Numerics   *note A.5(3/2): 6109.

EM in Ada.Characters.Latin_1   *note A.3.3(6): 5525.

Empty_Holder
   in Ada.Containers.Indefinite_Holders   *note A.18.18(7/3): 7286.

Empty_List
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(8/2): 6825.

Empty_Map
   in Ada.Containers.Hashed_Maps   *note A.18.5(5/2): 6911.
   in Ada.Containers.Ordered_Maps   *note A.18.6(6/2): 6964.

Empty_Set
   in Ada.Containers.Hashed_Sets   *note A.18.8(5/2): 7043.
   in Ada.Containers.Ordered_Sets   *note A.18.9(6/2): 7116.

Empty_Tree
   in Ada.Containers.Multiway_Trees   *note A.18.10(10/3): 7204.

Empty_Vector
   in Ada.Containers.Vectors   *note A.18.2(10/2): 6729.

ENQ in Ada.Characters.Latin_1   *note A.3.3(5): 5505.

EOT in Ada.Characters.Latin_1   *note A.3.3(5): 5504.

EPA in Ada.Characters.Latin_1   *note A.3.3(18): 5621.

Equals_Sign in Ada.Characters.Latin_1   *note A.3.3(10): 5552.

ESA in Ada.Characters.Latin_1   *note A.3.3(17): 5605.

ESC in Ada.Characters.Latin_1   *note A.3.3(6): 5527.

ETB in Ada.Characters.Latin_1   *note A.3.3(6): 5523.

ETX in Ada.Characters.Latin_1   *note A.3.3(5): 5503.

Exclamation in Ada.Characters.Latin_1   *note A.3.3(8): 5533.

Failure in Ada.Command_Line   *note A.15(8): 6632.

Feminine_Ordinal_Indicator
   in Ada.Characters.Latin_1   *note A.3.3(21/3): 5641.

FF in Ada.Characters.Latin_1   *note A.3.3(5): 5512.

Fine_Delta in System   *note 13.7(9): 5115.

Fraction_One_Half
   in Ada.Characters.Latin_1   *note A.3.3(22): 5662.

Fraction_One_Quarter
   in Ada.Characters.Latin_1   *note A.3.3(22): 5661.

Fraction_Three_Quarters
   in Ada.Characters.Latin_1   *note A.3.3(22): 5663.

Friday in Ada.Calendar.Formatting   *note 9.6.1(17/2): 4183.

FS in Ada.Characters.Latin_1   *note A.3.3(6): 5528.

Full_Stop in Ada.Characters.Latin_1   *note A.3.3(8): 5547.

Graphic_Set
   in Ada.Strings.Maps.Constants   *note A.4.6(4): 5956.

Grave in Ada.Characters.Latin_1   *note A.3.3(13): 5561.

Greater_Than_Sign
   in Ada.Characters.Latin_1   *note A.3.3(10): 5553.

GS in Ada.Characters.Latin_1   *note A.3.3(6): 5529.

Hexadecimal_Digit_Set
   in Ada.Strings.Maps.Constants   *note A.4.6(4): 5962.

High_Order_First
   in Interfaces.COBOL   *note B.4(25): 7570.
   in System   *note 13.7(15/2): 5124.

HT in Ada.Characters.Latin_1   *note A.3.3(5): 5509.

HTJ in Ada.Characters.Latin_1   *note A.3.3(17): 5607.

HTS in Ada.Characters.Latin_1   *note A.3.3(17): 5606.

Hyphen in Ada.Characters.Latin_1   *note A.3.3(8): 5545.

i
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(5): 8261.
   in Interfaces.Fortran   *note B.5(10): 7607.

Identity
   in Ada.Strings.Maps   *note A.4.2(22): 5799.
   in Ada.Strings.Wide_Maps   *note A.4.7(22): 6001.
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(22/2): 6040.

Interrupt_Clocks_Supported
   in Ada.Execution_Time   *note D.14(9.1/3): 8008.

Inverted_Exclamation
   in Ada.Characters.Latin_1   *note A.3.3(21/3): 5632.

Inverted_Question
   in Ada.Characters.Latin_1   *note A.3.3(22): 5664.

IS1 in Ada.Characters.Latin_1   *note A.3.3(16): 5597.

IS2 in Ada.Characters.Latin_1   *note A.3.3(16): 5596.

IS3 in Ada.Characters.Latin_1   *note A.3.3(16): 5595.

IS4 in Ada.Characters.Latin_1   *note A.3.3(16): 5594.

ISO_646_Set
   in Ada.Strings.Maps.Constants   *note A.4.6(4): 5965.

j
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(5): 8262.
   in Interfaces.Fortran   *note B.5(10): 7608.

Language_Unknown in Ada.Locales   *note A.19(5/3): 7373.

LC_A in Ada.Characters.Latin_1   *note A.3.3(13): 5562.

LC_A_Acute in Ada.Characters.Latin_1   *note A.3.3(25): 5698.

LC_A_Circumflex
   in Ada.Characters.Latin_1   *note A.3.3(25): 5699.

LC_A_Diaeresis
   in Ada.Characters.Latin_1   *note A.3.3(25): 5701.

LC_A_Grave in Ada.Characters.Latin_1   *note A.3.3(25): 5697.

LC_A_Ring in Ada.Characters.Latin_1   *note A.3.3(25): 5702.

LC_A_Tilde in Ada.Characters.Latin_1   *note A.3.3(25): 5700.

LC_AE_Diphthong
   in Ada.Characters.Latin_1   *note A.3.3(25): 5703.

LC_B in Ada.Characters.Latin_1   *note A.3.3(13): 5563.

LC_C in Ada.Characters.Latin_1   *note A.3.3(13): 5564.

LC_C_Cedilla
   in Ada.Characters.Latin_1   *note A.3.3(25): 5704.

LC_D in Ada.Characters.Latin_1   *note A.3.3(13): 5565.

LC_E in Ada.Characters.Latin_1   *note A.3.3(13): 5566.

LC_E_Acute in Ada.Characters.Latin_1   *note A.3.3(25): 5706.

LC_E_Circumflex
   in Ada.Characters.Latin_1   *note A.3.3(25): 5707.

LC_E_Diaeresis
   in Ada.Characters.Latin_1   *note A.3.3(25): 5708.

LC_E_Grave in Ada.Characters.Latin_1   *note A.3.3(25): 5705.

LC_F in Ada.Characters.Latin_1   *note A.3.3(13): 5567.

LC_G in Ada.Characters.Latin_1   *note A.3.3(13): 5568.

LC_German_Sharp_S
   in Ada.Characters.Latin_1   *note A.3.3(24): 5696.

LC_H in Ada.Characters.Latin_1   *note A.3.3(13): 5569.

LC_I in Ada.Characters.Latin_1   *note A.3.3(13): 5570.

LC_I_Acute in Ada.Characters.Latin_1   *note A.3.3(25): 5710.

LC_I_Circumflex
   in Ada.Characters.Latin_1   *note A.3.3(25): 5711.

LC_I_Diaeresis
   in Ada.Characters.Latin_1   *note A.3.3(25): 5712.

LC_I_Grave in Ada.Characters.Latin_1   *note A.3.3(25): 5709.

LC_Icelandic_Eth
   in Ada.Characters.Latin_1   *note A.3.3(26): 5713.

LC_Icelandic_Thorn
   in Ada.Characters.Latin_1   *note A.3.3(26): 5727.

LC_J in Ada.Characters.Latin_1   *note A.3.3(13): 5571.

LC_K in Ada.Characters.Latin_1   *note A.3.3(13): 5572.

LC_L in Ada.Characters.Latin_1   *note A.3.3(13): 5573.

LC_M in Ada.Characters.Latin_1   *note A.3.3(13): 5574.

LC_N in Ada.Characters.Latin_1   *note A.3.3(13): 5575.

LC_N_Tilde in Ada.Characters.Latin_1   *note A.3.3(26): 5714.

LC_O in Ada.Characters.Latin_1   *note A.3.3(13): 5576.

LC_O_Acute in Ada.Characters.Latin_1   *note A.3.3(26): 5716.

LC_O_Circumflex
   in Ada.Characters.Latin_1   *note A.3.3(26): 5717.

LC_O_Diaeresis
   in Ada.Characters.Latin_1   *note A.3.3(26): 5719.

LC_O_Grave in Ada.Characters.Latin_1   *note A.3.3(26): 5715.

LC_O_Oblique_Stroke
   in Ada.Characters.Latin_1   *note A.3.3(26): 5721.

LC_O_Tilde in Ada.Characters.Latin_1   *note A.3.3(26): 5718.

LC_P in Ada.Characters.Latin_1   *note A.3.3(14): 5577.

LC_Q in Ada.Characters.Latin_1   *note A.3.3(14): 5578.

LC_R in Ada.Characters.Latin_1   *note A.3.3(14): 5579.

LC_S in Ada.Characters.Latin_1   *note A.3.3(14): 5580.

LC_T in Ada.Characters.Latin_1   *note A.3.3(14): 5581.

LC_U in Ada.Characters.Latin_1   *note A.3.3(14): 5582.

LC_U_Acute in Ada.Characters.Latin_1   *note A.3.3(26): 5723.

LC_U_Circumflex
   in Ada.Characters.Latin_1   *note A.3.3(26): 5724.

LC_U_Diaeresis
   in Ada.Characters.Latin_1   *note A.3.3(26): 5725.

LC_U_Grave in Ada.Characters.Latin_1   *note A.3.3(26): 5722.

LC_V in Ada.Characters.Latin_1   *note A.3.3(14): 5583.

LC_W in Ada.Characters.Latin_1   *note A.3.3(14): 5584.

LC_X in Ada.Characters.Latin_1   *note A.3.3(14): 5585.

LC_Y in Ada.Characters.Latin_1   *note A.3.3(14): 5586.

LC_Y_Acute in Ada.Characters.Latin_1   *note A.3.3(26): 5726.

LC_Y_Diaeresis
   in Ada.Characters.Latin_1   *note A.3.3(26): 5728.

LC_Z in Ada.Characters.Latin_1   *note A.3.3(14): 5587.

Leading_Nonseparate
   in Interfaces.COBOL   *note B.4(23): 7567.

Leading_Separate in Interfaces.COBOL   *note B.4(23): 7565.

Left_Angle_Quotation
   in Ada.Characters.Latin_1   *note A.3.3(21/3): 5642.

Left_Curly_Bracket
   in Ada.Characters.Latin_1   *note A.3.3(14): 5588.

Left_Parenthesis
   in Ada.Characters.Latin_1   *note A.3.3(8): 5540.

Left_Square_Bracket
   in Ada.Characters.Latin_1   *note A.3.3(12): 5556.

Less_Than_Sign
   in Ada.Characters.Latin_1   *note A.3.3(10): 5551.

Letter_Set
   in Ada.Strings.Maps.Constants   *note A.4.6(4): 5957.

LF in Ada.Characters.Latin_1   *note A.3.3(5): 5510.

Low_Line in Ada.Characters.Latin_1   *note A.3.3(12): 5560.

Low_Order_First
   in Interfaces.COBOL   *note B.4(25): 7571.
   in System   *note 13.7(15/2): 5125.

Lower_Case_Map
   in Ada.Strings.Maps.Constants   *note A.4.6(5): 5966.

Lower_Set
   in Ada.Strings.Maps.Constants   *note A.4.6(4): 5958.

Macron in Ada.Characters.Latin_1   *note A.3.3(21/3): 5646.

Masculine_Ordinal_Indicator
   in Ada.Characters.Latin_1   *note A.3.3(22): 5659.

Max_Base_Digits in System   *note 13.7(8): 5112.

Max_Binary_Modulus in System   *note 13.7(7): 5110.

Max_Decimal_Digits in Ada.Decimal   *note F.2(5): 8228.

Max_Delta in Ada.Decimal   *note F.2(4): 8227.

Max_Digits in System   *note 13.7(8): 5113.

Max_Digits_Binary in Interfaces.COBOL   *note B.4(11): 7550.

Max_Digits_Long_Binary
   in Interfaces.COBOL   *note B.4(11): 7551.

Max_Image_Width
   in Ada.Numerics.Discrete_Random   *note A.5.2(25): 6168.
   in Ada.Numerics.Float_Random   *note A.5.2(13): 6156.

Max_Int in System   *note 13.7(6): 5109.

Max_Length in Ada.Strings.Bounded   *note A.4.4(5): 5845.

Max_Mantissa in System   *note 13.7(9): 5114.

Max_Nonbinary_Modulus in System   *note 13.7(7): 5111.

Max_Picture_Length
   in Ada.Text_IO.Editing   *note F.3.3(8): 8240.

Max_Scale in Ada.Decimal   *note F.2(3): 8224.

Memory_Size in System   *note 13.7(13): 5121.

Micro_Sign in Ada.Characters.Latin_1   *note A.3.3(22): 5653.

Middle_Dot in Ada.Characters.Latin_1   *note A.3.3(22): 5656.

Min_Delta in Ada.Decimal   *note F.2(4): 8226.

Min_Handler_Ceiling
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(7/2): 8034.
   in Ada.Execution_Time.Timers   *note D.14.1(6/2): 8018.

Min_Int in System   *note 13.7(6): 5108.

Min_Scale in Ada.Decimal   *note F.2(3): 8225.

Minus_Sign in Ada.Characters.Latin_1   *note A.3.3(8): 5546.

Monday in Ada.Calendar.Formatting   *note 9.6.1(17/2): 4179.

Multiplication_Sign
   in Ada.Characters.Latin_1   *note A.3.3(24): 5688.

MW in Ada.Characters.Latin_1   *note A.3.3(18): 5619.

NAK in Ada.Characters.Latin_1   *note A.3.3(6): 5521.

Native_Binary in Interfaces.COBOL   *note B.4(25): 7572.

NBH in Ada.Characters.Latin_1   *note A.3.3(17): 5601.

NBSP in Ada.Characters.Latin_1   *note A.3.3(21/3): 5631.

NEL in Ada.Characters.Latin_1   *note A.3.3(17): 5603.

No_Break_Space
   in Ada.Characters.Latin_1   *note A.3.3(21/3): 5630.

No_Element
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(9/2): 6826.
   in Ada.Containers.Hashed_Maps   *note A.18.5(6/2): 6912.
   in Ada.Containers.Hashed_Sets   *note A.18.8(6/2): 7044.
   in Ada.Containers.Multiway_Trees   *note A.18.10(11/3): 7205.
   in Ada.Containers.Ordered_Maps   *note A.18.6(7/2): 6965.
   in Ada.Containers.Ordered_Sets   *note A.18.9(7/2): 7117.
   in Ada.Containers.Vectors   *note A.18.2(11/2): 6730.

No_Index in Ada.Containers.Vectors   *note A.18.2(7/2): 6726.

No_Tag in Ada.Tags   *note 3.9(6.1/2): 2102.

Not_A_Specific_CPU
   in System.Multiprocessors   *note D.16(4/3): 8072.

Not_Sign in Ada.Characters.Latin_1   *note A.3.3(21/3): 5643.

NUL
   in Ada.Characters.Latin_1   *note A.3.3(5): 5500.
   in Interfaces.C   *note B.3(20/1): 7452.

Null_Address in System   *note 13.7(12): 5118.

Null_Bounded_String
   in Ada.Strings.Bounded   *note A.4.4(7): 5847.

Null_Id in Ada.Exceptions   *note 11.4.1(2/2): 4566.

Null_Occurrence in Ada.Exceptions   *note 11.4.1(3/2): 4572.

Null_Ptr in Interfaces.C.Strings   *note B.3.1(7): 7500.

Null_Set
   in Ada.Strings.Maps   *note A.4.2(5): 5785.
   in Ada.Strings.Wide_Maps   *note A.4.7(5): 5987.
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(5/2): 6026.

Null_Unbounded_String
   in Ada.Strings.Unbounded   *note A.4.5(5): 5904.

Number_Sign in Ada.Characters.Latin_1   *note A.3.3(8): 5535.

OSC in Ada.Characters.Latin_1   *note A.3.3(19): 5627.

Packed_Signed in Interfaces.COBOL   *note B.4(27): 7575.

Packed_Unsigned in Interfaces.COBOL   *note B.4(27): 7574.

Paragraph_Sign
   in Ada.Characters.Latin_1   *note A.3.3(22): 5655.

Percent_Sign
   in Ada.Characters.Latin_1   *note A.3.3(8): 5537.

Pi in Ada.Numerics   *note A.5(3/2): 6108.

Pilcrow_Sign
   in Ada.Characters.Latin_1   *note A.3.3(22): 5654.

PLD in Ada.Characters.Latin_1   *note A.3.3(17): 5609.

PLU in Ada.Characters.Latin_1   *note A.3.3(17): 5610.

Plus_Minus_Sign
   in Ada.Characters.Latin_1   *note A.3.3(22): 5649.

Plus_Sign in Ada.Characters.Latin_1   *note A.3.3(8): 5543.

PM in Ada.Characters.Latin_1   *note A.3.3(19): 5628.

Pound_Sign in Ada.Characters.Latin_1   *note A.3.3(21/3): 5634.

PU1 in Ada.Characters.Latin_1   *note A.3.3(18): 5615.

PU2 in Ada.Characters.Latin_1   *note A.3.3(18): 5616.

Question in Ada.Characters.Latin_1   *note A.3.3(10): 5554.

Quotation in Ada.Characters.Latin_1   *note A.3.3(8): 5534.

Registered_Trade_Mark_Sign
   in Ada.Characters.Latin_1   *note A.3.3(21/3): 5645.

Reserved_128
   in Ada.Characters.Latin_1   *note A.3.3(17): 5598.

Reserved_129
   in Ada.Characters.Latin_1   *note A.3.3(17): 5599.

Reserved_132
   in Ada.Characters.Latin_1   *note A.3.3(17): 5602.

Reserved_153
   in Ada.Characters.Latin_1   *note A.3.3(19): 5623.

Reverse_Solidus
   in Ada.Characters.Latin_1   *note A.3.3(12): 5557.

RI in Ada.Characters.Latin_1   *note A.3.3(17): 5611.

Right_Angle_Quotation
   in Ada.Characters.Latin_1   *note A.3.3(22): 5660.

Right_Curly_Bracket
   in Ada.Characters.Latin_1   *note A.3.3(14): 5590.

Right_Parenthesis
   in Ada.Characters.Latin_1   *note A.3.3(8): 5541.

Right_Square_Bracket
   in Ada.Characters.Latin_1   *note A.3.3(12): 5558.

Ring_Above in Ada.Characters.Latin_1   *note A.3.3(22): 5648.

RS in Ada.Characters.Latin_1   *note A.3.3(6): 5530.

Saturday in Ada.Calendar.Formatting   *note 9.6.1(17/2): 4184.

SCHAR_MAX in Interfaces.C   *note B.3(6): 7435.

SCHAR_MIN in Interfaces.C   *note B.3(6): 7434.

SCI in Ada.Characters.Latin_1   *note A.3.3(19): 5624.

Section_Sign
   in Ada.Characters.Latin_1   *note A.3.3(21/3): 5638.

Semicolon in Ada.Characters.Latin_1   *note A.3.3(10): 5550.

Separate_Interrupt_Clocks_Supported
   in Ada.Execution_Time   *note D.14(9.2/3): 8009.

SI in Ada.Characters.Latin_1   *note A.3.3(5): 5515.

SO in Ada.Characters.Latin_1   *note A.3.3(5): 5514.

Soft_Hyphen in Ada.Characters.Latin_1   *note A.3.3(21/3): 5644.

SOH in Ada.Characters.Latin_1   *note A.3.3(5): 5501.

Solidus in Ada.Characters.Latin_1   *note A.3.3(8): 5548.

SOS in Ada.Characters.Latin_1   *note A.3.3(19): 5622.

SPA in Ada.Characters.Latin_1   *note A.3.3(18): 5620.

Space
   in Ada.Characters.Latin_1   *note A.3.3(8): 5532.
   in Ada.Strings   *note A.4.1(4/2): 5771.

Special_Set
   in Ada.Strings.Maps.Constants   *note A.4.6(4): 5964.

SS2 in Ada.Characters.Latin_1   *note A.3.3(17): 5612.

SS3 in Ada.Characters.Latin_1   *note A.3.3(17): 5613.

SSA in Ada.Characters.Latin_1   *note A.3.3(17): 5604.

ST in Ada.Characters.Latin_1   *note A.3.3(19): 5626.

Storage_Unit in System   *note 13.7(13): 5119.

STS in Ada.Characters.Latin_1   *note A.3.3(18): 5617.

STX in Ada.Characters.Latin_1   *note A.3.3(5): 5502.

SUB in Ada.Characters.Latin_1   *note A.3.3(6): 5526.

Success in Ada.Command_Line   *note A.15(8): 6631.

Sunday in Ada.Calendar.Formatting   *note 9.6.1(17/2): 4185.

Superscript_One
   in Ada.Characters.Latin_1   *note A.3.3(22): 5658.

Superscript_Three
   in Ada.Characters.Latin_1   *note A.3.3(22): 5651.

Superscript_Two
   in Ada.Characters.Latin_1   *note A.3.3(22): 5650.

SYN in Ada.Characters.Latin_1   *note A.3.3(6): 5522.

System_Dispatching_Domain
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(6/3):
8080.

System_Name in System   *note 13.7(4): 5107.

Thursday in Ada.Calendar.Formatting   *note 9.6.1(17/2): 4182.

Tick
   in Ada.Real_Time   *note D.8(6): 7951.
   in System   *note 13.7(10): 5116.

Tilde in Ada.Characters.Latin_1   *note A.3.3(14): 5591.

Time_First in Ada.Real_Time   *note D.8(4): 7943.

Time_Last in Ada.Real_Time   *note D.8(4): 7944.

Time_Span_First in Ada.Real_Time   *note D.8(5): 7947.

Time_Span_Last in Ada.Real_Time   *note D.8(5): 7948.

Time_Span_Unit in Ada.Real_Time   *note D.8(5): 7950.

Time_Span_Zero in Ada.Real_Time   *note D.8(5): 7949.

Time_Unit in Ada.Real_Time   *note D.8(4): 7945.

Trailing_Nonseparate
   in Interfaces.COBOL   *note B.4(23): 7568.

Trailing_Separate in Interfaces.COBOL   *note B.4(23): 7566.

Tuesday in Ada.Calendar.Formatting   *note 9.6.1(17/2): 4180.

UC_A_Acute in Ada.Characters.Latin_1   *note A.3.3(23): 5666.

UC_A_Circumflex
   in Ada.Characters.Latin_1   *note A.3.3(23): 5667.

UC_A_Diaeresis
   in Ada.Characters.Latin_1   *note A.3.3(23): 5669.

UC_A_Grave in Ada.Characters.Latin_1   *note A.3.3(23): 5665.

UC_A_Ring in Ada.Characters.Latin_1   *note A.3.3(23): 5670.

UC_A_Tilde in Ada.Characters.Latin_1   *note A.3.3(23): 5668.

UC_AE_Diphthong
   in Ada.Characters.Latin_1   *note A.3.3(23): 5671.

UC_C_Cedilla
   in Ada.Characters.Latin_1   *note A.3.3(23): 5672.

UC_E_Acute in Ada.Characters.Latin_1   *note A.3.3(23): 5674.

UC_E_Circumflex
   in Ada.Characters.Latin_1   *note A.3.3(23): 5675.

UC_E_Diaeresis
   in Ada.Characters.Latin_1   *note A.3.3(23): 5676.

UC_E_Grave in Ada.Characters.Latin_1   *note A.3.3(23): 5673.

UC_I_Acute in Ada.Characters.Latin_1   *note A.3.3(23): 5678.

UC_I_Circumflex
   in Ada.Characters.Latin_1   *note A.3.3(23): 5679.

UC_I_Diaeresis
   in Ada.Characters.Latin_1   *note A.3.3(23): 5680.

UC_I_Grave in Ada.Characters.Latin_1   *note A.3.3(23): 5677.

UC_Icelandic_Eth
   in Ada.Characters.Latin_1   *note A.3.3(24): 5681.

UC_Icelandic_Thorn
   in Ada.Characters.Latin_1   *note A.3.3(24): 5695.

UC_N_Tilde in Ada.Characters.Latin_1   *note A.3.3(24): 5682.

UC_O_Acute in Ada.Characters.Latin_1   *note A.3.3(24): 5684.

UC_O_Circumflex
   in Ada.Characters.Latin_1   *note A.3.3(24): 5685.

UC_O_Diaeresis
   in Ada.Characters.Latin_1   *note A.3.3(24): 5687.

UC_O_Grave in Ada.Characters.Latin_1   *note A.3.3(24): 5683.

UC_O_Oblique_Stroke
   in Ada.Characters.Latin_1   *note A.3.3(24): 5689.

UC_O_Tilde in Ada.Characters.Latin_1   *note A.3.3(24): 5686.

UC_U_Acute in Ada.Characters.Latin_1   *note A.3.3(24): 5691.

UC_U_Circumflex
   in Ada.Characters.Latin_1   *note A.3.3(24): 5692.

UC_U_Diaeresis
   in Ada.Characters.Latin_1   *note A.3.3(24): 5693.

UC_U_Grave in Ada.Characters.Latin_1   *note A.3.3(24): 5690.

UC_Y_Acute in Ada.Characters.Latin_1   *note A.3.3(24): 5694.

UCHAR_MAX in Interfaces.C   *note B.3(6): 7436.

Unbounded in Ada.Text_IO   *note A.10.1(5): 6379.

Unsigned in Interfaces.COBOL   *note B.4(23): 7564.

Upper_Case_Map
   in Ada.Strings.Maps.Constants   *note A.4.6(5): 5967.

Upper_Set
   in Ada.Strings.Maps.Constants   *note A.4.6(4): 5959.

US in Ada.Characters.Latin_1   *note A.3.3(6): 5531.

Vertical_Line
   in Ada.Characters.Latin_1   *note A.3.3(14): 5589.

VT in Ada.Characters.Latin_1   *note A.3.3(5): 5511.

VTS in Ada.Characters.Latin_1   *note A.3.3(17): 5608.

Wednesday in Ada.Calendar.Formatting   *note 9.6.1(17/2): 4181.

Wide_Character_Set
   in Ada.Strings.Wide_Maps.Wide_Constants   *note A.4.8(48/2): 6047.

wide_nul in Interfaces.C   *note B.3(31/1): 7462.

Wide_Space in Ada.Strings   *note A.4.1(4/2): 5772.

Wide_Wide_Space in Ada.Strings   *note A.4.1(4/2): 5773.

Word_Size in System   *note 13.7(13): 5120.

Yen_Sign in Ada.Characters.Latin_1   *note A.3.3(21/3): 5636.


File: arm2012.info,  Node: Index,  Prev: Annex Q,  Up: Top

Index
*****

Index entries are given by paragraph number.
* Menu:

* operators::
* A::
* B::
* C::
* D::
* E::
* F::
* G::
* H::
* I::
* J::
* K::
* L::
* M::
* N::
* O::
* P::
* Q::
* R::
* S::
* T::
* U::
* V::
* W::
* X::
* Y::


File: arm2012.info,  Node: operators,  Next: A,  Up: Index

operators
=========

 

& operator   *note 4.4(1/3): 2625, *note 4.5.3(3): 2815.
 
* operator   *note 4.4(1/3): 2632, *note 4.5.5(1): 2840.
** operator   *note 4.4(1/3): 2646, *note 4.5.6(7): 2871.
 
+ operator   *note 4.4(1/3): 2617, *note 4.5.3(1): 2807, *note 4.5.4(1):
2830.
 
- operator   *note 4.4(1/3): 2621, *note 4.5.3(1): 2811, *note 4.5.4(1):
2834.
 
/ operator   *note 4.4(1/3): 2638, *note 4.5.5(1): 2846.
/= operator   *note 4.4(1/3): 2595, *note 4.5.2(1): 2769, *note
6.6(6/3): 3542.
 
10646:2011, ISO/IEC standard   *note 1.2(8/3): 1115.
14882:2011, ISO/IEC standard   *note 1.2(9/3): 1118.
1539-1:2004, ISO/IEC standard   *note 1.2(3/2): 1095.
19769:2004, ISO/IEC technical report   *note 1.2(10/2): 1121.
1989:2002, ISO standard   *note 1.2(4/2): 1098.
 
3166-1:2006, ISO/IEC standard   *note 1.2(4.1/3): 1101.
 
639-3:2007, ISO standard   *note 1.2(1.1/3): 1089.
6429:1992, ISO/IEC standard   *note 1.2(5): 1104.
646:1991, ISO/IEC standard   *note 1.2(2): 1092.
 
8859-1:1998, ISO/IEC standard   *note 1.2(6/3): 1109.
 
9899:2011, ISO/IEC standard   *note 1.2(7/3): 1112.
 
< operator   *note 4.4(1/3): 2599, *note 4.5.2(1): 2773.
<= operator   *note 4.4(1/3): 2603, *note 4.5.2(1): 2777.
 
= operator   *note 4.4(1/3): 2591, *note 4.5.2(1): 2765.
 
> operator   *note 4.4(1/3): 2607, *note 4.5.2(1): 2781.
>= operator   *note 4.4(1/3): 2611, *note 4.5.2(1): 2785.



File: arm2012.info,  Node: A,  Next: B,  Prev: operators,  Up: Index

A 
==



AARM   *note 0.3(5/3): 1002.
abnormal completion   *note 7.6.1(2/2): 3691.
abnormal state of an object   *note 13.9.1(4): 5167.
   [partial]   *note 9.8(21): 4294, *note 11.6(6/3): 4660, *note
A.13(17): 6624.
abnormal task   *note 9.8(4): 4284.
abort
   of a partition   *note E.1(7): 8105.
   of a task   *note 9.8(4): 4283.
   of the execution of a construct   *note 9.8(5): 4287.
abort completion point   *note 9.8(15): 4290.
abort-deferred operation   *note 9.8(5): 4288.
abort_statement   *note 9.8(2): 4277.
   used   *note 5.1(4/2): 3131, *note P: 9366.
Abort_Task
   in Ada.Task_Identification   *note C.7.1(3/3): 7714.
abortable_part   *note 9.7.4(5): 4264.
   used   *note 9.7.4(2): 4257, *note P: 9643.
abs operator   *note 4.4(1/3): 2650, *note 4.5.6(1): 2860.
absolute value   *note 4.4(1/3): 2652, *note 4.5.6(1): 2862.
abstract data type (ADT)
   See private types and private extensions   *note 7.3(1): 3598.
   See also abstract type   *note 3.9.3(1/2): 2180.
abstract subprogram   *note 3.9.3(1/2): 2183, *note 3.9.3(3/2): 2191.
abstract type   *note 3.9.3(1.2/2): 2189, *note 3.9.3(1/2): 2179, *note
N(1.1/2): 8879.
abstract_subprogram_declaration   *note 3.9.3(1.1/3): 2185.
   used   *note 3.1(3/3): 1298, *note P: 9014.
accept_alternative   *note 9.7.1(5): 4227.
   used   *note 9.7.1(4): 4224, *note P: 9627.
accept_statement   *note 9.5.2(3): 4044.
   used   *note 5.1(5/2): 3140, *note 9.7.1(5): 4228, *note P: 9630.
acceptable interpretation   *note 8.6(14): 3852.
Access attribute   *note 3.10.2(25/1): 2307, *note 3.10.2(33/3): 2317.
   See also Unchecked_Access attribute   *note 13.10(3): 5182.
access discriminant   *note 3.7(9/2): 1986.
access parameter   *note 6.1(24/2): 3340.
access paths
   distinct   *note 6.2(12/3): 3398.
access result type   *note 6.1(24/2): 3341.
access type   *note 3.10(1): 2222, *note N(2): 8880.
   subpool   *note 13.11.4(22/3): 5276.
access types
   input-output unspecified   *note A.7(6): 6284.
access value   *note 3.10(1): 2223.
access-to-constant type   *note 3.10(10): 2258.
access-to-object type   *note 3.10(7/1): 2247.
access-to-subprogram type   *note 3.10(7/1): 2248, *note 3.10(11): 2260.
access-to-variable type   *note 3.10(10): 2259.
Access_Check   *note 11.5(11/2): 4629.
   [partial]   *note 4.1(13): 2390, *note 4.1.5(8/3): 2459, *note
4.6(51/4): 3004, *note 4.8(10.4/3): 3078.
access_definition   *note 3.10(6/2): 2240.
   used   *note 3.3.1(2/3): 1485, *note 3.6(7/2): 1905, *note 3.7(5/2):
1980, *note 6.1(13/2): 3315, *note 6.1(15/3): 3326, *note 6.5(2.3/2):
3508, *note 8.5.1(2/3): 3805, *note 12.4(2/3): 4750, *note P: 9520.
access_to_object_definition   *note 3.10(3): 2232.
   used   *note 3.10(2/2): 2229, *note P: 9169.
access_to_subprogram_definition   *note 3.10(5): 2236.
   used   *note 3.10(2/2): 2231, *note P: 9171.
access_type_definition   *note 3.10(2/2): 2227.
   used   *note 3.2.1(4/2): 1386, *note 12.5.4(2): 4821, *note P: 9038.
accessibility
   distributed   *note 3.10.2(33.1/3): 2322.
   from shared passive library units   *note E.2.1(8): 8130.
accessibility level   *note 3.10.2(3/2): 2289.
accessibility rule
   Access attribute   *note 3.10.2(29/3): 2310, *note 3.10.2(33/3):
2318.
   requeue statement   *note 9.5.4(6/3): 4125.
   type conversion   *note 4.6(24.17/4): 2955, *note 4.6(24.21/4): 2961.
   type conversion, array components   *note 4.6(24.6/2): 2950.
Accessibility_Check   *note 11.5(19.1/2): 4638.
   [partial]   *note 3.10.2(30): 2312, *note 4.6(39.1/2): 2982, *note
4.6(48/3): 2996, *note 4.8(10.1/3): 3069, *note 6.5(8/4): 3526, *note
6.5(21/3): 3532, *note 13.11.4(25/3): 5278, *note 13.11.4(26/3): 5280,
*note E.4(18/1): 8192.
accessible partition   *note E.1(7): 8107.
accuracy   *note 4.6(32): 2972, *note G.2(1): 8329.
ACK
   in Ada.Characters.Latin_1   *note A.3.3(5): 5506.
acquire
   execution resource associated with protected object   *note
9.5.1(5/4): 4031.
activation
   of a task   *note 9.2(1): 3935.
activation failure   *note 9.2(1): 3937.
Activation_Is_Complete
   in Ada.Task_Identification   *note C.7.1(4/3): 7717.
activator
   of a task   *note 9.2(5): 3938.
active locale   *note A.19(8/3): 7377.
active partition   *note 10.2(28/3): 4460, *note E.1(2): 8100.
active priority   *note D.1(15): 7765.
actual   *note 12.3(7/3): 4726.
actual duration   *note D.9(12): 7972.
actual parameter
   for a formal parameter   *note 6.4.1(3): 3475.
actual subtype   *note 3.3(23/3): 1466, *note 12.5(4): 4791.
   of an object   *note 3.3.1(9/2): 1506.
actual type   *note 12.5(4): 4793.
actual_parameter_part   *note 6.4(4): 3454.
   used   *note 4.1.6(10/3): 2470, *note 6.4(2): 3449, *note 6.4(3):
3453, *note 9.5.3(2): 4094, *note P: 9453.
Actual_Quantum
   in Ada.Dispatching.Round_Robin   *note D.2.5(4/2): 7817.
Acute
   in Ada.Characters.Latin_1   *note A.3.3(22): 5652.
Ada   *note A.2(2): 5456.
Ada calling convention   *note 6.3.1(3/3): 3419.
Ada.Ada.Unchecked_Deallocate_Subpool   *note 13.11.5(3/3): 5287.
Ada.Assertions   *note 11.4.2(12/2): 4604.
Ada.Asynchronous_Task_Control   *note D.11(3/2): 7988.
Ada.Calendar   *note 9.6(10): 4145.
Ada.Calendar.Arithmetic   *note 9.6.1(8/2): 4173.
Ada.Calendar.Formatting   *note 9.6.1(15/2): 4177.
Ada.Calendar.Time_Zones   *note 9.6.1(2/2): 4169.
Ada.Characters   *note A.3.1(2): 5457.
Ada.Characters.Conversions   *note A.3.4(2/2): 5729.
Ada.Characters.Handling   *note A.3.2(2/2): 5460.
Ada.Characters.Latin_1   *note A.3.3(3): 5498.
Ada.Command_Line   *note A.15(3): 6626.
Ada.Complex_Text_IO   *note G.1.3(9.1/2): 8324.
Ada.Containers   *note A.18.1(3/2): 6715.
Ada.Containers.Bounded_Priority_Queues   *note A.18.31(2/3): 7362.
Ada.Containers.Bounded_Synchronized_Queues   *note A.18.29(2/3): 7349.
Ada.Containers.Doubly_Linked_Lists   *note A.18.3(5/3): 6822.
Ada.Containers.Generic_Array_Sort   *note A.18.26(3/2): 7330.
Ada.Containers.Generic_Constrained_Array_Sort   *note A.18.26(7/2):
7332.
Ada.Containers.Generic_Sort   *note A.18.26(9.2/4): 7334.
Ada.Containers.Hashed_Maps   *note A.18.5(2/3): 6908.
Ada.Containers.Hashed_Sets   *note A.18.8(2/3): 7040.
Ada.Containers.Indefinite_Doubly_Linked_Lists   *note A.18.12(2/3):
7277.
Ada.Containers.Indefinite_Hashed_Maps   *note A.18.13(2/3): 7278.
Ada.Containers.Indefinite_Hashed_Sets   *note A.18.15(2/3): 7280.
Ada.Containers.Indefinite_Holders   *note A.18.18(5/3): 7284.
Ada.Containers.Indefinite_Multiway_Trees   *note A.18.17(2/3): 7282.
Ada.Containers.Indefinite_Ordered_Maps   *note A.18.14(2/3): 7279.
Ada.Containers.Indefinite_Ordered_Sets   *note A.18.16(2/3): 7281.
Ada.Containers.Indefinite_Vectors   *note A.18.11(2/3): 7276.
Ada.Containers.Multiway_Trees   *note A.18.10(7/3): 7201.
Ada.Containers.Ordered_Maps   *note A.18.6(2/3): 6960.
Ada.Containers.Ordered_Sets   *note A.18.9(2/3): 7112.
Ada.Containers.Synchronized_Queue_Interfaces   *note A.18.27(3/3): 7336.
Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(2/3): 7355.
Ada.Containers.Unbounded_Synchronized_Queues   *note A.18.28(2/3): 7343.
Ada.Containers.Vectors   *note A.18.2(6/3): 6724.
Ada.Decimal   *note F.2(2): 8223.
Ada.Direct_IO   *note A.8.4(2): 6323.
Ada.Directories   *note A.16(3/2): 6635.
Ada.Directories.Hierarchical_File_Names   *note A.16.1(3/3): 6686.
Ada.Directories.Information   *note A.16(124/2): 6685.
Ada.Dispatching   *note D.2.1(1.2/3): 7769.
Ada.Dispatching.EDF   *note D.2.6(9/2): 7821.
Ada.Dispatching.Non_Preemptive   *note D.2.4(2.2/3): 7806.
Ada.Dispatching.Round_Robin   *note D.2.5(4/2): 7813.
Ada.Dynamic_Priorities   *note D.5.1(3/2): 7865.
Ada.Environment_Variables   *note A.17(3/2): 6699.
Ada.Exceptions   *note 11.4.1(2/2): 4564.
Ada.Execution_Time   *note D.14(3/2): 7999.
Ada.Execution_Time.Group_Budgets   *note D.14.2(3/3): 8030.
Ada.Execution_Time.Interrupts   *note D.14.3(3/3): 8055.
Ada.Execution_Time.Timers   *note D.14.1(3/2): 8015.
Ada.Finalization   *note 7.6(4/3): 3661.
Ada.Float_Text_IO   *note A.10.9(33): 6536.
Ada.Float_Wide_Text_IO   *note A.11(2/2): 6557.
Ada.Float_Wide_Wide_Text_IO   *note A.11(3/2): 6560.
Ada.Integer_Text_IO   *note A.10.8(21): 6535.
Ada.Integer_Wide_Text_IO   *note A.11(2/2): 6556.
Ada.Integer_Wide_Wide_Text_IO   *note A.11(3/2): 6559.
Ada.Interrupts   *note C.3.2(2/3): 7659.
Ada.Interrupts.Names   *note C.3.2(12): 7670.
Ada.IO_Exceptions   *note A.13(3): 6613.
Ada.Iterator_Interfaces   *note 5.5.1(2/3): 3209.
Ada.Locales   *note A.19(3/3): 7370.
Ada.Numerics   *note A.5(3/2): 6106.
Ada.Numerics.Complex_Arrays   *note G.3.2(53/2): 8422.
Ada.Numerics.Complex_Elementary_Functions   *note G.1.2(9/1): 8306.
Ada.Numerics.Complex_Types   *note G.1.1(25/1): 8279.
Ada.Numerics.Discrete_Random   *note A.5.2(17): 6160.
Ada.Numerics.Elementary_Functions   *note A.5.1(9/1): 6139.
Ada.Numerics.Float_Random   *note A.5.2(5): 6147.
Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(2/2): 8386.
Ada.Numerics.Generic_Complex_Elementary_Functions   *note G.1.2(2/2):
8285.
Ada.Numerics.Generic_Complex_Types   *note G.1.1(2/1): 8258.
Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(3): 6110.
Ada.Numerics.Generic_Real_Arrays   *note G.3.1(2/2): 8370.
Ada.Numerics.Real_Arrays   *note G.3.1(31/2): 8382.
Ada.Real_Time   *note D.8(3): 7941.
Ada.Real_Time.Timing_Events   *note D.15(3/2): 8058.
Ada.Sequential_IO   *note A.8.1(2): 6298.
Ada.Storage_IO   *note A.9(3): 6355.
Ada.Streams   *note 13.13.1(2): 5333.
Ada.Streams.Stream_IO   *note A.12.1(3/3): 6568.
Ada.Strings   *note A.4.1(3): 5770.
Ada.Strings.Bounded   *note A.4.4(3): 5843.
Ada.Strings.Bounded.Equal_Case_Insensitive   *note A.4.10(7/3): 6058.
Ada.Strings.Bounded.Hash   *note A.4.9(7/3): 6050.
Ada.Strings.Bounded.Hash_Case_Insensitive   *note A.4.9(11.7/3): 6054.
Ada.Strings.Bounded.Less_Case_Insensitive   *note A.4.10(18/3): 6062.
Ada.Strings.Equal_Case_Insensitive   *note A.4.10(2/3): 6056.
Ada.Strings.Fixed   *note A.4.3(5): 5807.
Ada.Strings.Fixed.Equal_Case_Insensitive   *note A.4.10(5/3): 6057.
Ada.Strings.Fixed.Hash_Case_Insensitive   *note A.4.9(11.5/3): 6053.
Ada.Strings.Fixed.Less_Case_Insensitive   *note A.4.10(16/3): 6061.
Ada.Strings.Hash   *note A.4.9(2/3): 6049.
Ada.Strings.Hash_Case_Insensitive   *note A.4.9(11.2/3): 6052.
Ada.Strings.Less_Case_Insensitive   *note A.4.10(13/3): 6060.
Ada.Strings.Maps   *note A.4.2(3/2): 5783.
Ada.Strings.Maps.Constants   *note A.4.6(3/2): 5954.
Ada.Strings.Unbounded   *note A.4.5(3): 5902.
Ada.Strings.Unbounded.Equal_Case_Insensitive   *note A.4.10(10/3): 6059.
Ada.Strings.Unbounded.Hash   *note A.4.9(10/3): 6051.
Ada.Strings.Unbounded.Hash_Case_Insensitive   *note A.4.9(11.10/3):
6055.
Ada.Strings.Unbounded.Less_Case_Insensitive   *note A.4.10(21/3): 6063.
Ada.Strings.UTF_Encoding   *note A.4.11(3/3): 6064.
Ada.Strings.UTF_Encoding.Conversions   *note A.4.11(15/3): 6075.
Ada.Strings.UTF_Encoding.Strings   *note A.4.11(22/3): 6081.
Ada.Strings.UTF_Encoding.Wide_Strings   *note A.4.11(30/3): 6088.
Ada.Strings.UTF_Encoding.Wide_Wide_Strings   *note A.4.11(38/3): 6095.
Ada.Strings.Wide_Bounded   *note A.4.7(1/3): 5970.
Ada.Strings.Wide_Bounded.Wide_Equal_Case_Insensitive   *note A.4.7(1/3):
5978.
Ada.Strings.Wide_Bounded.Wide_Hash   *note A.4.7(1/3): 5974.
Ada.Strings.Wide_Bounded.Wide_Hash_Case_Insensitive   *note A.4.7(1/3):
5982.
Ada.Strings.Wide_Equal_Case_Insensitive   *note A.4.7(1/3): 5976.
Ada.Strings.Wide_Fixed   *note A.4.7(1/3): 5969.
Ada.Strings.Wide_Fixed.Wide_Equal_Case_Insensitive   *note A.4.7(1/3):
5977.
Ada.Strings.Wide_Fixed.Wide_Hash   *note A.4.7(1/3): 5973.
Ada.Strings.Wide_Fixed.Wide_Hash_Case_Insensitive   *note A.4.7(1/3):
5981.
Ada.Strings.Wide_Hash   *note A.4.7(1/3): 5972.
Ada.Strings.Wide_Hash_Case_Insensitive   *note A.4.7(1/3): 5980.
Ada.Strings.Wide_Maps   *note A.4.7(3): 5985.
Ada.Strings.Wide_Maps.Wide_Constants   *note A.4.7(1/3): 5984, *note
A.4.8(28/2): 6045.
Ada.Strings.Wide_Unbounded   *note A.4.7(1/3): 5971.
Ada.Strings.Wide_Unbounded.Wide_Equal_Case_Insensitive   *note
A.4.7(1/3): 5979.
Ada.Strings.Wide_Unbounded.Wide_Hash   *note A.4.7(1/3): 5975.
Ada.Strings.Wide_Unbounded.Wide_Hash_Case_Insensitive   *note
A.4.7(1/3): 5983.
Ada.Strings.Wide_Wide_Bounded   *note A.4.8(1/3): 6009.
Ada.Strings.Wide_Wide_Bounded.Wide_Wide_Equal_Case_Insensitive   *note
A.4.8(1/3): 6017.
Ada.Strings.Wide_Wide_Bounded.Wide_Wide_Hash   *note A.4.8(1/3): 6013.
Ada.Strings.Wide_Wide_Bounded.Wide_Wide_Hash_Case_Insensitive   *note
A.4.8(1/3): 6021.
Ada.Strings.Wide_Wide_Equal_Case_Insensitive   *note A.4.8(1/3): 6015.
Ada.Strings.Wide_Wide_Fixed   *note A.4.8(1/3): 6008.
Ada.Strings.Wide_Wide_Fixed.Wide_Wide_Equal_Case_Insensitive   *note
A.4.8(1/3): 6016.
Ada.Strings.Wide_Wide_Fixed.Wide_Wide_Hash   *note A.4.8(1/3): 6012.
Ada.Strings.Wide_Wide_Fixed.Wide_Wide_Hash_Case_Insensitive   *note
A.4.8(1/3): 6020.
Ada.Strings.Wide_Wide_Hash   *note A.4.8(1/3): 6011.
Ada.Strings.Wide_Wide_Hash_Case_Insensitive   *note A.4.8(1/3): 6019.
Ada.Strings.Wide_Wide_Maps   *note A.4.8(3/2): 6024.
Ada.Strings.Wide_Wide_Maps.Wide_Wide_Constants   *note A.4.8(1/3): 6023.
Ada.Strings.Wide_Wide_Unbounded   *note A.4.8(1/3): 6010.
Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Equal_Case_Insensitive   *note
A.4.8(1/3): 6018.
Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Hash   *note A.4.8(1/3): 6014.
Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Hash_Case_Insensitive   *note
A.4.8(1/3): 6022.
Ada.Synchronous_Barriers   *note D.10.1(3/3): 7984.
Ada.Synchronous_Task_Control   *note D.10(3/2): 7973.
Ada.Synchronous_Task_Control.EDF   *note D.10(5.2/3): 7979.
Ada.Tags   *note 3.9(6/2): 2100.
Ada.Tags.Generic_Dispatching_Constructor   *note 3.9(18.2/3): 2125.
Ada.Task_Attributes   *note C.7.2(2): 7728.
Ada.Task_Identification   *note C.7.1(2/2): 7708.
Ada.Task_Termination   *note C.7.3(2/2): 7740.
Ada.Text_IO   *note A.10.1(2): 6374.
Ada.Text_IO.Bounded_IO   *note A.10.11(3/2): 6537.
Ada.Text_IO.Complex_IO   *note G.1.3(3): 8314.
Ada.Text_IO.Editing   *note F.3.3(3): 8234.
Ada.Text_IO.Text_Streams   *note A.12.2(3): 6604.
Ada.Text_IO.Unbounded_IO   *note A.10.12(3/2): 6546.
Ada.Unchecked_Conversion   *note 13.9(3/3): 5159.
Ada.Unchecked_Deallocate_Subpool
   child of Ada   *note 13.11.5(3/3): 5287.
Ada.Unchecked_Deallocation   *note 13.11.2(3/3): 5228.
Ada.Wide_Characters   *note A.3.1(4/2): 5458.
Ada.Wide_Characters.Handling   *note A.3.5(3/3): 5748.
Ada.Wide_Text_IO   *note A.11(2/2): 6555.
Ada.Wide_Text_IO.Bounded_IO   *note A.11(4/3): 6561.
Ada.Wide_Text_IO.Complex_IO   *note G.1.4(1): 8325.
Ada.Wide_Text_IO.Editing   *note F.3.4(1): 8253.
Ada.Wide_Text_IO.Text_Streams   *note A.12.3(3): 6607.
Ada.Wide_Text_IO.Unbounded_IO   *note A.11(5/3): 6563.
Ada.Wide_Wide_Characters   *note A.3.1(6/2): 5459.
Ada.Wide_Wide_Characters.Handling   *note A.3.6(1/3): 5769.
Ada.Wide_Wide_Text_IO   *note A.11(3/2): 6558.
Ada.Wide_Wide_Text_IO.Bounded_IO   *note A.11(4/3): 6562.
Ada.Wide_Wide_Text_IO.Complex_IO   *note G.1.5(1/2): 8328.
Ada.Wide_Wide_Text_IO.Editing   *note F.3.5(1/2): 8255.
Ada.Wide_Wide_Text_IO.Text_Streams   *note A.12.4(3/2): 6610.
Ada.Wide_Wide_Text_IO.Unbounded_IO   *note A.11(5/3): 6564.
Ada_To_COBOL
   in Interfaces.COBOL   *note B.4(14): 7555.
adafinal   *note B.1(39/3): 7417.
adainit   *note B.1(39/3): 7416.
Add
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(9/2): 8041.
Add_Task
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(8/2): 8035.
address
   arithmetic   *note 13.7.1(6): 5137.
   comparison   *note 13.7(14/3): 5122.
   in System   *note 13.7(12): 5117.
Address aspect   *note 13.3(12): 4983.
Address attribute   *note 13.3(11): 4979, *note J.7.1(5): 8510.
Address clause   *note 13.3(7/2): 4959, *note 13.3(12): 4981.
Address_To_Access_Conversions
   child of System   *note 13.7.2(2): 5144.
Adjacent attribute   *note A.5.3(48): 6237.
Adjust   *note 7.6(2): 3660.
   in Ada.Finalization   *note 7.6(6/2): 3664.
adjusting the value of an object   *note 7.6(15): 3674, *note 7.6(16/3):
3676.
adjustment   *note 7.6(15): 3675, *note 7.6(16/3): 3677.
   as part of assignment   *note 5.2(14/3): 3168.
ADT (abstract data type)
   See private types and private extensions   *note 7.3(1): 3599.
   See also abstract type   *note 3.9.3(1/2): 2181.
advice   *note 1.1.2(37): 1048.
Aft attribute   *note 3.5.10(5): 1875.
aggregate   *note 4.3(1): 2492, *note 4.3(2): 2494.
   used   *note 4.4(7/3): 2712, *note 4.7(2): 3029, *note 6.8(2/4):
3558, *note P: 9344.
   See also composite type   *note 3.2(2/2): 1338.
aliased   *note 3.10(9/3): 2255, *note N(3): 8881.
aliasing
   See distinct access paths   *note 6.2(12/3): 3399.
Alignment
   in Ada.Strings   *note A.4.1(6): 5778.
Alignment (subtype) aspect   *note 13.3(26.4/2): 4995.
Alignment attribute   *note 13.3(23/2): 4987, *note 13.3(26.2/2): 4991.
Alignment clause   *note 13.3(7/2): 4960, *note 13.3(25/2): 4989, *note
13.3(26.4/2): 4993.
All_Calls_Remote aspect   *note E.2.3(16/3): 8165.
All_Calls_Remote pragma   *note E.2.3(5): 8153, *note L(2): 8696.
All_Checks   *note 11.5(25/3): 4643.
Allocate
   in System.Storage_Pools   *note 13.11(7): 5189.
   in System.Storage_Pools.Subpools   *note 13.11.4(14/3): 5266.
Allocate_From_Subpool
   in System.Storage_Pools.Subpools   *note 13.11.4(11/3): 5263.
Allocation_Check   *note 11.5(19.2/2): 4639.
   [partial]   *note 4.8(10.2/2): 3072, *note 4.8(10.3/2): 3075, *note
4.8(10.4/3): 3080, *note 13.11.4(30/3): 5283.
allocator   *note 4.8(2/3): 3043.
   used   *note 4.4(7/3): 2714, *note P: 9313.
Alphanumeric
   in Interfaces.COBOL   *note B.4(16/3): 7557.
alphanumeric character
   a category of Character   *note A.3.2(31): 5496.
Alphanumeric_Set
   in Ada.Strings.Maps.Constants   *note A.4.6(4): 5963.
ambiguous   *note 8.6(30): 3872.
ambiguous cursor
   of a vector   *note A.18.2(240/2): 6811.
ampersand   *note 2.1(15/3): 1153.
   in Ada.Characters.Latin_1   *note A.3.3(8): 5538.
ampersand operator   *note 4.4(1/3): 2627, *note 4.5.3(3): 2817.
ancestor   *note N(3.1/2): 8882.
   of a library unit   *note 10.1.1(11): 4357.
   of a tree node   *note A.18.10(4/3): 7198.
   of a type   *note 3.4.1(10/2): 1577.
   ultimate   *note 3.4.1(10/2): 1579.
ancestor subtype
   of a formal derived type   *note 12.5.1(5/3): 4804.
   of a private_extension_declaration   *note 7.3(8): 3612.
ancestor type
   of an extension_aggregate   *note 4.3.2(5/3): 2535.
Ancestor_Find
   in Ada.Containers.Multiway_Trees   *note A.18.10(40/3): 7233.
ancestor_part   *note 4.3.2(3): 2530.
   used   *note 4.3.2(2): 2528, *note P: 9245.
and operator   *note 4.4(1/3): 2583, *note 4.5.1(2): 2745.
and then (short-circuit control form)   *note 4.4(1/3): 2589, *note
4.5.1(1): 2740.
angle threshold   *note G.2.4(10): 8363.
Annex
   informative   *note 1.1.2(18): 1013.
   normative   *note 1.1.2(14): 1010.
   Specialized Needs   *note 1.1.2(7): 1007.
Annotated Ada Reference Manual   *note 0.3(5/3): 1001.
anonymous access type   *note 3.10(12/3): 2263.
anonymous allocator   *note 3.10.2(14/3): 2300.
anonymous array type   *note 3.3.1(1/3): 1476.
anonymous protected type   *note 3.3.1(1/3): 1478.
anonymous task type   *note 3.3.1(1/3): 1477.
anonymous type   *note 3.2.1(7/2): 1391.
Any_Priority subtype of Integer
   in System   *note 13.7(16): 5127.
APC
   in Ada.Characters.Latin_1   *note A.3.3(19): 5629.
apostrophe   *note 2.1(15/3): 1154.
   in Ada.Characters.Latin_1   *note A.3.3(8): 5539.
Append
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(23/2): 6846.
   in Ada.Containers.Vectors   *note A.18.2(46/2): 6769, *note
A.18.2(47/2): 6770.
   in Ada.Strings.Bounded   *note A.4.4(13): 5853, *note A.4.4(14):
5854, *note A.4.4(15): 5855, *note A.4.4(16): 5856, *note A.4.4(17):
5857, *note A.4.4(18): 5858, *note A.4.4(19): 5859, *note A.4.4(20):
5860.
   in Ada.Strings.Unbounded   *note A.4.5(12): 5912, *note A.4.5(13):
5913, *note A.4.5(14): 5914.
Append_Child
   in Ada.Containers.Multiway_Trees   *note A.18.10(52/3): 7245.
applicable index constraint   *note 4.3.3(10): 2568.
application areas   *note 1.1.2(7): 1008.
applies
   aspect   *note 13.1.1(23/3): 4931, *note 13.1.1(27/3): 4932, *note
13.1.1(29/3): 4935, *note 13.1.1(30/3): 4936.
apply
   to a callable construct by a return statement   *note 6.5(4/2): 3512.
   to a loop_statement by an exit_statement   *note 5.7(4): 3269.
   to a program unit by a program unit pragma   *note 10.1.5(2): 4421.
arbitrary order   *note 1.1.4(18): 1069.
   allowed   *note 2.8(12): 1280, *note 3.3.1(20/2): 1519, *note 3.5(9):
1609, *note 3.6(22/2): 1928, *note 3.11(10/1): 2349, *note 3.11(11/3):
2350, *note 3.11(13): 2351, *note 4.1.1(7): 2401, *note 4.1.2(7): 2412,
*note 4.3(5): 2501, *note 4.3.1(19): 2526, *note 4.3.2(7): 2538, *note
4.3.3(22): 2570, *note 4.3.3(23): 2573, *note 4.5.2(27/4): 2803, *note
4.8(10/2): 3068, *note 5.2(7): 3160, *note 6.1.1(34/3): 3380, *note
6.1.1(35/3): 3385, *note 6.4(10/2): 3466, *note 6.4.1(17): 3494, *note
7.6(12): 3672, *note 7.6(16/3): 3678, *note 7.6.1(9/3): 3698, *note
7.6.1(11.1/3): 3704, *note 7.6.1(20.2/3): 3712, *note 9.7.1(15): 4237,
*note 9.8(4): 4282, *note 12.3(20): 4737, *note 13.11.5(7/3): 5288.
Arccos
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(5): 8295.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(6): 6125.
Arccosh
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(7): 8303.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7): 6136.
Arccot
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(5): 8297.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(6): 6129.
Arccoth
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(7): 8305.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7): 6138.
Arcsin
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(5): 8294.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(6): 6124.
Arcsinh
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(7): 8302.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7): 6135.
Arctan
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(5): 8296.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(6): 6128.
Arctanh
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(7): 8304.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7): 6137.
Argument
   in Ada.Command_Line   *note A.15(5): 6628.
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(10/2): 8396,
*note G.3.2(31/2): 8410.
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(10): 8273.
argument of a pragma   *note 2.8(9): 1275.
Argument_Count
   in Ada.Command_Line   *note A.15(4): 6627.
Argument_Error
   in Ada.Numerics   *note A.5(3/2): 6107.
Arithmetic
   child of Ada.Calendar   *note 9.6.1(8/2): 4173.
array   *note 3.6(1): 1885.
array component expression   *note 4.3.3(6): 2563.
array component iterator   *note 5.5.2(3/3): 3245.
array for a loop   *note 5.5.2(11/3): 3255.
array indexing
   See indexed_component   *note 4.1.1(1): 2393.
array slice   *note 4.1.2(1): 2406.
array type   *note 3.6(1): 1886, *note N(4): 8883.
array_aggregate   *note 4.3.3(2): 2542.
   used   *note 4.3(2): 2497, *note 13.4(3): 5042, *note P: 9823.
array_component_association   *note 4.3.3(5/2): 2557.
   used   *note 4.3.3(4): 2556, *note P: 9259.
array_type_definition   *note 3.6(2): 1887.
   used   *note 3.2.1(4/2): 1384, *note 3.3.1(2/3): 1489, *note
12.5.3(2): 4817, *note P: 9777.
ASCII
   package physically nested within the declaration of Standard   *note
A.1(36.3/2): 5446.
   in Standard   *note A.1(36.3/2): 5445.
aspect   *note 13.1(0.1/3): 4867, *note K.1(1/3): 8648, *note N(4.1/3):
8884.
   class-wide   *note 13.1.1(28/4): 4934.
   interfacing   *note B.1(0.1/3): 7383.
   predicate   *note 3.2.4(1/3): 1435.
aspect of representation   *note 13.1(8/3): 4886.
aspect_clause   *note 13.1(2/1): 4872.
   used   *note 3.8(5/1): 2035, *note 3.11(4/1): 2334, *note 9.1(5/1):
3910, *note 9.4(5/1): 3973, *note 9.4(8/4): 3988, *note P: 9188.
aspect_definition   *note 13.1.1(4/3): 4918.
   used   *note 13.1.1(2/3): 4913, *note P: 9810.
aspect_mark   *note 13.1.1(3/3): 4916.
   used   *note 2.8(3/3): 1270, *note 11.4.2(6.1/3): 4598, *note
13.1.1(2/3): 4912, *note L(2.3/3): 8707, *note P: 9809.
aspect_specification   *note 13.1.1(2/3): 4911.
   used   *note 3.2.1(3/3): 1377, *note 3.2.2(2/3): 1403, *note
3.3.1(2/3): 1487, *note 3.8(6/3): 2040, *note 3.9.3(1.1/3): 2188, *note
6.1(2/3): 3284, *note 6.3(2/3): 3405, *note 6.7(2/3): 3546, *note
6.8(2/4): 3555, *note 7.1(3/3): 3575, *note 7.2(2/3): 3588, *note
7.3(2/3): 3603, *note 7.3(3/3): 3609, *note 8.5.1(2/3): 3803, *note
8.5.2(2/3): 3815, *note 8.5.3(2/3): 3819, *note 8.5.4(2/3): 3826, *note
8.5.5(2/3): 3838, *note 9.1(2/3): 3896, *note 9.1(3/3): 3901, *note
9.1(6/3): 3913, *note 9.4(2/3): 3958, *note 9.4(3/3): 3963, *note
9.4(7/3): 3979, *note 9.5.2(2/3): 4043, *note 10.1.3(3/3): 4395, *note
10.1.3(4/3): 4398, *note 10.1.3(5/3): 4401, *note 10.1.3(6/3): 4404,
*note 11.1(2/3): 4517, *note 12.1(3/3): 4673, *note 12.3(2/3): 4708,
*note 12.4(2/3): 4747, *note 12.5(2.1/3): 4774, *note 12.6(2.1/3): 4834,
*note 12.6(2.2/3): 4838, *note 12.7(2/3): 4856, *note P: 9058.
aspects
   Address   *note 13.3(12): 4982.
   Alignment (subtype)   *note 13.3(26.4/2): 4994.
   All_Calls_Remote   *note E.2.3(16/3): 8164.
   Asynchronous   *note E.4.1(8.1/3): 8198.
   Atomic   *note C.6(6.2/3): 7688.
   Atomic_Components   *note C.6(6.6/3): 7694.
   Attach_Handler   *note C.3.1(6.3/3): 7643.
   Bit_Order   *note 13.5.3(4): 5099.
   Coding   *note 13.4(7): 5046.
   Component_Size   *note 13.3(70): 5025.
   Constant_Indexing   *note 4.1.6(2/3): 2462.
   Convention   *note B.1(2/3): 7397.
   CPU   *note D.16(8/3): 8075.
   Default_Component_Value   *note 3.6(22.2/3): 1929.
   Default_Iterator   *note 5.5.1(8/3): 3224.
   Default_Storage_Pool   *note 13.11.3(5/4): 5254.
   Default_Value   *note 3.5(56.3/3): 1683.
   Discard_Names   *note C.5(1.3/4): 7679.
   Dispatching_Domain   *note D.16.1(18/3): 8093.
   Dynamic_Predicate   *note 3.2.4(1/3): 1438.
   Elaborate_Body   *note 10.2.1(26.1/3): 4504.
   Exclusive_Functions   *note 9.5.1(2.2/4): 4025.
   Export   *note B.1(1/3): 7386.
   External_Name   *note B.1(1/3): 7390.
   External_Tag   *note 13.3(75/3): 5036, *note K.2(65): 8663.
   Implicit_Dereference   *note 4.1.5(2/3): 2450.
   Import   *note B.1(1/3): 7384.
   Independent   *note C.6(6.3/3): 7690.
   Independent_Components   *note C.6(6.9/3): 7698.
   Inline   *note 6.3.2(5.1/3): 3443.
   Input   *note 13.13.2(38/4): 5382.
   Input'Class   *note 13.13.2(38/4): 5390.
   Interrupt_Handler   *note C.3.1(6.2/3): 7641.
   Interrupt_Priority   *note D.1(6.3/3): 7759.
   Iterator_Element   *note 5.5.1(9/3): 3227.
   Layout   *note 13.5(1): 5049.
   Link_Name   *note B.1(1/3): 7388.
   Machine_Radix   *note F.1(1): 8221.
   No_Return   *note 6.5.1(3.2/3): 3535.
   Output   *note 13.13.2(38/4): 5384.
   Output'Class   *note 13.13.2(38/4): 5392.
   Pack   *note 13.2(5.1/3): 4939.
   Post   *note 6.1.1(4/3): 3355.
   Post'Class   *note 6.1.1(5/3): 3359.
   Pre   *note 6.1.1(2/3): 3347.
   Pre'Class   *note 6.1.1(3/3): 3351.
   Preelaborate   *note 10.2.1(11/3): 4473.
   Priority   *note D.1(6.2/3): 7757.
   Pure   *note 10.2.1(17/3): 4486.
   Read   *note 13.13.2(38/4): 5378.
   Read'Class   *note 13.13.2(38/4): 5386.
   Record layout   *note 13.5(1): 5053.
   Relative_Deadline   *note D.2.6(9.2/3): 7827.
   Remote_Call_Interface   *note E.2.3(7/3): 8162.
   Remote_Types   *note E.2.2(4/3): 8142.
   Shared_Passive   *note E.2.1(4/3): 8128.
   Size (object)   *note 13.3(41): 5004.
   Size (subtype)   *note 13.3(48): 5011.
   Small   *note 3.5.10(2/1): 1868.
   Static_Predicate   *note 3.2.4(1/3): 1436.
   Storage_Pool   *note 13.11(15): 5205.
   Storage_Size (access)   *note 13.11(15): 5207.
   Storage_Size (task)   *note 13.3(65.2/3): 5016.
   Stream_Size   *note 13.13.2(1.5/2): 5346.
   Synchronization   *note 9.5(12/3): 4019.
   Type_Invariant   *note 7.3.2(2/3): 3628.
   Type_Invariant'Class   *note 7.3.2(3/4): 3630.
   Unchecked_Union   *note B.3.3(3.2/3): 7535.
   Variable_Indexing   *note 4.1.6(3/3): 2464.
   Volatile   *note C.6(6.4/3): 7692.
   Volatile_Components   *note C.6(6.7/3): 7696.
   Write   *note 13.13.2(38/4): 5380.
   Write'Class   *note 13.13.2(38/4): 5388.
assembly language   *note C.1(4/3): 7627.
Assert
   in Ada.Assertions   *note 11.4.2(14/2): 4607.
Assert pragma   *note 11.4.2(3/2): 4590, *note L(2.1/2): 8699.
assertion   *note N(4.2/3): 8885.
assertion expressions   *note 11.4.2(1.1/3): 4588.
assertion policy
   Assert pragma   *note 11.4.2(18/3): 4608.
Assertion_Error
   raised by failure of assertion   *note 11.4.2(18/3): 4609.
   raised by failure of run-time check   *note 3.2.4(31.1/4): 1453,
*note 4.6(57/4): 3019, *note 6.1.1(32/3): 3374, *note 6.1.1(33/3): 3377,
*note 6.1.1(35/3): 3384, *note 7.3.2(22/3): 3639.
   in Ada.Assertions   *note 11.4.2(13/2): 4605.
Assertion_Policy pragma   *note 11.4.2(6.1/3): 4597, *note 11.4.2(6/2):
4594, *note L(2.2/2): 8703, *note L(2.3/3): 8706.
assertions   *note 11.4.2(1.1/3): 4587.
   child of Ada   *note 11.4.2(12/2): 4604.
Assign
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(17.5/3): 6839.
   in Ada.Containers.Hashed_Maps   *note A.18.5(17.7/3): 6930.
   in Ada.Containers.Hashed_Sets   *note A.18.8(17.3/3): 7058.
   in Ada.Containers.Indefinite_Holders   *note A.18.18(20/3): 7298.
   in Ada.Containers.Multiway_Trees   *note A.18.10(32/3): 7225.
   in Ada.Containers.Ordered_Maps   *note A.18.6(16.7/3): 6981.
   in Ada.Containers.Ordered_Sets   *note A.18.9(16.3/3): 7129.
   in Ada.Containers.Vectors   *note A.18.2(34.7/3): 6756.
   See assignment operation   *note 5.2(3): 3154.
Assign_Task
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(11/3):
8088.
assigning back of parameters   *note 6.4.1(17): 3491.
assignment
   user-defined   *note 7.6(1): 3653.
assignment operation   *note 5.2(3): 3153, *note 5.2(12): 3166, *note
7.6(13): 3673.
   during elaboration of an object_declaration   *note 3.3.1(18/2):
1517.
   during evaluation of a generic_association for a formal object of
mode in   *note 12.4(11): 4765.
   during evaluation of a parameter_association   *note 6.4.1(11): 3483.
   during evaluation of an aggregate   *note 4.3(5): 2500.
   during evaluation of an initialized allocator   *note 4.8(7/2): 3059.
   during evaluation of an uninitialized allocator   *note 4.8(9/2):
3062.
   during evaluation of concatenation   *note 4.5.3(10): 2827.
   during execution of a for loop   *note 5.5(9/4): 3208.
   during execution of an assignment_statement   *note 5.2(12): 3167.
   during parameter copy back   *note 6.4.1(17): 3492.
assignment_statement   *note 5.2(2): 3150.
   used   *note 5.1(4/2): 3123, *note P: 9358.
associated components
   of a record_component_association   *note 4.3.1(10): 2522.
associated declaration
   of an aspect specification   *note 13.1.1(1/3): 4910.
associated discriminants
   of a named discriminant_association   *note 3.7.1(5): 2010.
   of a positional discriminant_association   *note 3.7.1(5): 2011.
associated entity
   of an aspect specification   *note 13.1.1(5/3): 4922.
associated object
   of a value of a by-reference type   *note 6.2(10/4): 3395.
asterisk   *note 2.1(15/3): 1158.
   in Ada.Characters.Latin_1   *note A.3.3(8): 5542.
asynchronous
   remote procedure call   *note E.4.1(9/3): 8201.
Asynchronous aspect   *note E.4.1(8.1/3): 8199.
Asynchronous pragma   *note J.15.13(2/3): 8646, *note L(3.1/3): 8712.
asynchronous remote procedure call   *note E.4(1): 8179.
asynchronous_select   *note 9.7.4(2): 4255.
   used   *note 9.7(2): 4213, *note P: 9620.
Asynchronous_Task_Control
   child of Ada   *note D.11(3/2): 7988.
at-most-once execution   *note E.4(11): 8188.
at_clause   *note J.7(1): 8505.
   used   *note 13.1(2/1): 4876, *note P: 9802.
atomic   *note C.6(7/3): 7700.
Atomic aspect   *note C.6(6.2/3): 7689.
Atomic pragma   *note J.15.8(2/3): 8598, *note L(4.1/3): 8715.
Atomic_Components aspect   *note C.6(6.6/3): 7695.
Atomic_Components pragma   *note J.15.8(5/3): 8607, *note L(5.1/3):
8718.
Attach_Handler
   in Ada.Interrupts   *note C.3.2(7): 7665.
Attach_Handler aspect   *note C.3.1(6.3/3): 7644.
Attach_Handler pragma   *note J.15.7(4/3): 8592, *note L(6.1/3): 8721.
attaching
   to an interrupt   *note C.3(2): 7636.
attribute   *note 4.1.4(1): 2433, *note K.2(1/3): 8649.
   representation   *note 13.3(1/1): 4943.
   specifiable   *note 13.3(5/3): 4955.
   specifying   *note 13.3(1/1): 4944.
   stream-oriented   *note 13.13.2(1/3): 5343.
attribute_definition_clause   *note 13.3(2): 4945.
   used   *note 13.1(2/1): 4873, *note P: 9799.
attribute_designator   *note 4.1.4(3/2): 2437.
   used   *note 4.1.4(2): 2436, *note 13.1(3): 4880, *note 13.3(2):
4950, *note P: 9819.
Attribute_Handle
   in Ada.Task_Attributes   *note C.7.2(3): 7729.
attribute_reference   *note 4.1.4(2): 2434.
   used   *note 4.1(2/3): 2365, *note P: 9201.
attributes
   Access   *note 3.10.2(25/1): 2306, *note 3.10.2(33/3): 2316.
   Address   *note 13.3(11): 4978, *note J.7.1(5): 8509.
   Adjacent   *note A.5.3(48): 6236.
   Aft   *note 3.5.10(5): 1874.
   Alignment   *note 13.3(23/2): 4986, *note 13.3(26.2/2): 4990.
   Base   *note 3.5(15): 1617.
   Bit_Order   *note 13.5.3(4): 5095.
   Body_Version   *note E.3(4): 8171.
   Callable   *note 9.9(2): 4297.
   Caller   *note C.7.1(14/3): 7720.
   Ceiling   *note A.5.3(33): 6220.
   Class   *note 3.9(14): 2117, *note 7.3.1(9): 3625, *note J.11(2/2):
8525.
   Component_Size   *note 13.3(69): 5021.
   Compose   *note A.5.3(24): 6208.
   Constrained   *note 3.7.2(3/3): 2018, *note J.4(2): 8503.
   Copy_Sign   *note A.5.3(51): 6241.
   Count   *note 9.9(5): 4303.
   Definite   *note 12.5.1(23/3): 4807.
   Delta   *note 3.5.10(3): 1870.
   Denorm   *note A.5.3(9): 6190.
   Digits   *note 3.5.8(2/1): 1822, *note 3.5.10(7): 1876.
   Exponent   *note A.5.3(18): 6204.
   External_Tag   *note 13.3(75/3): 5032.
   First   *note 3.5(12): 1611, *note 3.6.2(3): 1946.
   First(N)   *note 3.6.2(4): 1948.
   First_Bit   *note 13.5.2(3/2): 5082.
   First_Valid   *note 3.5.5(7.2/4): 1778.
   Floor   *note A.5.3(30): 6218.
   Fore   *note 3.5.10(4): 1872.
   Fraction   *note A.5.3(21): 6206.
   Has_Same_Storage   *note 13.3(73.2/4): 5028.
   Identity   *note 11.4.1(9): 4583, *note C.7.1(12): 7718.
   Image   *note 3.5(35): 1645, *note 3.5(55.4/4): 1681.
   Input   *note 13.13.2(22): 5359, *note 13.13.2(32): 5363.
   Last   *note 3.5(13): 1613, *note 3.6.2(5): 1950.
   Last(N)   *note 3.6.2(6): 1952.
   Last_Bit   *note 13.5.2(4/2): 5084.
   Last_Valid   *note 3.5.5(7.3/4): 1780.
   Leading_Part   *note A.5.3(54): 6246.
   Length   *note 3.6.2(9): 1958.
   Length(N)   *note 3.6.2(10): 1960.
   Machine   *note A.5.3(60): 6251.
   Machine_Emax   *note A.5.3(8): 6188.
   Machine_Emin   *note A.5.3(7): 6186.
   Machine_Mantissa   *note A.5.3(6): 6184.
   Machine_Overflows   *note A.5.3(12): 6198, *note A.5.4(4): 6276.
   Machine_Radix   *note A.5.3(2): 6181, *note A.5.4(2): 6272.
   Machine_Rounding   *note A.5.3(41.1/2): 6226.
   Machine_Rounds   *note A.5.3(11): 6196, *note A.5.4(3): 6274.
   Max   *note 3.5(19): 1622.
   Max_Alignment_For_Allocation   *note 13.11.1(4/3): 5221.
   Max_Size_In_Storage_Elements   *note 13.11.1(3/3): 5219.
   Min   *note 3.5(16): 1620.
   Mod   *note 3.5.4(16.1/2): 1749.
   Model   *note A.5.3(68): 6265, *note G.2.2(7): 8349.
   Model_Emin   *note A.5.3(65): 6259, *note G.2.2(4): 8342.
   Model_Epsilon   *note A.5.3(66): 6261.
   Model_Mantissa   *note A.5.3(64): 6257, *note G.2.2(3/2): 8340.
   Model_Small   *note A.5.3(67): 6263.
   Modulus   *note 3.5.4(17): 1751.
   Old   *note 6.1.1(26/4): 3370.
   Output   *note 13.13.2(19): 5357, *note 13.13.2(29): 5361.
   Overlaps_Storage   *note 13.3(73.6/3): 5030.
   Partition_Id   *note E.1(9): 8108.
   Pos   *note 3.5.5(2): 1770.
   Position   *note 13.5.2(2/2): 5080.
   Pred   *note 3.5(25): 1631.
   Priority   *note D.5.2(3/2): 7871.
   Range   *note 3.5(14): 1615, *note 3.6.2(7): 1954.
   Range(N)   *note 3.6.2(8): 1956.
   Read   *note 13.13.2(6): 5351, *note 13.13.2(14): 5355.
   Remainder   *note A.5.3(45): 6231.
   Result   *note 6.1.1(29/3): 3372.
   Round   *note 3.5.10(12): 1882.
   Rounding   *note A.5.3(36): 6222.
   Safe_First   *note A.5.3(71): 6267, *note G.2.2(5): 8344.
   Safe_Last   *note A.5.3(72): 6269, *note G.2.2(6): 8346.
   Scale   *note 3.5.10(11): 1879.
   Scaling   *note A.5.3(27): 6213.
   Signed_Zeros   *note A.5.3(13): 6200.
   Size   *note 13.3(40): 5000, *note 13.3(45): 5007.
   Small   *note 3.5.10(2/1): 1864.
   Storage_Pool   *note 13.11(13): 5197.
   Storage_Size   *note 13.3(60/3): 5014, *note 13.11(14): 5199, *note
J.9(2): 8518.
   Stream_Size   *note 13.13.2(1.2/3): 5344.
   Succ   *note 3.5(22): 1624.
   Tag   *note 3.9(16): 2121, *note 3.9(18): 2123.
   Terminated   *note 9.9(3): 4301.
   Truncation   *note A.5.3(42): 6229.
   Unbiased_Rounding   *note A.5.3(39): 6224.
   Unchecked_Access   *note 13.10(3): 5180, *note H.4(18): 8470.
   Val   *note 3.5.5(5): 1772.
   Valid   *note 13.9.2(3/4): 5177, *note H(6): 8429.
   Value   *note 3.5(52): 1671.
   Version   *note E.3(3): 8169.
   Wide_Image   *note 3.5(28): 1642, *note 3.5(55.3/4): 1679.
   Wide_Value   *note 3.5(40): 1665.
   Wide_Wide_Image   *note 3.5(27.1/2): 1638, *note 3.5(55.2/4): 1677.
   Wide_Wide_Value   *note 3.5(39.1/2): 1653.
   Wide_Wide_Width   *note 3.5(37.1/2): 1647.
   Wide_Width   *note 3.5(38): 1649.
   Width   *note 3.5(39): 1651.
   Write   *note 13.13.2(3): 5349, *note 13.13.2(11): 5353.
available
   stream attribute   *note 13.13.2(39/2): 5394.



File: arm2012.info,  Node: B,  Next: C,  Prev: A,  Up: Index

B 
==



Backus-Naur Form (BNF)
   complete listing   *note P: 8961.
   cross reference   *note P: 9850.
   notation   *note 1.1.4(3): 1064.
   under Syntax heading   *note 1.1.2(25): 1018.
Barrier_Limit subtype of Positive
   in Ada.Synchronous_Barriers   *note D.10.1(4/3): 7985.
base   *note 2.4.2(3): 1238, *note 2.4.2(6): 1246.
   used   *note 2.4.2(2): 1234, *note P: 8985.
base 16 literal   *note 2.4.2(1): 1231.
base 2 literal   *note 2.4.2(1): 1225.
base 8 literal   *note 2.4.2(1): 1228.
Base attribute   *note 3.5(15): 1618.
base decimal precision
   of a floating point type   *note 3.5.7(9): 1808.
   of a floating point type   *note 3.5.7(10): 1810.
base priority   *note D.1(15): 7764.
base range
   of a decimal fixed point type   *note 3.5.9(16): 1854.
   of a fixed point type   *note 3.5.9(12): 1849.
   of a floating point type   *note 3.5.7(8): 1807, *note 3.5.7(10):
1812.
   of a modular type   *note 3.5.4(10): 1737.
   of a scalar type   *note 3.5(6): 1601.
   of a signed integer type   *note 3.5.4(9): 1734.
   of an ordinary fixed point type   *note 3.5.9(13): 1850.
base subtype
   of a type   *note 3.5(15): 1619.
Base_Name
   in Ada.Directories   *note A.16(19/2): 6649.
based_literal   *note 2.4.2(2): 1233.
   used   *note 2.4(2): 1209, *note P: 8976.
based_numeral   *note 2.4.2(4): 1240.
   used   *note 2.4.2(2): 1236, *note P: 8987.
basic letter
   a category of Character   *note A.3.2(27): 5493.
basic_declaration   *note 3.1(3/3): 1292.
   used   *note 3.11(4/1): 2333, *note P: 9187.
basic_declarative_item   *note 3.11(4/1): 2332.
   used   *note 3.11(3): 2330, *note 7.1(3/3): 3576, *note P: 9486.
Basic_Map
   in Ada.Strings.Maps.Constants   *note A.4.6(5): 5968.
Basic_Set
   in Ada.Strings.Maps.Constants   *note A.4.6(4): 5960.
become nonlimited   *note 7.3.1(5/1): 3621, *note 7.5(16): 3649.
BEL
   in Ada.Characters.Latin_1   *note A.3.3(5): 5507.
belong
   to a range   *note 3.5(4): 1596.
   to a subtype   *note 3.2(8/2): 1359.
belongs
   subpool to a pool   *note 13.11.4(20/4): 5274.
bibliography   *note 1.2(1/3): 1087.
big endian   *note 13.5.3(2): 5090.
binary
   literal   *note 2.4.2(1): 1226.
   in Interfaces.COBOL   *note B.4(10): 7548.
binary adding operator   *note 4.5.3(1): 2805.
binary literal   *note 2.4.2(1): 1224.
binary operator   *note 4.5(9): 2732.
binary_adding_operator   *note 4.5(4): 2726.
   used   *note 4.4(4): 2698, *note P: 9300.
Binary_Format
   in Interfaces.COBOL   *note B.4(24): 7569.
bit field
   See record_representation_clause   *note 13.5.1(1): 5058.
bit ordering   *note 13.5.3(2): 5088.
bit string
   See logical operators on boolean arrays   *note 4.5.1(2): 2751.
Bit_Order
   in System   *note 13.7(15/2): 5123.
Bit_Order aspect   *note 13.5.3(4): 5100.
Bit_Order attribute   *note 13.5.3(4): 5096.
Bit_Order clause   *note 13.3(7/2): 4965, *note 13.5.3(4): 5098.
blank
   in text input for enumeration and numeric types   *note A.10.6(5/2):
6530.
Blank_When_Zero
   in Ada.Text_IO.Editing   *note F.3.3(7): 8239.
block_statement   *note 5.6(2): 3260.
   used   *note 5.1(5/2): 3138, *note P: 9372.
blocked
   [partial]   *note D.2.1(11/3): 7783.
   a task state   *note 9(10): 3886.
   during an entry call   *note 9.5.3(19): 4114.
   execution of a selective_accept   *note 9.7.1(16): 4238.
   on a delay_statement   *note 9.6(21): 4163.
   on an accept_statement   *note 9.5.2(24): 4085.
   waiting for activations to complete   *note 9.2(5): 3939.
   waiting for dependents to terminate   *note 9.3(5): 3946.
blocked interrupt   *note C.3(2): 7635.
blocking, potentially   *note 9.5.1(8): 4036.
   Abort_Task   *note C.7.1(16): 7724.
   delay_statement   *note 9.6(34): 4166, *note D.9(5): 7970.
   remote subprogram call   *note E.4(17): 8191.
   RPC operations   *note E.5(23): 8217.
   Suspend_Until_True   *note D.10(10): 7982.
BMP   *note 3.5.2(2/3): 1703, *note 3.5.2(3/3): 1709.
BNF (Backus-Naur Form)
   complete listing   *note P: 8960.
   cross reference   *note P: 9849.
   notation   *note 1.1.4(3): 1063.
   under Syntax heading   *note 1.1.2(25): 1017.
body   *note 3.11(5): 2336, *note 3.11.1(1/3): 2355.
   used   *note 3.11(3): 2331, *note P: 9186.
body_stub   *note 10.1.3(2): 4387.
   used   *note 3.11(5): 2338, *note P: 9191.
Body_Version attribute   *note E.3(4): 8172.
BOM_16
   in Ada.Strings.UTF_Encoding   *note A.4.11(12/3): 6073.
BOM_16BE
   in Ada.Strings.UTF_Encoding   *note A.4.11(10/3): 6071.
BOM_16LE
   in Ada.Strings.UTF_Encoding   *note A.4.11(11/3): 6072.
BOM_8
   in Ada.Strings.UTF_Encoding   *note A.4.11(9/3): 6070.
Boolean   *note 3.5.3(1): 1713.
   in Standard   *note A.1(5): 5437.
boolean type   *note 3.5.3(1): 1716.
Bounded
   child of Ada.Strings   *note A.4.4(3): 5843.
bounded error   *note 1.1.2(31): 1039, *note 1.1.5(8): 1078.
   cause   *note 4.8(11.1/2): 3084, *note 6.2(12/3): 3400, *note
7.6.1(14/1): 3706, *note 9.4(20.1/2): 4009, *note 9.5.1(8): 4034, *note
9.8(20/3): 4291, *note 10.2(26): 4457, *note 13.9.1(9): 5172, *note
13.11.2(11): 5234, *note 13.11.2(15.2/4): 5241, *note A.17(25/2): 6707,
*note A.18.2(238/3): 6809, *note A.18.2(239/2): 6810, *note
A.18.2(243/2): 6813, *note A.18.3(152.1/3): 6882, *note A.18.3(152.2/3):
6883, *note A.18.3(152/2): 6881, *note A.18.4(75.1/3): 6902, *note
A.18.4(75.2/3): 6903, *note A.18.7(96.13/3): 7034, *note
A.18.7(96.14/3): 7035, *note A.18.10(220/3): 7271, *note A.18.10(221/3):
7272, *note A.18.18(68/3): 7306, *note A.18.18(69/3): 7307, *note
A.18.19(10/3): 7309, *note A.18.20(14/3): 7312, *note A.18.21(15/3):
7316, *note A.18.22(12/3): 7319, *note A.18.23(15/3): 7323, *note
A.18.24(12/3): 7326, *note A.18.25(14/3): 7328, *note C.7.1(17/3): 7725,
*note C.7.2(13.2/1): 7736, *note D.2.6(30/2): 7829, *note D.3(13.1/2):
7848, *note E.1(10/2): 8110, *note E.3(6): 8175, *note J.7.1(11): 8515.
Bounded_IO
   child of Ada.Text_IO   *note A.10.11(3/2): 6537.
   child of Ada.Wide_Text_IO   *note A.11(4/3): 6561.
   child of Ada.Wide_Wide_Text_IO   *note A.11(4/3): 6562.
Bounded_Priority_Queues
   child of Ada.Containers   *note A.18.31(2/3): 7362.
Bounded_Slice
   in Ada.Strings.Bounded   *note A.4.4(28.1/2): 5864, *note
A.4.4(28.2/2): 5865.
Bounded_String
   in Ada.Strings.Bounded   *note A.4.4(6): 5846.
Bounded_Synchronized_Queues
   child of Ada.Containers   *note A.18.29(2/3): 7349.
bounds
   of a discrete_range   *note 3.6.1(6): 1940.
   of an array   *note 3.6(13): 1914.
   of the index range of an array_aggregate   *note 4.3.3(24): 2574.
box
   compound delimiter   *note 3.6(15): 1919.
BPH
   in Ada.Characters.Latin_1   *note A.3.3(17): 5600.
broadcast signal
   See protected object   *note 9.4(1): 3954.
   See requeue   *note 9.5.4(1): 4119.
Broken_Bar
   in Ada.Characters.Latin_1   *note A.3.3(21/3): 5637.
BS
   in Ada.Characters.Latin_1   *note A.3.3(5): 5508.
budget   *note D.14.2(14/2): 8049.
Budget_Has_Expired
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(9/2): 8042.
Budget_Remaining
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(9/2): 8043.
Buffer_Size
   in Ada.Storage_IO   *note A.9(4): 6356.
Buffer_Type subtype of Storage_Array
   in Ada.Storage_IO   *note A.9(4): 6357.
build-in-place
   See built in place
built in place   *note 7.6(17.1/3): 3680.
by copy parameter passing   *note 6.2(2): 3388.
by reference parameter passing   *note 6.2(2): 3391.
by-copy type   *note 6.2(3/3): 3393.
by-reference type   *note 6.2(4): 3394.
   atomic or volatile   *note C.6(18): 7706.
Byte
   in Interfaces.COBOL   *note B.4(29/3): 7576.
   See storage element   *note 13.3(8): 4975.
byte sex
   See ordering of storage elements in a word   *note 13.5.3(5): 5101.
Byte_Array
   in Interfaces.COBOL   *note B.4(29/3): 7577.



File: arm2012.info,  Node: C,  Next: D,  Prev: B,  Up: Index

C 
==



C
   child of Interfaces   *note B.3(4): 7432.
C interface   *note B.3(1/4): 7431.
C standard   *note 1.2(7/3): 1113.
C++ standard   *note 1.2(9/3): 1119.
C_float
   in Interfaces.C   *note B.3(15): 7448.
C_Variadic   *note B.3(60.16/4): 7494.
Calendar
   child of Ada   *note 9.6(10): 4145.
call   *note 6(2/3): 3279.
   master of   *note 3.10.2(10.1/3): 2298.
call on a dispatching operation   *note 3.9.2(2/3): 2159.
callable   *note 9.9(2): 4300.
Callable attribute   *note 9.9(2): 4298.
callable construct   *note 6(2/3): 3280.
callable entity   *note 6(2/3): 3278.
called partition   *note E.4(1): 8181.
Caller attribute   *note C.7.1(14/3): 7721.
calling convention   *note 6.3.1(2/1): 3418, *note B.1(11/3): 7405.
   Ada   *note 6.3.1(3/3): 3420.
   associated with a designated profile   *note 3.10(11): 2262.
   entry   *note 6.3.1(13/4): 3426.
   Intrinsic   *note 6.3.1(4): 3422.
   protected   *note 6.3.1(12/4): 3424.
calling partition   *note E.4(1): 8180.
calling stub   *note E.4(10): 8186.
CAN
   in Ada.Characters.Latin_1   *note A.3.3(6): 5524.
Cancel_Handler
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(10/2): 8046.
   in Ada.Execution_Time.Timers   *note D.14.1(7/2): 8022.
   in Ada.Real_Time.Timing_Events   *note D.15(5/2): 8064.
cancellation
   of a delay_statement   *note 9.6(22/3): 4164.
   of an entry call   *note 9.5.3(20): 4115.
cancellation of a remote subprogram call   *note E.4(13): 8189.
canonical form   *note A.5.3(3): 6183.
canonical order of array components   *note 5.5.2(11/3): 3256.
canonical semantics   *note 11.6(2/3): 4654.
canonical-form representation   *note A.5.3(10): 6195.
capacity
   of a hashed map   *note A.18.5(41/2): 6951.
   of a hashed set   *note A.18.8(63/2): 7100.
   of a queue   *note A.18.27(10/3): 7342.
   of a vector   *note A.18.2(2/2): 6722.
   in Ada.Containers.Hashed_Maps   *note A.18.5(8/2): 6915.
   in Ada.Containers.Hashed_Sets   *note A.18.8(10/2): 7049.
   in Ada.Containers.Vectors   *note A.18.2(19/2): 6735.
Capacity_Error
   in Ada.Containers   *note A.18.1(5.1/3): 6718.
case insensitive   *note 2.3(5/3): 1203.
case_expression   *note 4.5.7(5/3): 2889.
   used   *note 4.5.7(2/3): 2880, *note P: 9318.
case_expression_alternative   *note 4.5.7(6/3): 2893.
   used   *note 4.5.7(5/3): 2891, *note P: 9326.
case_statement   *note 5.4(2/3): 3176.
   used   *note 5.1(5/2): 3136, *note P: 9370.
case_statement_alternative   *note 5.4(3): 3180.
   used   *note 5.4(2/3): 3179, *note P: 9387.
cast
   See type conversion   *note 4.6(1/3): 2922.
   See unchecked type conversion   *note 13.9(1): 5158.
catch (an exception)
   See handle   *note 11(1/3): 4510.
categorization aspect   *note E.2(2/3): 8116.
categorization pragma   *note E.2(2/3): 8112.
   Remote_Call_Interface   *note E.2.3(2): 8147.
   Remote_Types   *note E.2.2(2): 8136.
   Shared_Passive   *note E.2.1(2): 8122.
categorized library unit   *note E.2(2/3): 8117.
category
   of types   *note 3.2(2/2): 1331, *note 3.4(1.1/2): 1532.
category (of types)   *note N(4.3/2): 8886.
category determined for a formal type   *note 12.5(6/3): 4799.
catenation operator
   See concatenation operator   *note 4.4(1/3): 2631.
   See concatenation operator   *note 4.5.3(3): 2821.
Cause_Of_Termination
   in Ada.Task_Termination   *note C.7.3(3/2): 7741.
CCH
   in Ada.Characters.Latin_1   *note A.3.3(18): 5618.
cease to exist
   object   *note 7.6.1(11/3): 3701, *note 13.11.2(10/4): 5233.
   type   *note 7.6.1(11/3): 3702.
Cedilla
   in Ada.Characters.Latin_1   *note A.3.3(22): 5657.
Ceiling
   in Ada.Containers.Ordered_Maps   *note A.18.6(41/2): 7007.
   in Ada.Containers.Ordered_Sets   *note A.18.9(51/2): 7161, *note
A.18.9(71/2): 7174.
Ceiling attribute   *note A.5.3(33): 6221.
ceiling priority
   of a protected object   *note D.3(8/3): 7844.
Ceiling_Check
   [partial]   *note C.3.1(11/3): 7652, *note D.3(13): 7845.
Ceiling_Locking locking policy   *note D.3(7): 7843.
Cent_Sign
   in Ada.Characters.Latin_1   *note A.3.3(21/3): 5633.
change of representation   *note 13.6(1/3): 5103.
char
   in Interfaces.C   *note B.3(19): 7451.
char16_array
   in Interfaces.C   *note B.3(39.5/3): 7475.
char16_nul
   in Interfaces.C   *note B.3(39.3/2): 7472.
char16_t
   in Interfaces.C   *note B.3(39.2/2): 7471.
char32_array
   in Interfaces.C   *note B.3(39.14/3): 7485.
char32_nul
   in Interfaces.C   *note B.3(39.12/2): 7482.
char32_t
   in Interfaces.C   *note B.3(39.11/2): 7481.
char_array
   in Interfaces.C   *note B.3(23/3): 7455.
char_array_access
   in Interfaces.C.Strings   *note B.3.1(4): 7497.
CHAR_BIT
   in Interfaces.C   *note B.3(6): 7433.
Character   *note 3.5.2(2/3): 1705.
   used   *note 2.7(2): 1257, *note P: 8997.
   in Standard   *note A.1(35/3): 5442.
character encoding   *note A.4.11(46/3): 6103.
character plane   *note 2.1(1/3): 1129.
character set   *note 2.1(1/3): 1127.
character set standard
   16 and 32-bit   *note 1.2(8/3): 1116.
   7-bit   *note 1.2(2): 1093.
   8-bit   *note 1.2(6/3): 1110.
   control functions   *note 1.2(5): 1105.
character type   *note 3.5.2(1): 1701, *note N(5): 8887.
character_literal   *note 2.5(2): 1247.
   used   *note 3.5.1(4): 1694, *note 4.1(2/3): 2368, *note 4.1.3(3):
2423, *note P: 9084.
Character_Mapping
   in Ada.Strings.Maps   *note A.4.2(20/2): 5797.
Character_Mapping_Function
   in Ada.Strings.Maps   *note A.4.2(25): 5803.
Character_Range
   in Ada.Strings.Maps   *note A.4.2(6): 5786.
Character_Ranges
   in Ada.Strings.Maps   *note A.4.2(7): 5787.
Character_Sequence subtype of String
   in Ada.Strings.Maps   *note A.4.2(16): 5793.
Character_Set
   in Ada.Strings.Maps   *note A.4.2(4/2): 5784.
   in Ada.Strings.Wide_Maps   *note A.4.7(46/2): 6006.
   in Ada.Strings.Wide_Maps.Wide_Constants   *note A.4.8(48/2): 6046.
   in Interfaces.Fortran   *note B.5(11): 7609.
Character_Set_Version
   in Ada.Wide_Characters.Handling   *note A.3.5(4/3): 5749.
characteristics
   [partial]   *note 3.4(7/3): 1544.
Characters
   child of Ada   *note A.3.1(2): 5457.
chars_ptr
   in Interfaces.C.Strings   *note B.3.1(5/2): 7498.
chars_ptr_array
   in Interfaces.C.Strings   *note B.3.1(6/2): 7499.
check
   language-defined   *note 11.5(2/3): 4612, *note 11.6(1/3): 4649.
check, language-defined
   Access_Check   *note 4.1(13): 2391, *note 4.1.5(8/3): 2460, *note
4.6(51/4): 3005, *note 4.8(10.4/3): 3079.
   Accessibility_Check   *note 3.10.2(30): 2313, *note 4.6(39.1/2):
2983, *note 4.6(48/3): 2997, *note 4.8(10.1/3): 3070, *note 6.5(8/4):
3527, *note 6.5(21/3): 3533, *note 13.11.4(25/3): 5279, *note
13.11.4(26/3): 5281, *note E.4(18/1): 8193.
   Allocation_Check   *note 4.8(10.2/2): 3073, *note 4.8(10.3/2): 3076,
*note 4.8(10.4/3): 3081, *note 13.11.4(30/3): 5284.
   Ceiling_Check   *note C.3.1(11/3): 7653, *note D.3(13): 7846.
   controlled by assertion policy   *note 3.2.4(31/4): 1452, *note
4.6(51/4): 3007, *note 6.1.1(32/3): 3375, *note 6.1.1(33/3): 3378, *note
6.1.1(35/3): 3383, *note 7.3.2(9/4): 3637.
   Discriminant_Check   *note 4.1.3(15): 2430, *note 4.3(6): 2503, *note
4.3.2(8/3): 2540, *note 4.6(43): 2989, *note 4.6(45): 2991, *note
4.6(51/4): 3001, *note 4.6(52): 3014, *note 4.7(4/4): 3035, *note
4.8(10/2): 3066, *note 6.5(5.11/3): 3521.
   Division_Check   *note 3.5.4(20): 1758, *note 4.5.5(22): 2856, *note
A.5.1(28): 6141, *note A.5.3(47): 6235, *note G.1.1(40): 8281, *note
G.1.2(28): 8308, *note K.2(202): 8679.
   Elaboration_Check   *note 3.11(9): 2348.
   Index_Check   *note 4.1.1(7): 2404, *note 4.1.2(7): 2414, *note
4.3.3(29/3): 2578, *note 4.3.3(30): 2580, *note 4.5.3(8): 2824, *note
4.6(51/4): 3003, *note 4.7(4/4): 3037, *note 4.8(10/2): 3064.
   Length_Check   *note 4.5.1(8): 2754, *note 4.6(37): 2978, *note
4.6(52): 3010.
   Overflow_Check   *note 3.5.4(20): 1755, *note 4.4(11): 2720, *note
4.5.7(21/3): 2903, *note 5.4(13): 3188, *note G.2.1(11): 8338, *note
G.2.2(7): 8352, *note G.2.3(25): 8356, *note G.2.4(2): 8361, *note
G.2.6(3): 8368.
   Partition_Check   *note E.4(19): 8196.
   Range_Check   *note 3.2.2(11): 1424, *note 3.5(24): 1630, *note
3.5(27): 1635, *note 3.5(39.12/3): 1664, *note 3.5(39.4/3): 1658, *note
3.5(39.5/3): 1661, *note 3.5(43/3): 1670, *note 3.5(55/3): 1676, *note
3.5.5(7): 1777, *note 3.5.9(19/4): 1862, *note 4.2(11): 2490, *note
4.3.3(28): 2576, *note 4.5.1(8): 2756, *note 4.5.6(6): 2867, *note
4.5.6(13): 2876, *note 4.6(28): 2968, *note 4.6(38): 2980, *note
4.6(46): 2993, *note 4.6(51/4): 2999, *note 4.7(4/4): 3033, *note
13.13.2(35/3): 5366, *note A.5.2(39): 6176, *note A.5.3(26): 6212, *note
A.5.3(29): 6217, *note A.5.3(50): 6240, *note A.5.3(53): 6245, *note
A.5.3(59): 6250, *note A.5.3(62): 6255, *note K.2(11): 8652, *note
K.2(114): 8667, *note K.2(122): 8670, *note K.2(184): 8674, *note
K.2(220): 8683, *note K.2(241): 8688, *note K.2(41): 8657, *note
K.2(47): 8660.
   Reserved_Check   *note C.3.1(10/3): 7649.
   Storage_Check   *note 11.1(6): 4525, *note 13.3(67): 5019, *note
13.11(17): 5211, *note D.7(17/1): 7923, *note D.7(18/1): 7928, *note
D.7(19/1): 7933.
   Tag_Check   *note 3.9.2(16): 2176, *note 4.6(42): 2987, *note
4.6(52): 3012, *note 5.2(10): 3163, *note 6.5(8.1/3): 3529.
checking pragmas   *note 11.5(1/2): 4610.
child
   of a library unit   *note 10.1.1(1): 4321.
Child_Count
   in Ada.Containers.Multiway_Trees   *note A.18.10(46/3): 7239.
Child_Depth
   in Ada.Containers.Multiway_Trees   *note A.18.10(47/3): 7240.
choice parameter   *note 11.2(9): 4542.
choice_expression   *note 4.4(2.1/3): 2666.
   used   *note 3.8.1(5/3): 2069, *note P: 9158.
choice_parameter_specification   *note 11.2(4): 4537.
   used   *note 11.2(3): 4533, *note P: 9698.
choice_relation   *note 4.4(2.2/3): 2677.
   used   *note 4.4(2.1/3): 2673, *note P: 9277.
Circumflex
   in Ada.Characters.Latin_1   *note A.3.3(12): 5559.
class
   of types   *note 3.2(2/2): 1332, *note 3.4(1.1/2): 1531.
   See also package   *note 7(1): 3570.
   See also tag   *note 3.9(3): 2098.
class (of types)   *note N(6/2): 8888.
Class attribute   *note 3.9(14): 2118, *note 7.3.1(9): 3626, *note
J.11(2/2): 8526.
class factory   *note 3.9(30/2): 2134.
class-wide aspect   *note 13.1.1(28/4): 4933.
class-wide postcondition expression   *note 6.1.1(5/3): 3357.
class-wide precondition expression   *note 6.1.1(3/3): 3349.
class-wide type   *note 3.4.1(4): 1566, *note 3.7(26): 1998.
class-wide type invariant   *note 7.3.2(3/4): 3632.
cleanup
   See finalization   *note 7.6.1(1): 3685.
clear
   execution timer object   *note D.14.1(12/2): 8026.
   group budget object   *note D.14.2(15/2): 8053.
   timing event object   *note D.15(9/2): 8068.
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(13/2): 6831.
   in Ada.Containers.Hashed_Maps   *note A.18.5(12/2): 6919.
   in Ada.Containers.Hashed_Sets   *note A.18.8(14/2): 7053.
   in Ada.Containers.Indefinite_Holders   *note A.18.18(11/3): 7289.
   in Ada.Containers.Multiway_Trees   *note A.18.10(23/3): 7216.
   in Ada.Containers.Ordered_Maps   *note A.18.6(11/2): 6970.
   in Ada.Containers.Ordered_Sets   *note A.18.9(13/2): 7124.
   in Ada.Containers.Vectors   *note A.18.2(24/2): 6740.
   in Ada.Environment_Variables   *note A.17(7/2): 6704.
cleared
   termination handler   *note C.7.3(9/2): 7754.
clock   *note 9.6(6/3): 4144.
   in Ada.Calendar   *note 9.6(12): 4151.
   in Ada.Execution_Time   *note D.14(5/2): 8005.
   in Ada.Execution_Time.Interrupts   *note D.14.3(3/3): 8056.
   in Ada.Real_Time   *note D.8(6): 7952.
clock jump   *note D.8(32): 7967.
clock tick   *note D.8(23): 7966.
Clock_For_Interrupts
   in Ada.Execution_Time   *note D.14(9.3/3): 8010.
Close
   in Ada.Direct_IO   *note A.8.4(8): 6330.
   in Ada.Sequential_IO   *note A.8.1(8): 6303.
   in Ada.Streams.Stream_IO   *note A.12.1(10): 6576.
   in Ada.Text_IO   *note A.10.1(11): 6385.
close result set   *note G.2.3(5): 8354.
closed entry   *note 9.5.3(5): 4097.
   of a protected object   *note 9.5.3(7/3): 4102.
   of a task   *note 9.5.3(6/3): 4100.
closed under derivation   *note 3.4(28): 1559, *note N(6/2): 8889.
closure
   downward   *note 3.10.2(38/2): 2326.
COBOL
   child of Interfaces   *note B.4(7): 7545.
COBOL interface   *note B.4(1/3): 7544.
COBOL standard   *note 1.2(4/2): 1099.
COBOL_Character
   in Interfaces.COBOL   *note B.4(13): 7554.
COBOL_To_Ada
   in Interfaces.COBOL   *note B.4(15): 7556.
code point
   for characters   *note 3.5.2(2/3): 1707.
code_statement   *note 13.8(2): 5149.
   used   *note 5.1(4/2): 3133, *note P: 9368.
Coding aspect   *note 13.4(7): 5047.
coextension
   of an object   *note 3.10.2(14.4/3): 2301.
Col
   in Ada.Text_IO   *note A.10.1(37): 6437.
collection
   of an access type   *note 7.6.1(11.1/3): 3703.
colon   *note 2.1(15/3): 1169.
   in Ada.Characters.Latin_1   *note A.3.3(10): 5549.
column number   *note A.10(9): 6368.
comma   *note 2.1(15/3): 1161.
   in Ada.Characters.Latin_1   *note A.3.3(8): 5544.
Command_Line
   child of Ada   *note A.15(3): 6626.
Command_Name
   in Ada.Command_Line   *note A.15(6): 6629.
comment   *note 2.7(2): 1256.
comments, instructions for submission   *note 0.3(58/1): 1004.
Commercial_At
   in Ada.Characters.Latin_1   *note A.3.3(10): 5555.
Communication_Error
   in System.RPC   *note E.5(5): 8206.
comparison operator
   See relational operator   *note 4.5.2(1): 2760.
compatibility
   composite_constraint with an access subtype   *note 3.10(15/2): 2271.
   constraint with a subtype   *note 3.2.2(12): 1425.
   delta_constraint with an ordinary fixed point subtype   *note
J.3(9/4): 8500.
   digits_constraint with a decimal fixed point subtype   *note
3.5.9(18/4): 1859.
   digits_constraint with a floating point subtype   *note J.3(10/4):
8501.
   discriminant constraint with a subtype   *note 3.7.1(10): 2014.
   index constraint with a subtype   *note 3.6.1(7): 1941.
   range with a scalar subtype   *note 3.5(8): 1605.
   range_constraint with a scalar subtype   *note 3.5(8): 1606.
compatible
   a type, with a convention   *note B.1(12): 7406.
compilation   *note 10.1.1(2): 4322.
   separate   *note 10.1(1): 4316.
Compilation unit   *note 10.1(2): 4318, *note 10.1.1(9): 4352, *note
N(7): 8890.
compilation units needed
   by a compilation unit   *note 10.2(2): 4448.
   remote call interface   *note E.2.3(18): 8166.
   shared passive library unit   *note E.2.1(11): 8133.
compilation_unit   *note 10.1.1(3): 4324.
   used   *note 10.1.1(2): 4323, *note P: 9651.
compile-time error   *note 1.1.2(27): 1023, *note 1.1.5(4): 1072.
compile-time semantics   *note 1.1.2(28): 1028.
complete context   *note 8.6(4): 3848.
completely defined   *note 3.11.1(8): 2358.
completion
   abnormal   *note 7.6.1(2/2): 3692.
   compile-time concept   *note 3.11.1(1/3): 2354.
   normal   *note 7.6.1(2/2): 3690.
   run-time concept   *note 7.6.1(2/2): 3688.
completion and leaving (completed and left)   *note 7.6.1(2/2): 3687.
completion legality
   [partial]   *note 3.10.1(13): 2285.
   entry_body   *note 9.5.2(16): 4073.
Complex
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(3): 8259.
   in Interfaces.Fortran   *note B.5(9): 7605.
Complex_Arrays
   child of Ada.Numerics   *note G.3.2(53/2): 8422.
Complex_Elementary_Functions
   child of Ada.Numerics   *note G.1.2(9/1): 8306.
Complex_IO
   child of Ada.Text_IO   *note G.1.3(3): 8314.
   child of Ada.Wide_Text_IO   *note G.1.4(1): 8326.
   child of Ada.Wide_Wide_Text_IO   *note G.1.5(1/2): 8328.
Complex_Matrix
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(4/2): 8388.
Complex_Text_IO
   child of Ada   *note G.1.3(9.1/2): 8324.
Complex_Types
   child of Ada.Numerics   *note G.1.1(25/1): 8279.
Complex_Vector
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(4/2): 8387.
component   *note 3.2(2/2): 1337.
   of a type   *note 3.2(6/2): 1350.
component subtype   *note 3.6(10): 1909.
component_choice_list   *note 4.3.1(5): 2514.
   used   *note 4.3.1(4/2): 2513, *note P: 9240.
component_clause   *note 13.5.1(3): 5063.
   used   *note 13.5.1(2): 5062, *note P: 9826.
component_declaration   *note 3.8(6/3): 2036.
   used   *note 3.8(5/1): 2034, *note 9.4(6): 3976, *note P: 9577.
component_definition   *note 3.6(7/2): 1903.
   used   *note 3.6(3): 1893, *note 3.6(5): 1899, *note 3.8(6/3): 2038,
*note P: 9148.
component_item   *note 3.8(5/1): 2033.
   used   *note 3.8(4): 2029, *note P: 9141.
component_list   *note 3.8(4): 2028.
   used   *note 3.8(3): 2027, *note 3.8.1(3): 2064, *note P: 9140.
Component_Size aspect   *note 13.3(70): 5026.
Component_Size attribute   *note 13.3(69): 5022.
Component_Size clause   *note 13.3(7/2): 4962, *note 13.3(70): 5024.
components
   of a record type   *note 3.8(9/2): 2042.
Compose
   in Ada.Directories   *note A.16(20/2): 6650.
   in Ada.Directories.Hierarchical_File_Names   *note A.16.1(14/3):
6697.
Compose attribute   *note A.5.3(24): 6209.
Compose_From_Cartesian
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(9/2): 8393,
*note G.3.2(29/2): 8406.
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(8): 8269.
Compose_From_Polar
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(11/2): 8399,
*note G.3.2(32/2): 8412.
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(11): 8275.
composite type   *note 3.2(2/2): 1336, *note N(8/2): 8891.
composite_constraint   *note 3.2.2(7): 1417.
   used   *note 3.2.2(5): 1412, *note P: 9049.
compound delimiter   *note 2.2(10): 1186.
compound_statement   *note 5.1(5/2): 3134.
   used   *note 5.1(3): 3120, *note P: 9356.
concatenation operator   *note 4.4(1/3): 2629, *note 4.5.3(3): 2819.
concrete subprogram
   See nonabstract subprogram   *note 3.9.3(1/2): 2184.
concrete type
   See nonabstract type   *note 3.9.3(1/2): 2182.
concurrent processing
   See task   *note 9(1/3): 3879.
condition   *note 4.5.7(4/3): 2887.
   used   *note 4.5.7(3/3): 2884, *note 5.3(2): 3172, *note 5.5(3/3):
3196, *note 5.7(2): 3268, *note 9.5.2(7): 4063, *note 9.7.1(3): 4222,
*note P: 9382.
   See also exception   *note 11(1/3): 4507.
conditional_entry_call   *note 9.7.3(2): 4251.
   used   *note 9.7(2): 4212, *note P: 9619.
conditional_expression   *note 4.5.7(2/3): 2878.
   used   *note 4.4(7/3): 2716, *note P: 9315.
configuration
   of the partitions of a program   *note E(4): 8099.
configuration pragma   *note 10.1.5(8): 4426.
   Assertion_Policy   *note 11.4.2(7/3): 4602.
   Detect_Blocking   *note H.5(4/2): 8486.
   Discard_Names   *note C.5(4): 7684.
   Locking_Policy   *note D.3(5): 7836.
   Normalize_Scalars   *note H.1(4): 8433.
   Partition_Elaboration_Policy   *note H.6(5/2): 8491.
   Priority_Specific_Dispatching   *note D.2.2(5/2): 7794.
   Profile   *note 13.12(14/3): 5308.
   Queuing_Policy   *note D.4(5): 7857.
   Restrictions   *note 13.12(8/3): 5302.
   Reviewable   *note H.3.1(4): 8438.
   Suppress   *note 11.5(5/2): 4623.
   Task_Dispatching_Policy   *note D.2.2(5/2): 7792.
   Unsuppress   *note 11.5(5/2): 4625.
confirming
   aspect specification   *note 13.1(18.2/3): 4903.
   nonoverridable aspect   *note 13.1.1(18.3/4): 4928.
   representation item   *note 13.1(18.2/3): 4901.
   representation value   *note 13.1(18.2/3): 4902.
conformance   *note 6.3.1(1): 3412.
   of an implementation with the Standard   *note 1.1.3(1): 1050.
   See also full conformance, mode conformance, subtype conformance,
type conformance
Conjugate
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(13/2): 8400,
*note G.3.2(34/2): 8413.
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(12): 8277, *note
G.1.1(15): 8278.
consistency
   among compilation units   *note 10.1.4(5): 4416.
constant   *note 3.3(13/3): 1456.
   result of a function_call   *note 6.4(12/2): 3469.
   See also literal   *note 4.2(1): 2477.
   See also static   *note 4.9(1): 3087.
constant indexing   *note 4.1.6(12/3): 2472.
constant object   *note 3.3(13/3): 1458.
constant view   *note 3.3(13/3): 1460.
Constant_Indexing aspect   *note 4.1.6(2/3): 2463.
Constant_Reference
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(17.3/3): 6837.
   in Ada.Containers.Hashed_Maps   *note A.18.5(17.3/3): 6926, *note
A.18.5(17.5/3): 6928.
   in Ada.Containers.Hashed_Sets   *note A.18.8(17.2/3): 7057, *note
A.18.8(58.3/3): 7098.
   in Ada.Containers.Indefinite_Holders   *note A.18.18(18/3): 7296.
   in Ada.Containers.Multiway_Trees   *note A.18.10(30/3): 7223.
   in Ada.Containers.Ordered_Maps   *note A.18.6(16.3/3): 6977, *note
A.18.6(16.5/3): 6979.
   in Ada.Containers.Ordered_Sets   *note A.18.9(16.2/3): 7128, *note
A.18.9(73.3/3): 7179.
   in Ada.Containers.Vectors   *note A.18.2(34.3/3): 6752, *note
A.18.2(34.5/3): 6754.
Constant_Reference_Type
   in Ada.Containers.Indefinite_Holders   *note A.18.18(16/3): 7294.
   in Ada.Containers.Multiway_Trees   *note A.18.10(28/3): 7221.
Constants
   child of Ada.Strings.Maps   *note A.4.6(3/2): 5954.
constituent
   of a construct   *note 1.1.4(17): 1068.
constrained   *note 3.2(9): 1362.
   known to be   *note 3.3(23.1/3): 1471.
   object   *note 3.3.1(9/2): 1508.
   object   *note 6.4.1(16): 3486.
   subtype   *note 3.2(9): 1364, *note 3.4(6): 1541, *note 3.5(7): 1602,
*note 3.5.1(10): 1699, *note 3.5.4(9): 1735, *note 3.5.4(10): 1738,
*note 3.5.7(11): 1813, *note 3.5.9(13): 1851, *note 3.5.9(16): 1855,
*note 3.6(15): 1917, *note 3.6(16): 1920, *note 3.7(26): 1994, *note
3.9(15): 2120.
   subtype   *note 3.10(14/3): 2269.
   subtype   *note K.2(33): 8654.
Constrained attribute   *note 3.7.2(3/3): 2019, *note J.4(2): 8504.
constrained by its initial value   *note 3.3.1(9/2): 1505.
   [partial]   *note 4.8(6/3): 3056, *note 6.5(5.11/3): 3518.
constrained_array_definition   *note 3.6(5): 1896.
   used   *note 3.6(2): 1889, *note P: 9106.
constraint   *note 3.2.2(5): 1410.
   [partial]   *note 3.2(7/2): 1351.
   null   *note 3.2(7/2): 1353.
   of a first array subtype   *note 3.6(16): 1922.
   of a subtype   *note 3.2(8/2): 1357.
   of an object   *note 3.3.1(9/2): 1504.
   used   *note 3.2.2(3/2): 1407, *note P: 9046.
Constraint_Error
   raised by failure of run-time check   *note 3.2.2(12): 1426, *note
3.5(24): 1626, *note 3.5(27): 1633, *note 3.5(39.12/3): 1662, *note
3.5(39.4/3): 1656, *note 3.5(39.5/3): 1659, *note 3.5(43/3): 1668, *note
3.5(55/3): 1674, *note 3.5.4(20): 1759, *note 3.5.5(7): 1775, *note
3.5.9(19/4): 1863, *note 3.9.2(16): 2177, *note 4.1(13): 2392, *note
4.1.1(7): 2405, *note 4.1.2(7): 2416, *note 4.1.3(15): 2432, *note
4.1.5(8/3): 2461, *note 4.2(11): 2491, *note 4.3(6): 2504, *note
4.3.2(8/3): 2541, *note 4.3.3(31): 2581, *note 4.4(11): 2721, *note
4.5(10): 2736, *note 4.5(11): 2737, *note 4.5(12): 2738, *note 4.5.1(8):
2757, *note 4.5.3(8): 2825, *note 4.5.5(22): 2857, *note 4.5.6(6): 2868,
*note 4.5.6(12): 2874, *note 4.5.6(13): 2877, *note 4.5.7(21/3): 2904,
*note 4.6(28): 2969, *note 4.6(57/4): 3018, *note 4.6(60): 3023, *note
4.7(4/4): 3039, *note 4.8(10.4/3): 3082, *note 4.8(10/2): 3067, *note
5.2(10): 3164, *note 5.4(13): 3189, *note 6.5(5.11/3): 3519, *note
6.5(8.1/3): 3530, *note 11.1(4): 4519, *note 11.4.1(14/2): 4586, *note
11.5(10): 4628, *note 13.9.1(9): 5174, *note 13.11.2(15.2/4): 5243,
*note 13.13.2(35/3): 5367, *note A.4.3(109): 5842, *note A.4.7(47):
6007, *note A.4.8(51/2): 6048, *note A.5.1(28): 6142, *note A.5.1(34):
6143, *note A.5.2(39): 6177, *note A.5.2(40.1/1): 6179, *note A.5.3(26):
6210, *note A.5.3(29): 6215, *note A.5.3(47): 6233, *note A.5.3(50):
6238, *note A.5.3(53): 6243, *note A.5.3(59): 6248, *note A.5.3(62):
6253, *note A.15(14): 6634, *note B.3(53): 7492, *note B.3(54): 7493,
*note B.4(58): 7596, *note E.4(19): 8197, *note G.1.1(40): 8282, *note
G.1.2(28): 8309, *note G.2.1(12): 8339, *note G.2.2(7): 8348, *note
G.2.3(26): 8357, *note G.2.4(3): 8362, *note G.2.6(4): 8369, *note
K.2(11): 8650, *note K.2(114): 8665, *note K.2(122): 8668, *note
K.2(184): 8672, *note K.2(202): 8677, *note K.2(220): 8681, *note
K.2(241): 8684, *note K.2(261): 8690, *note K.2(41): 8655, *note
K.2(47): 8658.
   in Standard   *note A.1(46): 5451.
Construct   *note 1.1.4(16): 1067, *note N(9): 8892.
constructor
   See initialization   *note 3.3.1(18/2): 1518.
   See initialization   *note 7.6(1): 3654.
   See initialization expression   *note 3.3.1(4): 1499.
   See Initialize   *note 7.6(1): 3655.
   See initialized allocator   *note 4.8(4): 3054.
container   *note N(9.1/3): 8893.
   cursor   *note A.18(2/2): 6710.
   list   *note A.18.3(1/2): 6819.
   map   *note A.18.4(1/2): 6889.
   set   *note A.18.7(1/2): 7019.
   vector   *note A.18.2(1/2): 6720.
container element iterator   *note 5.5.2(3/3): 3247.
Containers
   child of Ada   *note A.18.1(3/2): 6715.
Containing_Directory
   in Ada.Directories   *note A.16(17/2): 6647.
   in Ada.Directories.Hierarchical_File_Names   *note A.16.1(11/3):
6694.
Contains
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(43/2): 6866.
   in Ada.Containers.Hashed_Maps   *note A.18.5(32/2): 6946.
   in Ada.Containers.Hashed_Sets   *note A.18.8(44/2): 7082, *note
A.18.8(57/2): 7094.
   in Ada.Containers.Multiway_Trees   *note A.18.10(41/3): 7234.
   in Ada.Containers.Ordered_Maps   *note A.18.6(42/2): 7008.
   in Ada.Containers.Ordered_Sets   *note A.18.9(52/2): 7162, *note
A.18.9(72/2): 7175.
   in Ada.Containers.Vectors   *note A.18.2(71/2): 6794.
context free grammar
   complete listing   *note P: 8959.
   cross reference   *note P: 9848.
   notation   *note 1.1.4(3): 1062.
   under Syntax heading   *note 1.1.2(25): 1016.
context_clause   *note 10.1.2(2): 4368.
   used   *note 10.1.1(3): 4325, *note P: 9652.
context_item   *note 10.1.2(3): 4370.
   used   *note 10.1.2(2): 4369, *note P: 9669.
contiguous representation
   [partial]   *note 13.5.2(5): 5086, *note 13.7.1(12): 5141, *note
13.9(9): 5160, *note 13.9(17/3): 5163, *note 13.11(21.6/3): 5217.
Continue
   in Ada.Asynchronous_Task_Control   *note D.11(3/2): 7990.
control character
   a category of Character   *note A.3.2(22): 5488.
   a category of Character   *note A.3.3(4): 5499, *note A.3.3(15):
5593.
   See also format_effector   *note 2.1(13/3): 1146.
Control_Set
   in Ada.Strings.Maps.Constants   *note A.4.6(4): 5955.
Controlled
   in Ada.Finalization   *note 7.6(5/2): 3662.
controlled type   *note 7.6(2): 3657, *note 7.6(9/2): 3669, *note N(10):
8894.
controlling access result   *note 3.9.2(2/3): 2165.
controlling formal parameter   *note 3.9.2(2/3): 2162.
controlling operand   *note 3.9.2(2/3): 2161.
controlling result   *note 3.9.2(2/3): 2163.
controlling tag
   for a call on a dispatching operation   *note 3.9.2(1/2): 2153.
controlling tag value   *note 3.9.2(14): 2173.
   for the expression in an assignment_statement   *note 5.2(9): 3161.
controlling type
   of a formal_abstract_subprogram_declaration   *note 12.6(8.4/3):
4848.
convention   *note 6.3.1(2/1): 3417, *note B.1(11/3): 7404.
Convention aspect   *note B.1(2/3): 7398.
Convention pragma   *note J.15.5(4/3): 8577, *note L(8.1/3): 8725.
conversion   *note 4.6(1/3): 2921, *note 4.6(28): 2966.
   access   *note 4.6(24.11/2): 2952, *note 4.6(24.18/2): 2957, *note
4.6(24.19/2): 2959, *note 4.6(47): 2995.
   arbitrary order   *note 1.1.4(18): 1071.
   array   *note 4.6(24.2/2): 2947, *note 4.6(36): 2976.
   composite (non-array)   *note 4.6(21/3): 2941, *note 4.6(40): 2985.
   enumeration   *note 4.6(21.1/2): 2943, *note 4.6(34): 2974.
   numeric   *note 4.6(24.1/2): 2945, *note 4.6(29): 2971.
   unchecked   *note 13.9(1): 5156.
   value   *note 4.6(5/2): 2937.
   view   *note 4.6(5/2): 2935.
Conversion_Error
   in Interfaces.COBOL   *note B.4(30): 7578.
Conversions
   child of Ada.Characters   *note A.3.4(2/2): 5729.
   child of Ada.Strings.UTF_Encoding   *note A.4.11(15/3): 6075.
Convert
   in Ada.Strings.UTF_Encoding.Conversions   *note A.4.11(16/3): 6076,
*note A.4.11(17/3): 6077, *note A.4.11(18/3): 6078, *note A.4.11(19/3):
6079, *note A.4.11(20/3): 6080.
convertible   *note 4.6(4/3): 2933.
   required   *note 4.6(24.13/2): 2953, *note 4.6(24.4/2): 2948, *note
8.6(27.1/4): 3869.
Copy
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(17.6/3): 6840.
   in Ada.Containers.Hashed_Maps   *note A.18.5(17.8/3): 6931.
   in Ada.Containers.Hashed_Sets   *note A.18.8(17.4/3): 7059.
   in Ada.Containers.Indefinite_Holders   *note A.18.18(21/3): 7299,
*note A.18.20(10/3): 7311, *note A.18.21(13/3): 7315, *note
A.18.22(10/3): 7318, *note A.18.23(13/3): 7322, *note A.18.24(10/3):
7325.
   in Ada.Containers.Multiway_Trees   *note A.18.10(33/3): 7226.
   in Ada.Containers.Ordered_Maps   *note A.18.6(16.8/3): 6982.
   in Ada.Containers.Ordered_Sets   *note A.18.9(16.4/3): 7130.
   in Ada.Containers.Vectors   *note A.18.2(34.8/3): 6757.
copy back of parameters   *note 6.4.1(17): 3489.
copy parameter passing   *note 6.2(2): 3389.
Copy_Array
   in Interfaces.C.Pointers   *note B.3.2(15): 7527.
Copy_File
   in Ada.Directories   *note A.16(13/2): 6644.
Copy_Sign attribute   *note A.5.3(51): 6242.
Copy_Subtree
   in Ada.Containers.Multiway_Trees   *note A.18.10(54/3): 7247.
Copy_Terminated_Array
   in Interfaces.C.Pointers   *note B.3.2(14): 7526.
Copyright_Sign
   in Ada.Characters.Latin_1   *note A.3.3(21/3): 5640.
core language   *note 1.1.2(2): 1005.
corresponding constraint   *note 3.4(6): 1543.
corresponding discriminants   *note 3.7(18): 1988.
corresponding expresssion
   class-wide postcondition   *note 6.1.1(18/4): 3366.
   class-wide precondition   *note 6.1.1(18/4): 3365.
corresponding index
   for an array_aggregate   *note 4.3.3(8): 2567.
corresponding subtype   *note 3.4(18/3): 1553.
corresponding value
   of the target type of a conversion   *note 4.6(28): 2965.
Cos
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(4): 8291.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(5): 6117.
Cosh
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(6): 8299.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7): 6132.
Cot
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(4): 8293.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(5): 6121.
Coth
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(6): 8301.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7): 6134.
Count
   in Ada.Direct_IO   *note A.8.4(4): 6326.
   in Ada.Streams.Stream_IO   *note A.12.1(7): 6572.
   in Ada.Strings.Bounded   *note A.4.4(48): 5874, *note A.4.4(49):
5875, *note A.4.4(50): 5876.
   in Ada.Strings.Fixed   *note A.4.3(13): 5817, *note A.4.3(14): 5818,
*note A.4.3(15): 5819.
   in Ada.Strings.Unbounded   *note A.4.5(43): 5928, *note A.4.5(44):
5929, *note A.4.5(45): 5930.
   in Ada.Text_IO   *note A.10.1(5): 6377.
Count attribute   *note 9.9(5): 4304.
Count_Type
   in Ada.Containers   *note A.18.1(5/2): 6717.
Country
   in Ada.Locales   *note A.19(6/3): 7376.
Country code standard   *note 1.2(4.1/3): 1102.
Country_Code
   in Ada.Locales   *note A.19(4/4): 7372.
Country_Unknown
   in Ada.Locales   *note A.19(5/3): 7374.
cover
   a type   *note 3.4.1(9): 1575.
   of a choice and an exception   *note 11.2(6): 4541.
cover a value
   by a discrete_choice   *note 3.8.1(9): 2074.
   by a discrete_choice_list   *note 3.8.1(13): 2075.
CPU aspect   *note D.16(8/3): 8076.
CPU clock tick   *note D.14(15/2): 8013.
CPU pragma   *note J.15.9(2/3): 8628, *note L(8.2/3): 8729.
CPU subtype of CPU_Range
   in System.Multiprocessors   *note D.16(4/3): 8073.
CPU time
   of a task   *note D.14(11/3): 8012.
CPU_Range
   in System.Multiprocessors   *note D.16(4/3): 8071.
CPU_Set
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(9.1/4):
8084.
CPU_Tick
   in Ada.Execution_Time   *note D.14(4/2): 8004.
CPU_Time
   in Ada.Execution_Time   *note D.14(4/2): 8000.
CPU_Time_First
   in Ada.Execution_Time   *note D.14(4/2): 8001.
CPU_Time_Last
   in Ada.Execution_Time   *note D.14(4/2): 8002.
CPU_Time_Unit
   in Ada.Execution_Time   *note D.14(4/2): 8003.
CR
   in Ada.Characters.Latin_1   *note A.3.3(5): 5513.
create   *note 3.1(12): 1327.
   in Ada.Direct_IO   *note A.8.4(6): 6328.
   in Ada.Sequential_IO   *note A.8.1(6): 6301.
   in Ada.Streams.Stream_IO   *note A.12.1(8): 6574.
   in Ada.Text_IO   *note A.10.1(9): 6383.
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(7/4):
8081, *note D.16.1(9.2/4): 8085.
Create_Directory
   in Ada.Directories   *note A.16(7/2): 6638.
Create_Path
   in Ada.Directories   *note A.16(9/2): 6640.
Create_Subpool
   in System.Storage_Pools.Subpools   *note 13.11.4(7/3): 5260.
creation
   of a protected object   *note C.3.1(10/3): 7646.
   of a return object   *note 6.5(5.11/3): 3517.
   of a tag   *note 13.14(20/2): 5430.
   of a task object   *note D.1(17/4): 7766.
   of an object   *note 3.3(1): 1454.
critical section
   See intertask communication   *note 9.5(1): 4011.
CSI
   in Ada.Characters.Latin_1   *note A.3.3(19): 5625.
Currency_Sign
   in Ada.Characters.Latin_1   *note A.3.3(21/3): 5635.
current column number   *note A.10(9): 6369.
current index
   of an open direct file   *note A.8(4): 6297.
   of an open stream file   *note A.12.1(1.1/1): 6566.
current instance
   of a generic unit   *note 8.6(18): 3858.
   of a type   *note 8.6(17/3): 3857.
current line number   *note A.10(9): 6370.
current mode
   of an open file   *note A.7(7): 6287.
current page number   *note A.10(9): 6371.
Current size
   of a stream file   *note A.12.1(1.1/1): 6567.
   of an external file   *note A.8(3): 6296.
Current_Directory
   in Ada.Directories   *note A.16(5/2): 6636.
Current_Error
   in Ada.Text_IO   *note A.10.1(17): 6401, *note A.10.1(20): 6408.
Current_Handler
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(10/2): 8045.
   in Ada.Execution_Time.Timers   *note D.14.1(7/2): 8021.
   in Ada.Interrupts   *note C.3.2(6): 7664.
   in Ada.Real_Time.Timing_Events   *note D.15(5/2): 8063.
Current_Input
   in Ada.Text_IO   *note A.10.1(17): 6399, *note A.10.1(20): 6406.
Current_Output
   in Ada.Text_IO   *note A.10.1(17): 6400, *note A.10.1(20): 6407.
Current_State
   in Ada.Synchronous_Task_Control   *note D.10(4): 7977.
Current_Task
   in Ada.Task_Identification   *note C.7.1(3/3): 7712.
Current_Task_Fallback_Handler
   in Ada.Task_Termination   *note C.7.3(5/2): 7744.
Current_Use
   in Ada.Containers.Bounded_Priority_Queues   *note A.18.31(7/3): 7367.
   in Ada.Containers.Bounded_Synchronized_Queues   *note A.18.29(6/3):
7353.
   in Ada.Containers.Synchronized_Queue_Interfaces   *note A.18.27(7/3):
7340.
   in Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(7/3):
7360.
   in Ada.Containers.Unbounded_Synchronized_Queues   *note A.18.28(6/3):
7347.
cursor
   ambiguous   *note A.18.2(240/2): 6812.
   for a container   *note A.18(2/2): 6709.
   invalid   *note A.18.2(248/2): 6815, *note A.18.3(153/2): 6885, *note
A.18.4(76/2): 6905, *note A.18.7(97/2): 7037, *note A.18.10(222/3):
7274.
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(7/2): 6824.
   in Ada.Containers.Hashed_Maps   *note A.18.5(4/2): 6910.
   in Ada.Containers.Hashed_Sets   *note A.18.8(4/2): 7042.
   in Ada.Containers.Multiway_Trees   *note A.18.10(9/3): 7203.
   in Ada.Containers.Ordered_Maps   *note A.18.6(5/2): 6963.
   in Ada.Containers.Ordered_Sets   *note A.18.9(5/2): 7115.
   in Ada.Containers.Vectors   *note A.18.2(9/2): 6728.



File: arm2012.info,  Node: D,  Next: E,  Prev: C,  Up: Index

D 
==



dangling reference   *note 13.11.2(15.1/4): 5239.
dangling references
   prevention via accessibility rules   *note 3.10.2(3/2): 2293.
Data_Error
   in Ada.Direct_IO   *note A.8.4(18): 6353.
   in Ada.IO_Exceptions   *note A.13(4): 6620.
   in Ada.Sequential_IO   *note A.8.1(15): 6321.
   in Ada.Storage_IO   *note A.9(9): 6360.
   in Ada.Streams.Stream_IO   *note A.12.1(26): 6601.
   in Ada.Text_IO   *note A.10.1(85): 6526.
date and time formatting standard   *note 1.2(5.1/2): 1107.
Day
   in Ada.Calendar   *note 9.6(13): 4154.
   in Ada.Calendar.Formatting   *note 9.6.1(23/2): 4193.
Day_Count
   in Ada.Calendar.Arithmetic   *note 9.6.1(10/2): 4174.
Day_Duration subtype of Duration
   in Ada.Calendar   *note 9.6(11/2): 4150.
Day_Name
   in Ada.Calendar.Formatting   *note 9.6.1(17/2): 4178.
Day_Number subtype of Integer
   in Ada.Calendar   *note 9.6(11/2): 4149.
Day_of_Week
   in Ada.Calendar.Formatting   *note 9.6.1(18/2): 4186.
DC1
   in Ada.Characters.Latin_1   *note A.3.3(6): 5517.
DC2
   in Ada.Characters.Latin_1   *note A.3.3(6): 5518.
DC3
   in Ada.Characters.Latin_1   *note A.3.3(6): 5519.
DC4
   in Ada.Characters.Latin_1   *note A.3.3(6): 5520.
DCS
   in Ada.Characters.Latin_1   *note A.3.3(18): 5614.
Deadline subtype of Time
   in Ada.Dispatching.EDF   *note D.2.6(9/2): 7822.
Deallocate
   in System.Storage_Pools   *note 13.11(8): 5190.
   in System.Storage_Pools.Subpools   *note 13.11.4(15/3): 5267.
Deallocate_Subpool
   in System.Storage_Pools.Subpools   *note 13.11.4(12/3): 5264.
deallocation of storage   *note 13.11.2(1): 5225.
Decimal
   child of Ada   *note F.2(2): 8223.
decimal digit
   a category of Character   *note A.3.2(28): 5494.
decimal fixed point type   *note 3.5.9(1): 1827, *note 3.5.9(6): 1845.
Decimal_Conversions
   in Interfaces.COBOL   *note B.4(31): 7579.
Decimal_Digit_Set
   in Ada.Strings.Maps.Constants   *note A.4.6(4): 5961.
Decimal_Element
   in Interfaces.COBOL   *note B.4(12/3): 7552.
decimal_fixed_point_definition   *note 3.5.9(4): 1835.
   used   *note 3.5.9(2): 1831, *note P: 9097.
Decimal_IO
   in Ada.Text_IO   *note A.10.1(73): 6501.
decimal_literal   *note 2.4.1(2): 1211.
   used   *note 2.4(2): 1208, *note P: 8975.
Decimal_Output
   in Ada.Text_IO.Editing   *note F.3.3(11): 8246.
Declaration   *note 3.1(5): 1308, *note 3.1(6/3): 1311, *note N(11):
8895.
declaration list
   declarative_part   *note 3.11(6.1/2): 2344.
   package_specification   *note 7.1(6/2): 3584.
declarative region
   of a construct   *note 8.1(1): 3713.
declarative_item   *note 3.11(3): 2329.
   used   *note 3.11(2): 2328, *note P: 9184.
declarative_part   *note 3.11(2): 2327.
   used   *note 5.6(2): 3262, *note 6.3(2/3): 3406, *note 7.2(2/3):
3589, *note 9.1(6/3): 3914, *note 9.5.2(5): 4056, *note P: 9405.
declare   *note 3.1(8): 1320, *note 3.1(12): 1326.
declared pure   *note 10.2.1(17/3): 4485.
Decode
   in Ada.Strings.UTF_Encoding.Strings   *note A.4.11(26/3): 6085, *note
A.4.11(27/3): 6086, *note A.4.11(28/3): 6087.
   in Ada.Strings.UTF_Encoding.Wide_Strings   *note A.4.11(34/3): 6092,
*note A.4.11(35/3): 6093, *note A.4.11(36/3): 6094.
   in Ada.Strings.UTF_Encoding.Wide_Wide_Strings   *note A.4.11(42/3):
6099, *note A.4.11(43/3): 6100, *note A.4.11(44/3): 6101.
Decrement
   in Interfaces.C.Pointers   *note B.3.2(11/3): 7524.
deeper
   accessibility level   *note 3.10.2(3/2): 2291.
   statically   *note 3.10.2(4): 2296, *note 3.10.2(17): 2303.
default constant indexing function   *note 5.5.1(16/3): 3233.
default cursor subtype   *note 5.5.1(8/3): 3223.
default directory   *note A.16(48/2): 6682.
default element subtype   *note 5.5.1(9/3): 3226.
default entry queuing policy   *note 9.5.3(17): 4112.
default iterator function   *note 5.5.1(8/3): 3221.
default iterator subtype   *note 5.5.1(8/3): 3222.
default pool   *note 13.11.3(4.2/4): 5251.
default treatment   *note C.3(5): 7640.
default variable indexing function   *note 5.5.1(21/3): 3234.
Default_Aft
   in Ada.Text_IO   *note A.10.1(64): 6483, *note A.10.1(69): 6493,
*note A.10.1(74): 6503.
   in Ada.Text_IO.Complex_IO   *note G.1.3(5): 8316.
Default_Base
   in Ada.Text_IO   *note A.10.1(53): 6465, *note A.10.1(58): 6474.
Default_Bit_Order
   in System   *note 13.7(15/2): 5126.
Default_Component_Value aspect   *note 3.6(22.2/3): 1930.
Default_Currency
   in Ada.Text_IO.Editing   *note F.3.3(10): 8242.
Default_Deadline
   in Ada.Dispatching.EDF   *note D.2.6(9/2): 7823.
Default_Exp
   in Ada.Text_IO   *note A.10.1(64): 6484, *note A.10.1(69): 6494,
*note A.10.1(74): 6504.
   in Ada.Text_IO.Complex_IO   *note G.1.3(5): 8317.
default_expression   *note 3.7(6): 1982.
   used   *note 3.7(5/2): 1978, *note 3.8(6/3): 2039, *note 6.1(15/3):
3327, *note 12.4(2/3): 4746, *note P: 9754.
Default_Fill
   in Ada.Text_IO.Editing   *note F.3.3(10): 8243.
Default_Fore
   in Ada.Text_IO   *note A.10.1(64): 6482, *note A.10.1(69): 6492,
*note A.10.1(74): 6502.
   in Ada.Text_IO.Complex_IO   *note G.1.3(5): 8315.
Default_Iterator aspect   *note 5.5.1(8/3): 3225.
Default_Modulus
   in Ada.Containers.Indefinite_Holders   *note A.18.21(10/3): 7314,
*note A.18.23(10/3): 7321.
default_name   *note 12.6(4): 4841.
   used   *note 12.6(3/2): 4840, *note P: 9788.
Default_Priority
   in System   *note 13.7(17): 5130.
Default_Quantum
   in Ada.Dispatching.Round_Robin   *note D.2.5(4/2): 7814.
Default_Radix_Mark
   in Ada.Text_IO.Editing   *note F.3.3(10): 8245.
Default_Separator
   in Ada.Text_IO.Editing   *note F.3.3(10): 8244.
Default_Setting
   in Ada.Text_IO   *note A.10.1(80): 6513.
Default_Storage_Pool aspect   *note 13.11.3(5/4): 5255.
Default_Storage_Pool pragma   *note 13.11.3(3/3): 5247, *note L(8.3/3):
8732.
Default_Subpool_for_Pool
   in System.Storage_Pools.Subpools   *note 13.11.4(13/3): 5265.
Default_Value aspect   *note 3.5(56.3/3): 1684.
Default_Width
   in Ada.Text_IO   *note A.10.1(53): 6464, *note A.10.1(58): 6473,
*note A.10.1(80): 6512.
deferred constant   *note 7.4(2/3): 3641.
deferred constant declaration   *note 3.3.1(6/3): 1501, *note 7.4(2/3):
3640.
defining name   *note 3.1(10): 1321.
defining_character_literal   *note 3.5.1(4): 1693.
   used   *note 3.5.1(3): 1692, *note P: 9083.
defining_designator   *note 6.1(6): 3298.
   used   *note 6.1(4.2/2): 3292, *note 12.3(2/3): 4705, *note P: 9731.
defining_identifier   *note 3.1(4): 1306.
   used   *note 3.2.1(3/3): 1374, *note 3.2.2(2/3): 1401, *note
3.3.1(3): 1495, *note 3.5.1(3): 1691, *note 3.10.1(2/2): 2276, *note
5.5(4): 3200, *note 5.5.2(2/3): 3238, *note 6.1(7): 3303, *note
6.5(2.1/3): 3500, *note 7.3(2/3): 3601, *note 7.3(3/3): 3605, *note
8.5.1(2/3): 3804, *note 8.5.2(2/3): 3813, *note 9.1(2/3): 3894, *note
9.1(3/3): 3900, *note 9.1(6/3): 3912, *note 9.4(2/3): 3956, *note
9.4(3/3): 3962, *note 9.4(7/3): 3978, *note 9.5.2(2/3): 4040, *note
9.5.2(5): 4053, *note 9.5.2(8): 4065, *note 10.1.3(4/3): 4397, *note
10.1.3(5/3): 4400, *note 10.1.3(6/3): 4403, *note 11.2(4): 4538, *note
12.5(2.1/3): 4771, *note 12.5(2.2/3): 4776, *note 12.7(2/3): 4853, *note
P: 9519.
defining_identifier_list   *note 3.3.1(3): 1494.
   used   *note 3.3.1(2/3): 1488, *note 3.3.2(2): 1524, *note 3.7(5/2):
1975, *note 3.8(6/3): 2037, *note 6.1(15/3): 3320, *note 11.1(2/3):
4516, *note 12.4(2/3): 4748, *note P: 9071.
defining_operator_symbol   *note 6.1(11): 3306.
   used   *note 6.1(6): 3300, *note P: 9424.
defining_program_unit_name   *note 6.1(7): 3301.
   used   *note 6.1(4.1/2): 3289, *note 6.1(6): 3299, *note 7.1(3/3):
3574, *note 7.2(2/3): 3587, *note 8.5.3(2/3): 3817, *note 8.5.5(2/3):
3836, *note 12.3(2/3): 4700, *note P: 9483.
Definite attribute   *note 12.5.1(23/3): 4808.
definite subtype   *note 3.3(23/3): 1469.
definition   *note 3.1(7): 1313.
Degree_Sign
   in Ada.Characters.Latin_1   *note A.3.3(22): 5647.
DEL
   in Ada.Characters.Latin_1   *note A.3.3(14): 5592.
delay_alternative   *note 9.7.1(6): 4230.
   used   *note 9.7.1(4): 4225, *note 9.7.2(2): 4243, *note P: 9635.
delay_relative_statement   *note 9.6(4): 4138.
   used   *note 9.6(2): 4135, *note P: 9614.
delay_statement   *note 9.6(2): 4133.
   used   *note 5.1(4/2): 3130, *note 9.7.1(6): 4231, *note 9.7.4(4/2):
4263, *note P: 9647.
Delay_Until_And_Set_CPU
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(14/3):
8091.
Delay_Until_And_Set_Deadline
   in Ada.Dispatching.EDF   *note D.2.6(9/2): 7825.
delay_until_statement   *note 9.6(3): 4136.
   used   *note 9.6(2): 4134, *note P: 9613.
Delete
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(24/2): 6847.
   in Ada.Containers.Hashed_Maps   *note A.18.5(25/2): 6939, *note
A.18.5(26/2): 6940.
   in Ada.Containers.Hashed_Sets   *note A.18.8(24/2): 7066, *note
A.18.8(25/2): 7067, *note A.18.8(55/2): 7092.
   in Ada.Containers.Ordered_Maps   *note A.18.6(24/2): 6990, *note
A.18.6(25/2): 6991.
   in Ada.Containers.Ordered_Sets   *note A.18.9(23/2): 7137, *note
A.18.9(24/2): 7138, *note A.18.9(68/2): 7171.
   in Ada.Containers.Vectors   *note A.18.2(50/2): 6773, *note
A.18.2(51/2): 6774.
   in Ada.Direct_IO   *note A.8.4(8): 6331.
   in Ada.Sequential_IO   *note A.8.1(8): 6304.
   in Ada.Streams.Stream_IO   *note A.12.1(10): 6577.
   in Ada.Strings.Bounded   *note A.4.4(64): 5889, *note A.4.4(65):
5890.
   in Ada.Strings.Fixed   *note A.4.3(29): 5832, *note A.4.3(30): 5833.
   in Ada.Strings.Unbounded   *note A.4.5(59): 5943, *note A.4.5(60):
5944.
   in Ada.Text_IO   *note A.10.1(11): 6386.
Delete_Children
   in Ada.Containers.Multiway_Trees   *note A.18.10(53/3): 7246.
Delete_Directory
   in Ada.Directories   *note A.16(8/2): 6639.
Delete_File
   in Ada.Directories   *note A.16(11/2): 6642.
Delete_First
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(25/2): 6848.
   in Ada.Containers.Ordered_Maps   *note A.18.6(26/2): 6992.
   in Ada.Containers.Ordered_Sets   *note A.18.9(25/2): 7139.
   in Ada.Containers.Vectors   *note A.18.2(52/2): 6775.
Delete_Last
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(26/2): 6849.
   in Ada.Containers.Ordered_Maps   *note A.18.6(27/2): 6993.
   in Ada.Containers.Ordered_Sets   *note A.18.9(26/2): 7140.
   in Ada.Containers.Vectors   *note A.18.2(53/2): 6776.
Delete_Leaf
   in Ada.Containers.Multiway_Trees   *note A.18.10(35/3): 7228.
Delete_Subtree
   in Ada.Containers.Multiway_Trees   *note A.18.10(36/3): 7229.
Delete_Tree
   in Ada.Directories   *note A.16(10/2): 6641.
delimiter   *note 2.2(8/2): 1185.
delivery
   of an interrupt   *note C.3(2): 7633.
delta
   of a fixed point type   *note 3.5.9(1): 1828.
Delta attribute   *note 3.5.10(3): 1871.
delta_constraint   *note J.3(2/4): 8495.
   used   *note 3.2.2(6): 1416, *note P: 9052.
Denorm attribute   *note A.5.3(9): 6191.
denormalized number   *note A.5.3(10): 6192.
denote   *note 8.6(16): 3856.
   informal definition   *note 3.1(8): 1319.
   name used as a pragma argument   *note 8.6(32): 3873.
depend on a discriminant
   for a component   *note 3.7(20): 1991.
   for a constraint or component_definition   *note 3.7(19): 1990.
dependence
   elaboration   *note 10.2(9): 4453.
   of a task on a master   *note 9.3(1): 3941.
   of a task on another task   *note 9.3(4): 3945.
   semantic   *note 10.1.1(26/2): 4367.
depth
   accessibility level   *note 3.10.2(3/2): 2292.
   in Ada.Containers.Multiway_Trees   *note A.18.10(19/3): 7212.
depth-first order   *note A.18.10(5/3): 7200.
Dequeue
   in Ada.Containers.Bounded_Priority_Queues   *note A.18.31(5/3): 7365.
   in Ada.Containers.Bounded_Synchronized_Queues   *note A.18.29(5/3):
7352.
   in Ada.Containers.Synchronized_Queue_Interfaces   *note A.18.27(6/3):
7339.
   in Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(5/3):
7358.
   in Ada.Containers.Unbounded_Synchronized_Queues   *note A.18.28(5/3):
7346.
Dequeue_Only_High_Priority
   in Ada.Containers.Bounded_Priority_Queues   *note A.18.31(6/3): 7366.
   in Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(6/3):
7359.
dereference   *note 4.1(8): 2382.
Dereference_Error
   in Interfaces.C.Strings   *note B.3.1(12): 7505.
derivation class
   for a type   *note 3.4.1(2/2): 1562.
derived from
   directly or indirectly   *note 3.4.1(2/2): 1561.
derived type   *note 3.4(1/2): 1529, *note N(13/2): 8898.
   [partial]   *note 3.4(24): 1555.
derived_type_definition   *note 3.4(2/2): 1533.
   used   *note 3.2.1(4/2): 1387, *note P: 9039.
descendant   *note 10.1.1(11): 4358, *note N(13.1/2): 8899.
   at run-time   *note 3.9(12.3/3): 2115.
   of a tree node   *note A.18.10(4/3): 7199.
   of a type   *note 3.4.1(10/2): 1576.
   of the full view of a type   *note 7.3.1(5.1/3): 3624.
   relationship with scope   *note 8.2(4): 3722.
Descendant_Tag
   in Ada.Tags   *note 3.9(7.1/2): 2108.
designate   *note 3.10(1): 2224.
designated profile
   of an access-to-subprogram type   *note 3.10(11): 2261.
   of an anonymous access type   *note 3.10(12/3): 2266.
designated subtype
   of a named access type   *note 3.10(10): 2256.
   of an anonymous access type   *note 3.10(12/3): 2264.
designated type
   of a named access type   *note 3.10(10): 2257.
   of an anonymous access type   *note 3.10(12/3): 2265.
designator   *note 6.1(5): 3294.
   used   *note 6.3(2/3): 3408, *note P: 9450.
destructor
   See finalization   *note 7.6(1): 3656.
   See finalization   *note 7.6.1(1): 3686.
Detach_Handler
   in Ada.Interrupts   *note C.3.2(9): 7667.
Detect_Blocking pragma   *note H.5(3/2): 8485, *note L(8.4/2): 8735.
Determinant
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(46/2): 8418.
   in Ada.Numerics.Generic_Real_Arrays   *note G.3.1(24/2): 8378.
determined category for a formal type   *note 12.5(6/3): 4798.
determines
   a type by a subtype_mark   *note 3.2.2(8): 1420.
Device_Error
   in Ada.Direct_IO   *note A.8.4(18): 6351.
   in Ada.Directories   *note A.16(43/2): 6674.
   in Ada.IO_Exceptions   *note A.13(4): 6618.
   in Ada.Sequential_IO   *note A.8.1(15): 6319.
   in Ada.Streams.Stream_IO   *note A.12.1(26): 6599.
   in Ada.Text_IO   *note A.10.1(85): 6524.
Diaeresis
   in Ada.Characters.Latin_1   *note A.3.3(21/3): 5639.
Difference
   in Ada.Calendar.Arithmetic   *note 9.6.1(12/2): 4176.
   in Ada.Containers.Hashed_Sets   *note A.18.8(32/2): 7072, *note
A.18.8(33/2): 7073.
   in Ada.Containers.Ordered_Sets   *note A.18.9(33/2): 7145, *note
A.18.9(34/2): 7146.
digit   *note 2.4.1(4.1/2): 1222.
   used   *note 2.4.1(3): 1218, *note 2.4.2(5): 1245, *note P: 8993.
digits
   of a decimal fixed point subtype   *note 3.5.9(6): 1844, *note
3.5.10(7): 1878.
Digits attribute   *note 3.5.8(2/1): 1823, *note 3.5.10(7): 1877.
digits_constraint   *note 3.5.9(5/4): 1839.
   used   *note 3.2.2(6): 1415, *note P: 9051.
dimensionality
   of an array   *note 3.6(12): 1910.
direct access   *note A.8(3): 6294.
direct file   *note A.8(1/2): 6291.
Direct_IO
   child of Ada   *note A.8.4(2): 6323.
direct_name   *note 4.1(3): 2372.
   used   *note 3.8.1(2): 2059, *note 4.1(2/3): 2360, *note 5.1(8):
3146, *note 9.5.2(3): 4045, *note 10.2.1(4.2/2): 4469, *note 13.1(3):
4878, *note J.7(1): 8506, *note L(25.2/2): 8811, *note P: 9803.
Direction
   in Ada.Strings   *note A.4.1(6): 5781.
directly specified
   of a representation aspect of an entity   *note 13.1(8/3): 4888.
   of an operational aspect of an entity   *note 13.1(8.1/3): 4894.
directly visible   *note 8.3(2): 3736, *note 8.3(21): 3759.
   within a pragma in a context_clause   *note 10.1.6(3): 4434.
   within a pragma that appears at the place of a compilation unit  
*note 10.1.6(5): 4438.
   within a use_clause in a context_clause   *note 10.1.6(3): 4432.
   within a with_clause   *note 10.1.6(2/2): 4430.
   within the parent_unit_name of a library unit   *note 10.1.6(2/2):
4428.
   within the parent_unit_name of a subunit   *note 10.1.6(4): 4436.
Directories
   child of Ada   *note A.16(3/2): 6635.
directory   *note A.16(45/2): 6675.
directory entry   *note A.16(49/2): 6683.
directory name   *note A.16(46/2): 6678.
Directory_Entry_Type
   in Ada.Directories   *note A.16(29/2): 6659.
disabled
   predicate checks   *note 3.2.4(7/3): 1442.
Discard_Names aspect   *note C.5(1.3/4): 7680.
Discard_Names pragma   *note C.5(3): 7682, *note L(9): 8737.
discontiguous representation
   [partial]   *note 13.5.2(5): 5087, *note 13.7.1(12): 5142, *note
13.9(9): 5161, *note 13.9(17/3): 5164, *note 13.11(21.6/3): 5218.
discrete array type   *note 4.5.2(1): 2789.
discrete type   *note 3.2(3): 1340, *note 3.5(1): 1582, *note N(14):
8900.
discrete_choice   *note 3.8.1(5/3): 2068.
   used   *note 3.8.1(4): 2067, *note P: 9156.
discrete_choice_list   *note 3.8.1(4): 2065.
   used   *note 3.8.1(3): 2063, *note 4.3.3(5/2): 2558, *note
4.5.7(6/3): 2894, *note 5.4(3): 3181, *note P: 9263.
Discrete_Random
   child of Ada.Numerics   *note A.5.2(17): 6160.
discrete_range   *note 3.6.1(3): 1935.
   used   *note 3.6.1(2): 1934, *note 4.1.2(2): 2409, *note P: 9119.
discrete_subtype_definition   *note 3.6(6): 1900.
   used   *note 3.6(5): 1898, *note 5.5(4): 3201, *note 9.5.2(2/3):
4041, *note 9.5.2(8): 4066, *note P: 9112.
discriminant   *note 3.2(5/2): 1346, *note 3.7(1/2): 1964, *note
N(15/2): 8901.
   of a variant_part   *note 3.8.1(6): 2072.
   use in a record definition   *note 3.8(12/3): 2043.
discriminant_association   *note 3.7.1(3): 2004.
   used   *note 3.7.1(2): 2002, *note P: 9135.
Discriminant_Check   *note 11.5(12): 4630.
   [partial]   *note 4.1.3(15): 2429, *note 4.3(6): 2502, *note
4.3.2(8/3): 2539, *note 4.6(43): 2988, *note 4.6(45): 2990, *note
4.6(51/4): 3000, *note 4.6(52): 3013, *note 4.7(4/4): 3034, *note
4.8(10/2): 3065, *note 6.5(5.11/3): 3520.
discriminant_constraint   *note 3.7.1(2): 2001.
   used   *note 3.2.2(7): 1419, *note P: 9054.
discriminant_part   *note 3.7(2/2): 1967.
   used   *note 3.10.1(2/2): 2277, *note 7.3(2/3): 3602, *note 7.3(3/3):
3606, *note 12.5(2.1/3): 4772, *note 12.5(2.2/3): 4777, *note P: 9759.
discriminant_specification   *note 3.7(5/2): 1974.
   used   *note 3.7(4): 1973, *note P: 9125.
discriminants
   known   *note 3.7(26): 1993.
   unknown   *note 3.7(26): 1997.
discriminated type   *note 3.7(8/2): 1985.
dispatching   *note 3.9(3): 2094.
   child of Ada   *note D.2.1(1.2/3): 7769.
dispatching call
   on a dispatching operation   *note 3.9.2(1/2): 2147.
dispatching domain   *note D.16.1(16/4): 8092.
dispatching operation   *note 3.9.2(1/2): 2146, *note 3.9.2(2/3): 2160.
   [partial]   *note 3.9(1): 2079.
dispatching point   *note D.2.1(4/2): 7775.
   [partial]   *note D.2.3(8/2): 7801, *note D.2.4(9/3): 7810.
dispatching policy for tasks
   [partial]   *note D.2.1(5/2): 7781.
dispatching, task   *note D.2.1(4/2): 7773.
Dispatching_Domain
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(5/3):
8079.
Dispatching_Domain aspect   *note D.16.1(18/3): 8094.
Dispatching_Domain pragma   *note J.15.10(2/3): 8632, *note L(9.1/3):
8740.
Dispatching_Domain_Error
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(4/3):
8078.
Dispatching_Domains
   child of System.Multiprocessors   *note D.16.1(3/3): 8077.
Dispatching_Policy_Error
   in Ada.Dispatching   *note D.2.1(1.4/3): 7771.
Display_Format
   in Interfaces.COBOL   *note B.4(22): 7563.
displayed magnitude (of a decimal value)   *note F.3.2(14): 8233.
disruption of an assignment   *note 9.8(21): 4295, *note 13.9.1(5):
5168.
   [partial]   *note 11.6(6/3): 4661.
distinct access paths   *note 6.2(12/3): 3397.
distributed accessibility   *note 3.10.2(33.1/3): 2321.
distributed program   *note E(3): 8098.
distributed system   *note E(2): 8097.
distributed systems   *note C(1): 7621.
divide   *note 2.1(15/3): 1168.
   in Ada.Decimal   *note F.2(6/3): 8229.
divide operator   *note 4.4(1/3): 2640, *note 4.5.5(1): 2848.
Division_Check   *note 11.5(13/2): 4631.
   [partial]   *note 3.5.4(20): 1757, *note 4.5.5(22): 2855, *note
A.5.1(28): 6140, *note A.5.3(47): 6234, *note G.1.1(40): 8280, *note
G.1.2(28): 8307, *note K.2(202): 8678.
Division_Sign
   in Ada.Characters.Latin_1   *note A.3.3(26): 5720.
DLE
   in Ada.Characters.Latin_1   *note A.3.3(6): 5516.
Do_APC
   in System.RPC   *note E.5(10): 8211.
Do_RPC
   in System.RPC   *note E.5(9): 8210.
documentation (required of an implementation)   *note 1.1.3(18): 1058,
*note M.1(1/2): 8872, *note M.2(1/2): 8874, *note M.3(1/2): 8877.
documentation requirements   *note 1.1.2(34): 1044, *note M(1/3): 8870.
   summary of requirements   *note M.1(1/2): 8871.
Dollar_Sign
   in Ada.Characters.Latin_1   *note A.3.3(8): 5536.
dot   *note 2.1(15/3): 1165.
dot selection
   See selected_component   *note 4.1.3(1): 2417.
double
   in Interfaces.C   *note B.3(16): 7449.
Double_Precision
   in Interfaces.Fortran   *note B.5(6): 7602.
Doubly_Linked_Lists
   child of Ada.Containers   *note A.18.3(5/3): 6822.
downward closure   *note 3.10.2(38/2): 2325.
drift rate   *note D.8(41): 7968.
Duration
   in Standard   *note A.1(43): 5450.
dynamic binding
   See dispatching operation   *note 3.9(1): 2081.
dynamic semantics   *note 1.1.2(30): 1035.
Dynamic_Predicate aspect   *note 3.2.4(1/3): 1439.
Dynamic_Priorities
   child of Ada   *note D.5.1(3/2): 7865.
dynamically determined tag   *note 3.9.2(1/2): 2150.
dynamically enclosing
   of one execution by another   *note 11.4(2): 4556.
dynamically tagged   *note 3.9.2(5/2): 2168.



File: arm2012.info,  Node: E,  Next: F,  Prev: D,  Up: Index

E 
==



e
   in Ada.Numerics   *note A.5(3/2): 6109.
EDF
   child of Ada.Dispatching   *note D.2.6(9/2): 7821.
   child of Ada.Synchronous_Task_Control   *note D.10(5.2/3): 7979.
EDF_Across_Priorities task dispatching policy   *note D.2.6(7/2): 7820.
edited output   *note F.3(1/2): 8230.
Editing
   child of Ada.Text_IO   *note F.3.3(3): 8234.
   child of Ada.Wide_Text_IO   *note F.3.4(1): 8254.
   child of Ada.Wide_Wide_Text_IO   *note F.3.5(1/2): 8256.
effect
   external   *note 1.1.3(8): 1052.
efficiency   *note 11.5(29): 4647, *note 11.6(1/3): 4653.
Eigensystem
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(49/2): 8420.
   in Ada.Numerics.Generic_Real_Arrays   *note G.3.1(27/2): 8380.
Eigenvalues
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(48/2): 8419.
   in Ada.Numerics.Generic_Real_Arrays   *note G.3.1(26/2): 8379.
Elaborate pragma   *note 10.2.1(20): 4490, *note L(10): 8742.
Elaborate_All pragma   *note 10.2.1(21): 4494, *note L(11): 8746.
Elaborate_Body aspect   *note 10.2.1(26.1/3): 4505.
Elaborate_Body pragma   *note 10.2.1(22): 4498, *note L(12): 8750.
elaborated   *note 3.11(8): 2346.
elaboration   *note 3.1(11): 1324, *note N(15.1/2): 8902, *note N(19):
8910.
   abstract_subprogram_declaration   *note 3.9.3(11.1/2): 2194.
   access_definition   *note 3.10(17/2): 2274.
   access_type_definition   *note 3.10(16): 2273.
   array_type_definition   *note 3.6(21): 1925.
   aspect_clause   *note 13.1(19/1): 4907.
   choice_parameter_specification   *note 11.4(7): 4563.
   component_declaration   *note 3.8(17): 2051.
   component_definition   *note 3.6(22/2): 1927, *note 3.8(18/2): 2055.
   component_list   *note 3.8(17): 2050.
   declaration with a True Import aspect   *note B.1(38/3): 7413.
   declarative_part   *note 3.11(7): 2345.
   deferred constant declaration   *note 7.4(10/3): 3644.
   delta_constraint   *note J.3(11): 8502.
   derived_type_definition   *note 3.4(26): 1556.
   digits_constraint   *note 3.5.9(19/4): 1860.
   discrete_subtype_definition   *note 3.6(22/2): 1926.
   discriminant_constraint   *note 3.7.1(12): 2016.
   entry_declaration   *note 9.5.2(22/1): 4082.
   enumeration_type_definition   *note 3.5.1(10): 1698.
   exception_declaration   *note 11.1(5): 4523.
   expression_function_declaration   *note 6.8(8/3): 3565.
   fixed_point_definition   *note 3.5.9(17): 1858.
   floating_point_definition   *note 3.5.7(13): 1816.
   full type definition   *note 3.2.1(11): 1399.
   full_type_declaration   *note 3.2.1(11): 1398.
   generic body   *note 12.2(2): 4692.
   generic_declaration   *note 12.1(10): 4690.
   generic_instantiation   *note 12.3(20): 4736.
   incomplete_type_declaration   *note 3.10.1(12): 2284.
   index_constraint   *note 3.6.1(8): 1944.
   integer_type_definition   *note 3.5.4(18): 1753.
   loop_parameter_specification   *note 5.5(9/4): 3207.
   nongeneric package_body   *note 7.2(6): 3594.
   nongeneric subprogram_body   *note 6.3(6): 3410.
   null_procedure_declaration   *note 6.7(5/3): 3550.
   number_declaration   *note 3.3.2(7): 1528.
   object_declaration   *note 3.3.1(15): 1513.
   of library units for a foreign language main subprogram   *note
B.1(39/3): 7418.
   package_body of Standard   *note A.1(50): 5455.
   package_declaration   *note 7.1(8): 3585.
   partition   *note E.1(6): 8103.
   partition   *note E.5(21): 8214.
   per-object constraint   *note 3.8(18.1/1): 2056.
   pragma   *note 2.8(12): 1279.
   private_extension_declaration   *note 7.3(17): 3619.
   private_type_declaration   *note 7.3(17): 3618.
   protected declaration   *note 9.4(12): 4001.
   protected_body   *note 9.4(15): 4005.
   protected_definition   *note 9.4(13): 4003.
   range_constraint   *note 3.5(9): 1607.
   real_type_definition   *note 3.5.6(5): 1792.
   record_definition   *note 3.8(16): 2049.
   record_extension_part   *note 3.9.1(5): 2145.
   record_type_definition   *note 3.8(16): 2048.
   renaming_declaration   *note 8.5(3): 3795.
   single_protected_declaration   *note 9.4(12): 4002.
   single_task_declaration   *note 9.1(10): 3928.
   subprogram_declaration   *note 6.1(31/2): 3344.
   subtype_declaration   *note 3.2.2(9): 1421.
   subtype_indication   *note 3.2.2(9): 1422.
   task declaration   *note 9.1(10): 3927.
   task_body   *note 9.1(13): 3931.
   task_definition   *note 9.1(11): 3929.
   use_clause   *note 8.4(12): 3788.
   variant_part   *note 3.8.1(22): 2078.
elaboration control   *note 10.2.1(1): 4461.
elaboration dependence
   library_item on another   *note 10.2(9): 4452.
Elaboration_Check   *note 11.5(20): 4640.
   [partial]   *note 3.11(9): 2347.
element
   of a storage pool   *note 13.11(11): 5196.
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(14/2): 6832.
   in Ada.Containers.Hashed_Maps   *note A.18.5(14/2): 6921, *note
A.18.5(31/2): 6945.
   in Ada.Containers.Hashed_Sets   *note A.18.8(15/2): 7054, *note
A.18.8(52/2): 7089.
   in Ada.Containers.Indefinite_Holders   *note A.18.18(12/3): 7290.
   in Ada.Containers.Multiway_Trees   *note A.18.10(24/3): 7217.
   in Ada.Containers.Ordered_Maps   *note A.18.6(13/2): 6972, *note
A.18.6(39/2): 7005.
   in Ada.Containers.Ordered_Sets   *note A.18.9(14/2): 7125, *note
A.18.9(65/2): 7168.
   in Ada.Containers.Vectors   *note A.18.2(27/2): 6743, *note
A.18.2(28/2): 6744.
   in Ada.Strings.Bounded   *note A.4.4(26): 5861.
   in Ada.Strings.Unbounded   *note A.4.5(20): 5915.
elementary type   *note 3.2(2/2): 1335, *note N(16): 8903.
Elementary_Functions
   child of Ada.Numerics   *note A.5.1(9/1): 6139.
eligible
   a type, for a convention   *note B.1(14/3): 7407.
else part
   of a selective_accept   *note 9.7.1(11): 4234.
EM
   in Ada.Characters.Latin_1   *note A.3.3(6): 5525.
embedded systems   *note C(1): 7620, *note D(1): 7756.
empty element
   of a vector   *note A.18.2(4/2): 6723.
empty holder   *note A.18.18(3/3): 7283.
Empty_Holder
   in Ada.Containers.Indefinite_Holders   *note A.18.18(7/3): 7286.
Empty_List
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(8/2): 6825.
Empty_Map
   in Ada.Containers.Hashed_Maps   *note A.18.5(5/2): 6911.
   in Ada.Containers.Ordered_Maps   *note A.18.6(6/2): 6964.
Empty_Set
   in Ada.Containers.Hashed_Sets   *note A.18.8(5/2): 7043.
   in Ada.Containers.Ordered_Sets   *note A.18.9(6/2): 7116.
Empty_Tree
   in Ada.Containers.Multiway_Trees   *note A.18.10(10/3): 7204.
Empty_Vector
   in Ada.Containers.Vectors   *note A.18.2(10/2): 6729.
enabled
   invariant expression   *note 7.3.2(21/4): 3638.
   postcondition expression   *note 6.1.1(19/3): 3368.
   precondition expression   *note 6.1.1(19/3): 3367.
   predicate checks   *note 3.2.4(7/3): 1441.
encapsulation
   See package   *note 7(1): 3568.
enclosing
   immediately   *note 8.1(13): 3718.
Encode
   in Ada.Strings.UTF_Encoding.Strings   *note A.4.11(23/3): 6082, *note
A.4.11(24/3): 6083, *note A.4.11(25/3): 6084.
   in Ada.Strings.UTF_Encoding.Wide_Strings   *note A.4.11(31/3): 6089,
*note A.4.11(32/3): 6090, *note A.4.11(33/3): 6091.
   in Ada.Strings.UTF_Encoding.Wide_Wide_Strings   *note A.4.11(39/3):
6096, *note A.4.11(40/3): 6097, *note A.4.11(41/3): 6098.
Encoding
   in Ada.Strings.UTF_Encoding   *note A.4.11(13/3): 6074.
encoding scheme   *note A.4.11(46/3): 6102.
Encoding_Error
   in Ada.Strings.UTF_Encoding   *note A.4.11(8/3): 6069.
Encoding_Scheme
   in Ada.Strings.UTF_Encoding   *note A.4.11(4/3): 6065.
end of a line   *note 2.2(2/3): 1183.
End_Error
   raised by failure of run-time check   *note 13.13.2(37/1): 5369.
   in Ada.Direct_IO   *note A.8.4(18): 6352.
   in Ada.IO_Exceptions   *note A.13(4): 6619.
   in Ada.Sequential_IO   *note A.8.1(15): 6320.
   in Ada.Streams.Stream_IO   *note A.12.1(26): 6600.
   in Ada.Text_IO   *note A.10.1(85): 6525.
End_Of_File
   in Ada.Direct_IO   *note A.8.4(16): 6346.
   in Ada.Sequential_IO   *note A.8.1(13): 6314.
   in Ada.Streams.Stream_IO   *note A.12.1(12): 6584.
   in Ada.Text_IO   *note A.10.1(34): 6431.
End_Of_Line
   in Ada.Text_IO   *note A.10.1(30): 6423.
End_Of_Page
   in Ada.Text_IO   *note A.10.1(33): 6429.
End_Search
   in Ada.Directories   *note A.16(33/2): 6663.
endian
   big   *note 13.5.3(2): 5091.
   little   *note 13.5.3(2): 5094.
ENQ
   in Ada.Characters.Latin_1   *note A.3.3(5): 5505.
Enqueue
   in Ada.Containers.Bounded_Priority_Queues   *note A.18.31(5/3): 7364.
   in Ada.Containers.Bounded_Synchronized_Queues   *note A.18.29(5/3):
7351.
   in Ada.Containers.Synchronized_Queue_Interfaces   *note A.18.27(5/3):
7338.
   in Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(5/3):
7357.
   in Ada.Containers.Unbounded_Synchronized_Queues   *note A.18.28(5/3):
7345.
entity
   [partial]   *note 3.1(1): 1290.
entity with runtime name text   *note C.5(1.1/4): 7677.
entry
   closed   *note 9.5.3(5): 4098.
   open   *note 9.5.3(5): 4096.
   single   *note 9.5.2(20): 4080.
entry call   *note 9.5.3(1): 4089.
   simple   *note 9.5.3(1): 4091.
entry calling convention   *note 6.3.1(13/4): 3425.
entry family   *note 9.5.2(20): 4077.
entry index subtype   *note 3.8(18/2): 2054, *note 9.5.2(20): 4078.
entry queue   *note 9.5.3(12): 4107.
entry queuing policy   *note 9.5.3(17): 4111.
   default policy   *note 9.5.3(17): 4113.
entry_barrier   *note 9.5.2(7): 4062.
   used   *note 9.5.2(5): 4055, *note P: 9601.
entry_body   *note 9.5.2(5): 4052.
   used   *note 9.4(8/4): 3987, *note P: 9586.
entry_body_formal_part   *note 9.5.2(6): 4059.
   used   *note 9.5.2(5): 4054, *note P: 9600.
entry_call_alternative   *note 9.7.2(3/2): 4244.
   used   *note 9.7.2(2): 4242, *note 9.7.3(2): 4252, *note P: 9640.
entry_call_statement   *note 9.5.3(2): 4092.
   used   *note 5.1(4/2): 3128, *note 9.7.2(3.1/2): 4249, *note P: 9363.
entry_declaration   *note 9.5.2(2/3): 4038.
   used   *note 9.1(5/1): 3909, *note 9.4(5/1): 3972, *note P: 9574.
entry_index   *note 9.5.2(4): 4050.
   used   *note 9.5.2(3): 4046, *note P: 9594.
entry_index_specification   *note 9.5.2(8): 4064.
   used   *note 9.5.2(6): 4060, *note P: 9605.
enumeration literal   *note 3.5.1(6/3): 1695.
enumeration type   *note 3.2(3): 1341, *note 3.5.1(1): 1686, *note
N(17): 8904.
enumeration_aggregate   *note 13.4(3): 5041.
   used   *note 13.4(2): 5040, *note P: 9822.
Enumeration_IO
   in Ada.Text_IO   *note A.10.1(79): 6511.
enumeration_literal_specification   *note 3.5.1(3): 1690.
   used   *note 3.5.1(2): 1688, *note P: 9080.
enumeration_representation_clause   *note 13.4(2): 5038.
   used   *note 13.1(2/1): 4874, *note P: 9800.
enumeration_type_definition   *note 3.5.1(2): 1687.
   used   *note 3.2.1(4/2): 1381, *note P: 9033.
environment   *note 10.1.4(1): 4413.
environment declarative_part   *note 10.1.4(1): 4414.
   for the environment task of a partition   *note 10.2(13): 4454.
environment task   *note 10.2(8): 4451.
environment variable   *note A.17(1/2): 6698.
Environment_Task
   in Ada.Task_Identification   *note C.7.1(3/3): 7713.
Environment_Variables
   child of Ada   *note A.17(3/2): 6699.
EOT
   in Ada.Characters.Latin_1   *note A.3.3(5): 5504.
EPA
   in Ada.Characters.Latin_1   *note A.3.3(18): 5621.
epoch   *note D.8(19): 7964.
equal operator   *note 4.4(1/3): 2593, *note 4.5.2(1): 2767.
Equal_Case_Insensitive
   child of Ada.Strings   *note A.4.10(2/3): 6056.
   child of Ada.Strings.Bounded   *note A.4.10(7/3): 6058.
   child of Ada.Strings.Fixed   *note A.4.10(5/3): 6057.
   child of Ada.Strings.Unbounded   *note A.4.10(10/3): 6059.
Equal_Subtree
   in Ada.Containers.Multiway_Trees   *note A.18.10(14/3): 7208.
equality operator   *note 4.5.2(1): 2761.
   special inheritance rule for tagged types   *note 3.4(17/2): 1551,
*note 4.5.2(14/3): 2797.
equals sign   *note 2.1(15/3): 1172.
Equals_Sign
   in Ada.Characters.Latin_1   *note A.3.3(10): 5552.
equivalent element
   of a hashed set   *note A.18.8(64/2): 7101.
   of an ordered set   *note A.18.9(78/2): 7181.
equivalent key
   of a hashed map   *note A.18.5(42/2): 6952.
   of an ordered map   *note A.18.6(55/2): 7011.
Equivalent_Elements
   in Ada.Containers.Hashed_Sets   *note A.18.8(46/2): 7083, *note
A.18.8(47/2): 7084, *note A.18.8(48/2): 7085.
   in Ada.Containers.Ordered_Sets   *note A.18.9(3/2): 7113.
Equivalent_Keys
   in Ada.Containers.Hashed_Maps   *note A.18.5(34/2): 6947, *note
A.18.5(35/2): 6948, *note A.18.5(36/2): 6949.
   in Ada.Containers.Ordered_Maps   *note A.18.6(3/2): 6961.
   in Ada.Containers.Ordered_Sets   *note A.18.9(63/2): 7166.
Equivalent_Sets
   in Ada.Containers.Hashed_Sets   *note A.18.8(8/2): 7047.
   in Ada.Containers.Ordered_Sets   *note A.18.9(9/2): 7120.
erroneous execution   *note 1.1.2(32): 1041, *note 1.1.5(10): 1080.
   cause   *note 3.7.2(4): 2020, *note 3.9(25.3/2): 2132, *note
6.4.1(18/3): 3495, *note 9.8(21): 4296, *note 9.10(11): 4309, *note
11.5(26): 4644, *note 13.3(13/3): 4984, *note 13.3(27): 4996, *note
13.3(28/2): 4997, *note 13.9.1(8): 5170, *note 13.9.1(12/3): 5175, *note
13.9.1(13/3): 5176, *note 13.11(21): 5215, *note 13.11.2(16/3): 5245,
*note 13.11.4(31.1/4): 5286, *note 13.13.2(53/2): 5398, *note
A.10.3(22/1): 6529, *note A.12.1(36.1/1): 6603, *note A.13(17): 6622,
*note A.17(28/2): 6708, *note A.18.2(252/2): 6817, *note A.18.3(157/2):
6887, *note A.18.4(80/2): 6907, *note A.18.7(101/2): 7039, *note
A.18.18(70/3): 7308, *note A.18.19(11/3): 7310, *note A.18.20(15/3):
7313, *note A.18.21(16/3): 7317, *note A.18.22(13/3): 7320, *note
A.18.23(16/3): 7324, *note A.18.24(13/3): 7327, *note A.18.25(15/3):
7329, *note B.1(38.1/3): 7415, *note B.3.1(51): 7514, *note B.3.1(55):
7515, *note B.3.1(56): 7516, *note B.3.1(57): 7517, *note B.3.2(35):
7528, *note B.3.2(36): 7529, *note B.3.2(37): 7530, *note B.3.2(38):
7531, *note B.3.2(39): 7532, *note B.3.2(42): 7533, *note C.3.1(14):
7656, *note C.3.1(14.1/3): 7657, *note C.7.1(18): 7727, *note C.7.2(14):
7737, *note C.7.2(15): 7738, *note C.7.2(15.1/2): 7739, *note
D.2.6(31/2): 7830, *note D.5.1(12): 7870, *note D.11(9): 7997, *note
D.14(19/2): 8014, *note D.14.1(25/2): 8029, *note D.14.2(35/2): 8054,
*note H.4(26): 8482, *note H.4(27): 8483.
error
   compile-time   *note 1.1.2(27): 1024, *note 1.1.5(4): 1073.
   link-time   *note 1.1.2(29): 1032, *note 1.1.5(4): 1075.
   run-time   *note 1.1.2(30): 1038, *note 1.1.5(6): 1077, *note
11.5(2/3): 4615, *note 11.6(1/3): 4651.
   See also bounded error, erroneous execution
ESA
   in Ada.Characters.Latin_1   *note A.3.3(17): 5605.
ESC
   in Ada.Characters.Latin_1   *note A.3.3(6): 5527.
Establish_RPC_Receiver
   in System.RPC   *note E.5(12): 8213.
ETB
   in Ada.Characters.Latin_1   *note A.3.3(6): 5523.
ETX
   in Ada.Characters.Latin_1   *note A.3.3(5): 5503.
evaluation   *note 3.1(11): 1325, *note N(17.1/2): 8905, *note N(19):
8911.
   aggregate   *note 4.3(5): 2499.
   allocator   *note 4.8(7/2): 3057.
   array_aggregate   *note 4.3.3(21): 2569.
   attribute_reference   *note 4.1.4(11): 2447.
   case_expression   *note 4.5.7(21/3): 2905.
   concatenation   *note 4.5.3(5): 2822.
   dereference   *note 4.1(13): 2389.
   discrete_range   *note 3.6.1(8): 1945.
   extension_aggregate   *note 4.3.2(7): 2537.
   generalized_reference   *note 4.1.5(8/3): 2458.
   generic_association   *note 12.3(21): 4738.
   generic_association for a formal object of mode in   *note 12.4(11):
4764.
   if_expression   *note 4.5.7(20/3): 2901.
   indexed_component   *note 4.1.1(7): 2400.
   initialized allocator   *note 4.8(7/2): 3058.
   membership test   *note 4.5.2(27/4): 2802.
   name   *note 4.1(11/2): 2386.
   name that has a prefix   *note 4.1(12): 2387.
   null literal   *note 4.2(9): 2485.
   numeric literal   *note 4.2(9): 2484.
   parameter_association   *note 6.4.1(7): 3481.
   prefix   *note 4.1(12): 2388.
   primary that is a name   *note 4.4(10): 2718.
   qualified_expression   *note 4.7(4/4): 3031.
   quantified_expression   *note 4.5.8(6/4): 2918.
   range   *note 3.5(9): 1608.
   range_attribute_reference   *note 4.1.4(11): 2448.
   record_aggregate   *note 4.3.1(18): 2523.
   record_component_association_list   *note 4.3.1(19): 2524.
   selected_component   *note 4.1.3(14): 2428.
   short-circuit control form   *note 4.5.1(7): 2752.
   slice   *note 4.1.2(7): 2411.
   string_literal   *note 4.2(10): 2488.
   uninitialized allocator   *note 4.8(8): 3061.
   Val   *note 3.5.5(7): 1774, *note K.2(261): 8689.
   Value   *note 3.5(55/3): 1673.
   value conversion   *note 4.6(28): 2964.
   view conversion   *note 4.6(52): 3008.
   Wide_Value   *note 3.5(43/3): 1667.
   Wide_Wide_Value   *note 3.5(39.4/3): 1655.
Exception   *note 11(1/3): 4511, *note 11.1(1): 4514, *note N(18): 8906.
exception occurrence   *note 11(1/3): 4506.
exception_choice   *note 11.2(5): 4539.
   used   *note 11.2(3): 4534, *note P: 9699.
exception_declaration   *note 11.1(2/3): 4515.
   used   *note 3.1(3/3): 1303, *note P: 9019.
exception_handler   *note 11.2(3): 4532.
   used   *note 11.2(2): 4531, *note P: 9696.
Exception_Id
   in Ada.Exceptions   *note 11.4.1(2/2): 4565.
Exception_Identity
   in Ada.Exceptions   *note 11.4.1(5/2): 4576.
Exception_Information
   in Ada.Exceptions   *note 11.4.1(5/2): 4580.
Exception_Message
   in Ada.Exceptions   *note 11.4.1(4/3): 4574.
Exception_Name
   in Ada.Exceptions   *note 11.4.1(2/2): 4567, *note 11.4.1(5/2): 4577.
Exception_Occurrence
   in Ada.Exceptions   *note 11.4.1(3/2): 4570.
Exception_Occurrence_Access
   in Ada.Exceptions   *note 11.4.1(3/2): 4571.
exception_renaming_declaration   *note 8.5.2(2/3): 3812.
   used   *note 8.5(2): 3791, *note P: 9510.
Exceptions
   child of Ada   *note 11.4.1(2/2): 4564.
Exchange_Handler
   in Ada.Interrupts   *note C.3.2(8): 7666.
Exclamation
   in Ada.Characters.Latin_1   *note A.3.3(8): 5533.
exclamation point   *note 2.1(15/3): 1177.
Exclude
   in Ada.Containers.Hashed_Maps   *note A.18.5(24/2): 6938.
   in Ada.Containers.Hashed_Sets   *note A.18.8(23/2): 7065, *note
A.18.8(54/2): 7091.
   in Ada.Containers.Ordered_Maps   *note A.18.6(23/2): 6989.
   in Ada.Containers.Ordered_Sets   *note A.18.9(22/2): 7136, *note
A.18.9(67/2): 7170.
excludes null
   subtype   *note 3.10(13.1/2): 2268.
exclusive
   protected operation   *note 9.5.1(2.4/4): 4027.
Exclusive_Functions aspect   *note 9.5.1(2.2/4): 4026.
execution   *note 3.1(11): 1323, *note N(19): 8909.
   abort_statement   *note 9.8(4): 4281.
   aborting the execution of a construct   *note 9.8(5): 4286.
   accept_statement   *note 9.5.2(24): 4083.
   Ada program   *note 9(1/3): 3874.
   assignment_statement   *note 5.2(7): 3159, *note 7.6(17): 3679, *note
7.6.1(12/2): 3705.
   asynchronous_select with a delay_statement trigger   *note 9.7.4(7):
4268.
   asynchronous_select with a procedure call trigger   *note 9.7.4(6/2):
4267.
   asynchronous_select with an entry call trigger   *note 9.7.4(6/2):
4266.
   block_statement   *note 5.6(5): 3265.
   call on a dispatching operation   *note 3.9.2(14): 2172.
   call on an inherited subprogram   *note 3.4(27/2): 1557.
   case_statement   *note 5.4(11/3): 3186.
   conditional_entry_call   *note 9.7.3(3): 4254.
   delay_statement   *note 9.6(20): 4159.
   dynamically enclosing   *note 11.4(2): 4557.
   entry_body   *note 9.5.2(26): 4088.
   entry_call_statement   *note 9.5.3(8): 4104.
   exit_statement   *note 5.7(5): 3270.
   extended_return_statement   *note 6.5(5.11/3): 3515.
   goto_statement   *note 5.8(5): 3274.
   handled_sequence_of_statements   *note 11.2(10): 4543.
   handler   *note 11.4(7): 4562.
   if_statement   *note 5.3(5/3): 3175.
   instance of Unchecked_Deallocation   *note 7.6.1(10): 3699.
   loop_statement   *note 5.5(7): 3204.
   loop_statement with a for iteration_scheme   *note 5.5(9/4): 3206.
   loop_statement with a while iteration_scheme   *note 5.5(8): 3205.
   null_statement   *note 5.1(13): 3147.
   partition   *note 10.2(25): 4456.
   pragma   *note 2.8(12): 1278.
   program   *note 10.2(25): 4455.
   protected subprogram call   *note 9.5.1(3): 4028.
   raise_statement with an exception_name   *note 11.3(4/4): 4552.
   re-raise statement   *note 11.3(4/4): 4553.
   remote subprogram call   *note E.4(9): 8185.
   requeue protected entry   *note 9.5.4(9): 4128.
   requeue task entry   *note 9.5.4(8): 4127.
   requeue_statement   *note 9.5.4(7/4): 4126.
   selective_accept   *note 9.7.1(15): 4236.
   sequence_of_statements   *note 5.1(15): 3149.
   simple_return_statement   *note 6.5(6/2): 3522.
   subprogram call   *note 6.4(10/2): 3465.
   subprogram_body   *note 6.3(7): 3411.
   task   *note 9.2(1): 3932.
   task_body   *note 9.2(1): 3933.
   timed_entry_call   *note 9.7.2(4/2): 4250.
execution resource
   associated with a protected object   *note 9.4(18): 4006.
   required for a task to run   *note 9(10): 3891.
execution time
   of a task   *note D.14(11/3): 8011.
Execution_Time
   child of Ada   *note D.14(3/2): 7999.
exhaust
   a budget   *note D.14.2(14/2): 8050.
exist
   cease to   *note 7.6.1(11/3): 3700, *note 13.11.2(10/4): 5232, *note
13.11.5(7.1/4): 5289.
Exists
   in Ada.Directories   *note A.16(24/2): 6655.
   in Ada.Environment_Variables   *note A.17(5/2): 6702.
exit_statement   *note 5.7(2): 3266.
   used   *note 5.1(4/2): 3124, *note P: 9359.
Exit_Status
   in Ada.Command_Line   *note A.15(7): 6630.
Exp
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(3): 8288.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(4): 6114.
expanded name   *note 4.1.3(4): 2425.
Expanded_Name
   in Ada.Tags   *note 3.9(7/2): 2103.
expected profile   *note 8.6(26): 3864.
   accept_statement entry_direct_name   *note 9.5.2(11): 4067.
   Access attribute_reference prefix   *note 3.10.2(2.3/2): 2287.
   attribute_definition_clause name   *note 13.3(4): 4953.
   character_literal   *note 4.2(3): 2479.
   formal subprogram actual   *note 12.6(6): 4844.
   formal subprogram default_name   *note 12.6(5): 4843.
   name in an aspect_specification   *note 13.1.1(8/3): 4926.
   subprogram_renaming_declaration   *note 8.5.4(3): 3827.
expected type   *note 8.6(20/2): 3859.
   abort_statement task_name   *note 9.8(3): 4280.
   access attribute_reference   *note 3.10.2(2/2): 2286.
   Access attribute_reference prefix   *note 3.10.2(2.3/2): 2288.
   actual parameter   *note 6.4.1(3): 3476.
   aggregate   *note 4.3(3/2): 2498.
   allocator   *note 4.8(3/3): 3050.
   array_aggregate   *note 4.3.3(7/2): 2564.
   array_aggregate component expression   *note 4.3.3(7/2): 2565.
   array_aggregate discrete_choice   *note 4.3.3(8): 2566.
   assignment_statement expression   *note 5.2(4/2): 3158.
   assignment_statement variable_name   *note 5.2(4/2): 3157.
   Attach_Handler pragma second argument   *note J.15.7(6/3): 8595.
   attribute_definition_clause expression or name   *note 13.3(4): 4952.
   attribute_designator expression   *note 4.1.4(7): 2445.
   case_expression selecting_expression   *note 4.5.7(15/3): 2898.
   case_expression_alternative discrete_choice   *note 4.5.7(15/3):
2899.
   case_statement selecting_expression   *note 5.4(4/3): 3183.
   case_statement_alternative discrete_choice   *note 5.4(4/3): 3185.
   character_literal   *note 4.2(3): 2478.
   code_statement   *note 13.8(4): 5151.
   component_clause expressions   *note 13.5.1(7): 5074.
   component_declaration default_expression   *note 3.8(7): 2041.
   condition   *note 4.5.7(14/3): 2897.
   CPU pragma argument   *note J.15.9(3/3): 8630.
   decimal fixed point type digits   *note 3.5.9(6): 1843.
   delay_relative_statement expression   *note 9.6(5): 4140.
   delay_until_statement expression   *note 9.6(5): 4141.
   delta_constraint expression   *note J.3(3/4): 8498.
   dependent_expression   *note 4.5.7(8/3): 2896.
   dereference name   *note 4.1(8): 2383.
   discrete_subtype_definition range   *note 3.6(8): 1906.
   discriminant default_expression   *note 3.7(7): 1984.
   discriminant_association expression   *note 3.7.1(6): 2012.
   Dispatching_Domains pragma argument   *note J.15.10(3/3): 8633.
   entry_index   *note 9.5.2(11): 4068.
   enumeration_representation_clause expressions   *note 13.4(4): 5043.
   expression in an aspect_specification   *note 13.1.1(7/3): 4925.
   expression of a Default_Component_Value aspect   *note 3.6(22.4/3):
1931.
   expression of a Default_Value aspect   *note 3.5(56.5/3): 1685.
   expression of a predicate aspect   *note 3.2.4(2/3): 1440.
   expression of expression function   *note 6.8(3/4): 3560.
   expression of extended_return_statement   *note 6.5(3/2): 3511.
   expression of simple_return_statement   *note 6.5(3/2): 3510.
   extension_aggregate   *note 4.3.2(4/2): 2533.
   extension_aggregate ancestor expression   *note 4.3.2(4/2): 2534.
   external name   *note J.15.5(6/3): 8581.
   first_bit   *note 13.5.1(7): 5076.
   fixed point type delta   *note 3.5.9(6): 1842.
   generic formal in object actual   *note 12.4(4): 4754.
   generic formal object default_expression   *note 12.4(3): 4753.
   index_constraint discrete_range   *note 3.6.1(4): 1939.
   indexable_container_object_prefix   *note 4.1.6(11/3): 2471.
   indexed_component expression   *note 4.1.1(4): 2398.
   Interrupt_Priority pragma argument   *note J.15.11(5/3): 8639.
   invariant expression   *note 7.3.2(4/3): 3635.
   iterable_name   *note 5.5.2(3/3): 3244.
   iterator_name   *note 5.5.2(3/3): 3243.
   last_bit   *note 13.5.1(7): 5077.
   link name   *note J.15.5(6/3): 8580.
   linker options   *note B.1(10.1/3): 7402.
   membership test simple_expression   *note 4.5.2(3/3): 2793.
   modular_type_definition expression   *note 3.5.4(5): 1730.
   name in an aspect_specification   *note 13.1.1(7/3): 4924.
   number_declaration expression   *note 3.3.2(3): 1526.
   object in an aspect_specification   *note 13.1.1(6/3): 4923.
   object_declaration initialization expression   *note 3.3.1(4): 1497.
   parameter default_expression   *note 6.1(17): 3330.
   position   *note 13.5.1(7): 5075.
   postcondition expression   *note 6.1.1(6/3): 3362.
   precondition expression   *note 6.1.1(6/3): 3361.
   Priority pragma argument   *note J.15.11(5/3): 8638.
   quantified_expression   *note 4.5.8(5/3): 2916.
   range simple_expressions   *note 3.5(5): 1600.
   range_attribute_designator expression   *note 4.1.4(7): 2446.
   range_constraint range   *note 3.5(5): 1599.
   real_range_specification bounds   *note 3.5.7(5): 1803.
   record_aggregate   *note 4.3.1(8/2): 2519.
   record_component_association expression   *note 4.3.1(10): 2521.
   reference_object_name   *note 4.1.5(5/3): 2457.
   Relative_Deadline pragma argument   *note J.15.12(3/3): 8642.
   requested decimal precision   *note 3.5.7(4): 1802.
   restriction parameter expression   *note 13.12(5): 5301.
   selecting_expression case_expression   *note 4.5.7(15/3): 2900.
   selecting_expression case_statement   *note 5.4(4/3): 3184.
   short-circuit control form relation   *note 4.5.1(1): 2742.
   signed_integer_type_definition simple_expression   *note 3.5.4(5):
1729.
   slice discrete_range   *note 4.1.2(4): 2410.
   Storage_Size pragma argument   *note J.15.4(4/3): 8550.
   string_literal   *note 4.2(4): 2480.
   subpool_handle_name   *note 4.8(3/3): 3051.
   type_conversion operand   *note 4.6(6): 2939.
   variant_part discrete_choice   *note 3.8.1(6): 2073.
expiration time
   [partial]   *note 9.6(1): 4131.
   for a delay_relative_statement   *note 9.6(20): 4161.
   for a delay_until_statement   *note 9.6(20): 4160.
expires
   execution timer   *note D.14.1(15/3): 8028.
explicit declaration   *note 3.1(5): 1309, *note N(11): 8896.
explicit initial value   *note 3.3.1(1/3): 1474.
explicit_actual_parameter   *note 6.4(6): 3460.
   used   *note 6.4(5): 3459, *note P: 9460.
explicit_dereference   *note 4.1(5): 2378.
   used   *note 4.1(2/3): 2361, *note P: 9197.
explicit_generic_actual_parameter   *note 12.3(5): 4715.
   used   *note 12.3(4): 4714, *note P: 9738.
explicitly aliased parameter   *note 6.1(23.1/3): 3338.
explicitly assign   *note 10.2(2): 4446.
explicitly limited record   *note 3.8(13.1/3): 2044.
exponent   *note 2.4.1(4): 1219, *note 4.5.6(11/3): 2873.
   used   *note 2.4.1(2): 1214, *note 2.4.2(2): 1237, *note P: 8979.
Exponent attribute   *note A.5.3(18): 6205.
exponentiation operator   *note 4.4(1/3): 2648, *note 4.5.6(7): 2869.
Export aspect   *note B.1(1/3): 7387.
Export pragma   *note J.15.5(3/3): 8571, *note L(13.1/3): 8753.
exported entity   *note B.1(23/3): 7410.
expression   *note 4.4(1/3): 2582, *note 4.4(2): 2655.
   predicate-static   *note 3.2.4(15/3): 1445.
   used   *note 2.8(3/3): 1267, *note 3.3.1(2/3): 1486, *note 3.3.2(2):
1525, *note 3.5.4(4): 1728, *note 3.5.7(2): 1796, *note 3.5.9(3): 1833,
*note 3.5.9(4): 1837, *note 3.7(6): 1983, *note 3.7.1(3): 2007, *note
4.1.1(2): 2396, *note 4.1.4(3/2): 2439, *note 4.1.4(5): 2444, *note
4.3.1(4/2): 2512, *note 4.3.2(3): 2531, *note 4.3.3(3/2): 2548, *note
4.3.3(5/2): 2559, *note 4.4(7/3): 2715, *note 4.5.7(3/3): 2885, *note
4.5.7(4/3): 2888, *note 4.5.7(5/3): 2890, *note 4.5.7(6/3): 2895, *note
4.5.8(3/3): 2915, *note 4.6(2): 2927, *note 4.7(2): 3027, *note 5.2(2):
3152, *note 5.4(2/3): 3177, *note 6.4(6): 3461, *note 6.5(2.1/3): 3502,
*note 6.5(2/2): 3498, *note 6.8(2/4): 3554, *note 9.5.2(4): 4051, *note
9.6(3): 4137, *note 9.6(4): 4139, *note 11.3(2/2): 4546, *note
11.4.2(3/2): 4592, *note 12.3(5): 4716, *note 13.1.1(4/3): 4920, *note
13.3(2): 4948, *note 13.5.1(4): 5069, *note 13.12(4.1/2): 5300, *note
B.1(8): 7401, *note B.1(10.1/3): 7403, *note D.2.2(3.2/2): 7791, *note
J.7(1): 8507, *note J.8(1): 8517, *note J.15.4(2/3): 8549, *note
J.15.5(2/3): 8568, *note J.15.5(3/3): 8574, *note J.15.7(4/3): 8594,
*note J.15.9(2/3): 8629, *note L(2.1/2): 8701, *note L(6.1/3): 8723,
*note L(8.2/3): 8730, *note L(13.1/3): 8757, *note L(14.1/3): 8762,
*note L(19): 8785, *note L(27.2/2): 8820, *note L(35.1/3): 8851, *note
P: 9845.
expression function   *note 6.8(6/4): 3562.
expression_function_declaration   *note 6.8(2/4): 3551.
   used   *note 3.1(3/3): 1300, *note 9.4(8/4): 3986, *note P: 9016.
extended_digit   *note 2.4.2(5): 1244.
   used   *note 2.4.2(4): 1243, *note P: 8990.
Extended_Index subtype of Index_Type'Base
   in Ada.Containers.Vectors   *note A.18.2(7/2): 6725.
extended_return_object_declaration   *note 6.5(2.1/3): 3499.
   used   *note 6.5(2.2/3): 3504, *note P: 9467.
extended_return_statement   *note 6.5(2.2/3): 3503.
   used   *note 5.1(5/2): 3139, *note P: 9373.
extension
   of a private type   *note 3.9(2.1/2): 2092, *note 3.9.1(1/2): 2140.
   of a record type   *note 3.9(2.1/2): 2090, *note 3.9.1(1/2): 2138.
   of a type   *note 3.9(2/2): 2089, *note 3.9.1(1/2): 2136.
   in Ada.Directories   *note A.16(18/2): 6648.
extension_aggregate   *note 4.3.2(2): 2527.
   used   *note 4.3(2): 2496, *note P: 9235.
external call   *note 9.5(4/3): 4014.
external effect
   of the execution of an Ada program   *note 1.1.3(8): 1051.
   volatile/atomic objects   *note C.6(20): 7707.
external file   *note A.7(1): 6280.
external interaction   *note 1.1.3(8): 1053.
external name   *note B.1(34): 7411.
external requeue   *note 9.5(7): 4017.
external streaming
   type supports   *note 13.13.2(52/3): 5397.
External_Name aspect   *note B.1(1/3): 7391.
External_Tag
   in Ada.Tags   *note 3.9(7/2): 2106.
External_Tag aspect   *note 13.3(75/3): 5037, *note K.2(65): 8664.
External_Tag attribute   *note 13.3(75/3): 5033.
External_Tag clause   *note 13.3(7/2): 4963, *note 13.3(75/3): 5034,
*note K.2(65): 8661.
extra permission to avoid raising exceptions   *note 11.6(5): 4655.
extra permission to reorder actions   *note 11.6(6/3): 4657.



File: arm2012.info,  Node: F,  Next: G,  Prev: E,  Up: Index

F 
==



factor   *note 4.4(6): 2704.
   used   *note 4.4(5): 2701, *note P: 9302.
factory   *note 3.9(30/2): 2133.
failure
   of a language-defined check   *note 11.5(2/3): 4616.
   in Ada.Command_Line   *note A.15(8): 6632.
fall-back handler   *note C.7.3(9/2): 7749.
False   *note 3.5.3(1): 1714.
family
   entry   *note 9.5.2(20): 4076.
Feminine_Ordinal_Indicator
   in Ada.Characters.Latin_1   *note A.3.3(21/3): 5641.
FF
   in Ada.Characters.Latin_1   *note A.3.3(5): 5512.
Field subtype of Integer
   in Ada.Text_IO   *note A.10.1(6): 6380.
FIFO_Queuing queuing policy   *note D.4(7/2): 7861.
FIFO_Within_Priorities task dispatching policy   *note D.2.3(2/2): 7799.
file
   as file object   *note A.7(2/3): 6283.
file name   *note A.16(46/2): 6679.
file terminator   *note A.10(7): 6366.
File_Access
   in Ada.Text_IO   *note A.10.1(18): 6402.
File_Kind
   in Ada.Directories   *note A.16(22/2): 6653.
File_Mode
   in Ada.Direct_IO   *note A.8.4(4): 6325.
   in Ada.Sequential_IO   *note A.8.1(4): 6300.
   in Ada.Streams.Stream_IO   *note A.12.1(6): 6571.
   in Ada.Text_IO   *note A.10.1(4): 6376.
File_Size
   in Ada.Directories   *note A.16(23/2): 6654.
File_Type
   in Ada.Direct_IO   *note A.8.4(3): 6324.
   in Ada.Sequential_IO   *note A.8.1(3): 6299.
   in Ada.Streams.Stream_IO   *note A.12.1(5/4): 6570.
   in Ada.Text_IO   *note A.10.1(3): 6375.
Filter_Type
   in Ada.Directories   *note A.16(30/2): 6660.
finalization
   of a master   *note 7.6.1(4): 3696.
   of a protected object   *note 9.4(20): 4007.
   of a protected object   *note C.3.1(12/3): 7655.
   of a task object   *note J.7.1(8): 8514.
   of an object   *note 7.6.1(5): 3697.
   of environment task for a foreign language main subprogram   *note
B.1(39/3): 7419.
   child of Ada   *note 7.6(4/3): 3661.
Finalize   *note 7.6(2): 3659.
   in Ada.Finalization   *note 7.6(6/2): 3665, *note 7.6(8/2): 3668.
Find
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(41/2): 6864.
   in Ada.Containers.Hashed_Maps   *note A.18.5(30/2): 6944.
   in Ada.Containers.Hashed_Sets   *note A.18.8(43/2): 7081, *note
A.18.8(56/2): 7093.
   in Ada.Containers.Multiway_Trees   *note A.18.10(38/3): 7231.
   in Ada.Containers.Ordered_Maps   *note A.18.6(38/2): 7004.
   in Ada.Containers.Ordered_Sets   *note A.18.9(49/2): 7159, *note
A.18.9(69/2): 7172.
   in Ada.Containers.Vectors   *note A.18.2(68/2): 6791.
Find_In_Subtree
   in Ada.Containers.Multiway_Trees   *note A.18.10(39/3): 7232.
Find_Index
   in Ada.Containers.Vectors   *note A.18.2(67/2): 6790.
Find_Token
   in Ada.Strings.Bounded   *note A.4.4(50.1/3): 5877, *note A.4.4(51):
5878.
   in Ada.Strings.Fixed   *note A.4.3(15.1/3): 5820, *note A.4.3(16):
5821.
   in Ada.Strings.Unbounded   *note A.4.5(45.1/3): 5931, *note
A.4.5(46): 5932.
Fine_Delta
   in System   *note 13.7(9): 5115.
First
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(33/2): 6856.
   in Ada.Containers.Hashed_Maps   *note A.18.5(27/2): 6941.
   in Ada.Containers.Hashed_Sets   *note A.18.8(40/2): 7078.
   in Ada.Containers.Ordered_Maps   *note A.18.6(28/2): 6994.
   in Ada.Containers.Ordered_Sets   *note A.18.9(41/2): 7151.
   in Ada.Containers.Vectors   *note A.18.2(58/2): 6781.
   in Ada.Iterator_Interfaces   *note 5.5.1(3/3): 3211.
First attribute   *note 3.5(12): 1612, *note 3.6.2(3): 1947.
first element
   of a hashed set   *note A.18.8(68/2): 7106.
   of a set   *note A.18.7(6/2): 7023.
   of an ordered set   *note A.18.9(81/3): 7185.
first node
   of a hashed map   *note A.18.5(46/2): 6956.
   of a map   *note A.18.4(6/2): 6894.
   of an ordered map   *note A.18.6(58/3): 7014.
first subtype   *note 3.2.1(6): 1389, *note 3.4.1(5): 1567.
First(N) attribute   *note 3.6.2(4): 1949.
first_bit   *note 13.5.1(5): 5070.
   used   *note 13.5.1(3): 5066, *note P: 9829.
First_Bit attribute   *note 13.5.2(3/2): 5083.
First_Child
   in Ada.Containers.Multiway_Trees   *note A.18.10(60/3): 7253.
First_Child_Element
   in Ada.Containers.Multiway_Trees   *note A.18.10(61/3): 7254.
First_Element
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(34/2): 6857.
   in Ada.Containers.Ordered_Maps   *note A.18.6(29/2): 6995.
   in Ada.Containers.Ordered_Sets   *note A.18.9(42/2): 7152.
   in Ada.Containers.Vectors   *note A.18.2(59/2): 6782.
First_Index
   in Ada.Containers.Vectors   *note A.18.2(57/2): 6780.
First_Key
   in Ada.Containers.Ordered_Maps   *note A.18.6(30/2): 6996.
First_Valid attribute   *note 3.5.5(7.2/4): 1779.
Fixed
   child of Ada.Strings   *note A.4.3(5): 5807.
fixed point type   *note 3.5.9(1): 1825.
Fixed_IO
   in Ada.Text_IO   *note A.10.1(68): 6491.
fixed_point_definition   *note 3.5.9(2): 1829.
   used   *note 3.5.6(2): 1787, *note P: 9091.
Float   *note 3.5.7(12): 1815, *note 3.5.7(14): 1817.
   in Standard   *note A.1(21): 5441.
Float_IO
   in Ada.Text_IO   *note A.10.1(63): 6481.
Float_Random
   child of Ada.Numerics   *note A.5.2(5): 6147.
Float_Text_IO
   child of Ada   *note A.10.9(33): 6536.
Float_Wide_Text_IO
   child of Ada   *note A.11(2/2): 6557.
Float_Wide_Wide_Text_IO
   child of Ada   *note A.11(3/2): 6560.
Floating
   in Interfaces.COBOL   *note B.4(9): 7546.
floating point type   *note 3.5.7(1): 1794.
floating_point_definition   *note 3.5.7(2): 1795.
   used   *note 3.5.6(2): 1786, *note P: 9090.
Floor
   in Ada.Containers.Ordered_Maps   *note A.18.6(40/2): 7006.
   in Ada.Containers.Ordered_Sets   *note A.18.9(50/2): 7160, *note
A.18.9(70/2): 7173.
Floor attribute   *note A.5.3(30): 6219.
Flush
   in Ada.Direct_IO   *note A.8.4(10.1/4): 6338.
   in Ada.Sequential_IO   *note A.8.1(10.1/4): 6311.
   in Ada.Streams.Stream_IO   *note A.12.1(25/1): 6594.
   in Ada.Text_IO   *note A.10.1(21/1): 6410.
Fore attribute   *note 3.5.10(4): 1873.
form
   of an external file   *note A.7(1): 6282.
   in Ada.Direct_IO   *note A.8.4(9): 6336.
   in Ada.Sequential_IO   *note A.8.1(9): 6309.
   in Ada.Streams.Stream_IO   *note A.12.1(11): 6582.
   in Ada.Text_IO   *note A.10.1(12): 6391.
formal object, generic   *note 12.4(1): 4740.
formal package, generic   *note 12.7(1): 4851.
formal parameter
   of a subprogram   *note 6.1(17): 3329.
formal subprogram, generic   *note 12.6(1): 4827.
formal subtype   *note 12.5(5): 4797.
formal type   *note 12.5(5): 4795.
formal_abstract_subprogram_declaration   *note 12.6(2.2/3): 4835.
   used   *note 12.6(2/2): 4830, *note P: 9781.
formal_access_type_definition   *note 12.5.4(2): 4820.
   used   *note 12.5(3/2): 4788, *note P: 9773.
formal_array_type_definition   *note 12.5.3(2): 4816.
   used   *note 12.5(3/2): 4787, *note P: 9772.
formal_complete_type_declaration   *note 12.5(2.1/3): 4770.
   used   *note 12.5(2/3): 4768, *note P: 9756.
formal_concrete_subprogram_declaration   *note 12.6(2.1/3): 4831.
   used   *note 12.6(2/2): 4829, *note P: 9780.
formal_decimal_fixed_point_definition   *note 12.5.2(7): 4815.
   used   *note 12.5(3/2): 4786, *note P: 9771.
formal_derived_type_definition   *note 12.5.1(3/2): 4801.
   used   *note 12.5(3/2): 4780, *note P: 9765.
formal_discrete_type_definition   *note 12.5.2(2): 4810.
   used   *note 12.5(3/2): 4781, *note P: 9766.
formal_floating_point_definition   *note 12.5.2(5): 4813.
   used   *note 12.5(3/2): 4784, *note P: 9769.
formal_incomplete_type_declaration   *note 12.5(2.2/3): 4775.
   used   *note 12.5(2/3): 4769, *note P: 9757.
formal_interface_type_definition   *note 12.5.5(2/2): 4824.
   used   *note 12.5(3/2): 4789, *note P: 9774.
formal_modular_type_definition   *note 12.5.2(4): 4812.
   used   *note 12.5(3/2): 4783, *note P: 9768.
formal_object_declaration   *note 12.4(2/3): 4741.
   used   *note 12.1(6): 4681, *note P: 9717.
formal_ordinary_fixed_point_definition   *note 12.5.2(6): 4814.
   used   *note 12.5(3/2): 4785, *note P: 9770.
formal_package_actual_part   *note 12.7(3/2): 4857.
   used   *note 12.7(2/3): 4855, *note P: 9792.
formal_package_association   *note 12.7(3.1/2): 4861.
   used   *note 12.7(3/2): 4860, *note P: 9796.
formal_package_declaration   *note 12.7(2/3): 4852.
   used   *note 12.1(6): 4684, *note P: 9720.
formal_part   *note 6.1(14): 3316.
   used   *note 6.1(12): 3309, *note 6.1(13/2): 3314, *note P: 9430.
formal_private_type_definition   *note 12.5.1(2): 4800.
   used   *note 12.5(3/2): 4779, *note P: 9764.
formal_signed_integer_type_definition   *note 12.5.2(3): 4811.
   used   *note 12.5(3/2): 4782, *note P: 9767.
formal_subprogram_declaration   *note 12.6(2/2): 4828.
   used   *note 12.1(6): 4683, *note P: 9719.
formal_type_declaration   *note 12.5(2/3): 4767.
   used   *note 12.1(6): 4682, *note P: 9718.
formal_type_definition   *note 12.5(3/2): 4778.
   used   *note 12.5(2.1/3): 4773, *note P: 9760.
format_effector   *note 2.1(13/3): 1145.
Formatting
   child of Ada.Calendar   *note 9.6.1(15/2): 4177.
Fortran
   child of Interfaces   *note B.5(4): 7599.
Fortran interface   *note B.5(1/3): 7598.
Fortran standard   *note 1.2(3/2): 1096.
Fortran_Character
   in Interfaces.Fortran   *note B.5(12/3): 7610.
Fortran_Integer
   in Interfaces.Fortran   *note B.5(5): 7600.
forward iterator   *note 5.5.2(4/3): 3251.
Forward_Iterator
   in Ada.Iterator_Interfaces   *note 5.5.1(3/3): 3210.
Fraction attribute   *note A.5.3(21): 6207.
Fraction_One_Half
   in Ada.Characters.Latin_1   *note A.3.3(22): 5662.
Fraction_One_Quarter
   in Ada.Characters.Latin_1   *note A.3.3(22): 5661.
Fraction_Three_Quarters
   in Ada.Characters.Latin_1   *note A.3.3(22): 5663.
Free
   in Ada.Strings.Unbounded   *note A.4.5(7): 5907.
   in Interfaces.C.Strings   *note B.3.1(11): 7504.
freed
   See nonexistent   *note 13.11.2(10/4): 5230.
freeing storage   *note 13.11.2(1): 5227.
freezing
   by a constituent of a construct   *note 13.14(4/1): 5405.
   by an expression   *note 13.14(8/4): 5409.
   by an implicit call   *note 13.14(8.1/3): 5411.
   by an object name   *note 13.14(8/4): 5410.
   class-wide type caused by the freezing of the specific type   *note
13.14(15): 5428.
   constituents of a full type definition   *note 13.14(15): 5426.
   designated subtype caused by an allocator   *note 13.14(13): 5423.
   entity   *note 13.14(2): 5399.
   entity caused by a body   *note 13.14(3/4): 5403.
   entity caused by a construct   *note 13.14(4/1): 5404.
   entity caused by a name   *note 13.14(11): 5419.
   entity caused by the end of an enclosing construct   *note
13.14(3/4): 5402.
   expression of an expression function by a call   *note 13.14(10.1/4):
5415.
   expression of an expression function by Access attribute   *note
13.14(10.3/4): 5418.
   expression of an expression function by an instantiation   *note
13.14(10.2/4): 5417.
   first subtype caused by the freezing of the type   *note 13.14(15):
5427.
   generic_instantiation   *note 13.14(5/3): 5406.
   nominal subtype caused by a name   *note 13.14(11): 5420.
   object_declaration   *note 13.14(6): 5407.
   profile   *note 13.14(2.1/3): 5401.
   profile of a callable entity by an instantiation   *note
13.14(10.2/4): 5416.
   profile of a function call   *note 13.14(10.1/4): 5414.
   specific type caused by the freezing of the class-wide type   *note
13.14(15): 5429.
   subtype caused by a record extension   *note 13.14(7): 5408.
   subtype caused by an implicit conversion   *note 13.14(8.2/1): 5412.
   subtype caused by an implicit dereference   *note 13.14(11.1/1):
5421.
   subtypes of the profile of a callable entity   *note 13.14(14/3):
5424.
   type caused by a range   *note 13.14(12): 5422.
   type caused by an expression   *note 13.14(10): 5413.
   type caused by the freezing of a subtype   *note 13.14(15): 5425.
freezing points
   entity   *note 13.14(2): 5400.
Friday
   in Ada.Calendar.Formatting   *note 9.6.1(17/2): 4183.
FS
   in Ada.Characters.Latin_1   *note A.3.3(6): 5528.
full conformance
   for discrete_subtype_definitions   *note 6.3.1(24): 3441.
   for expressions   *note 6.3.1(19): 3438.
   for known_discriminant_parts   *note 6.3.1(23): 3439.
   for profiles   *note 6.3.1(18/3): 3436.
   required   *note 3.10.1(4/3): 2283, *note 6.3(4): 3409, *note
6.7(2.1/3): 3547, *note 6.8(4/3): 3561, *note 7.3(9): 3614, *note
8.3(12.3/2): 3752, *note 8.5.4(5/3): 3830, *note 9.5.2(14): 4070, *note
9.5.2(16): 4074, *note 9.5.2(17): 4075, *note 10.1.3(11): 4411, *note
10.1.3(12): 4412.
full constant declaration   *note 3.3.1(6/3): 1500.
   corresponding to a formal object of mode in   *note 12.4(10/2): 4761.
full declaration   *note 7.4(2/3): 3643.
full name
   of a file   *note A.16(47/2): 6680.
full stop   *note 2.1(15/3): 1164.
full type   *note 3.2.1(8/2): 1393.
full type definition   *note 3.2.1(8/2): 1394.
full view
   of a type   *note 3.2.1(8/2): 1395.
Full_Name
   in Ada.Directories   *note A.16(15/2): 6645, *note A.16(39/2): 6667.
Full_Stop
   in Ada.Characters.Latin_1   *note A.3.3(8): 5547.
full_type_declaration   *note 3.2.1(3/3): 1373.
   used   *note 3.2.1(2): 1369, *note P: 9023.
function   *note 6(1): 3277, *note N(19.1/2): 8912.
   expression   *note 6.8(6/4): 3563.
   with a controlling access result   *note 3.9.2(2/3): 2166.
   with a controlling result   *note 3.9.2(2/3): 2164.
function call
   master of   *note 3.10.2(10.1/3): 2299.
function instance   *note 12.3(13): 4730.
function_call   *note 6.4(3): 3450.
   used   *note 4.1(2/3): 2367, *note P: 9203.
function_specification   *note 6.1(4.2/2): 3291.
   used   *note 6.1(4/2): 3287, *note 6.8(2/4): 3553, *note P: 9475.



File: arm2012.info,  Node: G,  Next: H,  Prev: F,  Up: Index

G 
==



general access type   *note 3.10(7/1): 2250, *note 3.10(8): 2254.
general_access_modifier   *note 3.10(4): 2235.
   used   *note 3.10(3): 2233, *note P: 9172.
generalized iterator   *note 5.5.2(3/3): 3241.
generalized_indexing   *note 4.1.6(10/3): 2468.
   used   *note 4.1(2/3): 2371, *note P: 9207.
generalized_reference   *note 4.1.5(4/3): 2455.
   used   *note 4.1(2/3): 2370, *note P: 9206.
generation
   of an interrupt   *note C.3(2): 7632.
Generator
   in Ada.Numerics.Discrete_Random   *note A.5.2(19): 6161.
   in Ada.Numerics.Float_Random   *note A.5.2(7): 6148.
generic actual   *note 12.3(7/3): 4725.
generic actual parameter   *note 12.3(7/3): 4724.
generic actual subtype   *note 12.5(4): 4790.
generic actual type   *note 12.5(4): 4792.
generic body   *note 12.2(1): 4691.
generic contract issue   *note 10.2.1(10/2): 4471.
   [partial]   *note 3.2.4(29/3): 1446, *note 3.4(5.1/3): 1540, *note
3.7(10/3): 1987, *note 3.7.1(7/3): 2013, *note 3.9.1(3/2): 2143, *note
3.9.4(17/2): 2221, *note 3.10.2(29.1/3): 2311, *note 3.10.2(33/3): 2319,
*note 4.5.2(9.8/4): 2795, *note 4.6(24.22/4): 2962, *note 4.8(5.6/3):
3055, *note 4.9(37/2): 3105, *note 6.1.1(17.2/4): 3364, *note
6.4.1(5.4/4): 3477, *note 6.4.1(6.3/4): 3478, *note 6.5.1(6/2): 3537,
*note 7.3(8): 3613, *note 8.3(26/2): 3770, *note 8.3.1(7/2): 3773, *note
8.5.1(4.6/2): 3810, *note 8.5.1(5/3): 3811, *note 8.5.4(4.3/2): 3829,
*note 9.1(9.9/2): 3926, *note 9.4(11.13/2): 4000, *note 9.4(11.8/2):
3999, *note 9.5(17/3): 4021, *note 9.5.2(13.4/2): 4069, *note
10.2.1(11.7/3): 4478, *note 10.2.1(11/3): 4475, *note 10.2.1(17/3):
4488, *note 12.4(8.5/2): 4758, *note 12.6(8.3/2): 4847, *note
13.1.1(18.5/4): 4930, *note 13.11.2(3.1/3): 5229, *note 13.11.4(23/3):
5277, *note 13.13.2(49/4): 5395, *note B.3.3(10/3): 7540, *note
C.3.1(7/3): 7645, *note J.15.7(7/3): 8596.
generic formal   *note 12.1(9): 4689.
generic formal object   *note 12.4(1): 4739.
generic formal package   *note 12.7(1): 4850.
generic formal subprogram   *note 12.6(1): 4826.
generic formal subtype   *note 12.5(5): 4796.
generic formal type   *note 12.5(5): 4794.
generic function   *note 12.1(8/2): 4688.
generic package   *note 12.1(8/2): 4685.
generic procedure   *note 12.1(8/2): 4687.
generic subprogram   *note 12.1(8/2): 4686.
generic unit   *note 12(1): 4662, *note N(20): 8913.
   See also dispatching operation   *note 3.9(1): 2082.
generic_actual_part   *note 12.3(3): 4709.
   used   *note 12.3(2/3): 4702, *note 12.7(3/2): 4858, *note P: 9728.
Generic_Array_Sort
   child of Ada.Containers   *note A.18.26(3/2): 7330.
generic_association   *note 12.3(4): 4712.
   used   *note 12.3(3): 4711, *note 12.7(3.1/2): 4862, *note P: 9797.
Generic_Bounded_Length
   in Ada.Strings.Bounded   *note A.4.4(4): 5844.
Generic_Complex_Arrays
   child of Ada.Numerics   *note G.3.2(2/2): 8386.
Generic_Complex_Elementary_Functions
   child of Ada.Numerics   *note G.1.2(2/2): 8285.
Generic_Complex_Types
   child of Ada.Numerics   *note G.1.1(2/1): 8258.
Generic_Constrained_Array_Sort
   child of Ada.Containers   *note A.18.26(7/2): 7332.
generic_declaration   *note 12.1(2): 4667.
   used   *note 3.1(3/3): 1304, *note 10.1.1(5): 4336, *note P: 9020.
Generic_Dispatching_Constructor
   child of Ada.Tags   *note 3.9(18.2/3): 2125.
Generic_Elementary_Functions
   child of Ada.Numerics   *note A.5.1(3): 6110.
generic_formal_parameter_declaration   *note 12.1(6): 4680.
   used   *note 12.1(5): 4678, *note P: 9715.
generic_formal_part   *note 12.1(5): 4677.
   used   *note 12.1(3/3): 4671, *note 12.1(4): 4675, *note P: 9713.
generic_instantiation   *note 12.3(2/3): 4694.
   used   *note 3.1(3/3): 1305, *note 10.1.1(5): 4337, *note P: 9021.
Generic_Keys
   in Ada.Containers.Hashed_Sets   *note A.18.8(50/2): 7087.
   in Ada.Containers.Ordered_Sets   *note A.18.9(62/2): 7165.
generic_package_declaration   *note 12.1(4): 4674.
   used   *note 12.1(2): 4669, *note P: 9709.
Generic_Real_Arrays
   child of Ada.Numerics   *note G.3.1(2/2): 8370.
generic_renaming_declaration   *note 8.5.5(2/3): 3835.
   used   *note 8.5(2): 3794, *note 10.1.1(6): 4340, *note P: 9664.
Generic_Sort
   child of Ada.Containers   *note A.18.26(9.2/4): 7334.
Generic_Sorting
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(47/2): 6869.
   in Ada.Containers.Vectors   *note A.18.2(75/2): 6797.
generic_subprogram_declaration   *note 12.1(3/3): 4670.
   used   *note 12.1(2): 4668, *note P: 9708.
Get
   in Ada.Text_IO   *note A.10.1(41): 6443, *note A.10.1(47): 6453,
*note A.10.1(54): 6466, *note A.10.1(55): 6470, *note A.10.1(59): 6476,
*note A.10.1(60): 6479, *note A.10.1(65): 6485, *note A.10.1(67): 6489,
*note A.10.1(70): 6495, *note A.10.1(72): 6499, *note A.10.1(75): 6505,
*note A.10.1(77): 6509, *note A.10.1(81): 6515, *note A.10.1(83): 6518.
   in Ada.Text_IO.Complex_IO   *note G.1.3(6): 8318, *note G.1.3(8):
8322.
Get_CPU
   in Ada.Interrupts   *note C.3.2(10.1/3): 7669.
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(13/3):
8090.
Get_CPU_Set
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(9.3/4):
8086.
Get_Deadline
   in Ada.Dispatching.EDF   *note D.2.6(9/2): 7826.
Get_Dispatching_Domain
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(10/3):
8087.
Get_First_CPU
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(8/3):
8082.
Get_Immediate
   in Ada.Text_IO   *note A.10.1(44): 6450, *note A.10.1(45): 6451.
Get_Last_CPU
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(9/4):
8083.
Get_Line
   in Ada.Text_IO   *note A.10.1(49): 6458, *note A.10.1(49.1/2): 6459.
   in Ada.Text_IO.Bounded_IO   *note A.10.11(8/2): 6542, *note
A.10.11(9/2): 6543, *note A.10.11(10/2): 6544, *note A.10.11(11/2):
6545.
   in Ada.Text_IO.Unbounded_IO   *note A.10.12(8/2): 6551, *note
A.10.12(9/2): 6552, *note A.10.12(10/2): 6553, *note A.10.12(11/2):
6554.
Get_Next_Entry
   in Ada.Directories   *note A.16(35/2): 6665.
Get_Priority
   in Ada.Dynamic_Priorities   *note D.5.1(5): 7867.
global to   *note 8.1(15): 3720.
Glossary   *note N(1/2): 8878.
goto_statement   *note 5.8(2): 3271.
   used   *note 5.1(4/2): 3125, *note P: 9360.
govern a variant   *note 3.8.1(20): 2077.
govern a variant_part   *note 3.8.1(20): 2076.
grammar
   complete listing   *note P: 8958.
   cross reference   *note P: 9847.
   notation   *note 1.1.4(3): 1061.
   resolution of ambiguity   *note 8.6(3): 3847.
   under Syntax heading   *note 1.1.2(25): 1015.
graphic character
   a category of Character   *note A.3.2(23): 5489.
graphic_character   *note 2.1(14/3): 1150.
   used   *note 2.5(2): 1248, *note 2.6(3): 1253, *note P: 8994.
Graphic_Set
   in Ada.Strings.Maps.Constants   *note A.4.6(4): 5956.
Grave
   in Ada.Characters.Latin_1   *note A.3.3(13): 5561.
greater than operator   *note 4.4(1/3): 2609, *note 4.5.2(1): 2783.
greater than or equal operator   *note 4.4(1/3): 2613, *note 4.5.2(1):
2787.
greater-than sign   *note 2.1(15/3): 1173.
Greater_Than_Sign
   in Ada.Characters.Latin_1   *note A.3.3(10): 5553.
Group_Budget
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(4/3): 8031.
Group_Budget_Error
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(11/2): 8047.
Group_Budget_Handler
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(5/2): 8032.
Group_Budgets
   child of Ada.Execution_Time   *note D.14.2(3/3): 8030.
GS
   in Ada.Characters.Latin_1   *note A.3.3(6): 5529.
guard   *note 9.7.1(3): 4221.
   used   *note 9.7.1(2): 4218, *note P: 9623.



File: arm2012.info,  Node: H,  Next: I,  Prev: G,  Up: Index

H 
==



handle
   an exception   *note 11(1/3): 4513, *note N(18): 8908.
   an exception occurrence   *note 11.4(1): 4554, *note 11.4(7): 4561.
   subpool   *note 13.11.4(18/3): 5272.
handled_sequence_of_statements   *note 11.2(2): 4528.
   used   *note 5.6(2): 3263, *note 6.3(2/3): 3407, *note 6.5(2.2/3):
3505, *note 7.2(2/3): 3590, *note 9.1(6/3): 3915, *note 9.5.2(3): 4048,
*note 9.5.2(5): 4057, *note P: 9406.
handler
   execution timer   *note D.14.1(13/2): 8027.
   group budget   *note D.14.2(14/2): 8051.
   interrupt   *note C.3(2): 7639.
   termination   *note C.7.3(8/3): 7748.
   timing event   *note D.15(10/2): 8069.
Handling
   child of Ada.Characters   *note A.3.2(2/2): 5460.
   child of Ada.Wide_Characters   *note A.3.5(3/3): 5748.
   child of Ada.Wide_Wide_Characters   *note A.3.6(1/3): 5769.
Has_Element
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(9.1/3): 6827.
   in Ada.Containers.Hashed_Maps   *note A.18.5(6.1/3): 6913.
   in Ada.Containers.Hashed_Sets   *note A.18.8(6.1/3): 7045.
   in Ada.Containers.Multiway_Trees   *note A.18.10(12/3): 7206.
   in Ada.Containers.Ordered_Maps   *note A.18.6(7.1/3): 6966.
   in Ada.Containers.Ordered_Sets   *note A.18.9(7.1/3): 7118.
   in Ada.Containers.Vectors   *note A.18.2(11.1/3): 6731.
Has_Same_Storage attribute   *note 13.3(73.2/4): 5029.
Hash
   child of Ada.Strings   *note A.4.9(2/3): 6049.
   child of Ada.Strings.Bounded   *note A.4.9(7/3): 6050.
   child of Ada.Strings.Unbounded   *note A.4.9(10/3): 6051.
Hash_Case_Insensitive
   child of Ada.Strings   *note A.4.9(11.2/3): 6052.
   child of Ada.Strings.Bounded   *note A.4.9(11.7/3): 6054.
   child of Ada.Strings.Fixed   *note A.4.9(11.5/3): 6053.
   child of Ada.Strings.Unbounded   *note A.4.9(11.10/3): 6055.
Hash_Type
   in Ada.Containers   *note A.18.1(4/2): 6716.
Hashed_Maps
   child of Ada.Containers   *note A.18.5(2/3): 6908.
Hashed_Sets
   child of Ada.Containers   *note A.18.8(2/3): 7040.
Head
   in Ada.Strings.Bounded   *note A.4.4(70): 5895, *note A.4.4(71):
5896.
   in Ada.Strings.Fixed   *note A.4.3(35): 5838, *note A.4.3(36): 5839.
   in Ada.Strings.Unbounded   *note A.4.5(65): 5949, *note A.4.5(66):
5950.
head (of a queue)   *note D.2.1(5/2): 7777.
heap management
   user-defined   *note 13.11(1): 5186.
   See also allocator   *note 4.8(1): 3042.
held priority   *note D.11(4/2): 7993.
heterogeneous input-output   *note A.12.1(1): 6565.
hexadecimal
   literal   *note 2.4.2(1): 1232.
hexadecimal digit
   a category of Character   *note A.3.2(30): 5495.
hexadecimal literal   *note 2.4.2(1): 1230.
Hexadecimal_Digit_Set
   in Ada.Strings.Maps.Constants   *note A.4.6(4): 5962.
hidden from all visibility   *note 8.3(5): 3744, *note 8.3(14): 3754.
   by lack of a with_clause   *note 8.3(20/2): 3758.
   for a declaration completed by a subsequent declaration   *note
8.3(19): 3757.
   for overridden declaration   *note 8.3(15): 3755.
   within the declaration itself   *note 8.3(16): 3756.
hidden from direct visibility   *note 8.3(5): 3745, *note 8.3(21): 3763.
   by an inner homograph   *note 8.3(22): 3764.
   where hidden from all visibility   *note 8.3(23): 3765.
hiding   *note 8.3(5): 3743.
Hierarchical_File_Names
   child of Ada.Directories   *note A.16.1(3/3): 6686.
High_Order_First   *note 13.5.3(2): 5089.
   in Interfaces.COBOL   *note B.4(25): 7570.
   in System   *note 13.7(15/2): 5124.
highest precedence operator   *note 4.5.6(1): 2858.
highest_precedence_operator   *note 4.5(7): 2729.
Hold
   in Ada.Asynchronous_Task_Control   *note D.11(3/2): 7989.
Holder
   in Ada.Containers.Indefinite_Holders   *note A.18.18(6/3): 7285.
homograph   *note 8.3(8): 3748.
Hour
   in Ada.Calendar.Formatting   *note 9.6.1(24/2): 4194.
Hour_Number subtype of Natural
   in Ada.Calendar.Formatting   *note 9.6.1(20/2): 4187.
HT
   in Ada.Characters.Latin_1   *note A.3.3(5): 5509.
HTJ
   in Ada.Characters.Latin_1   *note A.3.3(17): 5607.
HTS
   in Ada.Characters.Latin_1   *note A.3.3(17): 5606.
Hyphen
   in Ada.Characters.Latin_1   *note A.3.3(8): 5545.
hyphen-minus   *note 2.1(15/3): 1162.



File: arm2012.info,  Node: I,  Next: J,  Prev: H,  Up: Index

I 
==



i
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(5): 8261.
   in Interfaces.Fortran   *note B.5(10): 7607.
identifier   *note 2.3(2/2): 1187.
   used   *note 2.8(2): 1260, *note 2.8(3/3): 1264, *note 2.8(21): 1283,
*note 2.8(23): 1288, *note 3.1(4): 1307, *note 4.1(3): 2373, *note
4.1.3(3): 2422, *note 4.1.4(3/2): 2438, *note 5.5(2): 3194, *note
5.6(2): 3264, *note 6.1(5): 3296, *note 7.1(3/3): 3579, *note 7.2(2/3):
3592, *note 9.1(4): 3907, *note 9.1(6/3): 3916, *note 9.4(4): 3969,
*note 9.4(7/3): 3981, *note 9.5.2(3): 4049, *note 9.5.2(5): 4058, *note
11.4.2(6.1/3): 4599, *note 11.4.2(6/2): 4595, *note 11.5(4.1/2): 4622,
*note 11.5(4/2): 4619, *note 13.1.1(3/3): 4917, *note 13.1.1(4/3): 4921,
*note 13.12(4/2): 5295, *note 13.12(11/3): 5306, *note D.2.2(3): 7786,
*note D.2.2(3.2/2): 7789, *note D.3(3): 7833, *note D.3(4): 7834, *note
D.4(3): 7854, *note D.4(4): 7855, *note H.6(3/2): 8490, *note J.10(3/2):
8523, *note J.15.5(2/3): 8566, *note J.15.5(3/3): 8572, *note
J.15.5(4/3): 8578, *note L(2.2/2): 8704, *note L(2.3/3): 8708, *note
L(8.1/3): 8726, *note L(13.1/3): 8754, *note L(14.1/3): 8760, *note
L(20): 8788, *note L(21): 8791, *note L(23): 8800, *note L(25.1/2):
8808, *note L(27.2/2): 8819, *note L(27.3/3): 8824, *note L(29): 8831,
*note L(36): 8854, *note L(37): 8857, *note L(37.3/2): 8863, *note
M.2(98): 8875, *note P: 9560.
identifier specific to a pragma   *note 2.8(10/3): 1276.
identifier_extend   *note 2.3(3.1/3): 1198.
   used   *note 2.3(2/2): 1190, *note P: 8964.
identifier_start   *note 2.3(3/2): 1191.
   used   *note 2.3(2/2): 1188, *note P: 8962.
Identity
   in Ada.Strings.Maps   *note A.4.2(22): 5799.
   in Ada.Strings.Wide_Maps   *note A.4.7(22): 6001.
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(22/2): 6040.
Identity attribute   *note 11.4.1(9): 4584, *note C.7.1(12): 7719.
idle task   *note D.11(4/2): 7994.
if_expression   *note 4.5.7(3/3): 2881.
   used   *note 4.5.7(2/3): 2879, *note P: 9317.
if_statement   *note 5.3(2): 3169.
   used   *note 5.1(5/2): 3135, *note P: 9369.
illegal
   construct   *note 1.1.2(27): 1026.
   partition   *note 1.1.2(29): 1034.
Im
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(7/2): 8390,
*note G.3.2(27/2): 8403.
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(6): 8264.
image
   of a value   *note 3.5(27.3/2): 1640, *note 3.5(30/3): 1644, *note
K.2(273/3): 8692, *note K.2(277.4/2): 8693.
   in Ada.Calendar.Formatting   *note 9.6.1(35/2): 4205, *note
9.6.1(37/2): 4207.
   in Ada.Numerics.Discrete_Random   *note A.5.2(26): 6169.
   in Ada.Numerics.Float_Random   *note A.5.2(14): 6157.
   in Ada.Task_Identification   *note C.7.1(3/3): 7711.
   in Ada.Text_IO.Editing   *note F.3.3(13): 8249.
Image attribute   *note 3.5(35): 1646, *note 3.5(55.4/4): 1682.
Imaginary
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(4/2): 8260.
Imaginary subtype of Imaginary
   in Interfaces.Fortran   *note B.5(10): 7606.
immediate scope
   of (a view of) an entity   *note 8.2(11): 3731.
   of a declaration   *note 8.2(2): 3721.
   of a pragma   *note 8.2(12/4): 3733.
Immediate_Reclamation restriction   *note H.4(10): 8459.
immediately enclosing   *note 8.1(13): 3717.
immediately visible   *note 8.3(4): 3741, *note 8.3(21): 3760.
immediately within   *note 8.1(13): 3715.
immutably limited   *note 7.5(8.1/3): 3647.
implementation advice   *note 1.1.2(37): 1047.
   summary of advice   *note M.3(1/2): 8876.
implementation defined   *note 1.1.3(18): 1054.
   summary of characteristics   *note M.2(1/2): 8873.
implementation permissions   *note 1.1.2(36): 1046.
implementation requirements   *note 1.1.2(33): 1043.
implementation-dependent
   See unspecified   *note 1.1.3(18): 1057.
implemented
   by a protected entry   *note 9.4(11.1/3): 3993.
   by a protected subprogram   *note 9.4(11.1/3): 3992.
   by a task entry   *note 9.1(9.2/3): 3920.
implicit conversion
   legality   *note 8.6(27.1/4): 3868.
implicit declaration   *note 3.1(5): 1310, *note N(11): 8897.
implicit initial values
   for a subtype   *note 3.3.1(10): 1510.
implicit subtype conversion   *note 4.6(59): 3021, *note 4.6(60): 3022.
   Access attribute   *note 3.10.2(31): 2315.
   access discriminant   *note 3.7(27/2): 2000.
   array bounds   *note 4.6(38): 2981.
   array index   *note 4.1.1(7): 2402.
   assignment to view conversion   *note 4.6(55): 3015.
   assignment_statement   *note 5.2(11): 3165.
   bounds of a decimal fixed point type   *note 3.5.9(16): 1857.
   bounds of a fixed point type   *note 3.5.9(14): 1853.
   bounds of a range   *note 3.5(9): 1610, *note 3.6(18): 1923.
   choices of aggregate   *note 4.3.3(22): 2571.
   component defaults   *note 3.3.1(13/3): 1512.
   default value of a scalar   *note 3.3.1(11.1/3): 1511.
   delay expression   *note 9.6(20): 4162.
   derived type discriminants   *note 3.4(21): 1554.
   discriminant values   *note 3.7.1(12): 2017.
   entry index   *note 9.5.2(24): 4084.
   expressions in aggregate   *note 4.3.1(19): 2525.
   expressions of aggregate   *note 4.3.3(23): 2572.
   function return   *note 6.5(5.11/3): 3516, *note 6.5(6/2): 3524.
   generic formal object of mode in   *note 12.4(11): 4766.
   inherited enumeration literal   *note 3.4(29): 1560.
   initialization expression   *note 3.3.1(17): 1514.
   initialization expression of allocator   *note 4.8(7/2): 3060.
   Interrupt_Priority aspect   *note D.1(17/4): 7768, *note D.3(6.1/3):
7841.
   named number value   *note 3.3.2(6): 1527.
   operand of concatenation   *note 4.5.3(9): 2826.
   parameter passing   *note 6.4.1(10): 3482, *note 6.4.1(11): 3484,
*note 6.4.1(17): 3493.
   Priority aspect   *note D.1(17/4): 7767, *note D.3(6.1/3): 7840.
   qualified_expression   *note 4.7(4/4): 3038.
   reading a view conversion   *note 4.6(56/4): 3016.
   result of inherited function   *note 3.4(27/2): 1558.
implicit_dereference   *note 4.1(6): 2380.
   used   *note 4.1(4): 2377, *note P: 9211.
Implicit_Dereference aspect   *note 4.1.5(2/3): 2451.
Import aspect   *note B.1(1/3): 7385.
Import pragma   *note J.15.5(2/3): 8565, *note L(14.1/3): 8759.
imported entity   *note B.1(23/3): 7409.
in (membership test)   *note 4.4(1/3): 2615, *note 4.5.2(2/3): 2791.
inaccessible partition   *note E.1(7): 8106.
inactive
   a task state   *note 9(10): 3884.
Include
   in Ada.Containers.Hashed_Maps   *note A.18.5(22/2): 6936.
   in Ada.Containers.Hashed_Sets   *note A.18.8(21/2): 7063.
   in Ada.Containers.Ordered_Maps   *note A.18.6(21/2): 6987.
   in Ada.Containers.Ordered_Sets   *note A.18.9(20/2): 7134.
included
   one range in another   *note 3.5(4): 1598.
incomplete type   *note 3.2(4.1/2): 1343, *note 3.10.1(2.1/4): 2278,
*note N(20.1/2): 8914.
incomplete view   *note 3.10.1(2.1/4): 2279.
   tagged   *note 3.10.1(2.1/4): 2280.
incomplete_type_declaration   *note 3.10.1(2/2): 2275.
   used   *note 3.2.1(2): 1370, *note P: 9024.
Increment
   in Interfaces.C.Pointers   *note B.3.2(11/3): 7523.
indefinite subtype   *note 3.3(23/3): 1468, *note 3.7(26): 1999.
Indefinite_Doubly_Linked_Lists
   child of Ada.Containers   *note A.18.12(2/3): 7277.
Indefinite_Hashed_Maps
   child of Ada.Containers   *note A.18.13(2/3): 7278.
Indefinite_Hashed_Sets
   child of Ada.Containers   *note A.18.15(2/3): 7280.
Indefinite_Holders
   child of Ada.Containers   *note A.18.18(5/3): 7284.
Indefinite_Multiway_Trees
   child of Ada.Containers   *note A.18.17(2/3): 7282.
Indefinite_Ordered_Maps
   child of Ada.Containers   *note A.18.14(2/3): 7279.
Indefinite_Ordered_Sets
   child of Ada.Containers   *note A.18.16(2/3): 7281.
Indefinite_Vectors
   child of Ada.Containers   *note A.18.11(2/3): 7276.
Independent aspect   *note C.6(6.3/3): 7691.
Independent pragma   *note J.15.8(4/3): 8604, *note L(14.2/3): 8765.
independent subprogram   *note 11.6(6/3): 4658.
Independent_Components aspect   *note C.6(6.9/3): 7699.
Independent_Components pragma   *note J.15.8(7/3): 8613, *note
L(14.3/3): 8768.
independently addressable   *note 9.10(1/3): 4306.
   specified   *note C.6(8.1/4): 7703.
index
   of an element of an open direct file   *note A.8(3): 6295.
   in Ada.Direct_IO   *note A.8.4(15): 6344.
   in Ada.Streams.Stream_IO   *note A.12.1(23): 6591.
   in Ada.Strings.Bounded   *note A.4.4(43.1/2): 5866, *note
A.4.4(43.2/2): 5867, *note A.4.4(44): 5868, *note A.4.4(45): 5869, *note
A.4.4(45.1/2): 5870, *note A.4.4(46): 5871.
   in Ada.Strings.Fixed   *note A.4.3(8.1/2): 5809, *note A.4.3(8.2/2):
5810, *note A.4.3(9): 5811, *note A.4.3(10): 5812, *note A.4.3(10.1/2):
5813, *note A.4.3(11): 5814.
   in Ada.Strings.Unbounded   *note A.4.5(38.1/2): 5920, *note
A.4.5(38.2/2): 5921, *note A.4.5(39): 5922, *note A.4.5(40): 5923, *note
A.4.5(40.1/2): 5924, *note A.4.5(41): 5925.
index range   *note 3.6(13): 1913.
index subtype   *note 3.6(9): 1907.
index type   *note 3.6(9): 1908.
Index_Check   *note 11.5(14): 4632.
   [partial]   *note 4.1.1(7): 2403, *note 4.1.2(7): 2413, *note
4.3.3(29/3): 2577, *note 4.3.3(30): 2579, *note 4.5.3(8): 2823, *note
4.6(51/4): 3002, *note 4.7(4/4): 3036, *note 4.8(10/2): 3063.
index_constraint   *note 3.6.1(2): 1932.
   used   *note 3.2.2(7): 1418, *note P: 9053.
Index_Error
   in Ada.Strings   *note A.4.1(5): 5776.
Index_Non_Blank
   in Ada.Strings.Bounded   *note A.4.4(46.1/2): 5872, *note A.4.4(47):
5873.
   in Ada.Strings.Fixed   *note A.4.3(11.1/2): 5815, *note A.4.3(12):
5816.
   in Ada.Strings.Unbounded   *note A.4.5(41.1/2): 5926, *note
A.4.5(42): 5927.
index_subtype_definition   *note 3.6(4): 1894.
   used   *note 3.6(3): 1892, *note P: 9108.
indexable container object   *note 4.1.6(5/3): 2467.
indexable container type   *note 4.1.6(5/3): 2466, *note N(20.2/3):
8915.
indexed_component   *note 4.1.1(2): 2394.
   used   *note 4.1(2/3): 2362, *note P: 9198.
indexing
   constant   *note 4.1.6(12/3): 2473.
   variable   *note 4.1.6(16/3): 2475.
individual membership test   *note 4.5.2(26.1/3): 2801.
indivisible   *note C.6(10/4): 7704.
inferable discriminants   *note B.3.3(20/2): 7541.
Information
   child of Ada.Directories   *note A.16(124/2): 6685.
information hiding
   See package   *note 7(1): 3567.
   See private types and private extensions   *note 7.3(1): 3596.
information systems   *note C(1): 7622, *note F(1): 8218.
informative   *note 1.1.2(18): 1011.
inherently mutable object   *note 3.3(13/3): 1462.
inheritance
   See derived types and classes   *note 3.4(1/2): 1530.
   See also tagged types and type extension   *note 3.9(1): 2086.
inherited
   from an ancestor type   *note 3.4.1(11): 1580.
inherited component   *note 3.4(11): 1546, *note 3.4(12): 1547.
inherited discriminant   *note 3.4(11): 1545.
inherited entry   *note 3.4(12): 1549.
inherited protected subprogram   *note 3.4(12): 1548.
inherited subprogram   *note 3.4(17/2): 1550.
Initial_Directory
   in Ada.Directories.Hierarchical_File_Names   *note A.16.1(12/3):
6695.
initialization
   of a protected object   *note 9.4(14): 4004.
   of a protected object   *note C.3.1(10/3): 7647, *note C.3.1(11/3):
7651.
   of a task object   *note 9.1(12/1): 3930, *note J.7.1(7): 8512.
   of an object   *note 3.3.1(18/2): 1516.
initialization expression   *note 3.3.1(1/3): 1475, *note 3.3.1(4):
1498.
Initialize   *note 7.6(2): 3658.
   in Ada.Finalization   *note 7.6(6/2): 3663, *note 7.6(8/2): 3667.
initialized allocator   *note 4.8(4): 3052.
initialized by default   *note 3.3.1(18/2): 1515.
Inline aspect   *note 6.3.2(5.1/3): 3444.
Inline pragma   *note J.15.1(2/3): 8533, *note L(15.1/3): 8771.
innermost dynamically enclosing   *note 11.4(2): 4558.
input   *note A.6(1/2): 6278.
Input aspect   *note 13.13.2(38/4): 5383.
Input attribute   *note 13.13.2(22): 5360, *note 13.13.2(32): 5364.
Input clause   *note 13.3(7/2): 4971, *note 13.13.2(38/4): 5376.
Input'Class aspect   *note 13.13.2(38/4): 5391.
input-output
   unspecified for access types   *note A.7(6): 6285.
Insert
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(19/2): 6842,
*note A.18.3(20/2): 6843, *note A.18.3(21/2): 6844.
   in Ada.Containers.Hashed_Maps   *note A.18.5(19/2): 6933, *note
A.18.5(20/2): 6934, *note A.18.5(21/2): 6935.
   in Ada.Containers.Hashed_Sets   *note A.18.8(19/2): 7061, *note
A.18.8(20/2): 7062.
   in Ada.Containers.Ordered_Maps   *note A.18.6(18/2): 6984, *note
A.18.6(19/2): 6985, *note A.18.6(20/2): 6986.
   in Ada.Containers.Ordered_Sets   *note A.18.9(18/2): 7132, *note
A.18.9(19/2): 7133.
   in Ada.Containers.Vectors   *note A.18.2(36/2): 6759, *note
A.18.2(37/2): 6760, *note A.18.2(38/2): 6761, *note A.18.2(39/2): 6762,
*note A.18.2(40/2): 6763, *note A.18.2(41/2): 6764, *note A.18.2(42/2):
6765, *note A.18.2(43/2): 6766.
   in Ada.Strings.Bounded   *note A.4.4(60): 5885, *note A.4.4(61):
5886.
   in Ada.Strings.Fixed   *note A.4.3(25): 5828, *note A.4.3(26): 5829.
   in Ada.Strings.Unbounded   *note A.4.5(55): 5939, *note A.4.5(56):
5940.
Insert_Child
   in Ada.Containers.Multiway_Trees   *note A.18.10(48/3): 7241, *note
A.18.10(49/3): 7242, *note A.18.10(50/3): 7243.
Insert_Space
   in Ada.Containers.Vectors   *note A.18.2(48/2): 6771, *note
A.18.2(49/2): 6772.
inspectable object   *note H.3.2(5/2): 8445.
inspection point   *note H.3.2(5/2): 8444.
Inspection_Point pragma   *note H.3.2(3): 8441, *note L(16): 8775.
instance
   of a generic function   *note 12.3(13): 4734.
   of a generic package   *note 12.3(13): 4731.
   of a generic procedure   *note 12.3(13): 4733.
   of a generic subprogram   *note 12.3(13): 4732.
   of a generic unit   *note 12.3(1): 4693.
instructions for comment submission   *note 0.3(58/1): 1003.
int
   in Interfaces.C   *note B.3(7): 7437.
Integer   *note 3.5.4(11): 1740, *note 3.5.4(21): 1760.
   in Standard   *note A.1(12): 5438.
integer literal   *note 2.4(1): 1206.
integer literals   *note 3.5.4(14): 1747, *note 3.5.4(30): 1769.
integer type   *note 3.5.4(1): 1717, *note N(21): 8916.
Integer_Address
   in System.Storage_Elements   *note 13.7.1(10/3): 5138.
Integer_IO
   in Ada.Text_IO   *note A.10.1(52): 6463.
Integer_N   *note B.2(8): 7427.
Integer_Text_IO
   child of Ada   *note A.10.8(21): 6535.
integer_type_definition   *note 3.5.4(2): 1721.
   used   *note 3.2.1(4/2): 1382, *note P: 9034.
Integer_Wide_Text_IO
   child of Ada   *note A.11(2/2): 6556.
Integer_Wide_Wide_Text_IO
   child of Ada   *note A.11(3/2): 6559.
interaction
   between tasks   *note 9(1/3): 3876.
interface   *note 3.9.4(4/2): 2200.
   limited   *note 3.9.4(5/2): 2205.
   nonlimited   *note 3.9.4(5/2): 2206.
   protected   *note 3.9.4(5/2): 2203.
   synchronized   *note 3.9.4(5/2): 2202.
   task   *note 3.9.4(5/2): 2204.
   type   *note 3.9.4(4/2): 2201.
interface to assembly language   *note C.1(4/3): 7624.
interface to C   *note B.3(1/4): 7430.
interface to COBOL   *note B.4(1/3): 7543.
interface to Fortran   *note B.5(1/3): 7597.
interface to other languages   *note B(1): 7379.
interface type   *note N(21.1/2): 8917.
Interface_Ancestor_Tags
   in Ada.Tags   *note 3.9(7.4/2): 2112.
interface_list   *note 3.9.4(3/2): 2197.
   used   *note 3.4(2/2): 1535, *note 3.9.4(2/2): 2196, *note 7.3(3/3):
3608, *note 9.1(2/3): 3897, *note 9.1(3/3): 3902, *note 9.4(2/3): 3959,
*note 9.4(3/3): 3964, *note 12.5.1(3/2): 4803, *note P: 9074.
interface_type_definition   *note 3.9.4(2/2): 2195.
   used   *note 3.2.1(4/2): 1388, *note 12.5.5(2/2): 4825, *note P:
9779.
Interfaces   *note B.2(3): 7420.
Interfaces.C   *note B.3(4): 7432.
Interfaces.C.Pointers   *note B.3.2(4): 7518.
Interfaces.C.Strings   *note B.3.1(3): 7496.
Interfaces.COBOL   *note B.4(7): 7545.
Interfaces.Fortran   *note B.5(4): 7599.
interfacing aspect   *note B.1(0.1/3): 7382.
interfacing pragma   *note J.15.5(1/3): 8551.
   Convention   *note J.15.5(1/3): 8556.
   Export   *note J.15.5(1/3): 8554.
   Import   *note J.15.5(1/3): 8552.
internal call   *note 9.5(3/3): 4013.
internal code   *note 13.4(7): 5045.
internal node
   of a tree   *note A.18.10(2/4): 7192.
internal requeue   *note 9.5(7): 4016.
Internal_Tag
   in Ada.Tags   *note 3.9(7/2): 2107.
interpretation
   of a complete context   *note 8.6(10): 3849.
   of a constituent of a complete context   *note 8.6(15): 3855.
   overload resolution   *note 8.6(14): 3854.
interrupt   *note C.3(2): 7630.
   example using asynchronous_select   *note 9.7.4(10): 4270, *note
9.7.4(12): 4275.
interrupt entry   *note J.7.1(5): 8508.
interrupt handler   *note C.3(2): 7638.
Interrupt_Clocks_Supported
   in Ada.Execution_Time   *note D.14(9.1/3): 8008.
Interrupt_Handler aspect   *note C.3.1(6.2/3): 7642.
Interrupt_Handler pragma   *note J.15.7(2/3): 8589, *note L(17.1/3):
8779.
Interrupt_Id
   in Ada.Interrupts   *note C.3.2(2/3): 7660.
Interrupt_Priority aspect   *note D.1(6.3/3): 7760.
Interrupt_Priority pragma   *note J.15.11(4/3): 8637, *note L(18.1/3):
8782.
Interrupt_Priority subtype of Any_Priority
   in System   *note 13.7(16): 5129.
Interrupts
   child of Ada   *note C.3.2(2/3): 7659.
   child of Ada.Execution_Time   *note D.14.3(3/3): 8055.
Intersection
   in Ada.Containers.Hashed_Sets   *note A.18.8(29/2): 7070, *note
A.18.8(30/2): 7071.
   in Ada.Containers.Ordered_Sets   *note A.18.9(30/2): 7143, *note
A.18.9(31/2): 7144.
intertask communication   *note 9.5(1): 4010.
   See also task   *note 9(1/3): 3880.
Intrinsic calling convention   *note 6.3.1(4): 3421.
invalid cursor
   of a list container   *note A.18.3(153/2): 6884.
   of a map   *note A.18.4(76/2): 6904.
   of a set   *note A.18.7(97/2): 7036.
   of a tree   *note A.18.10(222/3): 7273.
   of a vector   *note A.18.2(248/2): 6814.
invalid representation   *note 13.9.1(9): 5171.
invariant   *note N(21.2/4): 8918.
   class-wide   *note 7.3.2(3/4): 3634.
invariant check   *note 7.3.2(9/4): 3636.
invariant expression   *note 7.3.2(2/3): 3627.
Inverse
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(46/2): 8417.
   in Ada.Numerics.Generic_Real_Arrays   *note G.3.1(24/2): 8377.
Inverted_Exclamation
   in Ada.Characters.Latin_1   *note A.3.3(21/3): 5632.
Inverted_Question
   in Ada.Characters.Latin_1   *note A.3.3(22): 5664.
involve an inner product
   complex   *note G.3.2(56/2): 8423.
   real   *note G.3.1(34/2): 8383.
IO_Exceptions
   child of Ada   *note A.13(3): 6613.
IS1
   in Ada.Characters.Latin_1   *note A.3.3(16): 5597.
IS2
   in Ada.Characters.Latin_1   *note A.3.3(16): 5596.
IS3
   in Ada.Characters.Latin_1   *note A.3.3(16): 5595.
IS4
   in Ada.Characters.Latin_1   *note A.3.3(16): 5594.
Is_A_Group_Member
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(8/2): 8038.
Is_Abstract
   in Ada.Tags   *note 3.9(7.5/3): 2113.
Is_Alphanumeric
   in Ada.Characters.Handling   *note A.3.2(4/3): 5470.
   in Ada.Wide_Characters.Handling   *note A.3.5(12/3): 5757.
Is_Attached
   in Ada.Interrupts   *note C.3.2(5): 7663.
Is_Basic
   in Ada.Characters.Handling   *note A.3.2(4/3): 5466.
Is_Callable
   in Ada.Task_Identification   *note C.7.1(4/3): 7716.
Is_Character
   in Ada.Characters.Conversions   *note A.3.4(3/2): 5730.
Is_Control
   in Ada.Characters.Handling   *note A.3.2(4/3): 5461.
   in Ada.Wide_Characters.Handling   *note A.3.5(5/3): 5750.
Is_Current_Directory_Name
   in Ada.Directories.Hierarchical_File_Names   *note A.16.1(7/3): 6690.
Is_Decimal_Digit
   in Ada.Characters.Handling   *note A.3.2(4/3): 5468.
   in Ada.Wide_Characters.Handling   *note A.3.5(10/3): 5755.
Is_Descendant_At_Same_Level
   in Ada.Tags   *note 3.9(7.1/2): 2109.
Is_Digit
   in Ada.Characters.Handling   *note A.3.2(4/3): 5467.
   in Ada.Wide_Characters.Handling   *note A.3.5(9/3): 5754.
Is_Empty
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(12/2): 6830.
   in Ada.Containers.Hashed_Maps   *note A.18.5(11/2): 6918.
   in Ada.Containers.Hashed_Sets   *note A.18.8(13/2): 7052.
   in Ada.Containers.Indefinite_Holders   *note A.18.18(10/3): 7288.
   in Ada.Containers.Multiway_Trees   *note A.18.10(16/3): 7209.
   in Ada.Containers.Ordered_Maps   *note A.18.6(10/2): 6969.
   in Ada.Containers.Ordered_Sets   *note A.18.9(12/2): 7123.
   in Ada.Containers.Vectors   *note A.18.2(23/2): 6739.
Is_Full_Name
   in Ada.Directories.Hierarchical_File_Names   *note A.16.1(8/3): 6691.
Is_Graphic
   in Ada.Characters.Handling   *note A.3.2(4/3): 5462.
   in Ada.Wide_Characters.Handling   *note A.3.5(19/3): 5764.
Is_Held
   in Ada.Asynchronous_Task_Control   *note D.11(3/2): 7991.
Is_Hexadecimal_Digit
   in Ada.Characters.Handling   *note A.3.2(4/3): 5469.
   in Ada.Wide_Characters.Handling   *note A.3.5(11/3): 5756.
Is_In
   in Ada.Strings.Maps   *note A.4.2(13): 5791.
   in Ada.Strings.Wide_Maps   *note A.4.7(13): 5993.
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(13/2): 6032.
Is_ISO_646
   in Ada.Characters.Handling   *note A.3.2(10): 5484.
Is_Leaf
   in Ada.Containers.Multiway_Trees   *note A.18.10(21/3): 7214.
Is_Letter
   in Ada.Characters.Handling   *note A.3.2(4/3): 5463.
   in Ada.Wide_Characters.Handling   *note A.3.5(6/3): 5751.
Is_Line_Terminator
   in Ada.Characters.Handling   *note A.3.2(4/3): 5472.
   in Ada.Wide_Characters.Handling   *note A.3.5(14/3): 5759.
Is_Lower
   in Ada.Characters.Handling   *note A.3.2(4/3): 5464.
   in Ada.Wide_Characters.Handling   *note A.3.5(7/3): 5752.
Is_Mark
   in Ada.Characters.Handling   *note A.3.2(4/3): 5473.
   in Ada.Wide_Characters.Handling   *note A.3.5(15/3): 5760.
Is_Member
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(8/2): 8037.
Is_Nul_Terminated
   in Interfaces.C   *note B.3(24): 7456, *note B.3(35): 7466, *note
B.3(39.16/2): 7486, *note B.3(39.7/2): 7476.
Is_Open
   in Ada.Direct_IO   *note A.8.4(10): 6337.
   in Ada.Sequential_IO   *note A.8.1(10): 6310.
   in Ada.Streams.Stream_IO   *note A.12.1(12): 6583.
   in Ada.Text_IO   *note A.10.1(13): 6392.
Is_Other_Format
   in Ada.Characters.Handling   *note A.3.2(4/3): 5474.
   in Ada.Wide_Characters.Handling   *note A.3.5(16/3): 5761.
Is_Parent_Directory_Name
   in Ada.Directories.Hierarchical_File_Names   *note A.16.1(6/3): 6689.
Is_Punctuation_Connector
   in Ada.Characters.Handling   *note A.3.2(4/3): 5475.
   in Ada.Wide_Characters.Handling   *note A.3.5(17/3): 5762.
Is_Relative_Name
   in Ada.Directories.Hierarchical_File_Names   *note A.16.1(9/3): 6692.
Is_Reserved
   in Ada.Interrupts   *note C.3.2(4): 7662.
Is_Root
   in Ada.Containers.Multiway_Trees   *note A.18.10(20/3): 7213.
Is_Root_Directory_Name
   in Ada.Directories.Hierarchical_File_Names   *note A.16.1(5/3): 6688.
Is_Round_Robin
   in Ada.Dispatching.Round_Robin   *note D.2.5(4/2): 7818.
Is_Simple_Name
   in Ada.Directories.Hierarchical_File_Names   *note A.16.1(4/3): 6687.
Is_Sorted
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(48/2): 6870.
   in Ada.Containers.Vectors   *note A.18.2(76/2): 6798.
Is_Space
   in Ada.Characters.Handling   *note A.3.2(4/3): 5476.
   in Ada.Wide_Characters.Handling   *note A.3.5(18/3): 5763.
Is_Special
   in Ada.Characters.Handling   *note A.3.2(4/3): 5471.
   in Ada.Wide_Characters.Handling   *note A.3.5(13/3): 5758.
Is_String
   in Ada.Characters.Conversions   *note A.3.4(3/2): 5733.
Is_Subset
   in Ada.Containers.Hashed_Sets   *note A.18.8(39/2): 7077.
   in Ada.Containers.Ordered_Sets   *note A.18.9(40/2): 7150.
   in Ada.Strings.Maps   *note A.4.2(14): 5792.
   in Ada.Strings.Wide_Maps   *note A.4.7(14): 5994.
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(14/2): 6033.
Is_Terminated
   in Ada.Task_Identification   *note C.7.1(4/3): 7715.
Is_Upper
   in Ada.Characters.Handling   *note A.3.2(4/3): 5465.
   in Ada.Wide_Characters.Handling   *note A.3.5(8/3): 5753.
Is_Wide_Character
   in Ada.Characters.Conversions   *note A.3.4(3/2): 5734.
Is_Wide_String
   in Ada.Characters.Conversions   *note A.3.4(3/2): 5735.
ISO 1989:2002   *note 1.2(4/2): 1097.
ISO 639-3:2007   *note 1.2(1.1/3): 1088.
ISO 8601:2004   *note 1.2(5.1/2): 1106.
ISO/IEC 10646:2011   *note 1.2(8/3): 1114, *note 3.5.2(2/3): 1704, *note
3.5.2(3/3): 1710, *note 3.5.2(4/3): 1712.
ISO/IEC 14882:2011   *note 1.2(9/3): 1117.
ISO/IEC 1539-1:2004   *note 1.2(3/2): 1094.
ISO/IEC 3166-1:2006   *note 1.2(4.1/3): 1100.
ISO/IEC 6429:1992   *note 1.2(5): 1103.
ISO/IEC 646:1991   *note 1.2(2): 1091.
ISO/IEC 8859-1:1998   *note 1.2(6/3): 1108.
ISO/IEC 9899:2011   *note 1.2(7/3): 1111.
ISO/IEC TR 19769:2004   *note 1.2(10/2): 1120.
ISO_646 subtype of Character
   in Ada.Characters.Handling   *note A.3.2(9): 5483.
ISO_646_Set
   in Ada.Strings.Maps.Constants   *note A.4.6(4): 5965.
issue
   an entry call   *note 9.5.3(8): 4105.
italics
   nongraphic characters   *note 3.5.2(2/3): 1706.
   pseudo-names of anonymous types   *note 3.2.1(7/2): 1392, *note
A.1(2): 5435.
   syntax rules   *note 1.1.4(14): 1065.
   terms introduced or defined   *note 1.3(1/2): 1122.
iterable container object   *note 5.5.1(11/3): 3231.
iterable container object for a loop   *note 5.5.2(12/3): 3257.
iterable container type   *note 5.5.1(11/3): 3229, *note N(21.3/3):
8919.
Iterate
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(45/2): 6867.
   in Ada.Containers.Hashed_Maps   *note A.18.5(37/2): 6950.
   in Ada.Containers.Hashed_Sets   *note A.18.8(49/2): 7086.
   in Ada.Containers.Multiway_Trees   *note A.18.10(42/3): 7235, *note
A.18.10(44/3): 7237.
   in Ada.Containers.Ordered_Maps   *note A.18.6(50/2): 7009.
   in Ada.Containers.Ordered_Sets   *note A.18.9(60/2): 7163.
   in Ada.Containers.Vectors   *note A.18.2(73/2): 6795.
   in Ada.Environment_Variables   *note A.17(8/3): 6706.
Iterate_Children
   in Ada.Containers.Multiway_Trees   *note A.18.10(68/3): 7261, *note
A.18.10(70/3): 7263.
Iterate_Subtree
   in Ada.Containers.Multiway_Trees   *note A.18.10(43/3): 7236, *note
A.18.10(45/3): 7238.
iteration cursor subtype   *note 5.5.1(6/3): 3220.
iteration_scheme   *note 5.5(3/3): 3195.
   used   *note 5.5(2): 3192, *note P: 9391.
iterator   *note N(21.4/3): 8920.
   array component   *note 5.5.2(3/3): 3246.
   container element   *note 5.5.2(3/3): 3248.
   forward   *note 5.5.2(4/3): 3252.
   generalized   *note 5.5.2(3/3): 3242.
   reverse   *note 5.5.2(4/3): 3250.
iterator object   *note 5.5.1(6/3): 3218.
iterator type   *note 5.5.1(6/3): 3216.
Iterator_Element aspect   *note 5.5.1(9/3): 3228.
Iterator_Interfaces
   child of Ada   *note 5.5.1(2/3): 3209.
iterator_specification   *note 5.5.2(2/3): 3235.
   used   *note 4.5.8(1/3): 2911, *note 5.5(3/3): 3198, *note P: 9334.



File: arm2012.info,  Node: J,  Next: K,  Prev: I,  Up: Index

J 
==



j
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(5): 8262.
   in Interfaces.Fortran   *note B.5(10): 7608.



File: arm2012.info,  Node: K,  Next: L,  Prev: J,  Up: Index

K 
==



Key
   in Ada.Containers.Hashed_Maps   *note A.18.5(13/2): 6920.
   in Ada.Containers.Hashed_Sets   *note A.18.8(51/2): 7088.
   in Ada.Containers.Ordered_Maps   *note A.18.6(12/2): 6971.
   in Ada.Containers.Ordered_Sets   *note A.18.9(64/2): 7167.
Kind
   in Ada.Directories   *note A.16(25/2): 6656, *note A.16(40/2): 6668.
known discriminants   *note 3.7(26): 1992.
known to be constrained   *note 3.3(23.1/3): 1470.
known to denote the same object   *note 6.4.1(6.5/3): 3479.
known to refer to the same object   *note 6.4.1(6.12/3): 3480.
known_discriminant_part   *note 3.7(4): 1971.
   used   *note 3.2.1(3/3): 1375, *note 3.7(2/2): 1969, *note 9.1(2/3):
3895, *note 9.4(2/3): 3957, *note P: 9543.



File: arm2012.info,  Node: L,  Next: M,  Prev: K,  Up: Index

L 
==



label   *note 5.1(7): 3143.
   used   *note 5.1(2/3): 3115, *note 5.1(3): 3119, *note P: 9353.
Landau symbol O(X)   *note A.18(3/2): 6711.
language
   interface to assembly   *note C.1(4/3): 7625.
   interface to non-Ada   *note B(1): 7380.
   in Ada.Locales   *note A.19(6/3): 7375.
Language code standard   *note 1.2(1.1/3): 1090.
language-defined categories
   [partial]   *note 3.2(10/2): 1367.
language-defined category
   of types   *note 3.2(2/2): 1334.
language-defined check   *note 11.5(2/3): 4611, *note 11.6(1/3): 4648.
language-defined class
   [partial]   *note 3.2(10/2): 1366.
   of types   *note 3.2(2/2): 1333.
Language-defined constants   *note Q.5(1/3): 9857.
Language-defined exceptions   *note Q.4(1/3): 9855.
Language-Defined Library Units   *note A(1): 5431.
Language-defined objects   *note Q.5(1/3): 9856.
Language-defined packages   *note Q.1(1/3): 9851.
Language-defined subprograms   *note Q.3(1/3): 9854.
Language-defined subtypes   *note Q.2(1/3): 9853.
Language-defined types   *note Q.2(1/3): 9852.
Language-defined values   *note Q.5(1/3): 9858.
Language_Code
   in Ada.Locales   *note A.19(4/4): 7371.
Language_Unknown
   in Ada.Locales   *note A.19(5/3): 7373.
Last
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(35/2): 6858.
   in Ada.Containers.Ordered_Maps   *note A.18.6(31/2): 6997.
   in Ada.Containers.Ordered_Sets   *note A.18.9(43/2): 7153.
   in Ada.Containers.Vectors   *note A.18.2(61/2): 6784.
   in Ada.Iterator_Interfaces   *note 5.5.1(4/3): 3214.
Last attribute   *note 3.5(13): 1614, *note 3.6.2(5): 1951.
last element
   of a hashed set   *note A.18.8(68/2): 7107.
   of a set   *note A.18.7(6/2): 7024.
   of an ordered set   *note A.18.9(81/3): 7186.
last node
   of a hashed map   *note A.18.5(46/2): 6957.
   of a map   *note A.18.4(6/2): 6895.
   of an ordered map   *note A.18.6(58/3): 7015.
Last(N) attribute   *note 3.6.2(6): 1953.
last_bit   *note 13.5.1(6): 5072.
   used   *note 13.5.1(3): 5067, *note P: 9830.
Last_Bit attribute   *note 13.5.2(4/2): 5085.
Last_Child
   in Ada.Containers.Multiway_Trees   *note A.18.10(62/3): 7255.
Last_Child_Element
   in Ada.Containers.Multiway_Trees   *note A.18.10(63/3): 7256.
Last_Element
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(36/2): 6859.
   in Ada.Containers.Ordered_Maps   *note A.18.6(32/2): 6998.
   in Ada.Containers.Ordered_Sets   *note A.18.9(44/2): 7154.
   in Ada.Containers.Vectors   *note A.18.2(62/2): 6785.
Last_Index
   in Ada.Containers.Vectors   *note A.18.2(60/2): 6783.
Last_Key
   in Ada.Containers.Ordered_Maps   *note A.18.6(33/2): 6999.
Last_Valid attribute   *note 3.5.5(7.3/4): 1781.
lateness   *note D.9(12): 7971.
Latin-1   *note 3.5.2(2/3): 1702.
Latin_1
   child of Ada.Characters   *note A.3.3(3): 5498.
Layout aspect   *note 13.5(1): 5050.
Layout_Error
   in Ada.IO_Exceptions   *note A.13(4): 6621.
   in Ada.Text_IO   *note A.10.1(85): 6527.
LC_A
   in Ada.Characters.Latin_1   *note A.3.3(13): 5562.
LC_A_Acute
   in Ada.Characters.Latin_1   *note A.3.3(25): 5698.
LC_A_Circumflex
   in Ada.Characters.Latin_1   *note A.3.3(25): 5699.
LC_A_Diaeresis
   in Ada.Characters.Latin_1   *note A.3.3(25): 5701.
LC_A_Grave
   in Ada.Characters.Latin_1   *note A.3.3(25): 5697.
LC_A_Ring
   in Ada.Characters.Latin_1   *note A.3.3(25): 5702.
LC_A_Tilde
   in Ada.Characters.Latin_1   *note A.3.3(25): 5700.
LC_AE_Diphthong
   in Ada.Characters.Latin_1   *note A.3.3(25): 5703.
LC_B
   in Ada.Characters.Latin_1   *note A.3.3(13): 5563.
LC_C
   in Ada.Characters.Latin_1   *note A.3.3(13): 5564.
LC_C_Cedilla
   in Ada.Characters.Latin_1   *note A.3.3(25): 5704.
LC_D
   in Ada.Characters.Latin_1   *note A.3.3(13): 5565.
LC_E
   in Ada.Characters.Latin_1   *note A.3.3(13): 5566.
LC_E_Acute
   in Ada.Characters.Latin_1   *note A.3.3(25): 5706.
LC_E_Circumflex
   in Ada.Characters.Latin_1   *note A.3.3(25): 5707.
LC_E_Diaeresis
   in Ada.Characters.Latin_1   *note A.3.3(25): 5708.
LC_E_Grave
   in Ada.Characters.Latin_1   *note A.3.3(25): 5705.
LC_F
   in Ada.Characters.Latin_1   *note A.3.3(13): 5567.
LC_G
   in Ada.Characters.Latin_1   *note A.3.3(13): 5568.
LC_German_Sharp_S
   in Ada.Characters.Latin_1   *note A.3.3(24): 5696.
LC_H
   in Ada.Characters.Latin_1   *note A.3.3(13): 5569.
LC_I
   in Ada.Characters.Latin_1   *note A.3.3(13): 5570.
LC_I_Acute
   in Ada.Characters.Latin_1   *note A.3.3(25): 5710.
LC_I_Circumflex
   in Ada.Characters.Latin_1   *note A.3.3(25): 5711.
LC_I_Diaeresis
   in Ada.Characters.Latin_1   *note A.3.3(25): 5712.
LC_I_Grave
   in Ada.Characters.Latin_1   *note A.3.3(25): 5709.
LC_Icelandic_Eth
   in Ada.Characters.Latin_1   *note A.3.3(26): 5713.
LC_Icelandic_Thorn
   in Ada.Characters.Latin_1   *note A.3.3(26): 5727.
LC_J
   in Ada.Characters.Latin_1   *note A.3.3(13): 5571.
LC_K
   in Ada.Characters.Latin_1   *note A.3.3(13): 5572.
LC_L
   in Ada.Characters.Latin_1   *note A.3.3(13): 5573.
LC_M
   in Ada.Characters.Latin_1   *note A.3.3(13): 5574.
LC_N
   in Ada.Characters.Latin_1   *note A.3.3(13): 5575.
LC_N_Tilde
   in Ada.Characters.Latin_1   *note A.3.3(26): 5714.
LC_O
   in Ada.Characters.Latin_1   *note A.3.3(13): 5576.
LC_O_Acute
   in Ada.Characters.Latin_1   *note A.3.3(26): 5716.
LC_O_Circumflex
   in Ada.Characters.Latin_1   *note A.3.3(26): 5717.
LC_O_Diaeresis
   in Ada.Characters.Latin_1   *note A.3.3(26): 5719.
LC_O_Grave
   in Ada.Characters.Latin_1   *note A.3.3(26): 5715.
LC_O_Oblique_Stroke
   in Ada.Characters.Latin_1   *note A.3.3(26): 5721.
LC_O_Tilde
   in Ada.Characters.Latin_1   *note A.3.3(26): 5718.
LC_P
   in Ada.Characters.Latin_1   *note A.3.3(14): 5577.
LC_Q
   in Ada.Characters.Latin_1   *note A.3.3(14): 5578.
LC_R
   in Ada.Characters.Latin_1   *note A.3.3(14): 5579.
LC_S
   in Ada.Characters.Latin_1   *note A.3.3(14): 5580.
LC_T
   in Ada.Characters.Latin_1   *note A.3.3(14): 5581.
LC_U
   in Ada.Characters.Latin_1   *note A.3.3(14): 5582.
LC_U_Acute
   in Ada.Characters.Latin_1   *note A.3.3(26): 5723.
LC_U_Circumflex
   in Ada.Characters.Latin_1   *note A.3.3(26): 5724.
LC_U_Diaeresis
   in Ada.Characters.Latin_1   *note A.3.3(26): 5725.
LC_U_Grave
   in Ada.Characters.Latin_1   *note A.3.3(26): 5722.
LC_V
   in Ada.Characters.Latin_1   *note A.3.3(14): 5583.
LC_W
   in Ada.Characters.Latin_1   *note A.3.3(14): 5584.
LC_X
   in Ada.Characters.Latin_1   *note A.3.3(14): 5585.
LC_Y
   in Ada.Characters.Latin_1   *note A.3.3(14): 5586.
LC_Y_Acute
   in Ada.Characters.Latin_1   *note A.3.3(26): 5726.
LC_Y_Diaeresis
   in Ada.Characters.Latin_1   *note A.3.3(26): 5728.
LC_Z
   in Ada.Characters.Latin_1   *note A.3.3(14): 5587.
Leading_Nonseparate
   in Interfaces.COBOL   *note B.4(23): 7567.
Leading_Part attribute   *note A.5.3(54): 6247.
Leading_Separate
   in Interfaces.COBOL   *note B.4(23): 7565.
leaf node
   of a tree   *note A.18.10(4/3): 7197.
Leap_Seconds_Count subtype of Integer
   in Ada.Calendar.Arithmetic   *note 9.6.1(11/2): 4175.
leaving   *note 7.6.1(3/2): 3693.
left   *note 7.6.1(3/2): 3694.
left parenthesis   *note 2.1(15/3): 1156.
Left_Angle_Quotation
   in Ada.Characters.Latin_1   *note A.3.3(21/3): 5642.
Left_Curly_Bracket
   in Ada.Characters.Latin_1   *note A.3.3(14): 5588.
Left_Parenthesis
   in Ada.Characters.Latin_1   *note A.3.3(8): 5540.
Left_Square_Bracket
   in Ada.Characters.Latin_1   *note A.3.3(12): 5556.
legal
   construct   *note 1.1.2(27): 1025.
   partition   *note 1.1.2(29): 1033.
legality rules   *note 1.1.2(27): 1022.
length
   of a dimension of an array   *note 3.6(13): 1915.
   of a list container   *note A.18.3(3/2): 6821.
   of a map   *note A.18.4(5/2): 6893.
   of a one-dimensional array   *note 3.6(13): 1916.
   of a set   *note A.18.7(5/2): 7022.
   of a vector container   *note A.18.2(2/2): 6721.
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(11/2): 6829.
   in Ada.Containers.Hashed_Maps   *note A.18.5(10/2): 6917.
   in Ada.Containers.Hashed_Sets   *note A.18.8(12/2): 7051.
   in Ada.Containers.Ordered_Maps   *note A.18.6(9/2): 6968.
   in Ada.Containers.Ordered_Sets   *note A.18.9(11/2): 7122.
   in Ada.Containers.Vectors   *note A.18.2(21/2): 6737.
   in Ada.Strings.Bounded   *note A.4.4(9): 5849.
   in Ada.Strings.Unbounded   *note A.4.5(6): 5905.
   in Ada.Text_IO.Editing   *note F.3.3(11): 8247.
   in Interfaces.COBOL   *note B.4(34): 7581, *note B.4(39): 7585, *note
B.4(44): 7589.
Length attribute   *note 3.6.2(9): 1959.
Length(N) attribute   *note 3.6.2(10): 1961.
Length_Check   *note 11.5(15): 4633.
   [partial]   *note 4.5.1(8): 2753, *note 4.6(37): 2977, *note 4.6(52):
3009.
Length_Error
   in Ada.Strings   *note A.4.1(5): 5774.
Length_Range subtype of Natural
   in Ada.Strings.Bounded   *note A.4.4(8): 5848.
less than operator   *note 4.4(1/3): 2601, *note 4.5.2(1): 2775.
less than or equal operator   *note 4.4(1/3): 2605, *note 4.5.2(1):
2779.
less-than sign   *note 2.1(15/3): 1171.
Less_Case_Insensitive
   child of Ada.Strings   *note A.4.10(13/3): 6060.
   child of Ada.Strings.Bounded   *note A.4.10(18/3): 6062.
   child of Ada.Strings.Fixed   *note A.4.10(16/3): 6061.
   child of Ada.Strings.Unbounded   *note A.4.10(21/3): 6063.
Less_Than_Sign
   in Ada.Characters.Latin_1   *note A.3.3(10): 5551.
letter
   a category of Character   *note A.3.2(24): 5490.
letter_lowercase   *note 2.1(9/2): 1132.
   used   *note 2.3(3/2): 1193, *note P: 8966.
letter_modifier   *note 2.1(9.2/2): 1134.
   used   *note 2.3(3/2): 1195, *note P: 8968.
letter_other   *note 2.1(9.3/2): 1135.
   used   *note 2.3(3/2): 1196, *note P: 8969.
Letter_Set
   in Ada.Strings.Maps.Constants   *note A.4.6(4): 5957.
letter_titlecase   *note 2.1(9.1/2): 1133.
   used   *note 2.3(3/2): 1194, *note P: 8967.
letter_uppercase   *note 2.1(8/2): 1131.
   used   *note 2.3(3/2): 1192, *note P: 8965.
level
   accessibility   *note 3.10.2(3/2): 2290.
   library   *note 3.10.2(23): 2305.
lexical element   *note 2.2(1): 1180.
lexicographic order   *note 4.5.2(26/3): 2800.
LF
   in Ada.Characters.Latin_1   *note A.3.3(5): 5510.
library   *note 10.1.4(9): 4417.
   [partial]   *note 10.1.1(9): 4348.
   informal introduction   *note 10(2): 4313.
   See also library level, library unit, library_item
library level   *note 3.10.2(23): 2304.
Library unit   *note 10.1(3): 4319, *note 10.1.1(9): 4347, *note N(22):
8921.
   informal introduction   *note 10(2): 4311.
   See also language-defined library units
library unit pragma   *note 10.1.5(7/3): 4422.
   All_Calls_Remote   *note E.2.3(6): 8155.
   categorization pragmas   *note E.2(2/3): 8114.
   Elaborate_Body   *note 10.2.1(24): 4500.
   Preelaborate   *note 10.2.1(4): 4465.
   Pure   *note 10.2.1(15): 4482.
library_item   *note 10.1.1(4): 4329.
   informal introduction   *note 10(2): 4312.
   used   *note 10.1.1(3): 4326, *note P: 9653.
library_unit_body   *note 10.1.1(7): 4342.
   used   *note 10.1.1(4): 4331, *note P: 9657.
library_unit_declaration   *note 10.1.1(5): 4333.
   used   *note 10.1.1(4): 4330, *note P: 9656.
library_unit_renaming_declaration   *note 10.1.1(6): 4338.
   used   *note 10.1.1(4): 4332, *note P: 9658.
lifetime   *note 3.10.2(3/2): 2294.
limited interface   *note 3.9.4(5/2): 2210.
limited type   *note 7.5(3/3): 3645, *note N(23/2): 8923.
   becoming nonlimited   *note 7.3.1(5/1): 3623, *note 7.5(16): 3651.
   immutably   *note 7.5(8.1/3): 3648.
limited view   *note 10.1.1(12.1/2): 4365.
Limited_Controlled
   in Ada.Finalization   *note 7.6(7/2): 3666.
limited_with_clause   *note 10.1.2(4.1/2): 4376.
   used   *note 10.1.2(4/2): 4374, *note P: 9672.
line   *note 2.2(2/3): 1182.
   in Ada.Text_IO   *note A.10.1(38): 6440.
line terminator   *note A.10(7): 6364.
Line_Length
   in Ada.Text_IO   *note A.10.1(25): 6415.
link name   *note B.1(35): 7412.
link-time error
   See post-compilation error   *note 1.1.2(29): 1031.
   See post-compilation error   *note 1.1.5(4): 1074.
Link_Name aspect   *note B.1(1/3): 7389.
Linker_Options pragma   *note B.1(8): 7400, *note L(19): 8784.
linking
   See partition building   *note 10.2(2): 4447.
List
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(6/3): 6823.
list container   *note A.18.3(1/2): 6818.
List pragma   *note 2.8(21): 1282, *note L(20): 8787.
List_Iterator_Interfaces
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(9.2/3): 6828.
literal   *note 4.2(1): 2476.
   based   *note 2.4.2(1): 1223.
   decimal   *note 2.4.1(1): 1210.
   numeric   *note 2.4(1): 1204.
   See also aggregate   *note 4.3(1): 2493.
little endian   *note 13.5.3(2): 5093.
load time   *note C.4(3): 7676.
local to   *note 8.1(14): 3719.
local_name   *note 13.1(3): 4877.
   used   *note 13.3(2): 4949, *note 13.4(2): 5039, *note 13.5.1(2):
5060, *note 13.5.1(3): 5064, *note C.5(3): 7683, *note J.15.2(2/3):
8540, *note J.15.3(2/3): 8546, *note J.15.5(2/3): 8567, *note
J.15.5(3/3): 8573, *note J.15.5(4/3): 8579, *note J.15.6(2/3): 8587,
*note J.15.8(2/3): 8599, *note J.15.8(3/3): 8602, *note J.15.8(4/3):
8605, *note J.15.8(5/3): 8608, *note J.15.8(6/3): 8611, *note
J.15.8(7/3): 8614, *note J.15.13(2/3): 8647, *note L(3.1/3): 8713, *note
L(4.1/3): 8716, *note L(5.1/3): 8719, *note L(8.1/3): 8727, *note L(9):
8738, *note L(13.1/3): 8755, *note L(14.1/3): 8761, *note L(14.2/3):
8766, *note L(14.3/3): 8769, *note L(21.2/3): 8795, *note L(24.1/3):
8803, *note L(37.2/3): 8860, *note L(38.1/3): 8866, *note L(39.1/3):
8869, *note P: 9815.
locale   *note A.19(1/3): 7369.
   active   *note A.19(8/3): 7378.
Locales
   child of Ada   *note A.19(3/3): 7370.
locking policy   *note D.3(6/2): 7838.
   Ceiling_Locking   *note D.3(7): 7842.
Locking_Policy pragma   *note D.3(3): 7832, *note L(21): 8790.
Log
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(3): 8287.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(4): 6113.
Logical
   in Interfaces.Fortran   *note B.5(7): 7603.
logical operator   *note 4.5.1(2): 2743.
   See also not operator   *note 4.5.6(3): 2865.
logical_operator   *note 4.5(2): 2724.
long
   in Interfaces.C   *note B.3(7): 7439.
Long_Binary
   in Interfaces.COBOL   *note B.4(10): 7549.
long_double
   in Interfaces.C   *note B.3(17): 7450.
Long_Float   *note 3.5.7(15): 1818, *note 3.5.7(16): 1820, *note
3.5.7(17): 1821.
Long_Floating
   in Interfaces.COBOL   *note B.4(9): 7547.
Long_Integer   *note 3.5.4(22): 1761, *note 3.5.4(25): 1762, *note
3.5.4(28): 1766.
Look_Ahead
   in Ada.Text_IO   *note A.10.1(43): 6448.
loop cursor   *note 5.5.2(12/3): 3259.
loop iterator   *note 5.5.2(10/3): 3254.
   container element iterator   *note 5.5.2(12/3): 3258.
loop parameter   *note 5.5(6): 3202, *note 5.5.2(7/3): 3253.
loop_parameter_specification   *note 5.5(4): 3199.
   used   *note 4.5.8(1/3): 2908, *note 5.5(3/3): 3197, *note P: 9395.
loop_statement   *note 5.5(2): 3190.
   used   *note 5.1(5/2): 3137, *note P: 9371.
low line   *note 2.1(15/3): 1174.
low-level programming   *note C(1): 7618.
Low_Line
   in Ada.Characters.Latin_1   *note A.3.3(12): 5560.
Low_Order_First   *note 13.5.3(2): 5092.
   in Interfaces.COBOL   *note B.4(25): 7571.
   in System   *note 13.7(15/2): 5125.
lower bound
   of a range   *note 3.5(4): 1592.
lower-case letter
   a category of Character   *note A.3.2(25): 5491.
Lower_Case_Map
   in Ada.Strings.Maps.Constants   *note A.4.6(5): 5966.
Lower_Set
   in Ada.Strings.Maps.Constants   *note A.4.6(4): 5958.



File: arm2012.info,  Node: M,  Next: N,  Prev: L,  Up: Index

M 
==



Machine attribute   *note A.5.3(60): 6252.
machine code insertion   *note 13.8(1): 5148, *note C.1(2): 7623.
machine numbers
   of a fixed point type   *note 3.5.9(8/2): 1847.
   of a floating point type   *note 3.5.7(8): 1806.
machine scalar   *note 13.3(8.1/3): 4977.
Machine_Code
   child of System   *note 13.8(7): 5153.
Machine_Emax attribute   *note A.5.3(8): 6189.
Machine_Emin attribute   *note A.5.3(7): 6187.
Machine_Mantissa attribute   *note A.5.3(6): 6185.
Machine_Overflows attribute   *note A.5.3(12): 6199, *note A.5.4(4):
6277.
Machine_Radix aspect   *note F.1(1): 8222.
Machine_Radix attribute   *note A.5.3(2): 6182, *note A.5.4(2): 6273.
Machine_Radix clause   *note 13.3(7/2): 4973, *note F.1(1): 8220.
Machine_Rounding attribute   *note A.5.3(41.1/2): 6227.
Machine_Rounds attribute   *note A.5.3(11): 6197, *note A.5.4(3): 6275.
macro
   See generic unit   *note 12(1): 4665.
Macron
   in Ada.Characters.Latin_1   *note A.3.3(21/3): 5646.
main subprogram
   for a partition   *note 10.2(7): 4450.
malloc
   See allocator   *note 4.8(1): 3041.
Map
   in Ada.Containers.Hashed_Maps   *note A.18.5(3/3): 6909.
   in Ada.Containers.Ordered_Maps   *note A.18.6(4/3): 6962.
map container   *note A.18.4(1/2): 6888.
Map_Iterator_Interfaces
   in Ada.Containers.Hashed_Maps   *note A.18.5(6.2/3): 6914.
   in Ada.Containers.Ordered_Maps   *note A.18.6(7.2/3): 6967.
Maps
   child of Ada.Strings   *note A.4.2(3/2): 5783.
mark_non_spacing   *note 2.1(9.4/2): 1136, *note 2.1(9.5/2): 1137.
   used   *note 2.3(3.1/3): 1199, *note P: 8971.
mark_spacing_combining
   used   *note 2.3(3.1/3): 1200, *note P: 8972.
marshalling   *note E.4(9): 8183.
Masculine_Ordinal_Indicator
   in Ada.Characters.Latin_1   *note A.3.3(22): 5659.
master   *note 7.6.1(3/2): 3695.
master of a call   *note 3.10.2(10.1/3): 2297.
match
   a character to a pattern character   *note A.4.2(54): 5804.
   a character to a pattern character, with respect to a character
mapping function   *note A.4.2(64): 5806.
   a string to a pattern string   *note A.4.2(54): 5805.
   value of nonoverridable aspect   *note 13.1.1(18.3/4): 4929.
matching components   *note 4.5.2(16): 2798.
Max attribute   *note 3.5(19): 1623.
Max_Alignment_For_Allocation attribute   *note 13.11.1(4/3): 5222.
Max_Asynchronous_Select_Nesting restriction   *note D.7(18/1): 7926.
Max_Base_Digits   *note 3.5.7(6): 1804.
   in System   *note 13.7(8): 5112.
Max_Binary_Modulus   *note 3.5.4(7): 1732.
   in System   *note 13.7(7): 5110.
Max_Decimal_Digits
   in Ada.Decimal   *note F.2(5): 8228.
Max_Delta
   in Ada.Decimal   *note F.2(4): 8227.
Max_Digits   *note 3.5.7(6): 1805.
   in System   *note 13.7(8): 5113.
Max_Digits_Binary
   in Interfaces.COBOL   *note B.4(11): 7550.
Max_Digits_Long_Binary
   in Interfaces.COBOL   *note B.4(11): 7551.
Max_Entry_Queue_Length restriction   *note D.7(19.1/2): 7936.
Max_Image_Width
   in Ada.Numerics.Discrete_Random   *note A.5.2(25): 6168.
   in Ada.Numerics.Float_Random   *note A.5.2(13): 6156.
Max_Int   *note 3.5.4(14): 1745.
   in System   *note 13.7(6): 5109.
Max_Length
   in Ada.Strings.Bounded   *note A.4.4(5): 5845.
Max_Mantissa
   in System   *note 13.7(9): 5114.
Max_Nonbinary_Modulus   *note 3.5.4(7): 1733.
   in System   *note 13.7(7): 5111.
Max_Picture_Length
   in Ada.Text_IO.Editing   *note F.3.3(8): 8240.
Max_Protected_Entries restriction   *note D.7(14): 7917.
Max_Scale
   in Ada.Decimal   *note F.2(3): 8224.
Max_Select_Alternatives restriction   *note D.7(12): 7913.
Max_Size_In_Storage_Elements attribute   *note 13.11.1(3/3): 5220.
Max_Storage_At_Blocking restriction   *note D.7(17/1): 7921.
Max_Task_Entries restriction   *note D.7(13): 7915.
Max_Tasks restriction   *note D.7(19/1): 7931.
maximum box error
   for a component of the result of evaluating a complex function  
*note G.2.6(3): 8366.
maximum line length   *note A.10(11): 6372.
maximum page length   *note A.10(11): 6373.
maximum relative error
   for a component of the result of evaluating a complex function  
*note G.2.6(3): 8365.
   for the evaluation of an elementary function   *note G.2.4(2): 8359.
Members
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(8/2): 8039.
Membership
   in Ada.Strings   *note A.4.1(6): 5780.
membership test   *note 4.5.2(2/3): 2790.
membership_choice   *note 4.4(3.2/4): 2691.
   used   *note 4.4(3.1/3): 2689, *note P: 9294.
membership_choice_list   *note 4.4(3.1/3): 2688.
   used   *note 4.4(3/4): 2686, *note P: 9291.
Memory_Size
   in System   *note 13.7(13): 5121.
mentioned
   in a with_clause   *note 10.1.2(6/2): 4383.
Merge
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(50/2): 6872.
   in Ada.Containers.Vectors   *note A.18.2(78/2): 6800.
message
   See dispatching call   *note 3.9.2(1/2): 2156.
method
   See dispatching subprogram   *note 3.9.2(1/2): 2157.
metrics   *note 1.1.2(35): 1045.
Micro_Sign
   in Ada.Characters.Latin_1   *note A.3.3(22): 5653.
Microseconds
   in Ada.Real_Time   *note D.8(14/2): 7956.
Middle_Dot
   in Ada.Characters.Latin_1   *note A.3.3(22): 5656.
Milliseconds
   in Ada.Real_Time   *note D.8(14/2): 7957.
Min attribute   *note 3.5(16): 1621.
Min_Delta
   in Ada.Decimal   *note F.2(4): 8226.
Min_Handler_Ceiling
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(7/2): 8034.
   in Ada.Execution_Time.Timers   *note D.14.1(6/2): 8018.
Min_Int   *note 3.5.4(14): 1744.
   in System   *note 13.7(6): 5108.
Min_Scale
   in Ada.Decimal   *note F.2(3): 8225.
minus   *note 2.1(15/3): 1163.
minus operator   *note 4.4(1/3): 2623, *note 4.5.3(1): 2813, *note
4.5.4(1): 2836.
Minus_Sign
   in Ada.Characters.Latin_1   *note A.3.3(8): 5546.
Minute
   in Ada.Calendar.Formatting   *note 9.6.1(25/2): 4195.
Minute_Number subtype of Natural
   in Ada.Calendar.Formatting   *note 9.6.1(20/2): 4188.
Minutes
   in Ada.Real_Time   *note D.8(14/2): 7959.
mixed-language programs   *note B(1): 7381, *note C.1(4/3): 7626.
Mod attribute   *note 3.5.4(16.1/2): 1750.
mod operator   *note 4.4(1/3): 2642, *note 4.5.5(1): 2850.
mod_clause   *note J.8(1): 8516.
   used   *note 13.5.1(2): 5061, *note P: 9825.
mode   *note 6.1(16): 3328.
   used   *note 6.1(15/3): 3321, *note 12.4(2/3): 4743, *note P: 9438.
   in Ada.Direct_IO   *note A.8.4(9): 6334.
   in Ada.Sequential_IO   *note A.8.1(9): 6307.
   in Ada.Streams.Stream_IO   *note A.12.1(11): 6580.
   in Ada.Text_IO   *note A.10.1(12): 6389.
mode conformance   *note 6.3.1(16/3): 3430.
   required   *note 8.5.4(4/3): 3828, *note 8.5.4(5/3): 3831, *note
12.6(7/3): 4845, *note 12.6(8/3): 4846, *note 13.3(6): 4958.
mode of operation
   nonstandard   *note 1.1.5(11): 1081.
   standard   *note 1.1.5(11): 1083.
Mode_Error
   in Ada.Direct_IO   *note A.8.4(18): 6348.
   in Ada.IO_Exceptions   *note A.13(4): 6615.
   in Ada.Sequential_IO   *note A.8.1(15): 6316.
   in Ada.Streams.Stream_IO   *note A.12.1(26): 6596.
   in Ada.Text_IO   *note A.10.1(85): 6521.
Model attribute   *note A.5.3(68): 6266, *note G.2.2(7): 8350.
model interval   *note G.2.1(4): 8333.
   associated with a value   *note G.2.1(4): 8334.
model number   *note G.2.1(3): 8332.
model-oriented attributes
   of a floating point subtype   *note A.5.3(63): 6256.
Model_Emin attribute   *note A.5.3(65): 6260, *note G.2.2(4): 8343.
Model_Epsilon attribute   *note A.5.3(66): 6262.
Model_Mantissa attribute   *note A.5.3(64): 6258, *note G.2.2(3/2):
8341.
Model_Small attribute   *note A.5.3(67): 6264.
Modification_Time
   in Ada.Directories   *note A.16(27/2): 6658, *note A.16(42/2): 6670.
modular type   *note 3.5.4(1): 1719.
Modular_IO
   in Ada.Text_IO   *note A.10.1(57): 6472.
modular_type_definition   *note 3.5.4(4): 1727.
   used   *note 3.5.4(2): 1723, *note P: 9086.
module
   See package   *note 7(1): 3569.
modulus
   of a modular type   *note 3.5.4(7): 1731.
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(10/2): 8395,
*note G.3.2(30/2): 8408.
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(9): 8272.
Modulus attribute   *note 3.5.4(17): 1752.
Monday
   in Ada.Calendar.Formatting   *note 9.6.1(17/2): 4179.
Month
   in Ada.Calendar   *note 9.6(13): 4153.
   in Ada.Calendar.Formatting   *note 9.6.1(22/2): 4192.
Month_Number subtype of Integer
   in Ada.Calendar   *note 9.6(11/2): 4148.
More_Entries
   in Ada.Directories   *note A.16(34/2): 6664.
Move
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(18/2): 6841.
   in Ada.Containers.Hashed_Maps   *note A.18.5(18/2): 6932.
   in Ada.Containers.Hashed_Sets   *note A.18.8(18/2): 7060.
   in Ada.Containers.Indefinite_Holders   *note A.18.18(22/3): 7300.
   in Ada.Containers.Multiway_Trees   *note A.18.10(34/3): 7227.
   in Ada.Containers.Ordered_Maps   *note A.18.6(17/2): 6983.
   in Ada.Containers.Ordered_Sets   *note A.18.9(17/2): 7131.
   in Ada.Containers.Vectors   *note A.18.2(35/2): 6758.
   in Ada.Strings.Fixed   *note A.4.3(7): 5808.
multi-dimensional array   *note 3.6(12): 1912.
Multiplication_Sign
   in Ada.Characters.Latin_1   *note A.3.3(24): 5688.
multiply   *note 2.1(15/3): 1159.
multiply operator   *note 4.4(1/3): 2634, *note 4.5.5(1): 2842.
multiplying operator   *note 4.5.5(1): 2838.
multiplying_operator   *note 4.5(6): 2728.
   used   *note 4.4(5): 2702, *note P: 9303.
Multiprocessors
   child of System   *note D.16(3/3): 8070.
Multiway_Trees
   child of Ada.Containers   *note A.18.10(7/3): 7201.
mutates   *note 7.6(17.6/3): 3684.
MW
   in Ada.Characters.Latin_1   *note A.3.3(18): 5619.



File: arm2012.info,  Node: N,  Next: O,  Prev: M,  Up: Index

N 
==



n-dimensional array_aggregate   *note 4.3.3(6): 2561.
NAK
   in Ada.Characters.Latin_1   *note A.3.3(6): 5521.
name   *note 4.1(2/3): 2359.
   [partial]   *note 3.1(1): 1291.
   of (a view of) an entity   *note 3.1(8): 1318.
   of a pragma   *note 2.8(9): 1272.
   of an external file   *note A.7(1): 6281.
   used   *note 2.8(3/3): 1269, *note 3.2.2(4): 1409, *note 4.1(4):
2376, *note 4.1(5): 2379, *note 4.1(6): 2381, *note 4.1.5(4/3): 2456,
*note 4.4(7/3): 2713, *note 4.6(2): 2929, *note 4.8(2.1/3): 3049, *note
5.2(2): 3151, *note 5.5.2(2/3): 3237, *note 5.7(2): 3267, *note 5.8(2):
3272, *note 6.4(2): 3447, *note 6.4(3): 3451, *note 6.4(6): 3462, *note
8.4(3): 3778, *note 8.5.1(2/3): 3806, *note 8.5.2(2/3): 3814, *note
8.5.3(2/3): 3818, *note 8.5.4(2/3): 3825, *note 8.5.5(2/3): 3837, *note
9.5.3(2): 4093, *note 9.5.4(2/3): 4121, *note 9.8(2): 4279, *note
10.1.1(8): 4346, *note 10.1.2(4.1/2): 4378, *note 10.1.2(4.2/2): 4381,
*note 10.2.1(3): 4464, *note 10.2.1(14): 4481, *note 10.2.1(20): 4492,
*note 10.2.1(21): 4495, *note 10.2.1(22): 4499, *note 11.2(5): 4540,
*note 11.3(2.1/4): 4548, *note 11.3(2/2): 4545, *note 12.3(2/3): 4701,
*note 12.3(5): 4717, *note 12.6(4): 4842, *note 12.7(2/3): 4854, *note
13.1(3): 4881, *note 13.1.1(4/3): 4919, *note 13.3(2): 4951, *note
13.11.3(3.1/4): 5250, *note 13.12(4.1/2): 5299, *note E.2.1(3): 8126,
*note E.2.2(3): 8140, *note E.2.3(3): 8151, *note E.2.3(5): 8154, *note
H.3.2(3): 8443, *note J.10(3/2): 8524, *note J.15.1(2/3): 8535, *note
J.15.7(2/3): 8590, *note J.15.7(4/3): 8593, *note L(2): 8697, *note
L(6.1/3): 8722, *note L(10): 8744, *note L(11): 8748, *note L(12): 8751,
*note L(15.1/3): 8773, *note L(16): 8776, *note L(17.1/3): 8780, *note
L(26): 8814, *note L(28): 8828, *note L(30): 8836, *note L(31): 8839,
*note L(34): 8848, *note P: 9462.
   in Ada.Direct_IO   *note A.8.4(9): 6335.
   in Ada.Sequential_IO   *note A.8.1(9): 6308.
   in Ada.Streams.Stream_IO   *note A.12.1(11): 6581.
   in Ada.Text_IO   *note A.10.1(12): 6390.
   in System   *note 13.7(4): 5106.
name resolution rules   *note 1.1.2(26/3): 1019.
Name_Case_Equivalence
   in Ada.Directories   *note A.16(20.2/3): 6652.
Name_Case_Kind
   in Ada.Directories   *note A.16(20.1/3): 6651.
Name_Error
   in Ada.Direct_IO   *note A.8.4(18): 6349.
   in Ada.Directories   *note A.16(43/2): 6672.
   in Ada.IO_Exceptions   *note A.13(4): 6616.
   in Ada.Sequential_IO   *note A.8.1(15): 6317.
   in Ada.Streams.Stream_IO   *note A.12.1(26): 6597.
   in Ada.Text_IO   *note A.10.1(85): 6522.
named
   in a use clause   *note 8.4(7.1/2): 3784.
   in a with_clause   *note 10.1.2(6/2): 4385.
named association   *note 6.4(7): 3463, *note 6.4.1(2/3): 3471, *note
12.3(6): 4722.
named component association   *note 4.3.1(6): 2517.
named discriminant association   *note 3.7.1(4): 2008.
named entry index   *note 9.5.2(21): 4081.
named number   *note 3.3(24): 1472.
named parameter association   *note 6.4.1(2/3): 3473.
named type   *note 3.2.1(7/2): 1390.
named_array_aggregate   *note 4.3.3(4): 2554.
   used   *note 4.3.3(2): 2544, *note P: 9250.
Names
   child of Ada.Interrupts   *note C.3.2(12): 7670.
Nanoseconds
   in Ada.Real_Time   *note D.8(14/2): 7955.
Native_Binary
   in Interfaces.COBOL   *note B.4(25): 7572.
Natural   *note 3.5.4(12): 1741.
Natural subtype of Integer
   in Standard   *note A.1(13): 5439.
NBH
   in Ada.Characters.Latin_1   *note A.3.3(17): 5601.
NBSP
   in Ada.Characters.Latin_1   *note A.3.3(21/3): 5631.
needed
   of a compilation unit by another   *note 10.2(2): 4449.
   remote call interface   *note E.2.3(18): 8167.
   shared passive library unit   *note E.2.1(11): 8134.
needed component
   extension_aggregate record_component_association_list   *note
4.3.2(6): 2536.
   record_aggregate record_component_association_list   *note 4.3.1(9):
2520.
needs finalization   *note 7.6(9.1/2): 3670.
   language-defined type   *note A.4.5(72.1/2): 5953, *note
A.5.2(15.1/2): 6159, *note A.5.2(27.1/2): 6171, *note A.8.1(17/2): 6322,
*note A.8.4(20/2): 6354, *note A.10.1(86/2): 6528, *note A.12.1(27.1/2):
6602, *note A.16(102/2): 6684, *note A.18.2(147.3/3): 6807, *note
A.18.2(84/2): 6802, *note A.18.3(56/2): 6874, *note A.18.3(86.3/3):
6879, *note A.18.4(4/2): 6891, *note A.18.4(41.3/3): 6901, *note
A.18.7(4/2): 7021, *note A.18.7(36.2/3): 7030, *note A.18.7(96.2/3):
7033, *note A.18.10(124/3): 7270, *note A.18.10(73/3): 7265, *note
A.18.18(27/3): 7301, *note A.18.18(54/3): 7305, *note D.14.2(13/2):
8048, *note D.15(8/2): 8066.
NEL
   in Ada.Characters.Latin_1   *note A.3.3(17): 5603.
new
   See allocator   *note 4.8(1): 3040.
New_Char_Array
   in Interfaces.C.Strings   *note B.3.1(9): 7502.
New_Line
   in Ada.Text_IO   *note A.10.1(28): 6419.
New_Page
   in Ada.Text_IO   *note A.10.1(31): 6426.
New_String
   in Interfaces.C.Strings   *note B.3.1(10): 7503.
Next
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(37/2): 6860,
*note A.18.3(39/2): 6862.
   in Ada.Containers.Hashed_Maps   *note A.18.5(28/2): 6942, *note
A.18.5(29/2): 6943.
   in Ada.Containers.Hashed_Sets   *note A.18.8(41/2): 7079, *note
A.18.8(42/2): 7080.
   in Ada.Containers.Ordered_Maps   *note A.18.6(34/2): 7000, *note
A.18.6(35/2): 7001.
   in Ada.Containers.Ordered_Sets   *note A.18.9(45/2): 7155, *note
A.18.9(46/2): 7156.
   in Ada.Containers.Vectors   *note A.18.2(63/2): 6786, *note
A.18.2(64/2): 6787.
   in Ada.Iterator_Interfaces   *note 5.5.1(3/3): 3212.
Next_Sibling
   in Ada.Containers.Multiway_Trees   *note A.18.10(64/3): 7257, *note
A.18.10(66/3): 7259.
No_Abort_Statements restriction   *note D.7(5/3): 7879.
No_Access_Parameter_Allocators restriction   *note H.4(8.3/3): 8457.
No_Access_Subprograms restriction   *note H.4(17): 8467.
No_Allocators restriction   *note H.4(7): 8449.
No_Anonymous_Allocators restriction   *note H.4(8.1/3): 8453.
No_Break_Space
   in Ada.Characters.Latin_1   *note A.3.3(21/3): 5630.
No_Coextensions restriction   *note H.4(8.2/3): 8455.
No_Delay restriction   *note H.4(21): 8477.
No_Dependence restriction   *note 13.12.1(6/2): 5323.
No_Dispatch restriction   *note H.4(19): 8473.
No_Dynamic_Attachment restriction   *note D.7(10/3): 7890.
No_Dynamic_CPU_Assigmment restriction   *note D.7(10.1/4): 7892.
No_Dynamic_Priorities restriction   *note D.7(9/2): 7888.
No_Element
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(9/2): 6826.
   in Ada.Containers.Hashed_Maps   *note A.18.5(6/2): 6912.
   in Ada.Containers.Hashed_Sets   *note A.18.8(6/2): 7044.
   in Ada.Containers.Multiway_Trees   *note A.18.10(11/3): 7205.
   in Ada.Containers.Ordered_Maps   *note A.18.6(7/2): 6965.
   in Ada.Containers.Ordered_Sets   *note A.18.9(7/2): 7117.
   in Ada.Containers.Vectors   *note A.18.2(11/2): 6730.
No_Exceptions restriction   *note H.4(12): 8461.
No_Fixed_Point restriction   *note H.4(15): 8465.
No_Floating_Point restriction   *note H.4(14): 8463.
No_Implementation_Aspect_Specifications restriction   *note
13.12.1(1.1/3): 5311.
No_Implementation_Attributes restriction   *note 13.12.1(2/2): 5313.
No_Implementation_Identifiers restriction   *note 13.12.1(2.1/3): 5315.
No_Implementation_Pragmas restriction   *note 13.12.1(3/2): 5317.
No_Implementation_Units restriction   *note 13.12.1(3.1/3): 5319.
No_Implicit_Heap_Allocations restriction   *note D.7(8): 7886.
No_Index
   in Ada.Containers.Vectors   *note A.18.2(7/2): 6726.
No_IO restriction   *note H.4(20/2): 8475.
No_Local_Allocators restriction   *note H.4(8/1): 8451.
No_Local_Protected_Objects restriction   *note D.7(10.2/3): 7894.
No_Local_Timing_Events restriction   *note D.7(10.3/3): 7896.
No_Nested_Finalization restriction   *note D.7(4/3): 7877.
No_Obsolescent_Features restriction   *note 13.12.1(4/3): 5321.
No_Protected_Type_Allocators restriction   *note D.7(10.4/2): 7898.
No_Protected_Types restriction   *note H.4(5): 8447.
No_Recursion restriction   *note H.4(22): 8479.
No_Reentrancy restriction   *note H.4(23): 8481.
No_Relative_Delay restriction   *note D.7(10.6/3): 7901.
No_Requeue_Statements restriction   *note D.7(10.7/3): 7903.
No_Return aspect   *note 6.5.1(3.2/3): 3536.
No_Return pragma   *note J.15.2(2/3): 8539, *note L(21.2/3): 8793.
No_Select_Statements restriction   *note D.7(10.8/3): 7905.
No_Specific_Termination_Handlers restriction   *note D.7(10.9/3): 7907.
No_Specification_of_Aspect restriction   *note 13.12.1(6.1/3): 5325.
No_Standard_Allocators_After_Elaboration restriction   *note
D.7(19.2/3): 7939.
No_Tag
   in Ada.Tags   *note 3.9(6.1/2): 2102.
No_Task_Allocators restriction   *note D.7(7): 7883.
No_Task_Hierarchy restriction   *note D.7(3/3): 7875.
No_Task_Termination restriction   *note D.7(15.1/2): 7919.
No_Tasks_Unassigned_To_CPU restriction   *note D.7(10.10/4): 7909.
No_Terminate_Alternatives restriction   *note D.7(6): 7881.
No_Unchecked_Access restriction   *note H.4(18): 8469.
No_Use_Of_Attribute restriction   *note 13.12.1(6.2/3): 5327.
No_Use_Of_Pragma restriction   *note 13.12.1(6.3/3): 5329.
node
   of a list   *note A.18.3(2/2): 6820.
   of a map   *note A.18.4(5/2): 6892.
   of a tree   *note A.18.10(2/4): 7193.
Node_Count
   in Ada.Containers.Multiway_Trees   *note A.18.10(17/3): 7210.
nominal subtype   *note 3.3(23/3): 1465, *note 3.3.1(8/2): 1502.
   associated with a dereference   *note 4.1(9/3): 2384.
   associated with a type_conversion   *note 4.6(27): 2963.
   associated with an indexed_component   *note 4.1.1(5): 2399.
   of a component   *note 3.6(20): 1924.
   of a formal parameter   *note 6.1(23/2): 3336.
   of a function result   *note 6.1(23/2): 3337.
   of a generic formal object   *note 12.4(9/2): 4759.
   of a record component   *note 3.8(14): 2046.
   of the result of a function_call   *note 6.4(12/2): 3468.
Non_Preemptive
   child of Ada.Dispatching   *note D.2.4(2.2/3): 7806.
Non_Preemptive_FIFO_Within_Priorities task disp.  policy   *note
D.2.4(2/2): 7805.
nonconfirming
   aspect specification   *note 13.1(18.2/3): 4906.
   representation item   *note 13.1(18.2/3): 4905.
   representation value   *note 13.1(18.2/3): 4904.
nondispatching call
   on a dispatching operation   *note 3.9.2(1/2): 2148.
nonexistent   *note 13.11.2(10/4): 5231, *note 13.11.2(16/3): 5244.
nongraphic character   *note 3.5(27.5/2): 1641.
nonlimited interface   *note 3.9.4(5/2): 2211.
nonlimited type   *note 7.5(7): 3646.
   becoming nonlimited   *note 7.3.1(5/1): 3622, *note 7.5(16): 3650.
nonlimited_with_clause   *note 10.1.2(4.2/2): 4379.
   used   *note 10.1.2(4/2): 4375, *note P: 9673.
nonnormative
   See informative   *note 1.1.2(18): 1012.
nonoverridable
   aspect   *note 13.1.1(18.2/4): 4927.
nonreturning   *note 6.5.1(3.2/3): 3534.
nonstandard integer type   *note 3.5.4(26): 1764.
nonstandard mode   *note 1.1.5(11): 1082.
nonstandard real type   *note 3.5.6(8): 1793.
normal completion   *note 7.6.1(2/2): 3689.
normal library unit   *note E.2(4/3): 8121.
normal state of an object   *note 11.6(6/3): 4659, *note 13.9.1(4):
5166.
   [partial]   *note 9.8(21): 4293, *note A.13(17): 6623.
Normalize_Scalars pragma   *note H.1(3): 8432, *note L(22): 8797.
normalized exponent   *note A.5.3(14): 6202.
normalized number   *note A.5.3(10): 6193.
normative   *note 1.1.2(14): 1009.
not equal operator   *note 4.4(1/3): 2597, *note 4.5.2(1): 2771.
not in (membership test)   *note 4.4(1/3): 2616, *note 4.5.2(2/3): 2792.
not operator   *note 4.4(1/3): 2653, *note 4.5.6(3): 2863.
Not_A_Specific_CPU
   in System.Multiprocessors   *note D.16(4/3): 8072.
Not_Sign
   in Ada.Characters.Latin_1   *note A.3.3(21/3): 5643.
notes   *note 1.1.2(38): 1049.
notwithstanding   *note 7.6(17.5/3): 3683, *note 10.1.6(6/2): 4440,
*note 13.1.1(32/4): 4937, *note B.1(22/3): 7408, *note B.1(38/3): 7414,
*note C.3.1(19/3): 7658, *note E.2.1(8): 8131, *note E.2.1(11): 8135,
*note E.2.3(18): 8168, *note H.6(7/2): 8493, *note J.3(6): 8499.
   [partial]   *note J.15.5(8/3): 8582.
NUL
   in Ada.Characters.Latin_1   *note A.3.3(5): 5500.
   in Interfaces.C   *note B.3(20/1): 7452.
null access value   *note 4.2(9): 2486.
null array   *note 3.6.1(7): 1942.
null constraint   *note 3.2(7/2): 1352.
null extension   *note 3.9.1(4.1/2): 2144.
null pointer
   See null access value   *note 4.2(9): 2487.
null procedure   *note 6.7(3/3): 3548.
null range   *note 3.5(4): 1595.
null record   *note 3.8(15): 2047.
null slice   *note 4.1.2(7): 2415.
null string literal   *note 2.6(6): 1255.
null value
   of an access type   *note 3.10(13/2): 2267.
Null_Address
   in System   *note 13.7(12): 5118.
Null_Bounded_String
   in Ada.Strings.Bounded   *note A.4.4(7): 5847.
null_exclusion   *note 3.10(5.1/2): 2239.
   used   *note 3.2.2(3/2): 1405, *note 3.7(5/2): 1976, *note 3.10(2/2):
2230, *note 3.10(6/2): 2241, *note 6.1(13/2): 3312, *note 6.1(15/3):
3322, *note 8.5.1(2/3): 3800, *note 12.4(2/3): 4744, *note P: 9431.
Null_Id
   in Ada.Exceptions   *note 11.4.1(2/2): 4566.
Null_Occurrence
   in Ada.Exceptions   *note 11.4.1(3/2): 4572.
null_procedure_declaration   *note 6.7(2/3): 3543.
   used   *note 3.1(3/3): 1299, *note 9.4(8/4): 3985, *note P: 9015.
Null_Ptr
   in Interfaces.C.Strings   *note B.3.1(7): 7500.
Null_Set
   in Ada.Strings.Maps   *note A.4.2(5): 5785.
   in Ada.Strings.Wide_Maps   *note A.4.7(5): 5987.
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(5/2): 6026.
null_statement   *note 5.1(6): 3142.
   used   *note 5.1(4/2): 3122, *note P: 9357.
Null_Task_Id
   in Ada.Task_Identification   *note C.7.1(2/2): 7710.
Null_Unbounded_String
   in Ada.Strings.Unbounded   *note A.4.5(5): 5904.
number sign   *note 2.1(15/3): 1152.
Number_Base subtype of Integer
   in Ada.Text_IO   *note A.10.1(6): 6381.
number_decimal   *note 2.1(10/2): 1138.
   used   *note 2.3(3.1/3): 1201, *note P: 8973.
number_declaration   *note 3.3.2(2): 1523.
   used   *note 3.1(3/3): 1296, *note P: 9012.
number_letter   *note 2.1(10.1/2): 1139.
   used   *note 2.3(3/2): 1197, *note P: 8970.
Number_Of_CPUs
   in System.Multiprocessors   *note D.16(5/3): 8074.
Number_Sign
   in Ada.Characters.Latin_1   *note A.3.3(8): 5535.
numeral   *note 2.4.1(3): 1215.
   used   *note 2.4.1(2): 1212, *note 2.4.1(4): 1221, *note 2.4.2(3):
1239, *note P: 8989.
Numeric
   in Interfaces.COBOL   *note B.4(20/3): 7562.
numeric type   *note 3.5(1): 1584.
numeric_literal   *note 2.4(2): 1207.
   used   *note 4.4(7/3): 2710, *note P: 9309.
numerics   *note G(1): 8257.
   child of Ada   *note A.5(3/2): 6106.



File: arm2012.info,  Node: O,  Next: P,  Prev: N,  Up: Index

O 
==



O(f(N))   *note A.18(3/2): 6712.
object   *note 3.3(2): 1455, *note N(24): 8924.
   [partial]   *note 3.2(1): 1330.
object-oriented programming (OOP)
   See dispatching operations of tagged types   *note 3.9.2(1/2): 2154.
   See tagged types and type extensions   *note 3.9(1): 2084.
object_declaration   *note 3.3.1(2/3): 1479.
   used   *note 3.1(3/3): 1295, *note P: 9011.
object_renaming_declaration   *note 8.5.1(2/3): 3798.
   used   *note 8.5(2): 3790, *note P: 9509.
obsolescent feature   *note J(1/2): 8494.
occur immediately within   *note 8.1(13): 3714.
occurrence
   of an interrupt   *note C.3(2): 7631.
octal
   literal   *note 2.4.2(1): 1229.
octal literal   *note 2.4.2(1): 1227.
Old attribute   *note 6.1.1(26/4): 3371.
one's complement
   modular types   *note 3.5.4(27): 1765.
one-dimensional array   *note 3.6(12): 1911.
only as a completion
   entry_body   *note 9.5.2(16): 4072.
OOP (object-oriented programming)
   See dispatching operations of tagged types   *note 3.9.2(1/2): 2155.
   See tagged types and type extensions   *note 3.9(1): 2085.
opaque type
   See private types and private extensions   *note 7.3(1): 3597.
Open
   in Ada.Direct_IO   *note A.8.4(7): 6329.
   in Ada.Sequential_IO   *note A.8.1(7): 6302.
   in Ada.Streams.Stream_IO   *note A.12.1(9): 6575.
   in Ada.Text_IO   *note A.10.1(10): 6384.
open alternative   *note 9.7.1(14): 4235.
open entry   *note 9.5.3(5): 4095.
   of a protected object   *note 9.5.3(7/3): 4101.
   of a task   *note 9.5.3(6/3): 4099.
operand
   of a qualified_expression   *note 4.7(3): 3030.
   of a type_conversion   *note 4.6(3): 2931.
operand interval   *note G.2.1(6): 8335.
operand type
   of a type_conversion   *note 4.6(3): 2932.
operates on a type   *note 3.2.3(1/2): 1427.
operational aspect   *note 13.1(8.1/3): 4893.
   specifiable attributes   *note 13.3(5/3): 4957.
operational item   *note 13.1(1.1/1): 4871.
operator   *note 6.6(1): 3539.
   &   *note 4.4(1/3): 2626, *note 4.5.3(3): 2816.
   *   *note 4.4(1/3): 2633, *note 4.5.5(1): 2841.
   **   *note 4.4(1/3): 2647, *note 4.5.6(7): 2872.
   +   *note 4.4(1/3): 2618, *note 4.5.3(1): 2808, *note 4.5.4(1): 2831.
   -   *note 4.4(1/3): 2622, *note 4.5.3(1): 2812, *note 4.5.4(1): 2835.
   /   *note 4.4(1/3): 2639, *note 4.5.5(1): 2847.
   /=   *note 4.4(1/3): 2596, *note 4.5.2(1): 2770.
   <   *note 4.4(1/3): 2600, *note 4.5.2(1): 2774.
   <=   *note 4.4(1/3): 2604, *note 4.5.2(1): 2778.
   =   *note 4.4(1/3): 2592, *note 4.5.2(1): 2766.
   >   *note 4.4(1/3): 2608, *note 4.5.2(1): 2782.
   >=   *note 4.4(1/3): 2612, *note 4.5.2(1): 2786.
   abs   *note 4.4(1/3): 2651, *note 4.5.6(1): 2861.
   ampersand   *note 4.4(1/3): 2628, *note 4.5.3(3): 2818.
   and   *note 4.4(1/3): 2584, *note 4.5.1(2): 2746.
   binary   *note 4.5(9): 2733.
   binary adding   *note 4.5.3(1): 2806.
   concatenation   *note 4.4(1/3): 2630, *note 4.5.3(3): 2820.
   divide   *note 4.4(1/3): 2641, *note 4.5.5(1): 2849.
   equal   *note 4.4(1/3): 2594, *note 4.5.2(1): 2768.
   equality   *note 4.5.2(1): 2762.
   exponentiation   *note 4.4(1/3): 2649, *note 4.5.6(7): 2870.
   greater than   *note 4.4(1/3): 2610, *note 4.5.2(1): 2784.
   greater than or equal   *note 4.4(1/3): 2614, *note 4.5.2(1): 2788.
   highest precedence   *note 4.5.6(1): 2859.
   less than   *note 4.4(1/3): 2602, *note 4.5.2(1): 2776.
   less than or equal   *note 4.4(1/3): 2606, *note 4.5.2(1): 2780.
   logical   *note 4.5.1(2): 2744.
   minus   *note 4.4(1/3): 2624, *note 4.5.3(1): 2814, *note 4.5.4(1):
2837.
   mod   *note 4.4(1/3): 2643, *note 4.5.5(1): 2851.
   multiply   *note 4.4(1/3): 2635, *note 4.5.5(1): 2843.
   multiplying   *note 4.5.5(1): 2839.
   not   *note 4.4(1/3): 2654, *note 4.5.6(3): 2864.
   not equal   *note 4.4(1/3): 2598, *note 4.5.2(1): 2772.
   or   *note 4.4(1/3): 2586, *note 4.5.1(2): 2748.
   ordering   *note 4.5.2(1): 2764.
   plus   *note 4.4(1/3): 2620, *note 4.5.3(1): 2810, *note 4.5.4(1):
2833.
   predefined   *note 4.5(9): 2731.
   relational   *note 4.5.2(1): 2759.
   rem   *note 4.4(1/3): 2645, *note 4.5.5(1): 2853.
   times   *note 4.4(1/3): 2637, *note 4.5.5(1): 2845.
   unary   *note 4.5(9): 2735.
   unary adding   *note 4.5.4(1): 2829.
   user-defined   *note 6.6(1): 3541.
   xor   *note 4.4(1/3): 2588, *note 4.5.1(2): 2750.
operator precedence   *note 4.5(1): 2723.
operator_symbol   *note 6.1(9): 3304.
   used   *note 4.1(3): 2374, *note 4.1.3(3): 2424, *note 6.1(5): 3297,
*note 6.1(11): 3307, *note P: 9209.
optimization   *note 11.5(29): 4646, *note 11.6(1/3): 4652.
Optimize pragma   *note 2.8(23): 1287, *note L(23): 8799.
or else (short-circuit control form)   *note 4.4(1/3): 2590, *note
4.5.1(1): 2741.
or operator   *note 4.4(1/3): 2585, *note 4.5.1(2): 2747.
Ordered_Maps
   child of Ada.Containers   *note A.18.6(2/3): 6960.
Ordered_Sets
   child of Ada.Containers   *note A.18.9(2/3): 7112.
ordering operator   *note 4.5.2(1): 2763.
ordinary file   *note A.16(45/2): 6677.
ordinary fixed point type   *note 3.5.9(1): 1826, *note 3.5.9(8/2):
1848.
ordinary_fixed_point_definition   *note 3.5.9(3): 1832.
   used   *note 3.5.9(2): 1830, *note P: 9096.
OSC
   in Ada.Characters.Latin_1   *note A.3.3(19): 5627.
other_control   *note 2.1(13.1/2): 1147.
other_format   *note 2.1(10.3/2): 1141.
other_private_use   *note 2.1(13.2/2): 1148.
other_surrogate   *note 2.1(13.3/2): 1149.
output   *note A.6(1/2): 6279.
Output aspect   *note 13.13.2(38/4): 5385.
Output attribute   *note 13.13.2(19): 5358, *note 13.13.2(29): 5362.
Output clause   *note 13.3(7/2): 4972, *note 13.13.2(38/4): 5377.
Output'Class aspect   *note 13.13.2(38/4): 5393.
overall interpretation
   of a complete context   *note 8.6(10): 3850.
Overflow_Check   *note 11.5(16): 4634.
   [partial]   *note 3.5.4(20): 1754, *note 4.4(11): 2719, *note
4.5.7(21/3): 2902, *note 5.4(13): 3187, *note G.2.1(11): 8337, *note
G.2.2(7): 8351, *note G.2.3(25): 8355, *note G.2.4(2): 8360, *note
G.2.6(3): 8367.
Overlap
   in Ada.Containers.Hashed_Sets   *note A.18.8(38/2): 7076.
   in Ada.Containers.Ordered_Sets   *note A.18.9(39/2): 7149.
Overlaps_Storage attribute   *note 13.3(73.6/3): 5031.
overload resolution   *note 8.6(1/3): 3845.
overloadable   *note 8.3(7): 3747.
overloaded   *note 8.3(6): 3746.
   enumeration literal   *note 3.5.1(9): 1697.
overloading rules   *note 1.1.2(26/3): 1020, *note 8.6(2): 3846.
overridable   *note 8.3(9/1): 3751.
override   *note 8.3(9/1): 3750, *note 12.3(17): 4735.
   a primitive subprogram   *note 3.2.3(7/2): 1431.
   when implemented by   *note 9.1(9.2/3): 3919, *note 9.4(11.1/3):
3991.
overriding operation   *note N(24.1/2): 8925.
overriding_indicator   *note 8.3.1(2/2): 3772.
   used   *note 3.9.3(1.1/3): 2186, *note 6.1(2/3): 3282, *note
6.3(2/3): 3403, *note 6.7(2/3): 3544, *note 6.8(2/4): 3552, *note
8.5.4(2/3): 3823, *note 9.5.2(2/3): 4039, *note 10.1.3(3/3): 4393, *note
12.3(2/3): 4699, *note P: 9529.
Overwrite
   in Ada.Strings.Bounded   *note A.4.4(62): 5887, *note A.4.4(63):
5888.
   in Ada.Strings.Fixed   *note A.4.3(27): 5830, *note A.4.3(28): 5831.
   in Ada.Strings.Unbounded   *note A.4.5(57): 5941, *note A.4.5(58):
5942.



File: arm2012.info,  Node: P,  Next: Q,  Prev: O,  Up: Index

P 
==



Pack aspect   *note 13.2(5.1/3): 4940.
Pack pragma   *note J.15.3(2/3): 8545, *note L(24.1/3): 8802.
Package   *note 7(1): 3566, *note N(25): 8926.
package instance   *note 12.3(13): 4727.
package_body   *note 7.2(2/3): 3586.
   used   *note 3.11(6): 2341, *note 10.1.1(7): 4344, *note P: 9193.
package_body_stub   *note 10.1.3(4/3): 4396.
   used   *note 10.1.3(2): 4389, *note P: 9679.
package_declaration   *note 7.1(2): 3571.
   used   *note 3.1(3/3): 1301, *note 10.1.1(5): 4335, *note P: 9660.
package_renaming_declaration   *note 8.5.3(2/3): 3816.
   used   *note 8.5(2): 3792, *note 10.1.1(6): 4339, *note P: 9663.
package_specification   *note 7.1(3/3): 3573.
   used   *note 7.1(2): 3572, *note 12.1(4): 4676, *note P: 9482.
packed   *note 13.2(5.1/3): 4938.
Packed_Decimal
   in Interfaces.COBOL   *note B.4(12/3): 7553.
Packed_Format
   in Interfaces.COBOL   *note B.4(26): 7573.
Packed_Signed
   in Interfaces.COBOL   *note B.4(27): 7575.
Packed_Unsigned
   in Interfaces.COBOL   *note B.4(27): 7574.
padding bits   *note 13.1(7/2): 4885.
Page
   in Ada.Text_IO   *note A.10.1(39): 6442.
Page pragma   *note 2.8(22): 1285, *note L(25): 8805.
page terminator   *note A.10(7): 6365.
Page_Length
   in Ada.Text_IO   *note A.10.1(26): 6417.
Paragraph_Sign
   in Ada.Characters.Latin_1   *note A.3.3(22): 5655.
parallel processing
   See task   *note 9(1/3): 3877.
parameter
   explicitly aliased   *note 6.1(23.1/3): 3339.
   See formal parameter   *note 6.1(17): 3331.
   See generic formal parameter   *note 12(1): 4666.
   See also discriminant   *note 3.7(1/2): 1966.
   See also loop parameter   *note 5.5(6): 3203.
parameter assigning back   *note 6.4.1(17): 3490.
parameter copy back   *note 6.4.1(17): 3488.
parameter mode   *note 6.1(18/3): 3332.
parameter passing   *note 6.4.1(1): 3470.
parameter_and_result_profile   *note 6.1(13/2): 3310.
   used   *note 3.10(5): 2238, *note 3.10(6/2): 2246, *note 6.1(4.2/2):
3293, *note P: 9181.
parameter_association   *note 6.4(5): 3457.
   used   *note 6.4(4): 3456, *note P: 9458.
parameter_profile   *note 6.1(12): 3308.
   used   *note 3.10(5): 2237, *note 3.10(6/2): 2244, *note 6.1(4.1/2):
3290, *note 9.5.2(2/3): 4042, *note 9.5.2(3): 4047, *note 9.5.2(6):
4061, *note P: 9417.
parameter_specification   *note 6.1(15/3): 3319.
   used   *note 6.1(14): 3318, *note P: 9435.
Parameterless_Handler
   in Ada.Interrupts   *note C.3.2(2/3): 7661.
Params_Stream_Type
   in System.RPC   *note E.5(6): 8207.
parent   *note N(25.1/2): 8927.
   in Ada.Containers.Multiway_Trees   *note A.18.10(59/3): 7252.
parent body
   of a subunit   *note 10.1.3(8/2): 4408.
parent declaration
   of a library unit   *note 10.1.1(10): 4354.
   of a library_item   *note 10.1.1(10): 4353.
parent subtype   *note 3.4(3/2): 1537.
parent type   *note 3.4(3/2): 1538.
parent unit
   of a library unit   *note 10.1.1(10): 4356.
Parent_Tag
   in Ada.Tags   *note 3.9(7.2/2): 2110.
parent_unit_name   *note 10.1.1(8): 4345.
   used   *note 6.1(5): 3295, *note 6.1(7): 3302, *note 7.1(3/3): 3578,
*note 7.2(2/3): 3591, *note 10.1.3(7): 4406, *note P: 9487.
part
   of a type   *note 3.2(6/2): 1349.
   of an object or value   *note 3.2(6/2): 1348.
partial view
   of a type   *note 7.3(4): 3610.
partition   *note 10.2(2): 4444, *note N(26): 8928.
partition building   *note 10.2(2): 4445.
partition communication subsystem (PCS)   *note E.5(1/2): 8202.
Partition_Check
   [partial]   *note E.4(19): 8195.
Partition_Elaboration_Policy pragma   *note H.6(3/2): 8489, *note
L(25.1/2): 8807.
Partition_Id
   in System.RPC   *note E.5(4): 8205.
Partition_Id attribute   *note E.1(9): 8109.
pass by copy   *note 6.2(2): 3387.
pass by reference   *note 6.2(2): 3390.
passive partition   *note E.1(2): 8101.
Pattern_Error
   in Ada.Strings   *note A.4.1(5): 5775.
PCS (partition communication subsystem)   *note E.5(1/2): 8203.
Peak_Use
   in Ada.Containers.Bounded_Priority_Queues   *note A.18.31(7/3): 7368.
   in Ada.Containers.Bounded_Synchronized_Queues   *note A.18.29(6/3):
7354.
   in Ada.Containers.Synchronized_Queue_Interfaces   *note A.18.27(7/3):
7341.
   in Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(7/3):
7361.
   in Ada.Containers.Unbounded_Synchronized_Queues   *note A.18.28(6/3):
7348.
pending interrupt occurrence   *note C.3(2): 7634.
per-object constraint   *note 3.8(18/2): 2053.
per-object expression   *note 3.8(18/2): 2052.
percent sign   *note 2.1(15/3): 1178.
Percent_Sign
   in Ada.Characters.Latin_1   *note A.3.3(8): 5537.
perfect result set   *note G.2.3(5): 8353.
perform indefinite insertion   *note A.18(6/4): 6714.
periodic task
   example   *note 9.6(39): 4167.
   See delay_until_statement   *note 9.6(39): 4168.
Pi
   in Ada.Numerics   *note A.5(3/2): 6108.
Pic_String
   in Ada.Text_IO.Editing   *note F.3.3(7): 8238.
Picture
   in Ada.Text_IO.Editing   *note F.3.3(4): 8235.
picture String
   for edited output   *note F.3.1(1/3): 8231.
Picture_Error
   in Ada.Text_IO.Editing   *note F.3.3(9): 8241.
Pilcrow_Sign
   in Ada.Characters.Latin_1   *note A.3.3(22): 5654.
plain_char
   in Interfaces.C   *note B.3(11): 7445.
plane
   character   *note 2.1(1/3): 1128.
PLD
   in Ada.Characters.Latin_1   *note A.3.3(17): 5609.
PLU
   in Ada.Characters.Latin_1   *note A.3.3(17): 5610.
plus operator   *note 4.4(1/3): 2619, *note 4.5.3(1): 2809, *note
4.5.4(1): 2832.
plus sign   *note 2.1(15/3): 1160.
Plus_Minus_Sign
   in Ada.Characters.Latin_1   *note A.3.3(22): 5649.
Plus_Sign
   in Ada.Characters.Latin_1   *note A.3.3(8): 5543.
PM
   in Ada.Characters.Latin_1   *note A.3.3(19): 5628.
point   *note 2.1(15/3): 1166.
Pointer
   in Interfaces.C.Pointers   *note B.3.2(5): 7519.
   See access value   *note 3.10(1): 2225.
   See type System.Address   *note 13.7(34/2): 5131.
pointer type
   See access type   *note 3.10(1): 2226.
Pointer_Error
   in Interfaces.C.Pointers   *note B.3.2(8): 7522.
Pointers
   child of Interfaces.C   *note B.3.2(4): 7518.
polymorphism   *note 3.9(1): 2080, *note 3.9.2(1/2): 2151.
pool
   default   *note 13.11.3(4.2/4): 5253.
   subpool   *note 13.11.4(18/3): 5270.
pool element   *note 3.10(7/1): 2252, *note 13.11(11): 5195.
pool type   *note 13.11(11): 5193.
pool-specific access type   *note 3.10(7/1): 2249, *note 3.10(8): 2253.
Pool_of_Subpool
   in System.Storage_Pools.Subpools   *note 13.11.4(9/3): 5261.
Pos attribute   *note 3.5.5(2): 1771.
position   *note 13.5.1(4): 5068.
   used   *note 13.5.1(3): 5065, *note P: 9828.
Position attribute   *note 13.5.2(2/2): 5081.
position number   *note 3.5(1): 1583.
   of an enumeration value   *note 3.5.1(7): 1696.
   of an integer value   *note 3.5.4(15): 1748.
positional association   *note 6.4(7): 3464, *note 6.4.1(2/3): 3472,
*note 12.3(6): 4723.
positional component association   *note 4.3.1(6): 2518.
positional discriminant association   *note 3.7.1(4): 2009.
positional parameter association   *note 6.4.1(2/3): 3474.
positional_array_aggregate   *note 4.3.3(3/2): 2545.
   used   *note 4.3.3(2): 2543, *note P: 9249.
Positive   *note 3.5.4(12): 1742.
Positive subtype of Integer
   in Standard   *note A.1(13): 5440.
Positive_Count subtype of Count
   in Ada.Direct_IO   *note A.8.4(4): 6327.
   in Ada.Streams.Stream_IO   *note A.12.1(7): 6573.
   in Ada.Text_IO   *note A.10.1(5): 6378.
possible interpretation   *note 8.6(14): 3851.
   for direct_names   *note 8.3(24): 3768.
   for selector_names   *note 8.3(24): 3769.
Post aspect   *note 6.1.1(4/3): 3356.
Post'Class aspect   *note 6.1.1(5/3): 3360.
post-compilation error   *note 1.1.2(29): 1029.
post-compilation rules   *note 1.1.2(29): 1030.
postcondition   *note N(26.1/3): 8929.
postcondition check   *note 6.1.1(35/3): 3382.
postcondition expression
   class-wide   *note 6.1.1(5/3): 3358.
   specific   *note 6.1.1(4/3): 3354.
potentially blocking operation   *note 9.5.1(8): 4035.
   Abort_Task   *note C.7.1(16): 7723.
   delay_statement   *note 9.6(34): 4165, *note D.9(5): 7969.
   remote subprogram call   *note E.4(17): 8190.
   RPC operations   *note E.5(23): 8216.
   Suspend_Until_True   *note D.10(10): 7981.
potentially unevaluated expression   *note 6.1.1(20/3): 3369.
potentially use-visible   *note 8.4(8/3): 3785.
   [partial]   *note 12.6(9.2/3): 4849.
Pound_Sign
   in Ada.Characters.Latin_1   *note A.3.3(21/3): 5634.
Pragma   *note 2.8(1): 1258, *note 2.8(2): 1259, *note L(1): 8694, *note
N(27): 8930.
pragma argument   *note 2.8(9): 1274.
pragma name   *note 2.8(9): 1273.
pragma, categorization   *note E.2(2/3): 8113.
   Remote_Call_Interface   *note E.2.3(2): 8148.
   Remote_Types   *note E.2.2(2): 8137.
   Shared_Passive   *note E.2.1(2): 8123.
pragma, configuration   *note 10.1.5(8): 4427.
   Assertion_Policy   *note 11.4.2(7/3): 4603.
   Detect_Blocking   *note H.5(4/2): 8487.
   Discard_Names   *note C.5(4): 7685.
   Locking_Policy   *note D.3(5): 7837.
   Normalize_Scalars   *note H.1(4): 8434.
   Partition_Elaboration_Policy   *note H.6(5/2): 8492.
   Priority_Specific_Dispatching   *note D.2.2(5/2): 7795.
   Profile   *note 13.12(14/3): 5309.
   Queuing_Policy   *note D.4(5): 7858.
   Restrictions   *note 13.12(8/3): 5303.
   Reviewable   *note H.3.1(4): 8439.
   Suppress   *note 11.5(5/2): 4624.
   Task_Dispatching_Policy   *note D.2.2(5/2): 7793.
   Unsuppress   *note 11.5(5/2): 4626.
pragma, identifier specific to   *note 2.8(10/3): 1277.
pragma, interfacing
   Convention   *note J.15.5(1/3): 8557.
   Export   *note J.15.5(1/3): 8555.
   Import   *note J.15.5(1/3): 8553.
pragma, library unit   *note 10.1.5(7/3): 4423.
   All_Calls_Remote   *note E.2.3(6): 8156.
   categorization pragmas   *note E.2(2/3): 8115.
   Elaborate_Body   *note 10.2.1(24): 4501.
   Preelaborate   *note 10.2.1(4): 4466.
   Pure   *note 10.2.1(15): 4483.
pragma, program unit   *note 10.1.5(2): 4420.
   Inline   *note J.15.1(1/3): 8531.
   library unit pragmas   *note 10.1.5(7/3): 4425.
pragma, representation   *note 13.1(1/1): 4870.
   Asynchronous   *note J.15.13(1/3): 8644.
   Atomic   *note J.15.8(9/3): 8616.
   Atomic_Components   *note J.15.8(9/3): 8620.
   Convention   *note J.15.5(1/3): 8563.
   Discard_Names   *note C.5(6): 7687.
   Export   *note J.15.5(1/3): 8561.
   Import   *note J.15.5(1/3): 8559.
   Independent   *note J.15.8(9/3): 8624.
   Independent_Components   *note J.15.8(9/3): 8626.
   No_Return   *note J.15.2(1/3): 8537.
   Pack   *note J.15.3(1/3): 8543.
   Unchecked_Union   *note J.15.6(1/3): 8584.
   Volatile   *note J.15.8(9/3): 8618.
   Volatile_Components   *note J.15.8(9/3): 8622.
pragma_argument_association   *note 2.8(3/3): 1263.
   used   *note 2.8(2): 1261, *note 13.12(11/3): 5307, *note L(27.3/3):
8825, *note P: 8999.
pragmas
   All_Calls_Remote   *note E.2.3(5): 8152, *note L(2): 8695.
   Assert   *note 11.4.2(3/2): 4589, *note L(2.1/2): 8698.
   Assertion_Policy   *note 11.4.2(6.1/3): 4596, *note 11.4.2(6/2):
4593, *note L(2.2/2): 8702, *note L(2.3/3): 8705.
   Asynchronous   *note J.15.13(2/3): 8645, *note L(3.1/3): 8711.
   Atomic   *note J.15.8(2/3): 8597, *note L(4.1/3): 8714.
   Atomic_Components   *note J.15.8(5/3): 8606, *note L(5.1/3): 8717.
   Attach_Handler   *note J.15.7(4/3): 8591, *note L(6.1/3): 8720.
   Convention   *note J.15.5(4/3): 8576, *note L(8.1/3): 8724.
   CPU   *note J.15.9(2/3): 8627, *note L(8.2/3): 8728.
   Default_Storage_Pool   *note 13.11.3(3/3): 5246, *note L(8.3/3):
8731.
   Detect_Blocking   *note H.5(3/2): 8484, *note L(8.4/2): 8734.
   Discard_Names   *note C.5(3): 7681, *note L(9): 8736.
   Dispatching_Domain   *note J.15.10(2/3): 8631, *note L(9.1/3): 8739.
   Elaborate   *note 10.2.1(20): 4489, *note L(10): 8741.
   Elaborate_All   *note 10.2.1(21): 4493, *note L(11): 8745.
   Elaborate_Body   *note 10.2.1(22): 4497, *note L(12): 8749.
   Export   *note J.15.5(3/3): 8570, *note L(13.1/3): 8752.
   Import   *note J.15.5(2/3): 8564, *note L(14.1/3): 8758.
   Independent   *note J.15.8(4/3): 8603, *note L(14.2/3): 8764.
   Independent_Components   *note J.15.8(7/3): 8612, *note L(14.3/3):
8767.
   Inline   *note J.15.1(2/3): 8532, *note L(15.1/3): 8770.
   Inspection_Point   *note H.3.2(3): 8440, *note L(16): 8774.
   Interrupt_Handler   *note J.15.7(2/3): 8588, *note L(17.1/3): 8778.
   Interrupt_Priority   *note J.15.11(4/3): 8636, *note L(18.1/3): 8781.
   Linker_Options   *note B.1(8): 7399, *note L(19): 8783.
   List   *note 2.8(21): 1281, *note L(20): 8786.
   Locking_Policy   *note D.3(3): 7831, *note L(21): 8789.
   No_Return   *note J.15.2(2/3): 8538, *note L(21.2/3): 8792.
   Normalize_Scalars   *note H.1(3): 8431, *note L(22): 8796.
   Optimize   *note 2.8(23): 1286, *note L(23): 8798.
   Pack   *note J.15.3(2/3): 8544, *note L(24.1/3): 8801.
   Page   *note 2.8(22): 1284, *note L(25): 8804.
   Partition_Elaboration_Policy   *note H.6(3/2): 8488, *note L(25.1/2):
8806.
   Preelaborable_Initialization   *note 10.2.1(4.2/2): 4467, *note
L(25.2/2): 8809.
   Preelaborate   *note 10.2.1(3): 4462, *note L(26): 8812.
   Priority   *note J.15.11(2/3): 8634, *note L(27.1/3): 8815.
   Priority_Specific_Dispatching   *note D.2.2(3.2/2): 7787, *note
L(27.2/2): 8817.
   Profile   *note 13.12(11/3): 5304, *note L(27.3/3): 8822.
   Pure   *note 10.2.1(14): 4479, *note L(28): 8826.
   Queuing_Policy   *note D.4(3): 7852, *note L(29): 8829.
   Relative_Deadline   *note J.15.12(2/3): 8640, *note L(29.2/3): 8832.
   Remote_Call_Interface   *note E.2.3(3): 8149, *note L(30): 8834.
   Remote_Types   *note E.2.2(3): 8138, *note L(31): 8837.
   Restrictions   *note 13.12(3): 5290, *note L(32): 8840.
   Reviewable   *note H.3.1(3): 8436, *note L(33): 8844.
   Shared_Passive   *note E.2.1(3): 8124, *note L(34): 8846.
   Storage_Size   *note J.15.4(2/3): 8547, *note L(35.1/3): 8849.
   Suppress   *note 11.5(4/2): 4617, *note J.10(3/2): 8521, *note L(36):
8852.
   Task_Dispatching_Policy   *note D.2.2(3): 7784, *note L(37): 8855.
   Unchecked_Union   *note J.15.6(2/3): 8585, *note L(37.2/3): 8858.
   Unsuppress   *note 11.5(4.1/2): 4620, *note L(37.3/2): 8861.
   Volatile   *note J.15.8(3/3): 8600, *note L(38.1/3): 8864.
   Volatile_Components   *note J.15.8(6/3): 8609, *note L(39.1/3): 8867.
Pre aspect   *note 6.1.1(2/3): 3348.
Pre'Class aspect   *note 6.1.1(3/3): 3352.
precedence of operators   *note 4.5(1): 2722.
precondition   *note N(27.1/3): 8931.
precondition check
   class-wide   *note 6.1.1(33/3): 3379.
   specific   *note 6.1.1(32/3): 3376.
precondition expression
   class-wide   *note 6.1.1(3/3): 3350.
   specific   *note 6.1.1(2/3): 3346.
Pred attribute   *note 3.5(25): 1632.
predecessor element
   of an ordered set   *note A.18.9(81/3): 7188.
predecessor node
   of an ordered map   *note A.18.6(58/3): 7017.
predefined environment   *note A(1): 5432.
predefined exception   *note 11.1(4): 4518.
predefined library unit
   See language-defined library units
predefined operation
   of a type   *note 3.2.3(1/2): 1428.
predefined operations
   of a discrete type   *note 3.5.5(10/3): 1783.
   of a fixed point type   *note 3.5.10(17): 1884.
   of a floating point type   *note 3.5.8(3): 1824.
   of a record type   *note 3.8(24): 2057.
   of an access type   *note 3.10.2(35/2): 2323.
   of an array type   *note 3.6.2(15): 1962.
predefined operator   *note 4.5(9): 2730.
   [partial]   *note 3.2.1(9): 1396.
predefined type   *note 3.2.1(10): 1397.
   See language-defined types
predicate   *note 4.5.8(3/3): 2914, *note N(27.2/3): 8932.
   used   *note 4.5.8(1/3): 2909, *note P: 9332.
predicate aspect   *note 3.2.4(1/3): 1433.
predicate check
   allocator   *note 3.2.4(31/4): 1451.
   enabled   *note 3.2.4(7/3): 1443.
   in out parameters   *note 3.2.4(31/4): 1449.
   object_declaration   *note 3.2.4(31/4): 1450.
   subtype conversion   *note 4.6(51/4): 3006.
predicate specification   *note 3.2.4(1/3): 1434.
predicate-static   *note 3.2.4(15/3): 1444.
predicates satisfied   *note 3.2.4(29.2/4): 1448.
predicates satisfied required
   membership   *note 4.5.2(29/4): 2804.
   Valid attribute   *note 13.9.2(3/4): 5179, *note K.2(263/4): 8691.
preelaborable
   of an elaborable construct   *note 10.2.1(5): 4470.
preelaborable initialization   *note 10.2.1(11.1/2): 4477.
Preelaborable_Initialization pragma   *note 10.2.1(4.2/2): 4468, *note
L(25.2/2): 8810.
Preelaborate aspect   *note 10.2.1(11/3): 4474.
Preelaborate pragma   *note 10.2.1(3): 4463, *note L(26): 8813.
preelaborated   *note 10.2.1(11/3): 4476.
   [partial]   *note 10.2.1(11/3): 4472, *note E.2.1(9): 8132.
   implementation requirements   *note C.4(2): 7675.
preempt
   a running task   *note D.2.3(9/2): 7802.
preference
   for root numeric operators and ranges   *note 8.6(29): 3870.
   for universal access equality operators   *note 8.6(29.1/3): 3871.
preference control
   See requeue   *note 9.5.4(1): 4118.
prefix   *note 4.1(4): 2375.
   of a prefixed view   *note 4.1.3(9.2/3): 2427.
   used   *note 4.1.1(2): 2395, *note 4.1.2(2): 2408, *note 4.1.3(2):
2419, *note 4.1.4(2): 2435, *note 4.1.4(4): 2441, *note 4.1.6(10/3):
2469, *note 6.4(2): 3448, *note 6.4(3): 3452, *note P: 9228.
prefixed view   *note 4.1.3(9.2/3): 2426.
prefixed view profile   *note 6.3.1(24.1/2): 3442.
Prepend
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(22/2): 6845.
   in Ada.Containers.Vectors   *note A.18.2(44/2): 6767, *note
A.18.2(45/2): 6768.
Prepend_Child
   in Ada.Containers.Multiway_Trees   *note A.18.10(51/3): 7244.
prescribed result
   for the evaluation of a complex arithmetic operation   *note
G.1.1(42): 8284.
   for the evaluation of a complex elementary function   *note
G.1.2(35): 8311.
   for the evaluation of an elementary function   *note A.5.1(37): 6145.
Previous
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(38/2): 6861,
*note A.18.3(40/2): 6863.
   in Ada.Containers.Ordered_Maps   *note A.18.6(36/2): 7002, *note
A.18.6(37/2): 7003.
   in Ada.Containers.Ordered_Sets   *note A.18.9(47/2): 7157, *note
A.18.9(48/2): 7158.
   in Ada.Containers.Vectors   *note A.18.2(65/2): 6788, *note
A.18.2(66/2): 6789.
   in Ada.Iterator_Interfaces   *note 5.5.1(4/3): 3215.
Previous_Sibling
   in Ada.Containers.Multiway_Trees   *note A.18.10(65/3): 7258, *note
A.18.10(67/3): 7260.
primary   *note 4.4(7/3): 2709.
   used   *note 4.4(6): 2708, *note P: 9308.
primitive function   *note A.5.3(17): 6203.
primitive operation
   [partial]   *note 3.2(1): 1329.
primitive operations   *note N(28): 8933.
   of a type   *note 3.2.3(1/2): 1429.
primitive operator
   of a type   *note 3.2.3(8): 1432.
primitive subprograms
   of a type   *note 3.2.3(2): 1430.
priority   *note D.1(15): 7762.
   of a protected object   *note D.3(6/2): 7839.
Priority aspect   *note D.1(6.2/3): 7758.
Priority attribute   *note D.5.2(3/2): 7872.
priority inheritance   *note D.1(15): 7763.
priority inversion   *note D.2.3(11/2): 7803.
priority of an entry call   *note D.4(9): 7864.
Priority pragma   *note J.15.11(2/3): 8635, *note L(27.1/3): 8816.
Priority subtype of Any_Priority
   in System   *note 13.7(16): 5128.
Priority_Queuing queuing policy   *note D.4(8): 7863.
Priority_Specific_Dispatching pragma   *note D.2.2(3.2/2): 7788, *note
L(27.2/2): 8818.
private declaration of a library unit   *note 10.1.1(12): 4362.
private descendant
   of a library unit   *note 10.1.1(12): 4364.
private extension   *note 3.2(4.1/2): 1345, *note 3.9(2.1/2): 2091,
*note 3.9.1(1/2): 2139, *note N(29/2): 8934.
   [partial]   *note 7.3(14): 3617, *note 12.5.1(5/3): 4805.
private library unit   *note 10.1.1(12): 4361.
private operations   *note 7.3.1(1): 3620.
private part   *note 8.2(5): 3724.
   of a package   *note 7.1(6/2): 3583.
   of a protected unit   *note 9.4(11/2): 3990.
   of a task unit   *note 9.1(9): 3918.
private type   *note 3.2(4.1/2): 1344, *note N(30/2): 8935.
   [partial]   *note 7.3(14): 3616.
private types and private extensions   *note 7.3(1): 3595.
private_extension_declaration   *note 7.3(3/3): 3604.
   used   *note 3.2.1(2): 1372, *note P: 9026.
private_type_declaration   *note 7.3(2/3): 3600.
   used   *note 3.2.1(2): 1371, *note P: 9025.
procedure   *note 6(1): 3276, *note N(30.1/2): 8936.
   null   *note 6.7(3/3): 3549.
procedure instance   *note 12.3(13): 4729.
procedure_call_statement   *note 6.4(2): 3446.
   used   *note 5.1(4/2): 3126, *note 9.7.2(3.1/2): 4248, *note P: 9638.
procedure_or_entry_call   *note 9.7.2(3.1/2): 4247.
   used   *note 9.7.2(3/2): 4245, *note 9.7.4(4/2): 4262, *note P: 9646.
procedure_specification   *note 6.1(4.1/2): 3288.
   used   *note 6.1(4/2): 3286, *note 6.7(2/3): 3545, *note P: 9472.
processing node   *note E(2): 8095.
profile   *note 6.1(22): 3335.
   associated with a dereference   *note 4.1(10): 2385.
   fully conformant   *note 6.3.1(18/3): 3437.
   mode conformant   *note 6.3.1(16/3): 3431.
   No_Implementation_Extensions   *note 13.12.1(10/3): 5330.
   subtype conformant   *note 6.3.1(17/3): 3434.
   type conformant   *note 6.3.1(15/2): 3428.
Profile pragma   *note 13.12(11/3): 5305, *note L(27.3/3): 8823.
profile resolution rule
   name with a given expected profile   *note 8.6(26): 3865.
progenitor   *note N(30.2/2): 8937.
progenitor subtype   *note 3.9.4(9/2): 2219.
progenitor type   *note 3.9.4(9/2): 2220.
program   *note 10.2(1): 4441, *note N(31): 8938.
program execution   *note 10.2(1): 4442.
program library
   See library   *note 10(2): 4314.
   See library   *note 10.1.4(9): 4418.
Program unit   *note 10.1(1): 4317, *note N(32): 8939.
program unit pragma   *note 10.1.5(2): 4419.
   Inline   *note J.15.1(1/3): 8530.
   library unit pragmas   *note 10.1.5(7/3): 4424.
Program_Error
   raised by failure of run-time check   *note 1.1.3(20): 1059, *note
1.1.5(8): 1079, *note 1.1.5(12): 1085, *note 3.5.5(8): 1782, *note
3.10.2(30): 2314, *note 3.11(14): 2352, *note 4.6(57/4): 3017, *note
4.8(10.1/3): 3071, *note 4.8(10.2/2): 3074, *note 4.8(10.3/2): 3077,
*note 4.8(10.4/3): 3083, *note 6.2(12/3): 3401, *note 6.4(11/2): 3467,
*note 6.4.1(13.4/4): 3485, *note 6.5(8/4): 3525, *note 6.5(21/3): 3531,
*note 6.5.1(9/2): 3538, *note 7.6.1(15): 3707, *note 7.6.1(16/2): 3708,
*note 7.6.1(17): 3709, *note 7.6.1(17.2/1): 3710, *note 7.6.1(18/2):
3711, *note 8.5.4(8.1/1): 3833, *note 9.4(20): 4008, *note 9.5.1(17):
4037, *note 9.5.3(7/3): 4103, *note 9.7.1(21): 4239, *note 9.8(20/3):
4292, *note 10.2(26): 4458, *note 11.1(4): 4520, *note 11.5(19): 4637,
*note 12.5.1(23.3/2): 4809, *note 13.7.1(16): 5143, *note 13.9.1(9):
5173, *note 13.11.2(13): 5235, *note 13.11.2(14): 5237, *note
13.11.2(15.2/4): 5242, *note 13.11.4(27/3): 5282, *note 13.11.4(30/3):
5285, *note A.5.2(40.1/1): 6178, *note A.7(14/3): 6289, *note
B.3.3(22/2): 7542, *note C.3.1(10/3): 7650, *note C.3.1(11/3): 7654,
*note C.3.2(17/3): 7671, *note C.3.2(20): 7672, *note C.3.2(21/3): 7673,
*note C.3.2(22/2): 7674, *note C.7.1(15): 7722, *note C.7.1(17/3): 7726,
*note C.7.2(13): 7735, *note D.3(13): 7847, *note D.3(13.2/2): 7849,
*note D.3(13.4/2): 7850, *note D.5.1(9): 7869, *note D.5.2(6/3): 7873,
*note D.7(7.1/3): 7884, *note D.7(10.5/3): 7899, *note D.7(19.1/2):
7937, *note D.10(10): 7983, *note D.11(8): 7996, *note E.1(10/2): 8111,
*note E.3(6): 8177, *note E.4(18/1): 8194, *note J.7.1(7): 8513.
   in Standard   *note A.1(46): 5452.
prohibited
   tampering with a holder   *note A.18.18(35/4): 7303.
   tampering with a list   *note A.18.3(69.1/4): 6877.
   tampering with a map   *note A.18.4(15.1/4): 6899.
   tampering with a set   *note A.18.7(14.1/4): 7028.
   tampering with a tree   *note A.18.10(90/4): 7268.
   tampering with a vector   *note A.18.2(97.1/4): 6805.
propagate   *note 11.4(1): 4555.
   an exception occurrence by an execution, to a dynamically enclosing
execution   *note 11.4(6): 4560.
proper_body   *note 3.11(6): 2339.
   used   *note 3.11(5): 2337, *note 10.1.3(7): 4407, *note P: 9692.
protected action   *note 9.5.1(4/4): 4029.
   complete   *note 9.5.1(6): 4032.
   start   *note 9.5.1(5/4): 4030.
protected calling convention   *note 6.3.1(12/4): 3423.
protected declaration   *note 9.4(1): 3953.
protected entry   *note 9.4(1): 3950.
protected function   *note 9.5.1(1): 4024.
protected interface   *note 3.9.4(5/2): 2208.
protected object   *note 9(3): 3881, *note 9.4(1): 3947.
protected operation   *note 9.4(1): 3948.
protected procedure   *note 9.5.1(1): 4023.
protected subprogram   *note 9.4(1): 3949, *note 9.5.1(1): 4022.
protected tagged type   *note 3.9.4(6/2): 2218.
protected type   *note N(33/2): 8940.
protected unit   *note 9.4(1): 3952.
protected_body   *note 9.4(7/3): 3977.
   used   *note 3.11(6): 2343, *note P: 9195.
protected_body_stub   *note 10.1.3(6/3): 4402.
   used   *note 10.1.3(2): 4391, *note P: 9681.
protected_definition   *note 9.4(4): 3966.
   used   *note 9.4(2/3): 3960, *note 9.4(3/3): 3965, *note P: 9569.
protected_element_declaration   *note 9.4(6): 3974.
   used   *note 9.4(4): 3968, *note P: 9571.
protected_operation_declaration   *note 9.4(5/1): 3970.
   used   *note 9.4(4): 3967, *note 9.4(6): 3975, *note P: 9570.
protected_operation_item   *note 9.4(8/4): 3982.
   used   *note 9.4(7/3): 3980, *note P: 9580.
protected_type_declaration   *note 9.4(2/3): 3955.
   used   *note 3.2.1(3/3): 1379, *note P: 9032.
ptrdiff_t
   in Interfaces.C   *note B.3(12): 7446.
PU1
   in Ada.Characters.Latin_1   *note A.3.3(18): 5615.
PU2
   in Ada.Characters.Latin_1   *note A.3.3(18): 5616.
public declaration of a library unit   *note 10.1.1(12): 4360.
public descendant
   of a library unit   *note 10.1.1(12): 4363.
public library unit   *note 10.1.1(12): 4359.
punctuation_connector   *note 2.1(10.2/2): 1140.
   used   *note 2.3(3.1/3): 1202, *note P: 8974.
pure   *note 10.2.1(15.1/3): 4484.
Pure aspect   *note 10.2.1(17/3): 4487.
Pure pragma   *note 10.2.1(14): 4480, *note L(28): 8827.
Put
   in Ada.Text_IO   *note A.10.1(42): 6446, *note A.10.1(48): 6456,
*note A.10.1(55): 6471, *note A.10.1(60): 6480, *note A.10.1(66): 6488,
*note A.10.1(67): 6490, *note A.10.1(71): 6498, *note A.10.1(72): 6500,
*note A.10.1(76): 6508, *note A.10.1(77): 6510, *note A.10.1(82): 6517,
*note A.10.1(83): 6519.
   in Ada.Text_IO.Bounded_IO   *note A.10.11(4/2): 6538, *note
A.10.11(5/2): 6539.
   in Ada.Text_IO.Complex_IO   *note G.1.3(7): 8321, *note G.1.3(8):
8323.
   in Ada.Text_IO.Editing   *note F.3.3(14): 8250, *note F.3.3(15):
8251, *note F.3.3(16): 8252.
   in Ada.Text_IO.Unbounded_IO   *note A.10.12(4/2): 6547, *note
A.10.12(5/2): 6548.
Put_Line
   in Ada.Text_IO   *note A.10.1(50): 6461.
   in Ada.Text_IO.Bounded_IO   *note A.10.11(6/2): 6540, *note
A.10.11(7/2): 6541.
   in Ada.Text_IO.Unbounded_IO   *note A.10.12(6/2): 6549, *note
A.10.12(7/2): 6550.



File: arm2012.info,  Node: Q,  Next: R,  Prev: P,  Up: Index

Q 
==



qualified_expression   *note 4.7(2): 3025.
   used   *note 4.1(2/3): 2369, *note 4.8(2/3): 3047, *note 13.8(2):
5150, *note P: 9834.
quantified expressions   *note 4.5.8(5/3): 2917.
quantified_expression   *note 4.5.8(1/3): 2906.
   used   *note 4.4(7/3): 2717, *note P: 9316.
quantifier   *note 4.5.8(2/3): 2913.
   used   *note 4.5.8(1/3): 2910, *note P: 9333.
Query_Element
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(16/2): 6834.
   in Ada.Containers.Hashed_Maps   *note A.18.5(16/2): 6923.
   in Ada.Containers.Hashed_Sets   *note A.18.8(17/2): 7056.
   in Ada.Containers.Indefinite_Holders   *note A.18.18(14/3): 7292.
   in Ada.Containers.Multiway_Trees   *note A.18.10(26/3): 7219.
   in Ada.Containers.Ordered_Maps   *note A.18.6(15/2): 6974.
   in Ada.Containers.Ordered_Sets   *note A.18.9(16/2): 7127.
   in Ada.Containers.Vectors   *note A.18.2(31/2): 6747, *note
A.18.2(32/2): 6748.
Question
   in Ada.Characters.Latin_1   *note A.3.3(10): 5554.
Queue
   in Ada.Containers.Bounded_Priority_Queues   *note A.18.31(4/3): 7363.
   in Ada.Containers.Bounded_Synchronized_Queues   *note A.18.29(4/3):
7350.
   in Ada.Containers.Synchronized_Queue_Interfaces   *note A.18.27(4/3):
7337.
   in Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(4/3):
7356.
   in Ada.Containers.Unbounded_Synchronized_Queues   *note A.18.28(4/3):
7344.
queuing policy   *note D.4(1/3): 7851, *note D.4(6): 7859.
   FIFO_Queuing   *note D.4(7/2): 7860.
   Priority_Queuing   *note D.4(8): 7862.
Queuing_Policy pragma   *note D.4(3): 7853, *note L(29): 8830.
Quotation
   in Ada.Characters.Latin_1   *note A.3.3(8): 5534.
quotation mark   *note 2.1(15/3): 1151.
quoted string
   See string_literal   *note 2.6(1): 1249.



File: arm2012.info,  Node: R,  Next: S,  Prev: Q,  Up: Index

R 
==



raise
   an exception   *note 11(1/3): 4512.
   an exception   *note 11.3(4/4): 4551.
   an exception   *note N(18): 8907.
   an exception occurrence   *note 11.4(3): 4559.
Raise_Exception
   in Ada.Exceptions   *note 11.4.1(4/3): 4573.
raise_expression   *note 11.3(2.1/4): 4547.
   used   *note 4.4(3/4): 2687, *note P: 9292.
raise_statement   *note 11.3(2/2): 4544.
   used   *note 5.1(4/2): 3132, *note P: 9367.
Random
   in Ada.Numerics.Discrete_Random   *note A.5.2(20): 6162.
   in Ada.Numerics.Float_Random   *note A.5.2(8): 6150.
random number   *note A.5.2(1): 6146.
range   *note 3.5(3): 1587, *note 3.5(4): 1591.
   of a scalar subtype   *note 3.5(7): 1604.
   used   *note 3.5(2): 1586, *note 3.6(6): 1902, *note 3.6.1(3): 1937,
*note 3.8.1(5/3): 2071, *note 4.4(3.2/4): 2693, *note P: 9076.
Range attribute   *note 3.5(14): 1616, *note 3.6.2(7): 1955.
Range(N) attribute   *note 3.6.2(8): 1957.
range_attribute_designator   *note 4.1.4(5): 2443.
   used   *note 4.1.4(4): 2442, *note P: 9229.
range_attribute_reference   *note 4.1.4(4): 2440.
   used   *note 3.5(3): 1588, *note P: 9077.
Range_Check   *note 11.5(17): 4635.
   [partial]   *note 3.2.2(11): 1423, *note 3.5(24): 1629, *note
3.5(27): 1636, *note 3.5(39.12/3): 1663, *note 3.5(39.4/3): 1657, *note
3.5(39.5/3): 1660, *note 3.5(43/3): 1669, *note 3.5(55/3): 1675, *note
3.5.5(7): 1776, *note 3.5.9(19/4): 1861, *note 4.2(11): 2489, *note
4.3.3(28): 2575, *note 4.5.1(8): 2755, *note 4.5.6(6): 2866, *note
4.5.6(13): 2875, *note 4.6(28): 2967, *note 4.6(38): 2979, *note
4.6(46): 2992, *note 4.6(51/4): 2998, *note 4.7(4/4): 3032, *note
13.13.2(35/3): 5365, *note A.5.2(39): 6175, *note A.5.3(26): 6211, *note
A.5.3(29): 6216, *note A.5.3(50): 6239, *note A.5.3(53): 6244, *note
A.5.3(59): 6249, *note A.5.3(62): 6254, *note K.2(11): 8651, *note
K.2(114): 8666, *note K.2(122): 8669, *note K.2(184): 8675, *note
K.2(220): 8682, *note K.2(241): 8685, *note K.2(41): 8656, *note
K.2(47): 8659.
range_constraint   *note 3.5(2): 1585.
   used   *note 3.2.2(6): 1414, *note 3.5.9(5/4): 1841, *note J.3(2/4):
8497, *note P: 9050.
Ravenscar   *note D.13(1/3): 7998.
RCI
   generic   *note E.2.3(7/3): 8160.
   library unit   *note E.2.3(7/3): 8158.
   package   *note E.2.3(7/3): 8159.
Re
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(7/2): 8389,
*note G.3.2(27/2): 8402.
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(6): 8263.
re-raise statement   *note 11.3(3/4): 4550.
read
   the value of an object   *note 3.3(14): 1463.
   in Ada.Direct_IO   *note A.8.4(12): 6339.
   in Ada.Sequential_IO   *note A.8.1(12): 6312.
   in Ada.Storage_IO   *note A.9(6): 6358.
   in Ada.Streams   *note 13.13.1(5): 5340.
   in Ada.Streams.Stream_IO   *note A.12.1(15): 6586, *note A.12.1(16):
6587.
   in System.RPC   *note E.5(7): 8208.
Read aspect   *note 13.13.2(38/4): 5379.
Read attribute   *note 13.13.2(6): 5352, *note 13.13.2(14): 5356.
Read clause   *note 13.3(7/2): 4969, *note 13.13.2(38/4): 5374.
Read'Class aspect   *note 13.13.2(38/4): 5387.
ready
   a task state   *note 9(10): 3888.
ready queue   *note D.2.1(5/2): 7776.
ready task   *note D.2.1(5/2): 7779.
Real
   in Interfaces.Fortran   *note B.5(6): 7601.
real literal   *note 2.4(1): 1205.
real literals   *note 3.5.6(4): 1790.
real time   *note D.8(18): 7963.
real type   *note 3.2(3): 1342, *note 3.5.6(1): 1784, *note N(34): 8941.
real-time systems   *note C(1): 7619, *note D(1): 7755.
Real_Arrays
   child of Ada.Numerics   *note G.3.1(31/2): 8382.
Real_Matrix
   in Ada.Numerics.Generic_Real_Arrays   *note G.3.1(4/2): 8372.
real_range_specification   *note 3.5.7(3): 1798.
   used   *note 3.5.7(2): 1797, *note 3.5.9(3): 1834, *note 3.5.9(4):
1838, *note P: 9093.
Real_Time
   child of Ada   *note D.8(3): 7941.
real_type_definition   *note 3.5.6(2): 1785.
   used   *note 3.2.1(4/2): 1383, *note P: 9035.
Real_Vector
   in Ada.Numerics.Generic_Real_Arrays   *note G.3.1(4/2): 8371.
receiving stub   *note E.4(10): 8187.
reclamation of storage   *note 13.11.2(1): 5226.
recommended level of support   *note 13.1(20/3): 4908.
   Address attribute   *note 13.3(15): 4985.
   Alignment attribute for objects   *note 13.3(33): 4999.
   Alignment attribute for subtypes   *note 13.3(29): 4998.
   aspect Pack   *note 13.2(7/3): 4941.
   bit ordering   *note 13.5.3(7): 5102.
   Component_Size attribute   *note 13.3(71): 5027.
   enumeration_representation_clause   *note 13.4(9): 5048.
   record_representation_clause   *note 13.5.1(17): 5078.
   required in Systems Programming Annex   *note C.2(2/3): 7628.
   Size attribute   *note 13.3(42/2): 5006, *note 13.3(54): 5013.
   Stream_Size attribute   *note 13.13.2(1.7/2): 5348.
   unchecked conversion   *note 13.9(16): 5162.
   with respect to nonstatic expressions   *note 13.1(21/3): 4909.
record   *note 3.8(1): 2021.
   explicitly limited   *note 3.8(13.1/3): 2045.
record extension   *note 3.4(5/2): 1539, *note 3.9.1(1/2): 2137, *note
N(35): 8942.
Record layout aspect   *note 13.5(1): 5054.
record type   *note 3.8(1): 2022, *note N(36): 8943.
record_aggregate   *note 4.3.1(2): 2505.
   used   *note 4.3(2): 2495, *note P: 9234.
record_component_association   *note 4.3.1(4/2): 2510.
   used   *note 4.3.1(3): 2508, *note P: 9238.
record_component_association_list   *note 4.3.1(3): 2507.
   used   *note 4.3.1(2): 2506, *note 4.3.2(2): 2529, *note P: 9246.
record_definition   *note 3.8(3): 2026.
   used   *note 3.8(2): 2025, *note 3.9.1(2): 2142, *note P: 9139.
record_extension_part   *note 3.9.1(2): 2141.
   used   *note 3.4(2/2): 1536, *note P: 9075.
record_representation_clause   *note 13.5.1(2): 5059.
   used   *note 13.1(2/1): 4875, *note P: 9801.
record_type_definition   *note 3.8(2): 2024.
   used   *note 3.2.1(4/2): 1385, *note P: 9037.
reentrant   *note A(3/4): 5433.
reference
   dangling   *note 13.11.2(15.1/4): 5240.
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(17.4/3): 6838.
   in Ada.Containers.Hashed_Maps   *note A.18.5(17.4/3): 6927, *note
A.18.5(17.6/3): 6929.
   in Ada.Containers.Indefinite_Holders   *note A.18.18(19/3): 7297.
   in Ada.Containers.Multiway_Trees   *note A.18.10(31/3): 7224.
   in Ada.Containers.Ordered_Maps   *note A.18.6(16.4/3): 6978, *note
A.18.6(16.6/3): 6980.
   in Ada.Containers.Vectors   *note A.18.2(34.4/3): 6753, *note
A.18.2(34.6/3): 6755.
   in Ada.Interrupts   *note C.3.2(10): 7668.
   in Ada.Task_Attributes   *note C.7.2(5): 7731.
reference discriminant   *note 4.1.5(3/3): 2454.
reference object   *note 4.1.5(3/3): 2453.
reference parameter passing   *note 6.2(2): 3392.
reference type   *note 4.1.5(3/3): 2452, *note N(36.1/3): 8944.
Reference_Preserving_Key
   in Ada.Containers.Hashed_Sets   *note A.18.8(58.2/3): 7097, *note
A.18.8(58.4/3): 7099.
   in Ada.Containers.Ordered_Sets   *note A.18.9(73.2/3): 7178, *note
A.18.9(73.4/3): 7180.
Reference_Type
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(17.2/3): 6836.
   in Ada.Containers.Hashed_Maps   *note A.18.5(17.2/3): 6925.
   in Ada.Containers.Hashed_Sets   *note A.18.8(58.1/3): 7096.
   in Ada.Containers.Indefinite_Holders   *note A.18.18(17/3): 7295.
   in Ada.Containers.Multiway_Trees   *note A.18.10(29/3): 7222.
   in Ada.Containers.Ordered_Maps   *note A.18.6(16.2/3): 6976.
   in Ada.Containers.Ordered_Sets   *note A.18.9(73.1/3): 7177.
   in Ada.Containers.Vectors   *note A.18.2(34.2/3): 6751.
references   *note 1.2(1/3): 1086.
Registered_Trade_Mark_Sign
   in Ada.Characters.Latin_1   *note A.3.3(21/3): 5645.
Reinitialize
   in Ada.Task_Attributes   *note C.7.2(6): 7733.
relation   *note 4.4(3/4): 2681.
   used   *note 4.4(2): 2656, *note P: 9266.
relational operator   *note 4.5.2(1): 2758.
relational_operator   *note 4.5(3): 2725.
   used   *note 4.4(2.2/3): 2679, *note 4.4(3/4): 2683, *note P: 9285.
Relative_Deadline aspect   *note D.2.6(9.2/3): 7828.
Relative_Deadline pragma   *note J.15.12(2/3): 8641, *note L(29.2/3):
8833.
Relative_Name
   in Ada.Directories.Hierarchical_File_Names   *note A.16.1(13/3):
6696.
relaxed mode   *note G.2(1): 8331.
release
   execution resource associated with protected object   *note 9.5.1(6):
4033.
rem operator   *note 4.4(1/3): 2644, *note 4.5.5(1): 2852.
Remainder attribute   *note A.5.3(45): 6232.
remote access   *note E.1(5): 8102.
remote access type   *note E.2.2(9/3): 8144.
remote access-to-class-wide type   *note E.2.2(9/3): 8146.
remote access-to-subprogram type   *note E.2.2(9/3): 8145.
remote call interface   *note E.2(4/3): 8120, *note E.2.3(7/3): 8157.
remote procedure call
   asynchronous   *note E.4.1(9/3): 8200.
remote subprogram   *note E.2.3(7/3): 8161.
remote subprogram binding   *note E.4(1): 8182.
remote subprogram call   *note E.4(1): 8178.
remote types library unit   *note E.2(4/3): 8119, *note E.2.2(4/3):
8141.
Remote_Call_Interface aspect   *note E.2.3(7/3): 8163.
Remote_Call_Interface pragma   *note E.2.3(3): 8150, *note L(30): 8835.
Remote_Types aspect   *note E.2.2(4/3): 8143.
Remote_Types pragma   *note E.2.2(3): 8139, *note L(31): 8838.
Remove_Task
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(8/2): 8036.
Rename
   in Ada.Directories   *note A.16(12/2): 6643.
renamed entity   *note 8.5(3): 3797.
renamed view   *note 8.5(3): 3796.
renaming   *note N(36.2/2): 8945.
renaming-as-body   *note 8.5.4(1/3): 3820.
renaming-as-declaration   *note 8.5.4(1/3): 3821.
renaming_declaration   *note 8.5(2): 3789.
   used   *note 3.1(3/3): 1302, *note P: 9018.
rendezvous   *note 9.5.2(25): 4087.
Replace
   in Ada.Containers.Hashed_Maps   *note A.18.5(23/2): 6937.
   in Ada.Containers.Hashed_Sets   *note A.18.8(22/2): 7064, *note
A.18.8(53/2): 7090.
   in Ada.Containers.Ordered_Maps   *note A.18.6(22/2): 6988.
   in Ada.Containers.Ordered_Sets   *note A.18.9(21/2): 7135, *note
A.18.9(66/2): 7169.
Replace_Element
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(15/2): 6833.
   in Ada.Containers.Hashed_Maps   *note A.18.5(15/2): 6922.
   in Ada.Containers.Hashed_Sets   *note A.18.8(16/2): 7055.
   in Ada.Containers.Indefinite_Holders   *note A.18.18(13/3): 7291.
   in Ada.Containers.Multiway_Trees   *note A.18.10(25/3): 7218.
   in Ada.Containers.Ordered_Maps   *note A.18.6(14/2): 6973.
   in Ada.Containers.Ordered_Sets   *note A.18.9(15/2): 7126.
   in Ada.Containers.Vectors   *note A.18.2(29/2): 6745, *note
A.18.2(30/2): 6746.
   in Ada.Strings.Bounded   *note A.4.4(27): 5862.
   in Ada.Strings.Unbounded   *note A.4.5(21): 5916.
Replace_Slice
   in Ada.Strings.Bounded   *note A.4.4(58): 5883, *note A.4.4(59):
5884.
   in Ada.Strings.Fixed   *note A.4.3(23): 5826, *note A.4.3(24): 5827.
   in Ada.Strings.Unbounded   *note A.4.5(53): 5937, *note A.4.5(54):
5938.
Replenish
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(9/2): 8040.
Replicate
   in Ada.Strings.Bounded   *note A.4.4(78): 5899, *note A.4.4(79):
5900, *note A.4.4(80): 5901.
representation
   change of   *note 13.6(1/3): 5104.
representation aspect   *note 13.1(8/3): 4887.
   coding   *note 13.4(7): 5044.
   convention, calling convention   *note B.1(1/3): 7392.
   export   *note B.1(1/3): 7394.
   external_name   *note B.1(1/3): 7395.
   import   *note B.1(1/3): 7393.
   layout   *note 13.5(1): 5051.
   link_name   *note B.1(1/3): 7396.
   record layout   *note 13.5(1): 5052.
   specifiable attributes   *note 13.3(5/3): 4956.
   storage place   *note 13.5(1): 5055.
representation attribute   *note 13.3(1/1): 4942.
representation item   *note 13.1(1/1): 4868.
representation of an object   *note 13.1(7/2): 4883.
representation pragma   *note 13.1(1/1): 4869.
   Asynchronous   *note J.15.13(1/3): 8643.
   Atomic   *note J.15.8(9/3): 8615.
   Atomic_Components   *note J.15.8(9/3): 8619.
   Convention   *note J.15.5(1/3): 8562.
   Discard_Names   *note C.5(6): 7686.
   Export   *note J.15.5(1/3): 8560.
   Import   *note J.15.5(1/3): 8558.
   Independent   *note J.15.8(9/3): 8623.
   Independent_Components   *note J.15.8(9/3): 8625.
   No_Return   *note J.15.2(1/3): 8536.
   Pack   *note J.15.3(1/3): 8542.
   Unchecked_Union   *note J.15.6(1/3): 8583.
   Volatile   *note J.15.8(9/3): 8617.
   Volatile_Components   *note J.15.8(9/3): 8621.
representation-oriented attributes
   of a fixed point subtype   *note A.5.4(1): 6271.
   of a floating point subtype   *note A.5.3(1): 6180.
representation_clause
   See aspect_clause   *note 13.1(4/1): 4882.
represented in canonical form   *note A.5.3(10): 6194.
requested decimal precision
   of a floating point type   *note 3.5.7(4): 1801.
requeue   *note 9.5.4(1): 4117.
requeue target   *note 9.5.4(3/3): 4122.
requeue-with-abort   *note 9.5.4(13): 4129.
requeue_statement   *note 9.5.4(2/3): 4120.
   used   *note 5.1(4/2): 3129, *note P: 9364.
require overriding   *note 3.9.3(6/4): 2193.
requires a completion   *note 3.11.1(1/3): 2353, *note 3.11.1(6/3):
2357.
   declaration for which aspect Elaborate_Body is True   *note
10.2.1(25/3): 4503.
   declaration of a partial view   *note 7.3(4): 3611.
   declaration to which a pragma Elaborate_Body applies   *note
10.2.1(25/3): 4502.
   deferred constant declaration   *note 7.4(2/3): 3642.
   generic_package_declaration   *note 7.1(5/2): 3581.
   generic_subprogram_declaration   *note 6.1(20/3): 3334.
   incomplete_type_declaration   *note 3.10.1(3/3): 2282.
   package_declaration   *note 7.1(5/2): 3580.
   protected entry_declaration   *note 9.5.2(16): 4071.
   protected_declaration   *note 9.4(11.2/2): 3995.
   subprogram_declaration   *note 6.1(20/3): 3333.
   task_declaration   *note 9.1(9.3/2): 3922.
requires late initialization   *note 3.3.1(8.1/2): 1503.
requires overriding
   [partial]   *note 6.1.1(16/3): 3363.
Reraise_Occurrence
   in Ada.Exceptions   *note 11.4.1(4/3): 4575.
Reserve_Capacity
   in Ada.Containers.Hashed_Maps   *note A.18.5(9/2): 6916.
   in Ada.Containers.Hashed_Sets   *note A.18.8(11/2): 7050.
   in Ada.Containers.Vectors   *note A.18.2(20/2): 6736.
reserved interrupt   *note C.3(2): 7637.
reserved word   *note 2.9(2/3): 1289.
Reserved_128
   in Ada.Characters.Latin_1   *note A.3.3(17): 5598.
Reserved_129
   in Ada.Characters.Latin_1   *note A.3.3(17): 5599.
Reserved_132
   in Ada.Characters.Latin_1   *note A.3.3(17): 5602.
Reserved_153
   in Ada.Characters.Latin_1   *note A.3.3(19): 5623.
Reserved_Check
   [partial]   *note C.3.1(10/3): 7648.
Reset
   in Ada.Direct_IO   *note A.8.4(8): 6332.
   in Ada.Numerics.Discrete_Random   *note A.5.2(21): 6164, *note
A.5.2(24): 6167.
   in Ada.Numerics.Float_Random   *note A.5.2(9): 6151, *note A.5.2(12):
6155.
   in Ada.Sequential_IO   *note A.8.1(8): 6305.
   in Ada.Streams.Stream_IO   *note A.12.1(10): 6579.
   in Ada.Text_IO   *note A.10.1(11): 6387.
resolution rules   *note 1.1.2(26/3): 1021.
resolve
   overload resolution   *note 8.6(14): 3853.
restriction   *note 13.12(4/2): 5294.
   used   *note 13.12(3): 5293, *note L(32): 8842.
restriction_parameter_argument   *note 13.12(4.1/2): 5298.
   used   *note 13.12(4/2): 5297, *note P: 9838.
restrictions
   Immediate_Reclamation   *note H.4(10): 8458.
   Max_Asynchronous_Select_Nesting   *note D.7(18/1): 7925.
   Max_Entry_Queue_Length   *note D.7(19.1/2): 7935.
   Max_Protected_Entries   *note D.7(14): 7916.
   Max_Select_Alternatives   *note D.7(12): 7912.
   Max_Storage_At_Blocking   *note D.7(17/1): 7920.
   Max_Task_Entries   *note D.7(13): 7914.
   Max_Tasks   *note D.7(19/1): 7930.
   No_Abort_Statements   *note D.7(5/3): 7878.
   No_Access_Parameter_Allocators   *note H.4(8.3/3): 8456.
   No_Access_Subprograms   *note H.4(17): 8466.
   No_Allocators   *note H.4(7): 8448.
   No_Anonymous_Allocators   *note H.4(8.1/3): 8452.
   No_Asynchronous_Control   *note J.13(3/2): 8527.
   No_Coextensions   *note H.4(8.2/3): 8454.
   No_Delay   *note H.4(21): 8476.
   No_Dependence   *note 13.12.1(6/2): 5322.
   No_Dispatch   *note H.4(19): 8472.
   No_Dynamic_Attachment   *note D.7(10/3): 7889.
   No_Dynamic_CPU_Assignment   *note D.7(10.1/4): 7891.
   No_Dynamic_Priorities   *note D.7(9/2): 7887.
   No_Exceptions   *note H.4(12): 8460.
   No_Fixed_Point   *note H.4(15): 8464.
   No_Floating_Point   *note H.4(14): 8462.
   No_Implementation_Aspect_Specifications   *note 13.12.1(1.1/3): 5310.
   No_Implementation_Attributes   *note 13.12.1(2/2): 5312.
   No_Implementation_Identifiers   *note 13.12.1(2.1/3): 5314.
   No_Implementation_Pragmas   *note 13.12.1(3/2): 5316.
   No_Implementation_Units   *note 13.12.1(3.1/3): 5318.
   No_Implicit_Heap_Allocations   *note D.7(8): 7885.
   No_IO   *note H.4(20/2): 8474.
   No_Local_Allocators   *note H.4(8/1): 8450.
   No_Local_Protected_Objects   *note D.7(10.2/3): 7893.
   No_Local_Timing_Events   *note D.7(10.3/3): 7895.
   No_Nested_Finalization   *note D.7(4/3): 7876.
   No_Obsolescent_Features   *note 13.12.1(4/3): 5320.
   No_Protected_Type_Allocators   *note D.7(10.4/2): 7897.
   No_Protected_Types   *note H.4(5): 8446.
   No_Recursion   *note H.4(22): 8478.
   No_Reentrancy   *note H.4(23): 8480.
   No_Relative_Delay   *note D.7(10.6/3): 7900.
   No_Requeue_Statements   *note D.7(10.7/3): 7902.
   No_Select_Statements   *note D.7(10.8/3): 7904.
   No_Specific_Termination_Handlers   *note D.7(10.9/3): 7906.
   No_Specification_of_Aspect   *note 13.12.1(6.1/3): 5324.
   No_Standard_Allocators_After_Elaboration   *note D.7(19.2/3): 7938.
   No_Task_Allocators   *note D.7(7): 7882.
   No_Task_Hierarchy   *note D.7(3/3): 7874.
   No_Task_Termination   *note D.7(15.1/2): 7918.
   No_Tasks_Unassigned_To_CPU   *note D.7(10.10/4): 7908.
   No_Terminate_Alternatives   *note D.7(6): 7880.
   No_Unchecked_Access   *note H.4(18): 8468.
   No_Unchecked_Conversion   *note J.13(4/2): 8528.
   No_Unchecked_Deallocation   *note J.13(5/2): 8529.
   No_Use_Of_Attribute   *note 13.12.1(6.2/3): 5326.
   No_Use_Of_Pragma   *note 13.12.1(6.3/3): 5328.
   Simple_Barriers   *note D.7(10.11/3): 7910.
Restrictions pragma   *note 13.12(3): 5291, *note L(32): 8841.
Result attribute   *note 6.1.1(29/3): 3373.
result interval
   for a component of the result of evaluating a complex function  
*note G.2.6(3): 8364.
   for the evaluation of a predefined arithmetic operation   *note
G.2.1(8): 8336.
   for the evaluation of an elementary function   *note G.2.4(2): 8358.
result subtype
   of a function   *note 6.5(3/2): 3509.
return expression
   of expression function   *note 6.8(6/4): 3564.
return object
   extended_return_statement   *note 6.5(5.10/3): 3514.
   simple_return_statement   *note 6.5(6/2): 3523.
return statement   *note 6.5(1/2): 3496.
return_subtype_indication   *note 6.5(2.3/2): 3506.
   used   *note 6.5(2.1/3): 3501, *note P: 9465.
reverse iterator   *note 5.5.2(4/3): 3249.
Reverse_Elements
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(27/2): 6850.
   in Ada.Containers.Vectors   *note A.18.2(54/2): 6777.
Reverse_Find
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(42/2): 6865.
   in Ada.Containers.Vectors   *note A.18.2(70/2): 6793.
Reverse_Find_Index
   in Ada.Containers.Vectors   *note A.18.2(69/2): 6792.
Reverse_Iterate
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(46/2): 6868.
   in Ada.Containers.Ordered_Maps   *note A.18.6(51/2): 7010.
   in Ada.Containers.Ordered_Sets   *note A.18.9(61/2): 7164.
   in Ada.Containers.Vectors   *note A.18.2(74/2): 6796.
Reverse_Iterate_Children
   in Ada.Containers.Multiway_Trees   *note A.18.10(69/3): 7262.
Reverse_Solidus
   in Ada.Characters.Latin_1   *note A.3.3(12): 5557.
reversible iterable container object   *note 5.5.1(11/3): 3232.
reversible iterable container type   *note 5.5.1(11/3): 3230.
reversible iterator object   *note 5.5.1(6/3): 3219.
reversible iterator type   *note 5.5.1(6/3): 3217.
Reversible_Iterator
   in Ada.Iterator_Interfaces   *note 5.5.1(4/3): 3213.
Reviewable pragma   *note H.3.1(3): 8437, *note L(33): 8845.
RI
   in Ada.Characters.Latin_1   *note A.3.3(17): 5611.
right parenthesis   *note 2.1(15/3): 1157.
Right_Angle_Quotation
   in Ada.Characters.Latin_1   *note A.3.3(22): 5660.
Right_Curly_Bracket
   in Ada.Characters.Latin_1   *note A.3.3(14): 5590.
Right_Parenthesis
   in Ada.Characters.Latin_1   *note A.3.3(8): 5541.
Right_Square_Bracket
   in Ada.Characters.Latin_1   *note A.3.3(12): 5558.
Ring_Above
   in Ada.Characters.Latin_1   *note A.3.3(22): 5648.
root
   of a tree   *note A.18.10(2/4): 7190.
   in Ada.Containers.Multiway_Trees   *note A.18.10(22/3): 7215.
root library unit   *note 10.1.1(10): 4355.
root node
   of a tree   *note A.18.10(2/4): 7191.
root type
   of a class   *note 3.4.1(2/2): 1563.
root_integer   *note 3.5.4(14): 1743.
   [partial]   *note 3.4.1(8): 1573.
root_real   *note 3.5.6(3): 1788.
   [partial]   *note 3.4.1(8): 1574.
Root_Storage_Pool
   in System.Storage_Pools   *note 13.11(6/2): 5188.
Root_Storage_Pool_With_Subpools
   in System.Storage_Pools.Subpools   *note 13.11.4(4/3): 5257.
Root_Stream_Type
   in Ada.Streams   *note 13.13.1(3/2): 5335.
Root_Subpool
   in System.Storage_Pools.Subpools   *note 13.11.4(5/3): 5258.
rooted at a type   *note 3.4.1(2/2): 1564.
roots the subtree   *note A.18.10(3/4): 7195.
rotate   *note B.2(9): 7429.
Rotate_Left   *note B.2(6): 7424.
Rotate_Right   *note B.2(6): 7425.
Round attribute   *note 3.5.10(12): 1883.
Round_Robin
   child of Ada.Dispatching   *note D.2.5(4/2): 7813.
Round_Robin_Within_Priorities task dispatching policy   *note
D.2.5(2/2): 7812.
Rounding attribute   *note A.5.3(36): 6223.
RPC
   child of System   *note E.5(3): 8204.
RPC-receiver   *note E.5(21): 8215.
RPC_Receiver
   in System.RPC   *note E.5(11): 8212.
RS
   in Ada.Characters.Latin_1   *note A.3.3(6): 5530.
run-time check
   See language-defined check   *note 11.5(2/3): 4613.
run-time error   *note 1.1.2(30): 1037, *note 1.1.5(6): 1076, *note
11.5(2/3): 4614, *note 11.6(1/3): 4650.
run-time polymorphism   *note 3.9.2(1/2): 2152.
run-time semantics   *note 1.1.2(30): 1036.
run-time type
   See tag   *note 3.9(3): 2096.
running a program
   See program execution   *note 10.2(1): 4443.
running task   *note D.2.1(6/2): 7782.
runtime name text
   entity with   *note C.5(1.1/4): 7678.



File: arm2012.info,  Node: S,  Next: T,  Prev: R,  Up: Index

S 
==



safe range
   of a floating point type   *note 3.5.7(9): 1809.
   of a floating point type   *note 3.5.7(10): 1811.
Safe_First attribute   *note A.5.3(71): 6268, *note G.2.2(5): 8345.
Safe_Last attribute   *note A.5.3(72): 6270, *note G.2.2(6): 8347.
safety-critical systems   *note H(1/2): 8426.
satisfies
   a discriminant constraint   *note 3.7.1(11): 2015.
   a range constraint   *note 3.5(4): 1597.
   an index constraint   *note 3.6.1(7): 1943.
   for an access value   *note 3.10(15/2): 2272.
satisfies the predicates
   of a subtype   *note 3.2.4(29.2/4): 1447.
Saturday
   in Ada.Calendar.Formatting   *note 9.6.1(17/2): 4184.
Save
   in Ada.Numerics.Discrete_Random   *note A.5.2(24): 6166.
   in Ada.Numerics.Float_Random   *note A.5.2(12): 6154.
Save_Occurrence
   in Ada.Exceptions   *note 11.4.1(6/2): 4582.
scalar type   *note 3.2(3): 1339, *note 3.5(1): 1581, *note N(37): 8946.
scalar_constraint   *note 3.2.2(6): 1413.
   used   *note 3.2.2(5): 1411, *note P: 9048.
scale
   of a decimal fixed point subtype   *note 3.5.10(11): 1881, *note
K.2(216): 8680.
Scale attribute   *note 3.5.10(11): 1880.
Scaling attribute   *note A.5.3(27): 6214.
SCHAR_MAX
   in Interfaces.C   *note B.3(6): 7435.
SCHAR_MIN
   in Interfaces.C   *note B.3(6): 7434.
SCI
   in Ada.Characters.Latin_1   *note A.3.3(19): 5624.
scope
   informal definition   *note 3.1(8): 1317.
   of (a view of) an entity   *note 8.2(11): 3732.
   of a declaration   *note 8.2(10): 3728.
   of a use_clause   *note 8.4(6): 3783.
   of a with_clause   *note 10.1.2(5): 4382.
   of an aspect_specification   *note 8.2(10.1/3): 3730.
   of an attribute_definition_clause   *note 8.2(10.1/3): 3729.
Search_Type
   in Ada.Directories   *note A.16(31/2): 6661.
Second
   in Ada.Calendar.Formatting   *note 9.6.1(26/2): 4196.
Second_Duration subtype of Day_Duration
   in Ada.Calendar.Formatting   *note 9.6.1(20/2): 4190.
Second_Number subtype of Natural
   in Ada.Calendar.Formatting   *note 9.6.1(20/2): 4189.
Seconds
   in Ada.Calendar   *note 9.6(13): 4155.
   in Ada.Real_Time   *note D.8(14/2): 7958.
Seconds_Count
   in Ada.Real_Time   *note D.8(15): 7960.
Seconds_Of
   in Ada.Calendar.Formatting   *note 9.6.1(28/2): 4198.
Section_Sign
   in Ada.Characters.Latin_1   *note A.3.3(21/3): 5638.
secure systems   *note H(1/2): 8427.
select an entry call
   from an entry queue   *note 9.5.3(13): 4109, *note 9.5.3(16): 4110.
   immediately   *note 9.5.3(8): 4106.
select_alternative   *note 9.7.1(4): 4223.
   used   *note 9.7.1(2): 4217, *note P: 9624.
select_statement   *note 9.7(2): 4209.
   used   *note 5.1(5/2): 3141, *note P: 9375.
selected_component   *note 4.1.3(2): 2418.
   used   *note 4.1(2/3): 2364, *note P: 9200.
selection
   of an entry caller   *note 9.5.2(24): 4086.
selective_accept   *note 9.7.1(2): 4215.
   used   *note 9.7(2): 4210, *note P: 9617.
selector_name   *note 4.1.3(3): 2421.
   used   *note 3.7.1(3): 2005, *note 4.1.3(2): 2420, *note 4.3.1(5):
2516, *note 6.4(5): 3458, *note 12.3(4): 4713, *note 12.7(3.1/2): 4863,
*note P: 9136.
semantic dependence
   of one compilation unit upon another   *note 10.1.1(26/2): 4366.
semicolon   *note 2.1(15/3): 1170.
   in Ada.Characters.Latin_1   *note A.3.3(10): 5550.
separate compilation   *note 10.1(1): 4315.
Separate_Interrupt_Clocks_Supported
   in Ada.Execution_Time   *note D.14(9.2/3): 8009.
separator   *note 2.2(3/2): 1184.
separator_line   *note 2.1(12/2): 1143.
separator_paragraph   *note 2.1(12.1/2): 1144.
separator_space   *note 2.1(11/2): 1142.
sequence of characters
   of a string_literal   *note 2.6(5): 1254.
sequence_of_statements   *note 5.1(2/3): 3112.
   used   *note 5.3(2): 3171, *note 5.4(3): 3182, *note 5.5(2): 3193,
*note 9.7.1(2): 4220, *note 9.7.1(5): 4229, *note 9.7.1(6): 4232, *note
9.7.2(3/2): 4246, *note 9.7.3(2): 4253, *note 9.7.4(3): 4260, *note
9.7.4(5): 4265, *note 11.2(2): 4529, *note 11.2(3): 4536, *note P: 9631.
sequential
   actions   *note 9.10(11): 4310, *note C.6(17): 7705.
sequential access   *note A.8(2): 6293.
sequential file   *note A.8(1/2): 6290.
Sequential_IO
   child of Ada   *note A.8.1(2): 6298.
service
   an entry queue   *note 9.5.3(13): 4108.
set
   execution timer object   *note D.14.1(12/2): 8025.
   group budget object   *note D.14.2(15/2): 8052.
   termination handler   *note C.7.3(9/2): 7753.
   timing event object   *note D.15(9/2): 8067.
   in Ada.Containers.Hashed_Sets   *note A.18.8(3/3): 7041.
   in Ada.Containers.Ordered_Sets   *note A.18.9(4/3): 7114.
   in Ada.Environment_Variables   *note A.17(6/2): 6703.
set container   *note A.18.7(1/2): 7018.
Set_Bounded_String
   in Ada.Strings.Bounded   *note A.4.4(12.1/2): 5852.
Set_Col
   in Ada.Text_IO   *note A.10.1(35): 6434.
Set_CPU
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(12/3):
8089.
Set_Deadline
   in Ada.Dispatching.EDF   *note D.2.6(9/2): 7824.
Set_Dependents_Fallback_Handler
   in Ada.Task_Termination   *note C.7.3(5/2): 7743.
Set_Directory
   in Ada.Directories   *note A.16(6/2): 6637.
Set_Error
   in Ada.Text_IO   *note A.10.1(15): 6395.
Set_Exit_Status
   in Ada.Command_Line   *note A.15(9): 6633.
Set_False
   in Ada.Synchronous_Task_Control   *note D.10(4): 7976.
Set_Handler
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(10/2): 8044.
   in Ada.Execution_Time.Timers   *note D.14.1(7/2): 8019.
   in Ada.Real_Time.Timing_Events   *note D.15(5/2): 8061.
Set_Im
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(8/2): 8392,
*note G.3.2(28/2): 8405.
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(7): 8268.
Set_Index
   in Ada.Direct_IO   *note A.8.4(14): 6343.
   in Ada.Streams.Stream_IO   *note A.12.1(22): 6590.
Set_Input
   in Ada.Text_IO   *note A.10.1(15): 6393.
Set_Iterator_Interfaces
   in Ada.Containers.Hashed_Sets   *note A.18.8(6.2/3): 7046.
   in Ada.Containers.Ordered_Sets   *note A.18.9(7.2/3): 7119.
Set_Length
   in Ada.Containers.Vectors   *note A.18.2(22/2): 6738.
Set_Line
   in Ada.Text_IO   *note A.10.1(36): 6436.
Set_Line_Length
   in Ada.Text_IO   *note A.10.1(23): 6411.
Set_Mode
   in Ada.Streams.Stream_IO   *note A.12.1(24): 6593.
Set_Output
   in Ada.Text_IO   *note A.10.1(15): 6394.
Set_Page_Length
   in Ada.Text_IO   *note A.10.1(24): 6413.
Set_Pool_of_Subpool
   in System.Storage_Pools.Subpools   *note 13.11.4(10/3): 5262.
Set_Priority
   in Ada.Dynamic_Priorities   *note D.5.1(4): 7866.
Set_Quantum
   in Ada.Dispatching.Round_Robin   *note D.2.5(4/2): 7816.
Set_Re
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(8/2): 8391,
*note G.3.2(28/2): 8404.
   in Ada.Numerics.Generic_Complex_Types   *note G.1.1(7): 8266.
Set_Specific_Handler
   in Ada.Task_Termination   *note C.7.3(6/2): 7745.
Set_True
   in Ada.Synchronous_Task_Control   *note D.10(4): 7975.
Set_Unbounded_String
   in Ada.Strings.Unbounded   *note A.4.5(11.1/2): 5911.
Set_Value
   in Ada.Task_Attributes   *note C.7.2(6): 7732.
shared passive library unit   *note E.2(4/3): 8118, *note E.2.1(4/3):
8127.
shared variable
   protection of   *note 9.10(1/3): 4305.
Shared_Passive aspect   *note E.2.1(4/3): 8129.
Shared_Passive pragma   *note E.2.1(3): 8125, *note L(34): 8847.
shift   *note B.2(9): 7428.
Shift_Left   *note B.2(6): 7421.
Shift_Right   *note B.2(6): 7422.
Shift_Right_Arithmetic   *note B.2(6): 7423.
short
   in Interfaces.C   *note B.3(7): 7438.
short-circuit control form   *note 4.5.1(1): 2739.
Short_Float   *note 3.5.7(16): 1819.
Short_Integer   *note 3.5.4(25): 1763.
SI
   in Ada.Characters.Latin_1   *note A.3.3(5): 5515.
signal
   as defined between actions   *note 9.10(2): 4308.
   See interrupt   *note C.3(1/3): 7629.
signal (an exception)
   See raise   *note 11(1/3): 4508.
signal handling
   example   *note 9.7.4(10): 4269.
signed integer type   *note 3.5.4(1): 1718.
signed_char
   in Interfaces.C   *note B.3(8): 7440.
signed_integer_type_definition   *note 3.5.4(3): 1724.
   used   *note 3.5.4(2): 1722, *note P: 9085.
Signed_Zeros attribute   *note A.5.3(13): 6201.
simple entry call   *note 9.5.3(1): 4090.
simple name
   of a file   *note A.16(47/2): 6681.
Simple_Barriers restriction   *note D.7(10.11/3): 7911.
simple_expression   *note 4.4(4): 2695.
   used   *note 3.5(3): 1589, *note 3.5.4(3): 1725, *note 3.5.7(3):
1799, *note 3.5.9(5/4): 1840, *note 4.4(2.2/3): 2680, *note 4.4(3.2/4):
2692, *note 4.4(3/4): 2685, *note 11.3(2.1/4): 4549, *note 13.5.1(5):
5071, *note 13.5.1(6): 5073, *note J.3(2/4): 8496, *note P: 9078.
Simple_Name
   in Ada.Directories   *note A.16(16/2): 6646, *note A.16(38/2): 6666.
   in Ada.Directories.Hierarchical_File_Names   *note A.16.1(10/3):
6693.
simple_return_statement   *note 6.5(2/2): 3497.
   used   *note 5.1(4/2): 3127, *note P: 9362.
simple_statement   *note 5.1(4/2): 3121.
   used   *note 5.1(3): 3118, *note P: 9354.
Sin
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(4): 8290.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(5): 6116.
single
   class expected type   *note 8.6(27/2): 3867.
single entry   *note 9.5.2(20): 4079.
Single_Precision_Complex_Types
   in Interfaces.Fortran   *note B.5(8): 7604.
single_protected_declaration   *note 9.4(3/3): 3961.
   used   *note 3.3.1(2/3): 1493, *note P: 9068.
single_task_declaration   *note 9.1(3/3): 3899.
   used   *note 3.3.1(2/3): 1492, *note P: 9067.
Sinh
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(6): 8298.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7): 6131.
size
   of an object   *note 13.1(7/2): 4884.
   in Ada.Direct_IO   *note A.8.4(15): 6345.
   in Ada.Directories   *note A.16(26/2): 6657, *note A.16(41/2): 6669.
   in Ada.Streams.Stream_IO   *note A.12.1(23): 6592.
Size (object) aspect   *note 13.3(41): 5005.
Size (subtype) aspect   *note 13.3(48): 5012.
Size attribute   *note 13.3(40): 5001, *note 13.3(45): 5008.
Size clause   *note 13.3(7/2): 4961, *note 13.3(41): 5003, *note
13.3(48): 5010.
size_t
   in Interfaces.C   *note B.3(13): 7447.
Skip_Line
   in Ada.Text_IO   *note A.10.1(29): 6421.
Skip_Page
   in Ada.Text_IO   *note A.10.1(32): 6428.
slice   *note 4.1.2(2): 2407.
   used   *note 4.1(2/3): 2363, *note P: 9199.
   in Ada.Strings.Bounded   *note A.4.4(28): 5863.
   in Ada.Strings.Unbounded   *note A.4.5(22): 5917.
small
   of a fixed point type   *note 3.5.9(8/2): 1846.
Small aspect   *note 3.5.10(2/1): 1869.
Small attribute   *note 3.5.10(2/1): 1865.
Small clause   *note 3.5.10(2/1): 1867, *note 13.3(7/2): 4964.
SO
   in Ada.Characters.Latin_1   *note A.3.3(5): 5514.
Soft_Hyphen
   in Ada.Characters.Latin_1   *note A.3.3(21/3): 5644.
SOH
   in Ada.Characters.Latin_1   *note A.3.3(5): 5501.
solidus   *note 2.1(15/3): 1167.
   in Ada.Characters.Latin_1   *note A.3.3(8): 5548.
Solve
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(46/2): 8415.
   in Ada.Numerics.Generic_Real_Arrays   *note G.3.1(24/2): 8375.
Sort
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(49/2): 6871.
   in Ada.Containers.Vectors   *note A.18.2(77/2): 6799.
SOS
   in Ada.Characters.Latin_1   *note A.3.3(19): 5622.
SPA
   in Ada.Characters.Latin_1   *note A.3.3(18): 5620.
Space
   in Ada.Characters.Latin_1   *note A.3.3(8): 5532.
   in Ada.Strings   *note A.4.1(4/2): 5771.
special file   *note A.16(45/2): 6676.
special graphic character
   a category of Character   *note A.3.2(32): 5497.
Special_Set
   in Ada.Strings.Maps.Constants   *note A.4.6(4): 5964.
Specialized Needs Annexes   *note 1.1.2(7): 1006.
specifiable
   of Address for entries   *note J.7.1(6): 8511.
   of Address for stand-alone objects and for program units   *note
13.3(12): 4980.
   of Alignment for first subtypes   *note 13.3(26.4/2): 4992.
   of Alignment for objects   *note 13.3(25/2): 4988.
   of Bit_Order for record types and record extensions   *note
13.5.3(4): 5097.
   of Component_Size for array types   *note 13.3(70): 5023.
   of External_Tag for a tagged type   *note 13.3(75/3): 5035, *note
K.2(65): 8662.
   of Input for a type   *note 13.13.2(38/4): 5372.
   of Machine_Radix for decimal first subtypes   *note F.1(1): 8219.
   of Output for a type   *note 13.13.2(38/4): 5373.
   of Read for a type   *note 13.13.2(38/4): 5370.
   of Size for first subtypes   *note 13.3(48): 5009.
   of Size for stand-alone objects   *note 13.3(41): 5002.
   of Small for fixed point types   *note 3.5.10(2/1): 1866.
   of Storage_Pool for a nonderived access-to-object type   *note
13.11(15): 5202.
   of Storage_Size for a nonderived access-to-object type   *note
13.11(15): 5201.
   of Storage_Size for a task first subtype   *note J.9(3/3): 8520.
   of Write for a type   *note 13.13.2(38/4): 5371.
specifiable (of an attribute and for an entity)   *note 13.3(5/3): 4954.
specific handler   *note C.7.3(9/2): 7751.
specific postcondition expression   *note 6.1.1(4/3): 3353.
specific precondition expression   *note 6.1.1(2/3): 3345.
specific type   *note 3.4.1(3/2): 1565.
Specific_Handler
   in Ada.Task_Termination   *note C.7.3(6/2): 7746.
specified
   of an aspect of representation of an entity   *note 13.1(17): 4898.
   of an operational aspect of an entity   *note 13.1(18.1/1): 4900.
specified (not!)    *note 1.1.3(18): 1056.
specified as independently addressable   *note C.6(8.1/4): 7702.
specified discriminant   *note 3.7(18): 1989.
Splice
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(30/2): 6853,
*note A.18.3(31/2): 6854, *note A.18.3(32/2): 6855.
Splice_Children
   in Ada.Containers.Multiway_Trees   *note A.18.10(57/3): 7250, *note
A.18.10(58/3): 7251.
Splice_Subtree
   in Ada.Containers.Multiway_Trees   *note A.18.10(55/3): 7248, *note
A.18.10(56/3): 7249.
Split
   in Ada.Calendar   *note 9.6(14): 4156.
   in Ada.Calendar.Formatting   *note 9.6.1(29/2): 4199, *note
9.6.1(32/2): 4202, *note 9.6.1(33/2): 4203, *note 9.6.1(34/2): 4204.
   in Ada.Execution_Time   *note D.14(8/2): 8006.
   in Ada.Real_Time   *note D.8(16): 7961.
Sqrt
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(3): 8286.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(4): 6111.
SS2
   in Ada.Characters.Latin_1   *note A.3.3(17): 5612.
SS3
   in Ada.Characters.Latin_1   *note A.3.3(17): 5613.
SSA
   in Ada.Characters.Latin_1   *note A.3.3(17): 5604.
ST
   in Ada.Characters.Latin_1   *note A.3.3(19): 5626.
stand-alone constant   *note 3.3.1(23/3): 1521.
   corresponding to a formal object of mode in   *note 12.4(10/2): 4762.
stand-alone object   *note 3.3.1(1/3): 1473.
   [partial]   *note 12.4(10/2): 4763.
stand-alone variable   *note 3.3.1(23/3): 1522.
Standard   *note A.1(4): 5436.
standard error file   *note A.10(6): 6363.
standard input file   *note A.10(5): 6361.
standard mode   *note 1.1.5(11): 1084.
standard output file   *note A.10(5): 6362.
standard storage pool   *note 13.11(17): 5209.
Standard_Error
   in Ada.Text_IO   *note A.10.1(16): 6398, *note A.10.1(19): 6405.
Standard_Input
   in Ada.Text_IO   *note A.10.1(16): 6396, *note A.10.1(19): 6403.
Standard_Output
   in Ada.Text_IO   *note A.10.1(16): 6397, *note A.10.1(19): 6404.
Start_Search
   in Ada.Directories   *note A.16(32/2): 6662.
State
   in Ada.Numerics.Discrete_Random   *note A.5.2(23): 6165.
   in Ada.Numerics.Float_Random   *note A.5.2(11): 6153.
statement   *note 5.1(3): 3116.
   used   *note 5.1(2/3): 3114, *note P: 9350.
statement_identifier   *note 5.1(8): 3145.
   used   *note 5.1(7): 3144, *note 5.5(2): 3191, *note 5.6(2): 3261,
*note P: 9390.
static   *note 4.9(1): 3086.
   constant   *note 4.9(24): 3091.
   constraint   *note 4.9(27): 3097.
   delta constraint   *note 4.9(29): 3100.
   digits constraint   *note 4.9(29): 3099.
   discrete_range   *note 4.9(25): 3093.
   discriminant constraint   *note 4.9(31): 3102.
   expression   *note 4.9(2): 3088.
   function   *note 4.9(18): 3090.
   index constraint   *note 4.9(30): 3101.
   range   *note 4.9(25): 3092.
   range constraint   *note 4.9(29): 3098.
   scalar subtype   *note 4.9(26/3): 3095.
   string subtype   *note 4.9(26/3): 3096.
   subtype   *note 4.9(26/3): 3094.
   subtype   *note 12.4(9/2): 4760.
static semantics   *note 1.1.2(28): 1027.
Static_Predicate aspect   *note 3.2.4(1/3): 1437.
statically
   constrained   *note 4.9(32): 3103.
   denote   *note 4.9(14): 3089.
statically compatible
   for a constraint and a scalar subtype   *note 4.9.1(4/3): 3109.
   for a constraint and an access or composite subtype   *note
4.9.1(4/3): 3110.
   for two subtypes   *note 4.9.1(5/3): 3111.
statically deeper   *note 3.10.2(4): 2295, *note 3.10.2(17): 2302.
statically determined tag   *note 3.9.2(1/2): 2149.
   [partial]   *note 3.9.2(15): 2174, *note 3.9.2(19): 2178.
statically matching
   effect on subtype-specific aspects   *note 13.1(14): 4897.
   for constraints   *note 4.9.1(1/2): 3106.
   for ranges   *note 4.9.1(3): 3108.
   for subtypes   *note 4.9.1(2/3): 3107.
   required   *note 3.9.2(10/2): 2170, *note 3.10.2(28.1/2): 2309, *note
4.6(24.15/2): 2954, *note 4.6(24.5/2): 2949, *note 6.3.1(16.3/3): 3432,
*note 6.3.1(17/3): 3435, *note 6.3.1(23): 3440, *note 6.5(5.2/3): 3513,
*note 7.3(13): 3615, *note 8.5.1(4.2/2): 3808, *note 12.4(8.1/2): 4756,
*note 12.5.1(14): 4806, *note 12.5.3(6): 4818, *note 12.5.3(7): 4819,
*note 12.5.4(3): 4822, *note 12.7(7): 4865.
statically tagged   *note 3.9.2(4/2): 2167.
statically unevaluated   *note 4.9(32.1/3): 3104.
Status_Error
   in Ada.Direct_IO   *note A.8.4(18): 6347.
   in Ada.Directories   *note A.16(43/2): 6671.
   in Ada.IO_Exceptions   *note A.13(4): 6614.
   in Ada.Sequential_IO   *note A.8.1(15): 6315.
   in Ada.Streams.Stream_IO   *note A.12.1(26): 6595.
   in Ada.Text_IO   *note A.10.1(85): 6520.
storage deallocation
   unchecked   *note 13.11.2(1): 5224.
storage element   *note 13.3(8): 4974.
storage management
   user-defined   *note 13.11(1): 5184.
storage node   *note E(2): 8096.
storage place
   of a component   *note 13.5(1): 5057.
   representation aspect   *note 13.5(1): 5056.
storage place attributes
   of a component   *note 13.5.2(1): 5079.
storage pool   *note 3.10(7/1): 2251, *note N(37.1/3): 8947.
   default   *note 13.11.3(4.2/4): 5252.
storage pool element   *note 13.11(11): 5194.
storage pool that supports subpools   *note 13.11.4(18/3): 5273.
storage pool type   *note 13.11(11): 5192.
Storage_Array
   in System.Storage_Elements   *note 13.7.1(5): 5136.
Storage_Check   *note 11.5(23): 4641.
   [partial]   *note 11.1(6): 4524, *note 13.3(67): 5018, *note
13.11(17): 5210, *note D.7(17/1): 7922, *note D.7(18/1): 7927, *note
D.7(19/1): 7932.
Storage_Count subtype of Storage_Offset
   in System.Storage_Elements   *note 13.7.1(4): 5134.
Storage_Element
   in System.Storage_Elements   *note 13.7.1(5): 5135.
Storage_Elements
   child of System   *note 13.7.1(2/2): 5132.
Storage_Error
   raised by failure of run-time check   *note 4.8(14): 3085, *note
8.5.4(8.1/1): 3834, *note 11.1(4): 4521, *note 11.1(6): 4526, *note
11.5(23): 4642, *note 13.3(67): 5020, *note 13.11(17): 5212, *note
13.11(18/4): 5213, *note A.7(14/3): 6288, *note D.7(17/1): 7924, *note
D.7(18/1): 7929, *note D.7(19.3/3): 7940, *note D.7(19/1): 7934.
   in Standard   *note A.1(46): 5453.
Storage_IO
   child of Ada   *note A.9(3): 6355.
Storage_Offset
   in System.Storage_Elements   *note 13.7.1(3): 5133.
Storage_Pool aspect   *note 13.11(15): 5206.
Storage_Pool attribute   *note 13.11(13): 5198.
Storage_Pool clause   *note 13.3(7/2): 4966, *note 13.11(15): 5203.
storage_pool_indicator   *note 13.11.3(3.1/4): 5249.
   used   *note 13.11.3(3/3): 5248, *note L(8.3/3): 8733.
Storage_Pools
   child of System   *note 13.11(5): 5187.
Storage_Size
   in System.Storage_Pools   *note 13.11(9): 5191.
   in System.Storage_Pools.Subpools   *note 13.11.4(16/3): 5268.
Storage_Size (access) aspect   *note 13.11(15): 5208.
Storage_Size (task) aspect   *note 13.3(65.2/3): 5017.
Storage_Size attribute   *note 13.3(60/3): 5015, *note 13.11(14): 5200,
*note J.9(2): 8519.
Storage_Size clause   *note 13.3(7/2): 4967, *note 13.11(15): 5204.
Storage_Size pragma   *note J.15.4(2/3): 8548, *note L(35.1/3): 8850.
Storage_Unit
   in System   *note 13.7(13): 5119.
stream   *note 13.13(1): 5331, *note N(37.2/3): 8948.
   in Ada.Streams.Stream_IO   *note A.12.1(13): 6585.
   in Ada.Text_IO.Text_Streams   *note A.12.2(4): 6606.
   in Ada.Wide_Text_IO.Text_Streams   *note A.12.3(4): 6609.
   in Ada.Wide_Wide_Text_IO.Text_Streams   *note A.12.4(4/2): 6612.
stream file   *note A.8(1/2): 6292.
stream type   *note 13.13(1): 5332.
stream-oriented attributes   *note 13.13.2(1/3): 5342.
Stream_Access
   in Ada.Streams.Stream_IO   *note A.12.1(4): 6569.
   in Ada.Text_IO.Text_Streams   *note A.12.2(3): 6605.
   in Ada.Wide_Text_IO.Text_Streams   *note A.12.3(3): 6608.
   in Ada.Wide_Wide_Text_IO.Text_Streams   *note A.12.4(3/2): 6611.
Stream_Element
   in Ada.Streams   *note 13.13.1(4/1): 5336.
Stream_Element_Array
   in Ada.Streams   *note 13.13.1(4/1): 5339.
Stream_Element_Count subtype of Stream_Element_Offset
   in Ada.Streams   *note 13.13.1(4/1): 5338.
Stream_Element_Offset
   in Ada.Streams   *note 13.13.1(4/1): 5337.
Stream_IO
   child of Ada.Streams   *note A.12.1(3/3): 6568.
Stream_Size aspect   *note 13.13.2(1.5/2): 5347.
Stream_Size attribute   *note 13.13.2(1.2/3): 5345.
Stream_Size clause   *note 13.3(7/2): 4968.
Streams
   child of Ada   *note 13.13.1(2): 5333.
strict mode   *note G.2(1): 8330.
strict weak ordering   *note A.18(5/3): 6713.
String
   in Standard   *note A.1(37/3): 5447.
string type   *note 3.6.3(1): 1963.
String_Access
   in Ada.Strings.Unbounded   *note A.4.5(7): 5906.
string_element   *note 2.6(3): 1252.
   used   *note 2.6(2): 1251, *note P: 8995.
string_literal   *note 2.6(2): 1250.
   used   *note 4.4(7/3): 2711, *note 6.1(9): 3305, *note P: 9310.
Strings
   child of Ada   *note A.4.1(3): 5770.
   child of Ada.Strings.UTF_Encoding   *note A.4.11(22/3): 6081.
   child of Interfaces.C   *note B.3.1(3): 7496.
Strlen
   in Interfaces.C.Strings   *note B.3.1(17): 7510.
structure
   See record type   *note 3.8(1): 2023.
STS
   in Ada.Characters.Latin_1   *note A.3.3(18): 5617.
STX
   in Ada.Characters.Latin_1   *note A.3.3(5): 5502.
SUB
   in Ada.Characters.Latin_1   *note A.3.3(6): 5526.
Sub_Second
   in Ada.Calendar.Formatting   *note 9.6.1(27/2): 4197.
subaggregate
   of an array_aggregate   *note 4.3.3(6): 2562.
subcomponent   *note 3.2(6/2): 1347.
subpool   *note 13.11.4(18/3): 5269.
subpool access type   *note 13.11.4(22/3): 5275.
subpool handle   *note 13.11.4(18/3): 5271.
Subpool_Handle
   in System.Storage_Pools.Subpools   *note 13.11.4(6/3): 5259.
subpool_specification   *note 4.8(2.1/3): 3048.
   used   *note 4.8(2/3): 3044, *note P: 9347.
Subpools
   child of System.Storage_Pools   *note 13.11.4(3/3): 5256.
subprogram   *note 6(1): 3275, *note N(37.3/2): 8949.
   abstract   *note 3.9.3(3/2): 2192.
subprogram call   *note 6.4(1): 3445.
subprogram instance   *note 12.3(13): 4728.
subprogram_body   *note 6.3(2/3): 3402.
   used   *note 3.11(6): 2340, *note 9.4(8/4): 3984, *note 10.1.1(7):
4343, *note P: 9666.
subprogram_body_stub   *note 10.1.3(3/3): 4392.
   used   *note 10.1.3(2): 4388, *note P: 9678.
subprogram_declaration   *note 6.1(2/3): 3281.
   used   *note 3.1(3/3): 1297, *note 9.4(5/1): 3971, *note 9.4(8/4):
3983, *note 10.1.1(5): 4334, *note P: 9659.
subprogram_default   *note 12.6(3/2): 4839.
   used   *note 12.6(2.1/3): 4833, *note 12.6(2.2/3): 4837, *note P:
9786.
subprogram_renaming_declaration   *note 8.5.4(2/3): 3822.
   used   *note 8.5(2): 3793, *note 10.1.1(6): 4341, *note P: 9512.
subprogram_specification   *note 6.1(4/2): 3285.
   used   *note 3.9.3(1.1/3): 2187, *note 6.1(2/3): 3283, *note
6.3(2/3): 3404, *note 8.5.4(2/3): 3824, *note 10.1.3(3/3): 4394, *note
12.1(3/3): 4672, *note 12.6(2.1/3): 4832, *note 12.6(2.2/3): 4836, *note
P: 9412.
subsystem   *note 10.1(3): 4320, *note N(22): 8922.
subtree
   node which roots   *note A.18.10(3/4): 7196.
   of a tree   *note A.18.10(3/4): 7194.
Subtree_Node_Count
   in Ada.Containers.Multiway_Trees   *note A.18.10(18/3): 7211.
subtype   *note 3.2(8/2): 1354, *note N(38/3): 8950.
   constraint of   *note 3.2(8/2): 1358.
   type of   *note 3.2(8/2): 1356.
   values belonging to   *note 3.2(8/2): 1361.
subtype (of an object)
   See actual subtype of an object   *note 3.3(23/3): 1467.
   See actual subtype of an object   *note 3.3.1(9/2): 1507.
subtype conformance   *note 6.3.1(17/3): 3433.
   [partial]   *note 3.10.2(35/2): 2324, *note 9.5.4(17): 4130.
   required   *note 3.9.2(10/2): 2171, *note 3.10.2(33/3): 2320, *note
4.6(24.20/3): 2960, *note 8.5.1(4.3/2): 3809, *note 8.5.4(5/3): 3832,
*note 9.1(9.7/2): 3924, *note 9.1(9.8/2): 3925, *note 9.4(11.6/2): 3997,
*note 9.4(11.7/2): 3998, *note 9.5.4(5/3): 4124, *note 12.4(8.2/2):
4757, *note 12.5.4(5/3): 4823.
subtype conversion
   See type conversion   *note 4.6(1/3): 2919.
   See also implicit subtype conversion   *note 4.6(1/3): 2923.
subtype-specific
   of a representation item   *note 13.1(8/3): 4890.
   of an aspect   *note 13.1(8/3): 4892.
subtype_declaration   *note 3.2.2(2/3): 1400.
   used   *note 3.1(3/3): 1294, *note P: 9010.
subtype_indication   *note 3.2.2(3/2): 1404.
   used   *note 3.2.2(2/3): 1402, *note 3.3.1(2/3): 1481, *note
3.4(2/2): 1534, *note 3.6(6): 1901, *note 3.6(7/2): 1904, *note
3.6.1(3): 1936, *note 3.8.1(5/3): 2070, *note 3.10(3): 2234, *note
4.8(2/3): 3045, *note 5.5.2(2/3): 3239, *note 6.5(2.3/2): 3507, *note
7.3(3/3): 3607, *note P: 9346.
subtype_mark   *note 3.2.2(4): 1408.
   used   *note 3.2.2(3/2): 1406, *note 3.6(4): 1895, *note 3.7(5/2):
1977, *note 3.9.4(3/2): 2198, *note 3.10(6/2): 2242, *note 4.3.2(3):
2532, *note 4.4(3.2/4): 2694, *note 4.6(2): 2928, *note 4.7(2): 3028,
*note 6.1(13/2): 3313, *note 6.1(15/3): 3323, *note 8.4(4/3): 3781,
*note 8.5.1(2/3): 3801, *note 12.3(5): 4720, *note 12.4(2/3): 4745,
*note 12.5.1(3/2): 4802, *note P: 9748.
subtypes
   of a profile   *note 6.1(25): 3342.
subunit   *note 10.1.3(7): 4405, *note 10.1.3(8/2): 4409.
   of a program unit   *note 10.1.3(8/2): 4410.
   used   *note 10.1.1(3): 4328, *note P: 9655.
Succ attribute   *note 3.5(22): 1625.
Success
   in Ada.Command_Line   *note A.15(8): 6631.
successor element
   of a hashed set   *note A.18.8(68/2): 7108.
   of a set   *note A.18.7(6/2): 7025.
   of an ordered set   *note A.18.9(81/3): 7187.
successor node
   of a hashed map   *note A.18.5(46/2): 6958.
   of a map   *note A.18.4(6/2): 6896.
   of an ordered map   *note A.18.6(58/3): 7016.
Sunday
   in Ada.Calendar.Formatting   *note 9.6.1(17/2): 4185.
super
   See view conversion   *note 4.6(5/2): 2938.
Superscript_One
   in Ada.Characters.Latin_1   *note A.3.3(22): 5658.
Superscript_Three
   in Ada.Characters.Latin_1   *note A.3.3(22): 5651.
Superscript_Two
   in Ada.Characters.Latin_1   *note A.3.3(22): 5650.
support external streaming   *note 13.13.2(52/3): 5396.
Supported
   in Ada.Execution_Time.Interrupts   *note D.14.3(3/3): 8057.
Suppress pragma   *note 11.5(4/2): 4618, *note J.10(3/2): 8522, *note
L(36): 8853.
suppressed check   *note 11.5(8/2): 4627.
Suspend_Until_True
   in Ada.Synchronous_Task_Control   *note D.10(4): 7978.
Suspend_Until_True_And_Set_Deadline
   in Ada.Synchronous_Task_Control.EDF   *note D.10(5.2/3): 7980.
Suspension_Object
   in Ada.Synchronous_Task_Control   *note D.10(4): 7974.
Swap
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(28/2): 6851.
   in Ada.Containers.Multiway_Trees   *note A.18.10(37/3): 7230.
   in Ada.Containers.Vectors   *note A.18.2(55/2): 6778, *note
A.18.2(56/2): 6779.
Swap_Links
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(29/2): 6852.
Symmetric_Difference
   in Ada.Containers.Hashed_Sets   *note A.18.8(35/2): 7074, *note
A.18.8(36/2): 7075.
   in Ada.Containers.Ordered_Sets   *note A.18.9(36/2): 7147, *note
A.18.9(37/2): 7148.
SYN
   in Ada.Characters.Latin_1   *note A.3.3(6): 5522.
synchronization   *note 9(1/3): 3878.
Synchronization aspect   *note 9.5(12/3): 4020.
synchronization_kind   *note 9.5(10/3): 4018.
synchronized   *note N(38.1/2): 8951.
synchronized interface   *note 3.9.4(5/2): 2207.
synchronized tagged type   *note 3.9.4(6/2): 2212.
Synchronized_Queue_Interfaces
   child of Ada.Containers   *note A.18.27(3/3): 7336.
Synchronous_Barrier
   in Ada.Synchronous_Barriers   *note D.10.1(5/3): 7986.
Synchronous_Barriers
   child of Ada   *note D.10.1(3/3): 7984.
Synchronous_Task_Control
   child of Ada   *note D.10(3/2): 7973.
syntactic category   *note 1.1.4(15): 1066.
syntax
   complete listing   *note P(1): 8957.
   cross reference   *note P(1): 9846.
   notation   *note 1.1.4(3): 1060.
   under Syntax heading   *note 1.1.2(25): 1014.
System   *note 13.7(3/2): 5105.
System.Address_To_Access_Conversions   *note 13.7.2(2): 5144.
System.Machine_Code   *note 13.8(7): 5153.
System.Multiprocessors   *note D.16(3/3): 8070.
System.Multiprocessors.Dispatching_Domains   *note D.16.1(3/3): 8077.
System.RPC   *note E.5(3): 8204.
System.Storage_Elements   *note 13.7.1(2/2): 5132.
System.Storage_Pools   *note 13.11(5): 5187.
System.Storage_Pools.Subpools   *note 13.11.4(3/3): 5256.
System_Dispatching_Domain
   in System.Multiprocessors.Dispatching_Domains   *note D.16.1(6/3):
8080.
System_Name
   in System   *note 13.7(4): 5107.
systems programming   *note C(1): 7617.



File: arm2012.info,  Node: T,  Next: U,  Prev: S,  Up: Index

T 
==



Tag
   in Ada.Tags   *note 3.9(6/2): 2101.
Tag attribute   *note 3.9(16): 2122, *note 3.9(18): 2124.
tag indeterminate   *note 3.9.2(6/2): 2169.
tag of an object   *note 3.9(3): 2093.
   class-wide object   *note 3.9(22): 2128.
   object created by an allocator   *note 3.9(21): 2127.
   preserved by type conversion and parameter passing   *note 3.9(25):
2131.
   returned by a function   *note 3.9(23): 2129, *note 3.9(24/2): 2130.
   stand-alone object, component, or aggregate   *note 3.9(20): 2126.
Tag_Array
   in Ada.Tags   *note 3.9(7.3/2): 2111.
Tag_Check   *note 11.5(18): 4636.
   [partial]   *note 3.9.2(16): 2175, *note 4.6(42): 2986, *note
4.6(52): 3011, *note 5.2(10): 3162, *note 6.5(8.1/3): 3528.
Tag_Error
   in Ada.Tags   *note 3.9(8): 2114.
tagged incomplete view   *note 3.10.1(2.1/4): 2281.
tagged type   *note 3.9(2/2): 2087, *note N(39): 8952.
   protected   *note 3.9.4(6/2): 2216.
   synchronized   *note 3.9.4(6/2): 2214.
   task   *note 3.9.4(6/2): 2215.
Tags
   child of Ada   *note 3.9(6/2): 2100.
Tail
   in Ada.Strings.Bounded   *note A.4.4(72): 5897, *note A.4.4(73):
5898.
   in Ada.Strings.Fixed   *note A.4.3(37): 5840, *note A.4.3(38): 5841.
   in Ada.Strings.Unbounded   *note A.4.5(67): 5951, *note A.4.5(68):
5952.
tail (of a queue)   *note D.2.1(5/2): 7778.
tamper with cursors
   of a list   *note A.18.3(62/2): 6875.
   of a map   *note A.18.4(8/2): 6897.
   of a set   *note A.18.7(8/2): 7026.
   of a tree   *note A.18.10(81/3): 7266.
   of a vector   *note A.18.2(91/2): 6803.
tamper with elements
   of a holder   *note A.18.18(30/3): 7302.
   of a list   *note A.18.3(67/2): 6876.
   of a map   *note A.18.4(13/2): 6898.
   of a set   *note A.18.7(13/2): 7027.
   of a tree   *note A.18.10(87/3): 7267.
   of a vector   *note A.18.2(95/2): 6804.
tampering
   prohibited for a holder   *note A.18.18(35/4): 7304.
   prohibited for a list   *note A.18.3(69.1/4): 6878.
   prohibited for a map   *note A.18.4(15.1/4): 6900.
   prohibited for a set   *note A.18.7(14.1/4): 7029.
   prohibited for a tree   *note A.18.10(90/4): 7269.
   prohibited for a vector   *note A.18.2(97.1/4): 6806.
Tan
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(4): 8292.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(5): 6119.
Tanh
   in Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(6): 8300.
   in Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7): 6133.
target
   of an assignment operation   *note 5.2(3): 3155.
   of an assignment_statement   *note 5.2(3): 3156.
target object
   of a requeue_statement   *note 9.5(7): 4015.
   of the name of an entry or a protected subprogram   *note 9.5(2/3):
4012.
target statement
   of a goto_statement   *note 5.8(3): 3273.
target subtype
   of a type_conversion   *note 4.6(3): 2930.
task   *note 9(1/3): 3875.
   activation   *note 9.2(1): 3936.
   completion   *note 9.3(1): 3943.
   dependence   *note 9.3(1): 3942.
   execution   *note 9.2(1): 3934.
   termination   *note 9.3(1): 3944.
task declaration   *note 9.1(1): 3892.
task dispatching   *note D.2.1(4/2): 7772.
task dispatching point   *note D.2.1(4/2): 7774.
   [partial]   *note D.2.3(8/2): 7800, *note D.2.4(9/3): 7809.
task dispatching policy   *note D.2.2(7/2): 7796.
   [partial]   *note D.2.1(5/2): 7780.
   EDF_Across_Priorities   *note D.2.6(7/2): 7819.
   FIFO_Within_Priorities   *note D.2.3(2/2): 7798.
   Non_Preemptive_FIFO_Within_Priorities   *note D.2.4(2/2): 7804.
   Round_Robin_Within_Priorities   *note D.2.5(2/2): 7811.
task interface   *note 3.9.4(5/2): 2209.
task priority   *note D.1(15): 7761.
task state
   abnormal   *note 9.8(4): 4285.
   blocked   *note 9(10): 3885.
   callable   *note 9.9(2): 4299.
   held   *note D.11(4/2): 7992.
   inactive   *note 9(10): 3883.
   ready   *note 9(10): 3887.
   terminated   *note 9(10): 3889.
task tagged type   *note 3.9.4(6/2): 2217.
task type   *note N(40/2): 8953.
task unit   *note 9(9): 3882.
Task_Array
   in Ada.Execution_Time.Group_Budgets   *note D.14.2(6/2): 8033.
Task_Attributes
   child of Ada   *note C.7.2(2): 7728.
task_body   *note 9.1(6/3): 3911.
   used   *note 3.11(6): 2342, *note P: 9194.
task_body_stub   *note 10.1.3(5/3): 4399.
   used   *note 10.1.3(2): 4390, *note P: 9680.
task_definition   *note 9.1(4): 3904.
   used   *note 9.1(2/3): 3898, *note 9.1(3/3): 3903, *note P: 9550.
Task_Dispatching_Policy pragma   *note D.2.2(3): 7785, *note L(37):
8856.
Task_Id
   in Ada.Task_Identification   *note C.7.1(2/2): 7709.
Task_Identification
   child of Ada   *note C.7.1(2/2): 7708.
task_item   *note 9.1(5/1): 3908.
   used   *note 9.1(4): 3906, *note P: 9551.
Task_Termination
   child of Ada   *note C.7.3(2/2): 7740.
task_type_declaration   *note 9.1(2/3): 3893.
   used   *note 3.2.1(3/3): 1378, *note P: 9031.
Tasking_Error
   raised by failure of run-time check   *note 9.2(5): 3940, *note
9.5.3(21): 4116, *note 11.1(4): 4522, *note 13.11.2(13): 5236, *note
13.11.2(14): 5238, *note C.7.2(13): 7734, *note D.5.1(8): 7868, *note
D.11(8): 7995.
   in Standard   *note A.1(46): 5454.
template   *note 12(1): 4663.
   for a formal package   *note 12.7(4): 4864.
   See generic unit   *note 12(1): 4664.
term   *note 4.4(5): 2700.
   used   *note 4.4(4): 2697, *note P: 9301.
terminal interrupt
   example   *note 9.7.4(10): 4271.
terminate_alternative   *note 9.7.1(7): 4233.
   used   *note 9.7.1(4): 4226, *note P: 9629.
terminated
   a task state   *note 9(10): 3890.
Terminated attribute   *note 9.9(3): 4302.
termination
   of a partition   *note E.1(7): 8104.
termination handler   *note C.7.3(8/3): 7747.
   fall-back   *note C.7.3(9/2): 7750.
   specific   *note C.7.3(9/2): 7752.
Termination_Handler
   in Ada.Task_Termination   *note C.7.3(4/2): 7742.
Terminator_Error
   in Interfaces.C   *note B.3(40): 7491.
tested type
   of a membership test   *note 4.5.2(3/3): 2794.
text of a program   *note 2.2(1): 1179.
Text_IO
   child of Ada   *note A.10.1(2): 6374.
Text_Streams
   child of Ada.Text_IO   *note A.12.2(3): 6604.
   child of Ada.Wide_Text_IO   *note A.12.3(3): 6607.
   child of Ada.Wide_Wide_Text_IO   *note A.12.4(3/2): 6610.
throw (an exception)
   See raise   *note 11(1/3): 4509.
Thursday
   in Ada.Calendar.Formatting   *note 9.6.1(17/2): 4182.
tick   *note 2.1(15/3): 1155.
   in Ada.Real_Time   *note D.8(6): 7951.
   in System   *note 13.7(10): 5116.
Tilde
   in Ada.Characters.Latin_1   *note A.3.3(14): 5591.
Time
   in Ada.Calendar   *note 9.6(10): 4146.
   in Ada.Real_Time   *note D.8(4): 7942.
time base   *note 9.6(6/3): 4143.
time limit
   example   *note 9.7.4(12): 4274.
time type   *note 9.6(6/3): 4142.
Time-dependent Reset procedure
   of the random number generator   *note A.5.2(34): 6174.
time-out
   example   *note 9.7.4(12): 4273.
   See asynchronous_select   *note 9.7.4(12): 4272.
   See selective_accept   *note 9.7.1(1): 4214.
   See timed_entry_call   *note 9.7.2(1/2): 4240.
Time_Error
   in Ada.Calendar   *note 9.6(18): 4158.
Time_First
   in Ada.Real_Time   *note D.8(4): 7943.
Time_Last
   in Ada.Real_Time   *note D.8(4): 7944.
Time_Of
   in Ada.Calendar   *note 9.6(15): 4157.
   in Ada.Calendar.Formatting   *note 9.6.1(30/2): 4200, *note
9.6.1(31/2): 4201.
   in Ada.Execution_Time   *note D.14(9/2): 8007.
   in Ada.Real_Time   *note D.8(16): 7962.
Time_Of_Event
   in Ada.Real_Time.Timing_Events   *note D.15(6/2): 8065.
Time_Offset
   in Ada.Calendar.Time_Zones   *note 9.6.1(4/2): 4170.
Time_Remaining
   in Ada.Execution_Time.Timers   *note D.14.1(8/2): 8023.
Time_Span
   in Ada.Real_Time   *note D.8(5): 7946.
Time_Span_First
   in Ada.Real_Time   *note D.8(5): 7947.
Time_Span_Last
   in Ada.Real_Time   *note D.8(5): 7948.
Time_Span_Unit
   in Ada.Real_Time   *note D.8(5): 7950.
Time_Span_Zero
   in Ada.Real_Time   *note D.8(5): 7949.
Time_Unit
   in Ada.Real_Time   *note D.8(4): 7945.
Time_Zones
   child of Ada.Calendar   *note 9.6.1(2/2): 4169.
timed_entry_call   *note 9.7.2(2): 4241.
   used   *note 9.7(2): 4211, *note P: 9618.
Timer
   in Ada.Execution_Time.Timers   *note D.14.1(4/2): 8016.
timer interrupt
   example   *note 9.7.4(12): 4276.
Timer_Handler
   in Ada.Execution_Time.Timers   *note D.14.1(5/2): 8017.
Timer_Resource_Error
   in Ada.Execution_Time.Timers   *note D.14.1(9/2): 8024.
Timers
   child of Ada.Execution_Time   *note D.14.1(3/2): 8015.
times operator   *note 4.4(1/3): 2636, *note 4.5.5(1): 2844.
timing
   See delay_statement   *note 9.6(1): 4132.
Timing_Event
   in Ada.Real_Time.Timing_Events   *note D.15(4/2): 8059.
Timing_Event_Handler
   in Ada.Real_Time.Timing_Events   *note D.15(4/2): 8060.
Timing_Events
   child of Ada.Real_Time   *note D.15(3/2): 8058.
To_Ada
   in Interfaces.C   *note B.3(22): 7454, *note B.3(26): 7458, *note
B.3(28): 7460, *note B.3(32): 7464, *note B.3(37): 7468, *note B.3(39):
7470, *note B.3(39.10/2): 7480, *note B.3(39.13/2): 7484, *note
B.3(39.17/2): 7488, *note B.3(39.19/2): 7490, *note B.3(39.4/2): 7474,
*note B.3(39.8/2): 7478.
   in Interfaces.COBOL   *note B.4(17): 7559, *note B.4(19): 7561.
   in Interfaces.Fortran   *note B.5(13): 7612, *note B.5(14): 7614,
*note B.5(16): 7616.
To_Address
   in System.Address_To_Access_Conversions   *note 13.7.2(3/3): 5146.
   in System.Storage_Elements   *note 13.7.1(10/3): 5139.
To_Basic
   in Ada.Characters.Handling   *note A.3.2(6): 5479, *note A.3.2(7):
5482.
To_Binary
   in Interfaces.COBOL   *note B.4(45): 7591, *note B.4(48): 7594.
To_Bounded_String
   in Ada.Strings.Bounded   *note A.4.4(11): 5850.
To_C
   in Interfaces.C   *note B.3(21): 7453, *note B.3(25): 7457, *note
B.3(27): 7459, *note B.3(32): 7463, *note B.3(36): 7467, *note B.3(38):
7469, *note B.3(39.13/2): 7483, *note B.3(39.16/2): 7487, *note
B.3(39.18/2): 7489, *note B.3(39.4/2): 7473, *note B.3(39.7/2): 7477,
*note B.3(39.9/2): 7479.
To_Character
   in Ada.Characters.Conversions   *note A.3.4(5/2): 5744.
To_Chars_Ptr
   in Interfaces.C.Strings   *note B.3.1(8): 7501.
To_COBOL
   in Interfaces.COBOL   *note B.4(17): 7558, *note B.4(18): 7560.
To_Cursor
   in Ada.Containers.Vectors   *note A.18.2(25/2): 6741.
To_Decimal
   in Interfaces.COBOL   *note B.4(35): 7582, *note B.4(40): 7586, *note
B.4(44): 7590, *note B.4(47): 7593.
To_Display
   in Interfaces.COBOL   *note B.4(36): 7583.
To_Domain
   in Ada.Strings.Maps   *note A.4.2(24): 5801.
   in Ada.Strings.Wide_Maps   *note A.4.7(24): 6003.
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(24/2): 6042.
To_Duration
   in Ada.Real_Time   *note D.8(13): 7953.
To_Fortran
   in Interfaces.Fortran   *note B.5(13): 7611, *note B.5(14): 7613,
*note B.5(15): 7615.
To_Holder
   in Ada.Containers.Indefinite_Holders   *note A.18.18(9/3): 7287.
To_Index
   in Ada.Containers.Vectors   *note A.18.2(26/2): 6742.
To_Integer
   in System.Storage_Elements   *note 13.7.1(10/3): 5140.
To_ISO_646
   in Ada.Characters.Handling   *note A.3.2(11): 5486, *note A.3.2(12):
5487.
To_Long_Binary
   in Interfaces.COBOL   *note B.4(48): 7595.
To_Lower
   in Ada.Characters.Handling   *note A.3.2(6): 5477, *note A.3.2(7):
5480.
   in Ada.Wide_Characters.Handling   *note A.3.5(20/3): 5765, *note
A.3.5(21/3): 5767.
To_Mapping
   in Ada.Strings.Maps   *note A.4.2(23): 5800.
   in Ada.Strings.Wide_Maps   *note A.4.7(23): 6002.
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(23/2): 6041.
To_Packed
   in Interfaces.COBOL   *note B.4(41): 7587.
To_Picture
   in Ada.Text_IO.Editing   *note F.3.3(6): 8237.
To_Pointer
   in System.Address_To_Access_Conversions   *note 13.7.2(3/3): 5145.
To_Range
   in Ada.Strings.Maps   *note A.4.2(24): 5802.
   in Ada.Strings.Wide_Maps   *note A.4.7(25): 6004.
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(25/2): 6043.
To_Ranges
   in Ada.Strings.Maps   *note A.4.2(10): 5790.
   in Ada.Strings.Wide_Maps   *note A.4.7(10): 5992.
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(10/2): 6031.
To_Sequence
   in Ada.Strings.Maps   *note A.4.2(19): 5796.
   in Ada.Strings.Wide_Maps   *note A.4.7(19): 5998.
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(19/2): 6037.
To_Set
   in Ada.Containers.Hashed_Sets   *note A.18.8(9/2): 7048.
   in Ada.Containers.Ordered_Sets   *note A.18.9(10/2): 7121.
   in Ada.Strings.Maps   *note A.4.2(8): 5788, *note A.4.2(9): 5789,
*note A.4.2(17): 5794, *note A.4.2(18): 5795.
   in Ada.Strings.Wide_Maps   *note A.4.7(8): 5990, *note A.4.7(9):
5991, *note A.4.7(17): 5996, *note A.4.7(18): 5997.
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(8/2): 6029, *note
A.4.8(9/2): 6030, *note A.4.8(17/2): 6035, *note A.4.8(18/2): 6036.
To_String
   in Ada.Characters.Conversions   *note A.3.4(5/2): 5745.
   in Ada.Strings.Bounded   *note A.4.4(12): 5851.
   in Ada.Strings.Unbounded   *note A.4.5(11): 5910.
To_Time_Span
   in Ada.Real_Time   *note D.8(13): 7954.
To_Unbounded_String
   in Ada.Strings.Unbounded   *note A.4.5(9): 5908, *note A.4.5(10):
5909.
To_Upper
   in Ada.Characters.Handling   *note A.3.2(6): 5478, *note A.3.2(7):
5481.
   in Ada.Wide_Characters.Handling   *note A.3.5(20/3): 5766, *note
A.3.5(21/3): 5768.
To_Vector
   in Ada.Containers.Vectors   *note A.18.2(13/2): 6733, *note
A.18.2(14/2): 6734.
To_Wide_Character
   in Ada.Characters.Conversions   *note A.3.4(4/2): 5736, *note
A.3.4(5/2): 5746.
To_Wide_String
   in Ada.Characters.Conversions   *note A.3.4(4/2): 5737, *note
A.3.4(5/2): 5747.
To_Wide_Wide_Character
   in Ada.Characters.Conversions   *note A.3.4(4/2): 5738.
To_Wide_Wide_String
   in Ada.Characters.Conversions   *note A.3.4(4/2): 5739.
token
   See lexical element   *note 2.2(1): 1181.
Trailing_Nonseparate
   in Interfaces.COBOL   *note B.4(23): 7568.
Trailing_Separate
   in Interfaces.COBOL   *note B.4(23): 7566.
transfer of control   *note 5.1(14/2): 3148.
Translate
   in Ada.Strings.Bounded   *note A.4.4(53): 5879, *note A.4.4(54):
5880, *note A.4.4(55): 5881, *note A.4.4(56): 5882.
   in Ada.Strings.Fixed   *note A.4.3(18): 5822, *note A.4.3(19): 5823,
*note A.4.3(20): 5824, *note A.4.3(21): 5825.
   in Ada.Strings.Unbounded   *note A.4.5(48): 5933, *note A.4.5(49):
5934, *note A.4.5(50): 5935, *note A.4.5(51): 5936.
Translation_Error
   in Ada.Strings   *note A.4.1(5): 5777.
Transpose
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(34/2): 8414.
   in Ada.Numerics.Generic_Real_Arrays   *note G.3.1(17/2): 8374.
Tree
   in Ada.Containers.Multiway_Trees   *note A.18.10(8/3): 7202.
Tree_Iterator_Interfaces
   in Ada.Containers.Multiway_Trees   *note A.18.10(13/3): 7207.
triggering_alternative   *note 9.7.4(3): 4258.
   used   *note 9.7.4(2): 4256, *note P: 9642.
triggering_statement   *note 9.7.4(4/2): 4261.
   used   *note 9.7.4(3): 4259, *note P: 9644.
Trim
   in Ada.Strings.Bounded   *note A.4.4(67): 5891, *note A.4.4(68):
5893, *note A.4.4(69): 5894.
   in Ada.Strings.Fixed   *note A.4.3(31): 5834, *note A.4.3(32): 5835,
*note A.4.3(33): 5836, *note A.4.3(34): 5837.
   in Ada.Strings.Unbounded   *note A.4.5(61): 5945, *note A.4.5(62):
5946, *note A.4.5(63): 5947, *note A.4.5(64): 5948.
Trim_End
   in Ada.Strings   *note A.4.1(6): 5782.
True   *note 3.5.3(1): 1715.
Truncation
   in Ada.Strings   *note A.4.1(6): 5779.
Truncation attribute   *note A.5.3(42): 6230.
Tuesday
   in Ada.Calendar.Formatting   *note 9.6.1(17/2): 4180.
two's complement
   modular types   *note 3.5.4(29): 1767.
type   *note 3.2(1): 1328, *note N(41/2): 8954.
   abstract   *note 3.9.3(1.2/2): 2190.
   needs finalization   *note 7.6(9.1/2): 3671.
   of a subtype   *note 3.2(8/2): 1355.
   synchronized tagged   *note 3.9.4(6/2): 2213.
   See also tag   *note 3.9(3): 2097.
   See also language-defined types
type conformance   *note 6.3.1(15/2): 3427.
   [partial]   *note 3.4(17/2): 1552, *note 8.3(8): 3749, *note
8.3(26/2): 3771, *note 10.1.4(4/3): 4415.
   required   *note 3.11.1(5): 2356, *note 4.1.4(14/2): 2449, *note
8.6(26): 3866, *note 9.1(9.2/3): 3921, *note 9.1(9.5/3): 3923, *note
9.4(11.1/3): 3994, *note 9.4(11.4/3): 3996, *note 9.5.4(3/3): 4123,
*note 12.4(5/2): 4755.
type conversion   *note 4.6(1/3): 2920.
   access   *note 4.6(24.11/2): 2951, *note 4.6(24.18/2): 2956, *note
4.6(24.19/2): 2958, *note 4.6(47): 2994.
   arbitrary order   *note 1.1.4(18): 1070.
   array   *note 4.6(24.2/2): 2946, *note 4.6(36): 2975.
   composite (non-array)   *note 4.6(21/3): 2940, *note 4.6(40): 2984.
   enumeration   *note 4.6(21.1/2): 2942, *note 4.6(34): 2973.
   numeric   *note 4.6(24.1/2): 2944, *note 4.6(29): 2970.
   unchecked   *note 13.9(1): 5155.
   See also qualified_expression   *note 4.7(1): 3024.
type conversion, implicit
   See implicit subtype conversion   *note 4.6(1/3): 2924.
type extension   *note 3.9(2/2): 2088, *note 3.9.1(1/2): 2135.
type invariant   *note N(41.1/4): 8955.
   class-wide   *note 7.3.2(3/4): 3633.
type of a discrete_range   *note 3.6.1(4): 1938.
type of a range   *note 3.5(4): 1594.
type parameter
   See discriminant   *note 3.7(1/2): 1965.
type profile
   See profile, type conformant   *note 6.3.1(15/2): 3429.
type resolution rules   *note 8.6(20/2): 3860.
   if any type in a specified class of types is expected   *note
8.6(21): 3861.
   if expected type is specific   *note 8.6(22): 3863.
   if expected type is universal or class-wide   *note 8.6(21): 3862.
type tag
   See tag   *note 3.9(3): 2095.
type-related
   aspect   *note 13.1(8.1/3): 4896, *note 13.1(8/3): 4891.
   operational item   *note 13.1(8.1/3): 4895.
   representation item   *note 13.1(8/3): 4889.
type_conversion   *note 4.6(2): 2925.
   used   *note 4.1(2/3): 2366, *note P: 9202.
   See also unchecked type conversion   *note 13.9(1): 5157.
type_declaration   *note 3.2.1(2): 1368.
   used   *note 3.1(3/3): 1293, *note P: 9009.
type_definition   *note 3.2.1(4/2): 1380.
   used   *note 3.2.1(3/3): 1376, *note P: 9029.
Type_Invariant aspect   *note 7.3.2(2/3): 3629.
Type_Invariant'Class aspect   *note 7.3.2(3/4): 3631.
Type_Set
   in Ada.Text_IO   *note A.10.1(7): 6382.
types
   of a profile   *note 6.1(29): 3343.



File: arm2012.info,  Node: U,  Next: V,  Prev: T,  Up: Index

U 
==



UC_A_Acute
   in Ada.Characters.Latin_1   *note A.3.3(23): 5666.
UC_A_Circumflex
   in Ada.Characters.Latin_1   *note A.3.3(23): 5667.
UC_A_Diaeresis
   in Ada.Characters.Latin_1   *note A.3.3(23): 5669.
UC_A_Grave
   in Ada.Characters.Latin_1   *note A.3.3(23): 5665.
UC_A_Ring
   in Ada.Characters.Latin_1   *note A.3.3(23): 5670.
UC_A_Tilde
   in Ada.Characters.Latin_1   *note A.3.3(23): 5668.
UC_AE_Diphthong
   in Ada.Characters.Latin_1   *note A.3.3(23): 5671.
UC_C_Cedilla
   in Ada.Characters.Latin_1   *note A.3.3(23): 5672.
UC_E_Acute
   in Ada.Characters.Latin_1   *note A.3.3(23): 5674.
UC_E_Circumflex
   in Ada.Characters.Latin_1   *note A.3.3(23): 5675.
UC_E_Diaeresis
   in Ada.Characters.Latin_1   *note A.3.3(23): 5676.
UC_E_Grave
   in Ada.Characters.Latin_1   *note A.3.3(23): 5673.
UC_I_Acute
   in Ada.Characters.Latin_1   *note A.3.3(23): 5678.
UC_I_Circumflex
   in Ada.Characters.Latin_1   *note A.3.3(23): 5679.
UC_I_Diaeresis
   in Ada.Characters.Latin_1   *note A.3.3(23): 5680.
UC_I_Grave
   in Ada.Characters.Latin_1   *note A.3.3(23): 5677.
UC_Icelandic_Eth
   in Ada.Characters.Latin_1   *note A.3.3(24): 5681.
UC_Icelandic_Thorn
   in Ada.Characters.Latin_1   *note A.3.3(24): 5695.
UC_N_Tilde
   in Ada.Characters.Latin_1   *note A.3.3(24): 5682.
UC_O_Acute
   in Ada.Characters.Latin_1   *note A.3.3(24): 5684.
UC_O_Circumflex
   in Ada.Characters.Latin_1   *note A.3.3(24): 5685.
UC_O_Diaeresis
   in Ada.Characters.Latin_1   *note A.3.3(24): 5687.
UC_O_Grave
   in Ada.Characters.Latin_1   *note A.3.3(24): 5683.
UC_O_Oblique_Stroke
   in Ada.Characters.Latin_1   *note A.3.3(24): 5689.
UC_O_Tilde
   in Ada.Characters.Latin_1   *note A.3.3(24): 5686.
UC_U_Acute
   in Ada.Characters.Latin_1   *note A.3.3(24): 5691.
UC_U_Circumflex
   in Ada.Characters.Latin_1   *note A.3.3(24): 5692.
UC_U_Diaeresis
   in Ada.Characters.Latin_1   *note A.3.3(24): 5693.
UC_U_Grave
   in Ada.Characters.Latin_1   *note A.3.3(24): 5690.
UC_Y_Acute
   in Ada.Characters.Latin_1   *note A.3.3(24): 5694.
UCHAR_MAX
   in Interfaces.C   *note B.3(6): 7436.
ultimate ancestor
   of a type   *note 3.4.1(10/2): 1578.
unary adding operator   *note 4.5.4(1): 2828.
unary operator   *note 4.5(9): 2734.
unary_adding_operator   *note 4.5(5): 2727.
   used   *note 4.4(4): 2696, *note P: 9298.
Unbiased_Rounding attribute   *note A.5.3(39): 6225.
Unbounded
   child of Ada.Strings   *note A.4.5(3): 5902.
   in Ada.Text_IO   *note A.10.1(5): 6379.
Unbounded_IO
   child of Ada.Text_IO   *note A.10.12(3/2): 6546.
   child of Ada.Wide_Text_IO   *note A.11(5/3): 6563.
   child of Ada.Wide_Wide_Text_IO   *note A.11(5/3): 6564.
Unbounded_Priority_Queues
   child of Ada.Containers   *note A.18.30(2/3): 7355.
Unbounded_Slice
   in Ada.Strings.Unbounded   *note A.4.5(22.1/2): 5918, *note
A.4.5(22.2/2): 5919.
Unbounded_String
   in Ada.Strings.Unbounded   *note A.4.5(4/2): 5903.
Unbounded_Synchronized_Queues
   child of Ada.Containers   *note A.18.28(2/3): 7343.
unchecked storage deallocation   *note 13.11.2(1): 5223.
unchecked type conversion   *note 13.9(1): 5154.
unchecked union object   *note B.3.3(6/3): 7539.
unchecked union subtype   *note B.3.3(6/3): 7538.
unchecked union type   *note B.3.3(6/3): 7537.
Unchecked_Access attribute   *note 13.10(3): 5181, *note H.4(18): 8471.
   See also Access attribute   *note 3.10.2(25/1): 2308.
Unchecked_Conversion
   child of Ada   *note 13.9(3/3): 5159.
Unchecked_Deallocation
   child of Ada   *note 13.11.2(3/3): 5228.
Unchecked_Union aspect   *note B.3.3(3.2/3): 7536.
Unchecked_Union pragma   *note J.15.6(2/3): 8586, *note L(37.2/3): 8859.
unconstrained   *note 3.2(9): 1363.
   object   *note 3.3.1(9/2): 1509.
   object   *note 6.4.1(16): 3487.
   subtype   *note 3.2(9): 1365, *note 3.4(6): 1542, *note 3.5(7): 1603,
*note 3.5.1(10): 1700, *note 3.5.4(9): 1736, *note 3.5.4(10): 1739,
*note 3.5.7(11): 1814, *note 3.5.9(13): 1852, *note 3.5.9(16): 1856,
*note 3.6(15): 1918, *note 3.6(16): 1921, *note 3.7(26): 1995, *note
3.9(15): 2119.
   subtype   *note 3.10(14/3): 2270.
   subtype   *note K.2(33): 8653.
unconstrained_array_definition   *note 3.6(3): 1890.
   used   *note 3.6(2): 1888, *note P: 9105.
undefined result   *note 11.6(5): 4656.
underline   *note 2.1(15/3): 1175.
   used   *note 2.4.1(3): 1217, *note 2.4.2(4): 1242, *note P: 8981.
Uniformly_Distributed subtype of Float
   in Ada.Numerics.Float_Random   *note A.5.2(8): 6149.
uninitialized allocator   *note 4.8(4): 3053.
uninitialized variables   *note 13.9.1(2): 5165.
   [partial]   *note 3.3.1(21/3): 1520.
union
   C   *note B.3.3(1/3): 7534.
   in Ada.Containers.Hashed_Sets   *note A.18.8(26/2): 7068, *note
A.18.8(27/2): 7069.
   in Ada.Containers.Ordered_Sets   *note A.18.9(27/2): 7141, *note
A.18.9(28/2): 7142.
unit consistency   *note E.3(6): 8176.
unit matrix
   complex matrix   *note G.3.2(148/2): 8425.
   real matrix   *note G.3.1(80/2): 8385.
unit vector
   complex vector   *note G.3.2(90/2): 8424.
   real vector   *note G.3.1(48/2): 8384.
Unit_Matrix
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(51/2): 8421.
   in Ada.Numerics.Generic_Real_Arrays   *note G.3.1(29/2): 8381.
Unit_Vector
   in Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(24/2): 8401.
   in Ada.Numerics.Generic_Real_Arrays   *note G.3.1(14/2): 8373.
universal type   *note 3.4.1(6/2): 1568.
universal_access
   [partial]   *note 3.4.1(6/2): 1572, *note 4.2(8/2): 2483.
universal_fixed
   [partial]   *note 3.4.1(6/2): 1571, *note 3.5.6(4): 1791.
universal_integer
   [partial]   *note 3.4.1(6/2): 1569, *note 3.5.4(14): 1746, *note
3.5.4(30): 1768, *note 4.2(8/2): 2481.
universal_real
   [partial]   *note 3.4.1(6/2): 1570, *note 3.5.6(4): 1789, *note
4.2(8/2): 2482.
unknown discriminants   *note 3.7(26): 1996.
unknown_discriminant_part   *note 3.7(3): 1970.
   used   *note 3.7(2/2): 1968, *note P: 9122.
Unknown_Zone_Error
   in Ada.Calendar.Time_Zones   *note 9.6.1(5/2): 4171.
unmarshalling   *note E.4(9): 8184.
unpolluted   *note 13.13.1(2): 5334.
unsigned
   in Interfaces.C   *note B.3(9): 7441.
   in Interfaces.COBOL   *note B.4(23): 7564.
unsigned type
   See modular type   *note 3.5.4(1): 1720.
unsigned_char
   in Interfaces.C   *note B.3(10): 7444.
unsigned_long
   in Interfaces.C   *note B.3(9): 7443.
Unsigned_N   *note B.2(8): 7426.
unsigned_short
   in Interfaces.C   *note B.3(9): 7442.
unspecified   *note 1.1.3(18): 1055.
   [partial]   *note 2.1(5/3): 1130, *note 3.9(4/2): 2099, *note
3.9(12.5/3): 2116, *note 4.5.2(13): 2796, *note 4.5.2(24.2/1): 2799,
*note 4.5.5(21): 2854, *note 4.6(58.4/4): 3020, *note 6.1.1(34/3): 3381,
*note 6.1.1(35/3): 3386, *note 6.2(11/3): 3396, *note 7.2(5/3): 3593,
*note 7.6(17.4/3): 3682, *note 9.8(14): 4289, *note 9.10(1/3): 4307,
*note 10.2(26): 4459, *note 11.1(6): 4527, *note 11.4.1(10.1/4): 4585,
*note 11.5(27/2): 4645, *note 13.1(18): 4899, *note 13.7.2(5/2): 5147,
*note 13.9.1(7): 5169, *note 13.11(20): 5214, *note 13.11(21.6/3): 5216,
*note 13.13.2(36/2): 5368, *note A.1(1/3): 5434, *note A.5.1(34): 6144,
*note A.5.2(28): 6172, *note A.5.2(34): 6173, *note A.5.3(41.3/2): 6228,
*note A.7(6): 6286, *note A.10(8): 6367, *note A.10.7(8/3): 6531, *note
A.10.7(12/3): 6532, *note A.10.7(17.3/2): 6533, *note A.10.7(19): 6534,
*note A.14(1): 6625, *note A.18.2(231/3): 6808, *note A.18.2(252/2):
6816, *note A.18.2(83/2): 6801, *note A.18.3(145/3): 6880, *note
A.18.3(157/2): 6886, *note A.18.3(55/2): 6873, *note A.18.4(3/2): 6890,
*note A.18.4(80/2): 6906, *note A.18.5(43/2): 6953, *note A.18.5(44/2):
6954, *note A.18.5(45/2): 6955, *note A.18.5(46/2): 6959, *note
A.18.6(56/3): 7012, *note A.18.6(57/2): 7013, *note A.18.7(3/2): 7020,
*note A.18.7(101/2): 7038, *note A.18.7(87/2): 7031, *note A.18.7(88/2):
7032, *note A.18.8(65/2): 7102, *note A.18.8(66.1/3): 7104, *note
A.18.8(66/2): 7103, *note A.18.8(67/2): 7105, *note A.18.8(68/2): 7109,
*note A.18.8(86/2): 7110, *note A.18.8(87/2): 7111, *note A.18.9(114/2):
7189, *note A.18.9(79.1/3): 7183, *note A.18.9(79/3): 7182, *note
A.18.9(80/2): 7184, *note A.18.10(227/3): 7275, *note A.18.10(72/3):
7264, *note A.18.26(5/3): 7331, *note A.18.26(9.4/3): 7335, *note
A.18.26(9/3): 7333, *note D.2.2(7.1/2): 7797, *note D.8(19): 7965, *note
E.3(5/1): 8174, *note G.1.1(40): 8283, *note G.1.2(33): 8310, *note
G.1.2(48): 8313, *note H(4.1): 8428, *note H.2(1): 8435, *note
K.2(136.4/2): 8671.
Unsuppress pragma   *note 11.5(4.1/2): 4621, *note L(37.3/2): 8862.
update
   the value of an object   *note 3.3(14): 1464.
   in Interfaces.C.Strings   *note B.3.1(18): 7511, *note B.3.1(19):
7512.
Update_Element
   in Ada.Containers.Doubly_Linked_Lists   *note A.18.3(17/2): 6835.
   in Ada.Containers.Hashed_Maps   *note A.18.5(17/2): 6924.
   in Ada.Containers.Indefinite_Holders   *note A.18.18(15/3): 7293.
   in Ada.Containers.Multiway_Trees   *note A.18.10(27/3): 7220.
   in Ada.Containers.Ordered_Maps   *note A.18.6(16/2): 6975.
   in Ada.Containers.Vectors   *note A.18.2(33/2): 6749, *note
A.18.2(34/2): 6750.
Update_Element_Preserving_Key
   in Ada.Containers.Hashed_Sets   *note A.18.8(58/2): 7095.
   in Ada.Containers.Ordered_Sets   *note A.18.9(73/2): 7176.
Update_Error
   in Interfaces.C.Strings   *note B.3.1(20): 7513.
upper bound
   of a range   *note 3.5(4): 1593.
upper-case letter
   a category of Character   *note A.3.2(26): 5492.
Upper_Case_Map
   in Ada.Strings.Maps.Constants   *note A.4.6(5): 5967.
Upper_Set
   in Ada.Strings.Maps.Constants   *note A.4.6(4): 5959.
US
   in Ada.Characters.Latin_1   *note A.3.3(6): 5531.
usage name   *note 3.1(10): 1322.
use-visible   *note 8.3(4): 3742, *note 8.4(9): 3786.
use_clause   *note 8.4(2): 3774.
   used   *note 3.11(4/1): 2335, *note 10.1.2(3): 4372, *note 12.1(5):
4679, *note P: 9716.
Use_Error
   in Ada.Direct_IO   *note A.8.4(18): 6350.
   in Ada.Directories   *note A.16(43/2): 6673.
   in Ada.IO_Exceptions   *note A.13(4): 6617.
   in Ada.Sequential_IO   *note A.8.1(15): 6318.
   in Ada.Streams.Stream_IO   *note A.12.1(26): 6598.
   in Ada.Text_IO   *note A.10.1(85): 6523.
use_package_clause   *note 8.4(3): 3777.
   used   *note 8.4(2): 3775, *note P: 9503.
use_type_clause   *note 8.4(4/3): 3780.
   used   *note 8.4(2): 3776, *note P: 9504.
user-defined assignment   *note 7.6(1): 3652.
user-defined heap management   *note 13.11(1): 5185.
user-defined operator   *note 6.6(1): 3540.
user-defined storage management   *note 13.11(1): 5183.
UTC_Time_Offset
   in Ada.Calendar.Time_Zones   *note 9.6.1(6/2): 4172.
UTF-16   *note A.4.11(46/3): 6105.
UTF-8   *note A.4.11(46/3): 6104.
UTF_16_Wide_String subtype of Wide_String
   in Ada.Strings.UTF_Encoding   *note A.4.11(7/3): 6068.
UTF_8_String subtype of String
   in Ada.Strings.UTF_Encoding   *note A.4.11(6/3): 6067.
UTF_Encoding
   child of Ada.Strings   *note A.4.11(3/3): 6064.
UTF_String subtype of String
   in Ada.Strings.UTF_Encoding   *note A.4.11(5/3): 6066.



File: arm2012.info,  Node: V,  Next: W,  Prev: U,  Up: Index

V 
==



Val attribute   *note 3.5.5(5): 1773.
Valid
   in Ada.Text_IO.Editing   *note F.3.3(5): 8236, *note F.3.3(12): 8248.
   in Interfaces.COBOL   *note B.4(33): 7580, *note B.4(38): 7584, *note
B.4(43): 7588.
Valid attribute   *note 13.9.2(3/4): 5178, *note H(6): 8430.
Value
   in Ada.Calendar.Formatting   *note 9.6.1(36/2): 4206, *note
9.6.1(38/2): 4208.
   in Ada.Environment_Variables   *note A.17(4.1/3): 6701, *note
A.17(4/2): 6700.
   in Ada.Numerics.Discrete_Random   *note A.5.2(26): 6170.
   in Ada.Numerics.Float_Random   *note A.5.2(14): 6158.
   in Ada.Strings.Maps   *note A.4.2(21): 5798.
   in Ada.Strings.Wide_Maps   *note A.4.7(21): 6000.
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(21/2): 6039.
   in Ada.Task_Attributes   *note C.7.2(4): 7730.
   in Interfaces.C.Pointers   *note B.3.2(6): 7520, *note B.3.2(7):
7521.
   in Interfaces.C.Strings   *note B.3.1(13): 7506, *note B.3.1(14):
7507, *note B.3.1(15): 7508, *note B.3.1(16): 7509.
Value attribute   *note 3.5(52): 1672.
value conversion   *note 4.6(5/2): 2936.
values
   belonging to a subtype   *note 3.2(8/2): 1360.
variable   *note 3.3(13/3): 1457.
variable indexing   *note 4.1.6(16/3): 2474.
variable object   *note 3.3(13/3): 1459.
variable view   *note 3.3(13/3): 1461.
Variable_Indexing aspect   *note 4.1.6(3/3): 2465.
variadic
   C   *note B.3(60.16/4): 7495.
variant   *note 3.8.1(3): 2062.
   used   *note 3.8.1(2): 2061, *note P: 9152.
   See also tagged type   *note 3.9(1): 2083.
variant_part   *note 3.8.1(2): 2058.
   used   *note 3.8(4): 2032, *note P: 9144.
Vector
   in Ada.Containers.Vectors   *note A.18.2(8/3): 6727.
vector container   *note A.18.2(1/2): 6719.
Vector_Iterator_Interfaces
   in Ada.Containers.Vectors   *note A.18.2(11.2/3): 6732.
Vectors
   child of Ada.Containers   *note A.18.2(6/3): 6724.
version
   of a compilation unit   *note E.3(5/1): 8173.
Version attribute   *note E.3(3): 8170.
vertical line   *note 2.1(15/3): 1176.
Vertical_Line
   in Ada.Characters.Latin_1   *note A.3.3(14): 5589.
view   *note 3.1(7): 1312, *note N(42/2): 8956.
   of a subtype (implied)   *note 3.1(7.1/3): 1316.
   of a type (implied)   *note 3.1(7.1/3): 1315.
   of an object (implied)   *note 3.1(7.1/3): 1314.
view conversion   *note 4.6(5/2): 2934.
virtual function
   See dispatching subprogram   *note 3.9.2(1/2): 2158.
Virtual_Length
   in Interfaces.C.Pointers   *note B.3.2(13): 7525.
visibility
   direct   *note 8.3(2): 3735, *note 8.3(21): 3761.
   immediate   *note 8.3(4): 3739, *note 8.3(21): 3762.
   use clause   *note 8.3(4): 3740, *note 8.4(9): 3787.
visibility rules   *note 8.3(1): 3734.
visible   *note 8.3(2): 3738, *note 8.3(14): 3753.
   aspect_specification   *note 8.3(23.1/3): 3767.
   attribute_definition_clause   *note 8.3(23.1/3): 3766.
   within a pragma in a context_clause   *note 10.1.6(3): 4435.
   within a pragma that appears at the place of a compilation unit  
*note 10.1.6(5): 4439.
   within a use_clause in a context_clause   *note 10.1.6(3): 4433.
   within a with_clause   *note 10.1.6(2/2): 4431.
   within the parent_unit_name of a library unit   *note 10.1.6(2/2):
4429.
   within the parent_unit_name of a subunit   *note 10.1.6(4): 4437.
visible part   *note 8.2(5): 3723.
   of a formal package   *note 12.7(10/2): 4866.
   of a generic unit   *note 8.2(8): 3727.
   of a package (other than a generic formal package)   *note 7.1(6/2):
3582.
   of a protected unit   *note 9.4(11/2): 3989.
   of a task unit   *note 9.1(9): 3917.
   of a view of a callable entity   *note 8.2(6): 3725.
   of a view of a composite type   *note 8.2(7): 3726.
volatile   *note C.6(8/3): 7701.
Volatile aspect   *note C.6(6.4/3): 7693.
Volatile pragma   *note J.15.8(3/3): 8601, *note L(38.1/3): 8865.
Volatile_Components aspect   *note C.6(6.7/3): 7697.
Volatile_Components pragma   *note J.15.8(6/3): 8610, *note L(39.1/3):
8868.
VT
   in Ada.Characters.Latin_1   *note A.3.3(5): 5511.
VTS
   in Ada.Characters.Latin_1   *note A.3.3(17): 5608.



File: arm2012.info,  Node: W,  Next: X,  Prev: V,  Up: Index

W 
==



Wait_For_Release
   in Ada.Synchronous_Barriers   *note D.10.1(6/3): 7987.
wchar_array
   in Interfaces.C   *note B.3(33/3): 7465.
wchar_t
   in Interfaces.C   *note B.3(30/1): 7461.
Wednesday
   in Ada.Calendar.Formatting   *note 9.6.1(17/2): 4181.
well-formed picture String
   for edited output   *note F.3.1(1/3): 8232.
Wide_Bounded
   child of Ada.Strings   *note A.4.7(1/3): 5970.
Wide_Character   *note 3.5.2(3/3): 1708.
   in Standard   *note A.1(36.1/3): 5443.
Wide_Character_Mapping
   in Ada.Strings.Wide_Maps   *note A.4.7(20/2): 5999.
Wide_Character_Mapping_Function
   in Ada.Strings.Wide_Maps   *note A.4.7(26): 6005.
Wide_Character_Range
   in Ada.Strings.Wide_Maps   *note A.4.7(6): 5988.
Wide_Character_Ranges
   in Ada.Strings.Wide_Maps   *note A.4.7(7): 5989.
Wide_Character_Sequence subtype of Wide_String
   in Ada.Strings.Wide_Maps   *note A.4.7(16): 5995.
Wide_Character_Set
   in Ada.Strings.Wide_Maps   *note A.4.7(4/2): 5986.
   in Ada.Strings.Wide_Maps.Wide_Constants   *note A.4.8(48/2): 6047.
Wide_Characters
   child of Ada   *note A.3.1(4/2): 5458.
Wide_Constants
   child of Ada.Strings.Wide_Maps   *note A.4.7(1/3): 5984, *note
A.4.8(28/2): 6045.
Wide_Equal_Case_Insensitive
   child of Ada.Strings   *note A.4.7(1/3): 5976.
   child of Ada.Strings.Wide_Bounded   *note A.4.7(1/3): 5978.
   child of Ada.Strings.Wide_Fixed   *note A.4.7(1/3): 5977.
   child of Ada.Strings.Wide_Unbounded   *note A.4.7(1/3): 5979.
Wide_Exception_Name
   in Ada.Exceptions   *note 11.4.1(2/2): 4568, *note 11.4.1(5/2): 4578.
Wide_Expanded_Name
   in Ada.Tags   *note 3.9(7/2): 2104.
Wide_Fixed
   child of Ada.Strings   *note A.4.7(1/3): 5969.
Wide_Hash
   child of Ada.Strings   *note A.4.7(1/3): 5972.
   child of Ada.Strings.Wide_Bounded   *note A.4.7(1/3): 5974.
   child of Ada.Strings.Wide_Fixed   *note A.4.7(1/3): 5973.
   child of Ada.Strings.Wide_Unbounded   *note A.4.7(1/3): 5975.
Wide_Hash_Case_Insensitive
   child of Ada.Strings   *note A.4.7(1/3): 5980.
   child of Ada.Strings.Wide_Bounded   *note A.4.7(1/3): 5982.
   child of Ada.Strings.Wide_Fixed   *note A.4.7(1/3): 5981.
   child of Ada.Strings.Wide_Unbounded   *note A.4.7(1/3): 5983.
Wide_Image attribute   *note 3.5(28): 1643, *note 3.5(55.3/4): 1680.
Wide_Maps
   child of Ada.Strings   *note A.4.7(3): 5985.
wide_nul
   in Interfaces.C   *note B.3(31/1): 7462.
Wide_Space
   in Ada.Strings   *note A.4.1(4/2): 5772.
Wide_String
   in Standard   *note A.1(41/3): 5448.
Wide_Strings
   child of Ada.Strings.UTF_Encoding   *note A.4.11(30/3): 6088.
Wide_Text_IO
   child of Ada   *note A.11(2/2): 6555.
Wide_Unbounded
   child of Ada.Strings   *note A.4.7(1/3): 5971.
Wide_Value attribute   *note 3.5(40): 1666.
Wide_Wide_Bounded
   child of Ada.Strings   *note A.4.8(1/3): 6009.
Wide_Wide_Character   *note 3.5.2(4/3): 1711.
   in Standard   *note A.1(36.2/3): 5444.
Wide_Wide_Character_Mapping
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(20/2): 6038.
Wide_Wide_Character_Mapping_Function
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(26/2): 6044.
Wide_Wide_Character_Range
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(6/2): 6027.
Wide_Wide_Character_Ranges
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(7/2): 6028.
Wide_Wide_Character_Sequence subtype of Wide_Wide_String
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(16/2): 6034.
Wide_Wide_Character_Set
   in Ada.Strings.Wide_Wide_Maps   *note A.4.8(4/2): 6025.
Wide_Wide_Characters
   child of Ada   *note A.3.1(6/2): 5459.
Wide_Wide_Constants
   child of Ada.Strings.Wide_Wide_Maps   *note A.4.8(1/3): 6023.
Wide_Wide_Equal_Case_Insensitive
   child of Ada.Strings   *note A.4.8(1/3): 6015.
   child of Ada.Strings.Wide_Wide_Bounded   *note A.4.8(1/3): 6017.
   child of Ada.Strings.Wide_Wide_Fixed   *note A.4.8(1/3): 6016.
   child of Ada.Strings.Wide_Wide_Unbounded   *note A.4.8(1/3): 6018.
Wide_Wide_Exception_Name
   in Ada.Exceptions   *note 11.4.1(2/2): 4569, *note 11.4.1(5/2): 4579.
Wide_Wide_Expanded_Name
   in Ada.Tags   *note 3.9(7/2): 2105.
Wide_Wide_Fixed
   child of Ada.Strings   *note A.4.8(1/3): 6008.
Wide_Wide_Hash
   child of Ada.Strings   *note A.4.8(1/3): 6011.
   child of Ada.Strings.Wide_Wide_Bounded   *note A.4.8(1/3): 6013.
   child of Ada.Strings.Wide_Wide_Fixed   *note A.4.8(1/3): 6012.
   child of Ada.Strings.Wide_Wide_Unbounded   *note A.4.8(1/3): 6014.
Wide_Wide_Hash_Case_Insensitive
   child of Ada.Strings   *note A.4.8(1/3): 6019.
   child of Ada.Strings.Wide_Wide_Bounded   *note A.4.8(1/3): 6021.
   child of Ada.Strings.Wide_Wide_Fixed   *note A.4.8(1/3): 6020.
   child of Ada.Strings.Wide_Wide_Unbounded   *note A.4.8(1/3): 6022.
Wide_Wide_Image attribute   *note 3.5(27.1/2): 1639, *note 3.5(55.2/4):
1678.
Wide_Wide_Maps
   child of Ada.Strings   *note A.4.8(3/2): 6024.
Wide_Wide_Space
   in Ada.Strings   *note A.4.1(4/2): 5773.
Wide_Wide_String
   in Standard   *note A.1(42.1/3): 5449.
Wide_Wide_Strings
   child of Ada.Strings.UTF_Encoding   *note A.4.11(38/3): 6095.
Wide_Wide_Text_IO
   child of Ada   *note A.11(3/2): 6558.
Wide_Wide_Unbounded
   child of Ada.Strings   *note A.4.8(1/3): 6010.
Wide_Wide_Value attribute   *note 3.5(39.1/2): 1654.
Wide_Wide_Width attribute   *note 3.5(37.1/2): 1648.
Wide_Width attribute   *note 3.5(38): 1650.
Width attribute   *note 3.5(39): 1652.
with_clause   *note 10.1.2(4/2): 4373.
   mentioned in   *note 10.1.2(6/2): 4384.
   named in   *note 10.1.2(6/2): 4386.
   used   *note 10.1.2(3): 4371, *note P: 9670.
within
   immediately   *note 8.1(13): 3716.
word   *note 13.3(8): 4976.
Word_Size
   in System   *note 13.7(13): 5120.
Write
   in Ada.Direct_IO   *note A.8.4(13): 6341.
   in Ada.Sequential_IO   *note A.8.1(12): 6313.
   in Ada.Storage_IO   *note A.9(7): 6359.
   in Ada.Streams   *note 13.13.1(6): 5341.
   in Ada.Streams.Stream_IO   *note A.12.1(18): 6588, *note A.12.1(19):
6589.
   in System.RPC   *note E.5(8): 8209.
Write aspect   *note 13.13.2(38/4): 5381.
Write attribute   *note 13.13.2(3): 5350, *note 13.13.2(11): 5354.
Write clause   *note 13.3(7/2): 4970, *note 13.13.2(38/4): 5375.
Write'Class aspect   *note 13.13.2(38/4): 5389.



File: arm2012.info,  Node: X,  Next: Y,  Prev: W,  Up: Index

X 
==



xor operator   *note 4.4(1/3): 2587, *note 4.5.1(2): 2749.



File: arm2012.info,  Node: Y,  Prev: X,  Up: Index

Y 
==



Year
   in Ada.Calendar   *note 9.6(13): 4152.
   in Ada.Calendar.Formatting   *note 9.6.1(21/2): 4191.
Year_Number subtype of Integer
   in Ada.Calendar   *note 9.6(11/2): 4147.
Yen_Sign
   in Ada.Characters.Latin_1   *note A.3.3(21/3): 5636.
Yield
   in Ada.Dispatching   *note D.2.1(1.3/3): 7770.
Yield_To_Higher
   in Ada.Dispatching.Non_Preemptive   *note D.2.4(2.2/3): 7807.
Yield_To_Same_Or_Higher
   in Ada.Dispatching.Non_Preemptive   *note D.2.4(2.2/3): 7808.


Tag Table:
Node: Top221
Node: Front Matter1632
Node: 0.18786
Node: 0.211486
Node: 0.313261
Ref: 100113848
Ref: 100213848
Ref: 100336763
Ref: 100436763
Node: 0.9953246
Node: 153470
Node: 1.153665
Node: 1.1.155574
Node: 1.1.257138
Ref: 100557338
Ref: 100657625
Ref: 100757625
Ref: 100857625
Ref: 100958103
Ref: 101058103
Ref: 101158544
Ref: 101258544
Ref: 101358544
Ref: 101459267
Ref: 101559272
Ref: 101659272
Ref: 101759272
Ref: 101859272
Ref: 101959352
Ref: 102059352
Ref: 102159352
Ref: 102259485
Ref: 102359485
Ref: 102459485
Ref: 102559525
Ref: 102659526
Ref: 102759636
Ref: 102859636
Ref: 102959748
Ref: 103059748
Ref: 103159748
Ref: 103259748
Ref: 103359799
Ref: 103459800
Ref: 103559955
Ref: 103659955
Ref: 103759955
Ref: 103859955
Ref: 103960065
Ref: 104060065
Ref: 104160190
Ref: 104260190
Ref: 104360313
Ref: 104460424
Ref: 104560529
Ref: 104660690
Ref: 104760792
Ref: 104860792
Ref: 104961032
Node: 1.1.361298
Ref: 105061539
Ref: 105162450
Ref: 105262450
Ref: 105362575
Ref: 105464781
Ref: 105564781
Ref: 105664781
Ref: 105764781
Ref: 105864781
Ref: 105965484
Node: 1.1.466067
Ref: 106066550
Ref: 106166550
Ref: 106266550
Ref: 106366550
Ref: 106466550
Ref: 106567820
Ref: 106668887
Ref: 106769046
Ref: 106869172
Ref: 106969268
Ref: 107069843
Ref: 107169844
Node: 1.1.570716
Ref: 107271555
Ref: 107371560
Ref: 107471560
Ref: 107571560
Ref: 107671988
Ref: 107771993
Ref: 107872671
Ref: 107972731
Ref: 108072963
Ref: 108173419
Ref: 108273419
Ref: 108374045
Ref: 108474046
Ref: 108574311
Node: 1.274412
Ref: 108674533
Ref: 108774533
Ref: 108874835
Ref: 108974835
Ref: 109074835
Ref: 109174970
Ref: 109274970
Ref: 109374970
Ref: 109475078
Ref: 109575078
Ref: 109675078
Ref: 109775189
Ref: 109875189
Ref: 109975189
Ref: 110075273
Ref: 110175273
Ref: 110275273
Ref: 110375397
Ref: 110475397
Ref: 110575397
Ref: 110675501
Ref: 110775501
Ref: 110875624
Ref: 110975624
Ref: 111075624
Ref: 111175757
Ref: 111275757
Ref: 111375757
Ref: 111475835
Ref: 111575835
Ref: 111675835
Ref: 111775938
Ref: 111875938
Ref: 111975938
Ref: 112076020
Ref: 112176020
Node: 1.376225
Ref: 112276336
Ref: 112376979
Ref: 112476980
Ref: 112576980
Ref: 112676980
Node: 276982
Node: 2.177690
Ref: 112777785
Ref: 112878041
Ref: 112978041
Ref: 113079363
Ref: 113179463
Ref: 113279590
Ref: 113379719
Ref: 113479848
Ref: 113579975
Ref: 113680096
Ref: 113780225
Ref: 113880365
Ref: 113980491
Ref: 114080615
Ref: 114180755
Ref: 114280875
Ref: 114381001
Ref: 114481127
Ref: 114581261
Ref: 114681604
Ref: 114781614
Ref: 114881803
Ref: 114981935
Ref: 115082061
Ref: 115182453
Ref: 115282454
Ref: 115382454
Ref: 115482454
Ref: 115582454
Ref: 115682454
Ref: 115782454
Ref: 115882454
Ref: 115982454
Ref: 116082454
Ref: 116182454
Ref: 116282454
Ref: 116382454
Ref: 116482454
Ref: 116582454
Ref: 116682454
Ref: 116782454
Ref: 116882454
Ref: 116982454
Ref: 117082454
Ref: 117182454
Ref: 117282454
Ref: 117382454
Ref: 117482454
Ref: 117582454
Ref: 117682454
Ref: 117782454
Ref: 117882454
Node: 2.284204
Ref: 117984417
Ref: 118084490
Ref: 118184490
Ref: 118284937
Ref: 118384944
Ref: 118485191
Ref: 118586113
Ref: 118686257
Node: 2.387366
Ref: 118787559
Ref: S000287559
Ref: 118887572
Ref: 118987590
Ref: 119087609
Ref: 119187654
Ref: S000387654
Ref: S000487654
Ref: 119287669
Ref: 119387696
Ref: 119487723
Ref: 119587750
Ref: 119687776
Ref: 119787799
Ref: 119887842
Ref: S000587842
Ref: 119987857
Ref: 120087884
Ref: 120187917
Ref: 120287942
Ref: 120388398
Node: 2.489327
Ref: 120489438
Ref: 120589514
Ref: 120689573
Ref: 120789695
Ref: S000689695
Ref: 120889699
Ref: 120989718
Node: 2.4.189931
Ref: 121090040
Ref: 121190208
Ref: S000790208
Ref: 121290212
Ref: 121390223
Ref: 121490233
Ref: 121590258
Ref: S000890258
Ref: 121690262
Ref: 121790271
Ref: 121890282
Ref: 121990305
Ref: S000990305
Ref: 122090316
Ref: 122190330
Ref: 122290355
Ref: S001090355
Node: 2.4.291083
Ref: 122391188
Ref: 122491188
Ref: 122591188
Ref: 122691188
Ref: 122791188
Ref: 122891188
Ref: 122991188
Ref: 123091188
Ref: 123191188
Ref: 123291188
Ref: 123391343
Ref: S001191343
Ref: 123491356
Ref: 123591363
Ref: 123691379
Ref: 123791397
Ref: 123891419
Ref: S001291419
Ref: 123991423
Ref: 124091453
Ref: S001391453
Ref: 124191466
Ref: 124291483
Ref: 124391494
Ref: 124491532
Ref: S001491532
Ref: 124591536
Ref: 124691615
Node: 2.592675
Ref: 124792954
Ref: S001592954
Ref: 124892960
Node: 2.693370
Ref: 124993770
Ref: 125093835
Ref: S001693835
Ref: 125193842
Ref: 125293881
Ref: S001793881
Ref: 125393910
Ref: 125494108
Ref: 125594425
Node: 2.795134
Ref: 125695367
Ref: S001895367
Ref: 125795391
Node: 2.896059
Ref: 125896152
Ref: 125996416
Ref: S001996416
Ref: 126096436
Ref: 126196449
Ref: 126296480
Ref: 126396555
Ref: S002096555
Ref: 126496587
Ref: 126596602
Ref: 126696634
Ref: 126796649
Ref: 126896686
Ref: 126996702
Ref: 127096733
Ref: 127196749
Ref: 127297855
Ref: 127397855
Ref: 127497929
Ref: 127597930
Ref: 127698014
Ref: 127798014
Ref: 127898444
Ref: 127998444
Ref: 128098672
Ref: 128199918
Ref: 128299919
Ref: 128399924
Ref: 128499954
Ref: 128599955
Ref: 128699978
Ref: 128799979
Ref: 128899988
Node: 2.9101638
Ref: 1289101814
Node: 3103278
Node: 3.1103877
Ref: 1290103968
Ref: 1291104055
Ref: 1292104453
Ref: S0021104453
Ref: 1293104468
Ref: 1294104489
Ref: 1295104519
Ref: 1296104542
Ref: 1297104571
Ref: 1298104598
Ref: 1299104640
Ref: 1300104671
Ref: 1301104713
Ref: 1302104737
Ref: 1303104768
Ref: 1304104794
Ref: 1305104824
Ref: 1306104873
Ref: S0022104873
Ref: 1307104877
Ref: 1308104938
Ref: 1309105026
Ref: 1310105027
Ref: 1311105254
Ref: 1312105967
Ref: 1313105967
Ref: 1314106771
Ref: 1315106771
Ref: 1316106771
Ref: 1317106775
Ref: 1318107209
Ref: 1319107310
Ref: 1320107409
Ref: 1321107729
Ref: 1322107964
Ref: 1323108189
Ref: 1324108271
Ref: 1325108272
Ref: 1326108530
Ref: 1327108601
Node: 3.2108676
Ref: 1328108837
Ref: 1329108837
Ref: 1330108972
Ref: 1331109066
Ref: 1332109066
Ref: 1333109109
Ref: 1334109253
Ref: 1335109302
Ref: 1336109369
Ref: 1337109370
Ref: 1338109442
Ref: 1339109447
Ref: 1340109586
Ref: 1341109587
Ref: 1342109694
Ref: 1343109896
Ref: 1344109896
Ref: 1345109896
Ref: 1346110437
Ref: 1347110677
Ref: 1348110917
Ref: 1349111184
Ref: 1350111184
Ref: 1351111190
Ref: 1352111306
Ref: 1353111307
Ref: 1354111733
Ref: 1355111923
Ref: 1356111923
Ref: 1357112001
Ref: 1358112001
Ref: 1359112134
Ref: 1360112169
Ref: 1361112169
Ref: 1362112174
Ref: 1363112174
Ref: 1364112174
Ref: 1365112174
Ref: 1366113012
Ref: 1367113615
Node: 3.2.1115248
Ref: 1368115482
Ref: S0023115482
Ref: 1369115488
Ref: 1370115520
Ref: 1371115558
Ref: 1372115593
Ref: 1373115654
Ref: S0024115654
Ref: 1374115674
Ref: 1375115695
Ref: 1376115723
Ref: 1377115759
Ref: 1378115792
Ref: 1379115824
Ref: 1380115876
Ref: S0025115876
Ref: 1381115891
Ref: 1382115923
Ref: 1383115957
Ref: 1384115982
Ref: 1385116014
Ref: 1386116041
Ref: 1387116074
Ref: 1388116102
Ref: 1389116305
Ref: 1390116707
Ref: 1391116829
Ref: 1392117021
Ref: 1393117374
Ref: 1394117584
Ref: 1395117657
Ref: 1396118038
Ref: 1397118266
Ref: 1398118648
Ref: 1399118747
Node: 3.2.2119873
Ref: 1400120185
Ref: S0026120185
Ref: 1401120206
Ref: 1402120229
Ref: 1403120262
Ref: 1404120313
Ref: S0027120313
Ref: 1405120320
Ref: 1406120336
Ref: 1407120350
Ref: 1408120382
Ref: S0028120382
Ref: 1409120395
Ref: 1410120418
Ref: S0029120418
Ref: 1411120422
Ref: 1412120443
Ref: 1413120489
Ref: S0030120489
Ref: 1414120504
Ref: 1415120523
Ref: 1416120543
Ref: 1417120588
Ref: S0031120588
Ref: 1418120603
Ref: 1419120622
Ref: 1420120747
Ref: 1421120892
Ref: 1422120987
Ref: 1423121345
Ref: 1424121345
Ref: 1425121555
Ref: 1426121852
Node: 3.2.3122962
Ref: 1427123157
Ref: 1428123375
Ref: 1429123546
Ref: 1430123673
Ref: 1431124476
Ref: 1432124735
Node: 3.2.4124830
Ref: 1433125160
Ref: 1434125160
Ref: 1435125160
Ref: 1436125160
Ref: 1437125160
Ref: 1438125160
Ref: 1439125160
Ref: 1440125419
Ref: 1441126042
Ref: 1442126042
Ref: 1443126042
Ref: 1444128242
Ref: 1445128242
Ref: 1446130174
Ref: 1447130687
Ref: 1448130687
Ref: 1449132437
Ref: 1450132437
Ref: 1451132437
Ref: 1452132437
Ref: 1453133275
Node: 3.3136128
Ref: 1454136325
Ref: 1455136638
Ref: 1456137272
Ref: 1457137272
Ref: 1458137272
Ref: 1459137272
Ref: 1460137272
Ref: 1461137272
Ref: 1462137734
Ref: 1463137902
Ref: 1464138042
Ref: 1465139267
Ref: 1466139364
Ref: 1467139365
Ref: 1468139539
Ref: 1469139540
Ref: 1470140226
Ref: 1471140226
Ref: 1472141404
Node: 3.3.1142241
Ref: 1473142358
Ref: 1474142358
Ref: 1475142358
Ref: 1476142520
Ref: 1477142521
Ref: 1478142521
Ref: 1479142728
Ref: S0032142728
Ref: 1480142742
Ref: 1481142790
Ref: 1482142819
Ref: 1483142845
Ref: 1484142877
Ref: 1485142925
Ref: 1486142953
Ref: 1487142979
Ref: 1488143011
Ref: 1489143059
Ref: 1490143091
Ref: 1491143117
Ref: 1492143149
Ref: 1493143182
Ref: 1494143243
Ref: S0033143243
Ref: 1495143255
Ref: 1496143278
Ref: 1497143351
Ref: 1498143492
Ref: 1499143549
Ref: 1500143964
Ref: 1501144051
Ref: 1502144731
Ref: 1503144952
Ref: 1504145288
Ref: 1505145583
Ref: 1506145642
Ref: 1507145643
Ref: 1508145745
Ref: 1509145746
Ref: 1510145831
Ref: 1511146416
Ref: 1512146967
Ref: 1513147512
Ref: 1514148228
Ref: 1515148361
Ref: 1516148606
Ref: 1517148607
Ref: 1518148830
Ref: 1519149007
Ref: 1520150038
Ref: 1521150467
Ref: 1522150467
Node: 3.3.2152244
Ref: 1523152472
Ref: S0034152472
Ref: 1524152487
Ref: 1525152533
Ref: 1526152597
Ref: 1527153260
Ref: 1528153312
Node: 3.4153862
Ref: 1529153993
Ref: 1530154164
Ref: 1531154173
Ref: 1532154173
Ref: 1533154839
Ref: S0035154839
Ref: 1534154885
Ref: 1535154910
Ref: 1536154932
Ref: 1537155005
Ref: 1538155005
Ref: 1539155494
Ref: 1540156091
Ref: 1541156141
Ref: 1542156141
Ref: 1543156319
Ref: 1544156785
Ref: 1545158366
Ref: 1546158367
Ref: 1547158741
Ref: 1548158742
Ref: 1549158742
Ref: 1550159374
Ref: 1551159717
Ref: 1552160285
Ref: 1553160789
Ref: 1554161735
Ref: 1555162426
Ref: 1556162902
Ref: 1557163298
Ref: 1558164001
Ref: 1559164028
Ref: 1560164518
Node: 3.4.1166755
Ref: 1561167013
Ref: 1562167323
Ref: 1563167324
Ref: 1564167324
Ref: 1565167662
Ref: 1566167928
Ref: 1567168547
Ref: 1568169306
Ref: 1569169623
Ref: 1570169623
Ref: 1571169623
Ref: 1572169623
Ref: 1573170683
Ref: 1574170683
Ref: 1575170838
Ref: 1576170960
Ref: 1577171304
Ref: 1578171384
Ref: 1579171385
Ref: 1580171552
Node: 3.5172504
Ref: 1581172607
Ref: 1582172678
Ref: 1583172741
Ref: 1584172820
Ref: 1585173039
Ref: S0036173039
Ref: 1586173051
Ref: 1587173070
Ref: S0037173070
Ref: 1588173076
Ref: 1589173112
Ref: 1590173133
Ref: 1591173154
Ref: 1592173154
Ref: 1593173154
Ref: 1594173154
Ref: 1595173353
Ref: 1596173551
Ref: 1597173668
Ref: 1598173744
Ref: 1599173902
Ref: 1600174131
Ref: 1601174382
Ref: 1602174675
Ref: 1603174675
Ref: 1604174748
Ref: 1605174983
Ref: 1606175131
Ref: 1607175247
Ref: 1608175325
Ref: 1609175578
Ref: 1610175578
Ref: 1611175806
Ref: 1612175821
Ref: 1613175947
Ref: 1614175962
Ref: 1615176088
Ref: 1616176103
Ref: 1617176169
Ref: 1618176184
Ref: 1619176338
Ref: 1620176350
Ref: 1621176365
Ref: 1622176649
Ref: 1623176664
Ref: 1624176950
Ref: 1625176965
Ref: 1626177134
Ref: 1627177299
Ref: 1628177300
Ref: 1629177786
Ref: 1630177787
Ref: 1631177876
Ref: 1632177891
Ref: 1633178060
Ref: 1634178225
Ref: 1635178226
Ref: 1636178727
Ref: 1637178728
Ref: 1638178832
Ref: 1639178847
Ref: 1640179056
Ref: 1641179550
Ref: 1642181506
Ref: 1643181521
Ref: 1644181709
Ref: 1645182308
Ref: 1646182323
Ref: 1647183032
Ref: 1648183047
Ref: 1649183325
Ref: 1650183340
Ref: 1651183597
Ref: 1652183612
Ref: 1653183869
Ref: 1654183884
Ref: 1655184268
Ref: 1656184283
Ref: 1657184789
Ref: 1658184790
Ref: 1659184837
Ref: 1660185372
Ref: 1661185373
Ref: 1662185960
Ref: 1663186190
Ref: 1664186191
Ref: 1665186381
Ref: 1666186396
Ref: 1667186750
Ref: 1668186765
Ref: 1669187231
Ref: 1670187232
Ref: 1671187622
Ref: 1672187637
Ref: 1673187956
Ref: 1674187971
Ref: 1675188427
Ref: 1676188428
Ref: 1677188869
Ref: 1678188884
Ref: 1679189065
Ref: 1680189080
Ref: 1681189246
Ref: 1682189261
Ref: 1683190512
Ref: 1684190512
Ref: 1685190880
Node: 3.5.1192418
Ref: 1686192529
Ref: 1687192665
Ref: S0038192665
Ref: 1688192679
Ref: 1689192716
Ref: 1690192799
Ref: S0039192799
Ref: 1691192805
Ref: 1692192827
Ref: 1693192894
Ref: S0040192894
Ref: 1694192898
Ref: 1695193153
Ref: 1696193609
Ref: 1697193946
Ref: 1698194388
Ref: 1699194388
Ref: 1700194388
Node: 3.5.2195669
Ref: 1701195836
Ref: 1702195960
Ref: 1703195960
Ref: 1704195960
Ref: 1705195960
Ref: 1706196637
Ref: 1707196638
Ref: 1708196644
Ref: 1709196644
Ref: 1710196644
Ref: 1711197104
Ref: 1712197104
Node: 3.5.3198598
Ref: 1713198761
Ref: 1714198864
Ref: 1715198865
Ref: 1716198955
Node: 3.5.4199029
Ref: 1717199146
Ref: 1718199146
Ref: 1719199146
Ref: 1720199522
Ref: 1721199596
Ref: S0041199596
Ref: 1722199600
Ref: 1723199634
Ref: 1724199702
Ref: S0042199702
Ref: 1725199720
Ref: 1726199754
Ref: 1727199803
Ref: S0043199803
Ref: 1728199819
Ref: 1729199882
Ref: 1730200014
Ref: 1731200307
Ref: 1732200307
Ref: 1733200307
Ref: 1734200890
Ref: 1735201091
Ref: 1736201092
Ref: 1737201297
Ref: 1738201411
Ref: 1739201412
Ref: 1740201556
Ref: 1741201720
Ref: 1742201720
Ref: 1743201931
Ref: 1744201931
Ref: 1745201931
Ref: 1746202289
Ref: 1747202290
Ref: 1748202487
Ref: 1749202637
Ref: 1750202652
Ref: 1751202953
Ref: 1752202968
Ref: 1753203123
Ref: 1754203465
Ref: 1755203465
Ref: 1756203465
Ref: 1757203654
Ref: 1758203655
Ref: 1759203655
Ref: 1760203829
Ref: 1761203923
Ref: 1762204369
Ref: 1763204369
Ref: 1764205108
Ref: 1765205944
Ref: 1766206537
Ref: 1767206860
Ref: 1768207085
Ref: 1769207085
Node: 3.5.5208588
Ref: 1770208858
Ref: 1771208873
Ref: 1772209189
Ref: 1773209204
Ref: 1774209380
Ref: 1775209395
Ref: 1776209503
Ref: 1777209504
Ref: 1778209894
Ref: 1779209909
Ref: 1780210102
Ref: 1781210117
Ref: 1782210784
Ref: 1783211041
Node: 3.5.6212643
Ref: 1784212754
Ref: 1785212983
Ref: S0044212983
Ref: 1786212996
Ref: 1787213024
Ref: 1788213096
Ref: 1789213336
Ref: 1790213336
Ref: 1791213516
Ref: 1792213825
Ref: 1793214570
Node: 3.5.7215796
Ref: 1794215927
Ref: 1795216149
Ref: S0045216149
Ref: 1796216175
Ref: 1797216187
Ref: 1798216245
Ref: S0046216245
Ref: 1799216270
Ref: 1800216298
Ref: 1801216368
Ref: 1802216578
Ref: 1803216637
Ref: 1804216806
Ref: 1805217023
Ref: 1806217440
Ref: 1807217589
Ref: 1808217756
Ref: 1809217890
Ref: 1810218076
Ref: 1811218211
Ref: 1812218212
Ref: 1813218827
Ref: 1814218828
Ref: 1815219095
Ref: 1816219270
Ref: 1817219428
Ref: 1818219587
Ref: 1819219752
Ref: 1820219752
Ref: 1821220535
Node: 3.5.8221366
Ref: 1822221656
Ref: 1823221671
Ref: 1824222216
Node: 3.5.9222854
Ref: 1825222980
Ref: 1826222980
Ref: 1827222980
Ref: 1828223069
Ref: 1829223256
Ref: S0047223256
Ref: 1830223260
Ref: 1831223295
Ref: 1832223371
Ref: S0048223371
Ref: 1833223397
Ref: 1834223409
Ref: 1835223472
Ref: S0049223472
Ref: 1836223498
Ref: 1837223523
Ref: 1838223535
Ref: 1839223594
Ref: S0050223594
Ref: 1840223621
Ref: 1841223640
Ref: 1842223710
Ref: 1843223912
Ref: 1844223913
Ref: 1845223913
Ref: 1846224526
Ref: 1847224639
Ref: 1848224786
Ref: 1849225731
Ref: 1850225885
Ref: 1851226175
Ref: 1852226176
Ref: 1853226478
Ref: 1854226536
Ref: 1855226696
Ref: 1856226697
Ref: 1857226948
Ref: 1858227093
Ref: 1859227433
Ref: 1860227685
Ref: 1861227784
Ref: 1862227785
Ref: 1863228015
Node: 3.5.10229668
Ref: 1864229939
Ref: 1865229954
Ref: 1866230071
Ref: 1867230072
Ref: 1868230321
Ref: 1869230321
Ref: 1870230333
Ref: 1871230348
Ref: 1872230503
Ref: 1873230518
Ref: 1874231067
Ref: 1875231082
Ref: 1876231663
Ref: 1877231678
Ref: 1878232002
Ref: 1879232782
Ref: 1880232797
Ref: 1881232910
Ref: 1882233145
Ref: 1883233160
Ref: 1884233838
Node: 3.6234426
Ref: 1885234527
Ref: 1886234527
Ref: 1887234895
Ref: S0051234895
Ref: 1888234908
Ref: 1889234941
Ref: 1890235008
Ref: S0052235008
Ref: 1891235027
Ref: 1892235055
Ref: 1893235085
Ref: 1894235144
Ref: S0053235144
Ref: 1895235148
Ref: 1896235207
Ref: S0054235207
Ref: 1897235227
Ref: 1898235258
Ref: 1899235297
Ref: 1900235353
Ref: S0055235353
Ref: 1901235367
Ref: 1902235388
Ref: 1903235424
Ref: S0056235424
Ref: 1904235447
Ref: 1905235484
Ref: 1906235554
Ref: 1907235882
Ref: 1908235996
Ref: 1909236046
Ref: 1910236255
Ref: 1911236255
Ref: 1912236255
Ref: 1913236868
Ref: 1914236916
Ref: 1915236975
Ref: 1916237098
Ref: 1917237568
Ref: 1918237568
Ref: 1919237820
Ref: 1920237990
Ref: 1921237990
Ref: 1922238247
Ref: 1923238768
Ref: 1924238911
Ref: 1925239193
Ref: 1926239427
Ref: 1927239792
Ref: 1928240178
Ref: 1929240703
Ref: 1930240703
Ref: 1931241119
Node: 3.6.1242979
Ref: 1932243336
Ref: S0057243336
Ref: 1933243343
Ref: 1934243361
Ref: 1935243400
Ref: S0058243400
Ref: 1936243414
Ref: 1937243435
Ref: 1938243493
Ref: 1939243609
Ref: 1940244137
Ref: 1941244323
Ref: 1942244524
Ref: 1943244642
Ref: 1944244786
Ref: 1945244900
Node: 3.6.2246273
Ref: 1946246904
Ref: 1947246919
Ref: 1948247048
Ref: 1949247063
Ref: 1950247190
Ref: 1951247205
Ref: 1952247332
Ref: 1953247347
Ref: 1954247474
Ref: 1955247489
Ref: 1956247622
Ref: 1957247637
Ref: 1958247791
Ref: 1959247806
Ref: 1960247971
Ref: 1961247986
Ref: 1962249053
Node: 3.6.3250150
Ref: 1963250297
Node: 3.7251800
Ref: 1964251907
Ref: 1965251907
Ref: 1966251907
Ref: 1967252471
Ref: S0059252471
Ref: 1968252475
Ref: 1969252504
Ref: 1970252567
Ref: S0060252567
Ref: 1971252608
Ref: S0061252608
Ref: 1972252622
Ref: 1973252652
Ref: 1974252717
Ref: S0062252717
Ref: 1975252730
Ref: 1976252758
Ref: 1977252774
Ref: 1978252791
Ref: 1979252825
Ref: 1980252852
Ref: 1981252874
Ref: 1982252926
Ref: S0063252926
Ref: 1983252930
Ref: 1984252994
Ref: 1985253396
Ref: 1986253666
Ref: 1987254436
Ref: 1988255595
Ref: 1989255896
Ref: 1990256081
Ref: 1991256400
Ref: 1992257144
Ref: 1993257144
Ref: 1994257144
Ref: 1995257144
Ref: 1996257263
Ref: 1997257264
Ref: 1998257625
Ref: 1999257626
Ref: 2000258068
Node: 3.7.1260393
Ref: 2001260690
Ref: S0064260690
Ref: 2002260704
Ref: 2003260732
Ref: 2004260791
Ref: S0065260791
Ref: 2005260818
Ref: 2006260848
Ref: 2007260867
Ref: 2008260887
Ref: 2009260994
Ref: 2010261342
Ref: 2011261428
Ref: 2012261709
Ref: 2013262472
Ref: 2014262810
Ref: 2015262983
Ref: 2016263151
Ref: 2017263505
Node: 3.7.2264311
Ref: 2018265007
Ref: 2019265022
Ref: 2020265224
Node: 3.8265555
Ref: 2021265658
Ref: 2022265658
Ref: 2023265821
Ref: 2024265894
Ref: S0066265894
Ref: 2025265929
Ref: 2026265978
Ref: S0067265978
Ref: 2027266011
Ref: 2028266089
Ref: S0068266089
Ref: 2029266105
Ref: 2030266121
Ref: 2031266148
Ref: 2032266164
Ref: 2033266218
Ref: S0069266218
Ref: 2034266222
Ref: 2035266247
Ref: 2036266292
Ref: S0070266292
Ref: 2037266305
Ref: 2038266332
Ref: 2039266357
Ref: 2040266397
Ref: 2041266472
Ref: 2042266666
Ref: 2043267908
Ref: 2044268246
Ref: 2045268246
Ref: 2046268368
Ref: 2047268589
Ref: 2048268911
Ref: 2049269059
Ref: 2050269162
Ref: 2051269309
Ref: 2052269416
Ref: 2053269416
Ref: 2054269416
Ref: 2055269828
Ref: 2056270740
Ref: 2057272098
Node: 3.8.1273081
Ref: 2058273468
Ref: S0071273468
Ref: 2059273499
Ref: 2060273526
Ref: 2061273546
Ref: 2062273588
Ref: S0072273588
Ref: 2063273606
Ref: 2064273641
Ref: 2065273684
Ref: S0073273684
Ref: 2066273688
Ref: 2067273708
Ref: 2068273750
Ref: S0074273750
Ref: 2069273754
Ref: 2070273784
Ref: 2071273811
Ref: 2072273878
Ref: 2073274093
Ref: 2074274614
Ref: 2075275336
Ref: 2076276474
Ref: 2077276474
Ref: 2078277520
Node: 3.9278450
Ref: 2079278594
Ref: 2080278594
Ref: 2081278594
Ref: 2082278594
Ref: 2083278594
Ref: 2084278753
Ref: 2085278754
Ref: 2086278754
Ref: 2087278806
Ref: 2088279205
Ref: 2089279206
Ref: 2090279304
Ref: 2091279304
Ref: 2092279304
Ref: 2093279879
Ref: 2094280210
Ref: 2095280278
Ref: 2096280279
Ref: 2097280279
Ref: 2098280279
Ref: 2099280921
Ref: 2100280985
Ref: 2101281060
Ref: 2102281138
Ref: 2103281189
Ref: 2104281245
Ref: 2105281311
Ref: 2106281387
Ref: 2107281442
Ref: 2108281511
Ref: 2109281591
Ref: 2110281701
Ref: 2111281755
Ref: 2112281827
Ref: 2113281904
Ref: 2114281949
Ref: 2115284660
Ref: 2116285266
Ref: 2117285493
Ref: 2118285508
Ref: 2119285759
Ref: 2120285774
Ref: 2121285960
Ref: 2122285975
Ref: 2123286301
Ref: 2124286316
Ref: 2125286475
Ref: 2126287320
Ref: 2127287438
Ref: 2128287572
Ref: 2129287677
Ref: 2130287798
Ref: 2131287912
Ref: 2132288803
Ref: 2133290445
Ref: 2134290445
Node: 3.9.1290887
Ref: 2135290996
Ref: 2136290996
Ref: 2137290996
Ref: 2138290996
Ref: 2139290996
Ref: 2140290996
Ref: 2141291225
Ref: S0075291225
Ref: 2142291235
Ref: 2143291566
Ref: 2144291993
Ref: 2145292198
Node: 3.9.2294762
Ref: 2146294931
Ref: 2147294931
Ref: 2148294931
Ref: 2149294931
Ref: 2150294931
Ref: 2151294931
Ref: 2152294931
Ref: 2153294931
Ref: 2154295913
Ref: 2155295914
Ref: 2156295914
Ref: 2157295914
Ref: 2158295914
Ref: 2159295966
Ref: 2160295966
Ref: 2161296082
Ref: 2162296275
Ref: 2163296528
Ref: 2164296529
Ref: 2165296949
Ref: 2166296949
Ref: 2167297482
Ref: 2168297722
Ref: 2169297951
Ref: 2170299661
Ref: 2171299787
Ref: 2172301155
Ref: 2173301155
Ref: 2174301354
Ref: 2175301699
Ref: 2176301700
Ref: 2177301824
Ref: 2178303142
Node: 3.9.3305871
Ref: 2179306024
Ref: 2180306024
Ref: 2181306024
Ref: 2182306024
Ref: 2183306158
Ref: 2184306159
Ref: 2185306507
Ref: S0076306507
Ref: 2186306522
Ref: 2187306553
Ref: 2188306604
Ref: 2189306680
Ref: 2190306680
Ref: 2191307072
Ref: 2192307072
Ref: 2193308231
Ref: 2194310347
Node: 3.9.4311899
Ref: 2195312282
Ref: S0077312282
Ref: 2196312355
Ref: 2197312401
Ref: S0078312401
Ref: 2198312416
Ref: 2199312444
Ref: 2200312562
Ref: 2201312562
Ref: 2202312874
Ref: 2203312874
Ref: 2204312875
Ref: 2205312875
Ref: 2206312875
Ref: 2207312875
Ref: 2208312875
Ref: 2209312875
Ref: 2210312875
Ref: 2211312875
Ref: 2212312999
Ref: 2213312999
Ref: 2214312999
Ref: 2215312999
Ref: 2216312999
Ref: 2217312999
Ref: 2218312999
Ref: 2219313387
Ref: 2220313387
Ref: 2221315118
Node: 3.10319466
Ref: 2222319573
Ref: 2223319573
Ref: 2224319573
Ref: 2225319865
Ref: 2226319866
Ref: 2227319940
Ref: S0079319940
Ref: 2228319955
Ref: 2229319971
Ref: 2230320009
Ref: 2231320025
Ref: 2232320092
Ref: S0080320092
Ref: 2233320114
Ref: 2234320139
Ref: 2235320189
Ref: S0081320189
Ref: 2236320248
Ref: S0082320248
Ref: 2237320291
Ref: 2238320347
Ref: 2239320402
Ref: S0083320402
Ref: 2240320443
Ref: S0084320443
Ref: 2241320458
Ref: 2242320492
Ref: 2243320515
Ref: 2244320560
Ref: 2245320588
Ref: 2246320632
Ref: 2247320718
Ref: 2248320718
Ref: 2249320718
Ref: 2250320718
Ref: 2251320878
Ref: 2252321056
Ref: 2253321276
Ref: 2254321276
Ref: 2255321645
Ref: 2256322449
Ref: 2257322450
Ref: 2258322652
Ref: 2259322814
Ref: 2260323164
Ref: 2261323258
Ref: 2262323363
Ref: 2263323701
Ref: 2264323701
Ref: 2265323701
Ref: 2266324198
Ref: 2267324205
Ref: 2268324944
Ref: 2269325482
Ref: 2270325482
Ref: 2271326320
Ref: 2272326526
Ref: 2273326816
Ref: 2274327052
Node: 3.10.1328871
Ref: 2275329519
Ref: S0085329519
Ref: 2276329529
Ref: 2277329550
Ref: 2278329641
Ref: 2279329641
Ref: 2280329931
Ref: 2281329931
Ref: 2282331073
Ref: 2283332466
Ref: 2284335081
Ref: 2285335171
Node: 3.10.2337035
Ref: 2286337472
Ref: 2287338038
Ref: 2288338039
Ref: 2289338217
Ref: 2290338217
Ref: 2291338217
Ref: 2292338217
Ref: 2293338217
Ref: 2294338217
Ref: 2295339146
Ref: 2296339146
Ref: 2297341367
Ref: 2298341367
Ref: 2299341367
Ref: 2300346760
Ref: 2301347994
Ref: 2302349702
Ref: 2303349702
Ref: 2304352536
Ref: 2305352536
Ref: 2306352815
Ref: 2307352830
Ref: 2308353084
Ref: 2309354634
Ref: 2310355044
Ref: 2311355264
Ref: 2312355269
Ref: 2313355284
Ref: 2314355284
Ref: 2315355460
Ref: 2316355880
Ref: 2317355895
Ref: 2318356110
Ref: 2319356201
Ref: 2320356543
Ref: 2321357151
Ref: 2322357151
Ref: 2323358411
Ref: 2324358768
Ref: 2325359297
Ref: 2326359297
Node: 3.11360645
Ref: 2327360878
Ref: S0086360878
Ref: 2328360884
Ref: 2329360926
Ref: S0087360926
Ref: 2330360940
Ref: 2331360965
Ref: 2332361002
Ref: S0088361002
Ref: 2333361016
Ref: 2334361036
Ref: 2335361052
Ref: 2336361075
Ref: S0089361075
Ref: 2337361079
Ref: 2338361094
Ref: 2339361123
Ref: S0090361123
Ref: 2340361137
Ref: 2341361155
Ref: 2342361170
Ref: 2343361182
Ref: 2344361357
Ref: 2345361408
Ref: 2346361573
Ref: 2347361717
Ref: 2348361717
Ref: 2349362065
Ref: 2350362413
Ref: 2351363066
Ref: 2352363071
Node: 3.11.1363192
Ref: 2353363356
Ref: 2354363429
Ref: 2355363578
Ref: 2356364320
Ref: 2357364424
Ref: 2358364759
Node: 4365738
Node: 4.1366272
Ref: 2359366829
Ref: S0091366829
Ref: 2360366844
Ref: 2361366860
Ref: 2362366891
Ref: 2363366913
Ref: 2364366929
Ref: 2365366952
Ref: 2366366982
Ref: 2367367002
Ref: 2368367026
Ref: 2369367048
Ref: 2370367079
Ref: 2371367105
Ref: 2372367145
Ref: S0092367145
Ref: 2373367149
Ref: 2374367163
Ref: 2375367193
Ref: S0093367193
Ref: 2376367197
Ref: 2377367205
Ref: 2378367254
Ref: S0094367254
Ref: 2379367258
Ref: 2380367296
Ref: S0095367296
Ref: 2381367300
Ref: 2382367624
Ref: 2383367624
Ref: 2384367799
Ref: 2385368347
Ref: 2386368590
Ref: 2387368755
Ref: 2388368836
Ref: 2389369016
Ref: 2390369181
Ref: 2391369182
Ref: 2392369254
Node: 4.1.1370474
Ref: 2393370682
Ref: 2394370750
Ref: S0096370750
Ref: 2395370754
Ref: 2396370762
Ref: 2397370776
Ref: 2398371155
Ref: 2399371400
Ref: 2400371687
Ref: 2401371798
Ref: 2402371874
Ref: 2403371875
Ref: 2404371875
Ref: 2405372005
Node: 4.1.2373117
Ref: 2406373220
Ref: 2407373495
Ref: S0097373495
Ref: 2408373499
Ref: 2409373507
Ref: 2410373682
Ref: 2411374175
Ref: 2412374276
Ref: 2413374276
Ref: 2414374277
Ref: 2415374277
Ref: 2416374482
Node: 4.1.3375593
Ref: 2417375907
Ref: 2418375976
Ref: S0098375976
Ref: 2419375980
Ref: 2420375990
Ref: 2421376025
Ref: S0099376025
Ref: 2422376029
Ref: 2423376043
Ref: 2424376063
Ref: 2425376131
Ref: 2426378776
Ref: 2427378777
Ref: 2428380556
Ref: 2429380638
Ref: 2430380638
Ref: 2431380830
Ref: 2432380831
Node: 4.1.4382342
Ref: 2433382453
Ref: 2434382690
Ref: S0100382690
Ref: 2435382694
Ref: 2436382702
Ref: 2437382753
Ref: S0101382753
Ref: 2438382767
Ref: 2439382786
Ref: 2440382871
Ref: S0102382871
Ref: 2441382875
Ref: 2442382883
Ref: 2443382944
Ref: S0103382944
Ref: 2444382963
Ref: 2445383728
Ref: 2446383728
Ref: 2447385230
Ref: 2448385230
Ref: 2449386347
Node: 4.1.5387114
Ref: 2450387544
Ref: 2451387544
Ref: 2452387634
Ref: 2453387688
Ref: 2454387819
Ref: 2455388066
Ref: S0104388066
Ref: 2456388088
Ref: 2457388244
Ref: 2458389152
Ref: 2459389369
Ref: 2460389370
Ref: 2461389460
Node: 4.1.6390346
Ref: 2462391056
Ref: 2463391056
Ref: 2464391683
Ref: 2465391683
Ref: 2466391922
Ref: 2467391998
Ref: 2468392346
Ref: S0105392346
Ref: 2469392378
Ref: 2470392385
Ref: 2471392586
Ref: 2472392821
Ref: 2473392821
Ref: 2474393216
Ref: 2475393216
Node: 4.2394741
Ref: 2476394836
Ref: 2477395025
Ref: 2478395112
Ref: 2479395112
Ref: 2480395692
Ref: 2481396389
Ref: 2482396389
Ref: 2483396389
Ref: 2484396440
Ref: 2485396440
Ref: 2486396440
Ref: 2487396440
Ref: 2488396532
Ref: 2489396947
Ref: 2490396947
Ref: 2491397257
Node: 4.3397881
Ref: 2492397980
Ref: 2493398093
Ref: 2494398153
Ref: S0106398153
Ref: 2495398157
Ref: 2496398177
Ref: 2497398199
Ref: 2498398275
Ref: 2499398520
Ref: 2500398809
Ref: 2501398879
Ref: 2502398940
Ref: 2503398940
Ref: 2504399049
Node: 4.3.1399207
Ref: 2505399537
Ref: S0107399537
Ref: 2506399543
Ref: 2507399619
Ref: S0108399619
Ref: 2508399633
Ref: 2509399665
Ref: 2510399754
Ref: S0109399754
Ref: 2511399769
Ref: 2512399795
Ref: 2513399816
Ref: 2514399873
Ref: S0110399873
Ref: 2515399898
Ref: 2516399925
Ref: 2517399960
Ref: 2518400090
Ref: 2519400592
Ref: 2520400687
Ref: 2521401201
Ref: 2522401337
Ref: 2523403198
Ref: 2524403330
Ref: 2525403611
Ref: 2526403990
Node: 4.3.2405906
Ref: 2527406327
Ref: S0111406327
Ref: 2528406342
Ref: 2529406361
Ref: 2530406417
Ref: S0112406417
Ref: 2531406421
Ref: 2532406435
Ref: 2533406502
Ref: 2534406597
Ref: 2535406998
Ref: 2536407733
Ref: 2537408217
Ref: 2538408830
Ref: 2539408836
Ref: 2540408836
Ref: 2541409274
Node: 4.3.3410214
Ref: 2542410762
Ref: S0113410762
Ref: 2543410774
Ref: 2544410803
Ref: 2545410861
Ref: S0114410861
Ref: 2546410876
Ref: 2547410888
Ref: 2548410902
Ref: 2549410925
Ref: 2550410939
Ref: 2551410962
Ref: 2552410984
Ref: 2553410998
Ref: 2554411054
Ref: S0115411054
Ref: 2555411069
Ref: 2556411100
Ref: 2557411167
Ref: S0116411167
Ref: 2558411181
Ref: 2559411205
Ref: 2560411225
Ref: 2561411255
Ref: 2562411403
Ref: 2563411593
Ref: 2564411842
Ref: 2565411941
Ref: 2566412064
Ref: 2567412201
Ref: 2568412729
Ref: 2569416106
Ref: 2570416358
Ref: 2571416358
Ref: 2572416626
Ref: 2573416627
Ref: 2574417050
Ref: 2575417911
Ref: 2576417911
Ref: 2577418052
Ref: 2578418052
Ref: 2579418241
Ref: 2580418241
Ref: 2581418380
Node: 4.4420495
Ref: 2582420598
Ref: 2583420966
Ref: 2584420967
Ref: 2585420967
Ref: 2586420967
Ref: 2587420967
Ref: 2588420967
Ref: 2589420967
Ref: 2590420967
Ref: 2591420967
Ref: 2592420967
Ref: 2593420967
Ref: 2594420967
Ref: 2595420967
Ref: 2596420967
Ref: 2597420967
Ref: 2598420967
Ref: 2599420967
Ref: 2600420967
Ref: 2601420967
Ref: 2602420967
Ref: 2603420967
Ref: 2604420967
Ref: 2605420967
Ref: 2606420967
Ref: 2607420967
Ref: 2608420967
Ref: 2609420967
Ref: 2610420967
Ref: 2611420967
Ref: 2612420967
Ref: 2613420967
Ref: 2614420967
Ref: 2615420967
Ref: 2616420967
Ref: 2617420967
Ref: 2618420967
Ref: 2619420967
Ref: 2620420967
Ref: 2621420967
Ref: 2622420967
Ref: 2623420967
Ref: 2624420967
Ref: 2625420967
Ref: 2626420967
Ref: 2627420967
Ref: 2628420967
Ref: 2629420967
Ref: 2630420967
Ref: 2631420967
Ref: 2632420967
Ref: 2633420967
Ref: 2634420967
Ref: 2635420967
Ref: 2636420967
Ref: 2637420967
Ref: 2638420967
Ref: 2639420967
Ref: 2640420967
Ref: 2641420967
Ref: 2642420967
Ref: 2643420967
Ref: 2644420967
Ref: 2645420967
Ref: 2646420967
Ref: 2647420967
Ref: 2648420967
Ref: 2649420967
Ref: 2650420967
Ref: 2651420967
Ref: 2652420967
Ref: 2653420967
Ref: 2654420967
Ref: 2655421027
Ref: S0117421027
Ref: 2656421042
Ref: 2657421056
Ref: 2658421071
Ref: 2659421090
Ref: 2660421110
Ref: 2661421123
Ref: 2662421138
Ref: 2663421156
Ref: 2664421176
Ref: 2665421190
Ref: 2666421229
Ref: S0118421229
Ref: 2667421244
Ref: 2668421265
Ref: 2669421292
Ref: 2670421312
Ref: 2671421339
Ref: 2672421360
Ref: 2673421387
Ref: 2674421413
Ref: 2675421440
Ref: 2676421465
Ref: 2677421509
Ref: S0119421509
Ref: 2678421524
Ref: 2679421543
Ref: 2680421563
Ref: 2681421600
Ref: S0120421600
Ref: 2682421615
Ref: 2683421634
Ref: 2684421654
Ref: 2685421690
Ref: 2686421717
Ref: 2687421750
Ref: 2688421801
Ref: S0121421801
Ref: 2689421805
Ref: 2690421827
Ref: 2691421875
Ref: S0122421875
Ref: 2692421887
Ref: 2693421907
Ref: 2694421915
Ref: 2695421959
Ref: S0123421959
Ref: 2696421965
Ref: 2697421988
Ref: 2698421994
Ref: 2699422023
Ref: 2700422041
Ref: S0124422041
Ref: 2701422045
Ref: 2702422054
Ref: 2703422075
Ref: 2704422097
Ref: S0125422097
Ref: 2705422101
Ref: 2706422114
Ref: 2707422129
Ref: 2708422143
Ref: 2709422168
Ref: S0126422168
Ref: 2710422181
Ref: 2711422206
Ref: 2712422223
Ref: 2713422241
Ref: 2714422248
Ref: 2715422261
Ref: 2716422282
Ref: 2717422309
Ref: 2718422650
Ref: 2719422790
Ref: 2720422790
Ref: 2721422790
Node: 4.5424239
Ref: 2722424388
Ref: 2723424388
Ref: 2724424754
Ref: S0127424754
Ref: 2725424806
Ref: S0128424806
Ref: 2726424875
Ref: S0129424875
Ref: 2727424927
Ref: S0130424927
Ref: 2728424972
Ref: S0131424972
Ref: 2729425038
Ref: S0132425038
Ref: 2730425316
Ref: 2731425316
Ref: 2732425473
Ref: 2733425474
Ref: 2734425474
Ref: 2735425474
Ref: 2736426038
Ref: 2737426419
Ref: 2738426616
Node: 4.5.1428320
Ref: 2739428544
Ref: 2740428544
Ref: 2741428544
Ref: 2742428691
Ref: 2743428805
Ref: 2744428805
Ref: 2745428805
Ref: 2746428805
Ref: 2747428805
Ref: 2748428805
Ref: 2749428805
Ref: 2750428805
Ref: 2751428986
Ref: 2752430050
Ref: 2753430353
Ref: 2754430353
Ref: 2755430517
Ref: 2756430518
Ref: 2757430607
Node: 4.5.2431426
Ref: 2758431599
Ref: 2759431599
Ref: 2760431599
Ref: 2761431599
Ref: 2762431599
Ref: 2763431689
Ref: 2764431690
Ref: 2765431837
Ref: 2766431838
Ref: 2767431838
Ref: 2768431838
Ref: 2769431838
Ref: 2770431838
Ref: 2771431838
Ref: 2772431838
Ref: 2773431838
Ref: 2774431838
Ref: 2775431838
Ref: 2776431838
Ref: 2777431838
Ref: 2778431838
Ref: 2779431838
Ref: 2780431838
Ref: 2781431838
Ref: 2782431838
Ref: 2783431838
Ref: 2784431838
Ref: 2785431838
Ref: 2786431838
Ref: 2787431838
Ref: 2788431838
Ref: 2789431838
Ref: 2790432007
Ref: 2791432007
Ref: 2792432007
Ref: 2793432402
Ref: 2794432402
Ref: 2795436197
Ref: 2796437177
Ref: 2797437359
Ref: 2798438072
Ref: 2799440058
Ref: 2800440161
Ref: 2801440946
Ref: 2802440953
Ref: 2803441240
Ref: 2804442374
Node: 4.5.3445301
Ref: 2805445484
Ref: 2806445484
Ref: 2807445484
Ref: 2808445484
Ref: 2809445484
Ref: 2810445484
Ref: 2811445484
Ref: 2812445484
Ref: 2813445484
Ref: 2814445484
Ref: 2815445762
Ref: 2816445762
Ref: 2817445762
Ref: 2818445762
Ref: 2819445762
Ref: 2820445762
Ref: 2821445762
Ref: 2822446166
Ref: 2823447060
Ref: 2824447061
Ref: 2825447210
Ref: 2826447576
Ref: 2827447582
Node: 4.5.4448324
Ref: 2828448505
Ref: 2829448505
Ref: 2830448505
Ref: 2831448505
Ref: 2832448505
Ref: 2833448505
Ref: 2834448505
Ref: 2835448505
Ref: 2836448505
Ref: 2837448505
Node: 4.5.5449007
Ref: 2838449186
Ref: 2839449186
Ref: 2840449186
Ref: 2841449186
Ref: 2842449186
Ref: 2843449186
Ref: 2844449186
Ref: 2845449186
Ref: 2846449186
Ref: 2847449186
Ref: 2848449186
Ref: 2849449186
Ref: 2850449186
Ref: 2851449186
Ref: 2852449186
Ref: 2853449186
Ref: 2854453468
Ref: 2855453474
Ref: 2856453474
Ref: 2857453474
Node: 4.5.6456331
Ref: 2858456524
Ref: 2859456524
Ref: 2860456524
Ref: 2861456524
Ref: 2862456524
Ref: 2863456712
Ref: 2864456712
Ref: 2865456712
Ref: 2866457588
Ref: 2867457589
Ref: 2868457589
Ref: 2869457738
Ref: 2870457738
Ref: 2871457738
Ref: 2872457738
Ref: 2873458180
Ref: 2874458693
Ref: 2875459089
Ref: 2876459089
Ref: 2877459232
Node: 4.5.7459282
Ref: 2878460041
Ref: S0133460041
Ref: 2879460045
Ref: 2880460062
Ref: 2881460101
Ref: S0134460101
Ref: 2882460117
Ref: 2883460142
Ref: 2884460168
Ref: 2885460193
Ref: 2886460229
Ref: 2887460260
Ref: S0135460260
Ref: 2888460273
Ref: 2889460309
Ref: S0136460309
Ref: 2890460338
Ref: 2891460361
Ref: 2892460401
Ref: 2893460467
Ref: S0137460467
Ref: 2894460486
Ref: 2895460533
Ref: 2896461236
Ref: 2897461941
Ref: 2898462115
Ref: 2899462115
Ref: 2900462116
Ref: 2901463615
Ref: 2902464011
Ref: 2903464011
Ref: 2904464011
Ref: 2905464150
Node: 4.5.8464152
Ref: 2906464475
Ref: S0138464475
Ref: 2907464484
Ref: 2908464495
Ref: 2909464533
Ref: 2910464556
Ref: 2911464567
Ref: 2912464593
Ref: 2913464623
Ref: S0139464623
Ref: 2914464658
Ref: S0140464658
Ref: 2915464671
Ref: 2916464923
Ref: 2917465066
Ref: 2918465478
Node: 4.6466679
Ref: 2919467083
Ref: 2920467084
Ref: 2921467084
Ref: 2922467084
Ref: 2923467084
Ref: 2924467084
Ref: 2925467149
Ref: S0141467149
Ref: 2926467163
Ref: 2927467176
Ref: 2928467197
Ref: 2929467210
Ref: 2930467219
Ref: 2931467302
Ref: 2932467385
Ref: 2933467421
Ref: 2934467674
Ref: 2935467674
Ref: 2936467884
Ref: 2937467885
Ref: 2938467938
Ref: 2939467992
Ref: 2940468413
Ref: 2941468413
Ref: 2942468634
Ref: 2943468634
Ref: 2944469242
Ref: 2945469242
Ref: 2946469345
Ref: 2947469345
Ref: 2948469582
Ref: 2949469653
Ref: 2950469868
Ref: 2951470365
Ref: 2952470365
Ref: 2953470888
Ref: 2954471110
Ref: 2955471382
Ref: 2956471856
Ref: 2957471856
Ref: 2958471985
Ref: 2959471985
Ref: 2960472259
Ref: 2961472285
Ref: 2962472559
Ref: 2963473146
Ref: 2964473261
Ref: 2965473261
Ref: 2966473261
Ref: 2967473454
Ref: 2968473455
Ref: 2969473455
Ref: 2970473730
Ref: 2971473730
Ref: 2972474244
Ref: 2973474770
Ref: 2974474770
Ref: 2975474944
Ref: 2976474944
Ref: 2977474985
Ref: 2978474985
Ref: 2979475332
Ref: 2980475332
Ref: 2981475581
Ref: 2982476170
Ref: 2983476171
Ref: 2984476181
Ref: 2985476181
Ref: 2986476431
Ref: 2987476432
Ref: 2988476858
Ref: 2989476859
Ref: 2990477509
Ref: 2991477509
Ref: 2992477832
Ref: 2993477832
Ref: 2994477948
Ref: 2995477948
Ref: 2996478639
Ref: 2997478640
Ref: 2998479172
Ref: 2999479172
Ref: 3000479172
Ref: 3001479172
Ref: 3002479172
Ref: 3003479172
Ref: 3004479172
Ref: 3005479172
Ref: 3006479570
Ref: 3007479570
Ref: 3008479575
Ref: 3009479741
Ref: 3010479742
Ref: 3011479742
Ref: 3012479742
Ref: 3013479742
Ref: 3014479742
Ref: 3015480747
Ref: 3016481259
Ref: 3017481267
Ref: 3018481267
Ref: 3019481267
Ref: 3020482313
Ref: 3021482442
Ref: 3022483013
Ref: 3023483018
Node: 4.7484930
Ref: 3024485198
Ref: 3025485269
Ref: S0142485269
Ref: 3026485282
Ref: 3027485296
Ref: 3028485310
Ref: 3029485323
Ref: 3030485385
Ref: 3031485870
Ref: 3032485870
Ref: 3033485870
Ref: 3034485870
Ref: 3035485870
Ref: 3036485870
Ref: 3037485870
Ref: 3038486095
Ref: 3039486096
Node: 4.8487339
Ref: 3040487541
Ref: 3041487542
Ref: 3042487542
Ref: 3043487603
Ref: S0143487603
Ref: 3044487621
Ref: 3045487644
Ref: 3046487676
Ref: 3047487699
Ref: 3048487753
Ref: S0144487753
Ref: 3049487774
Ref: 3050487954
Ref: 3051488483
Ref: 3052488532
Ref: 3053488601
Ref: 3054488897
Ref: 3055490131
Ref: 3056490834
Ref: 3057490888
Ref: 3058490998
Ref: 3059490999
Ref: 3060491151
Ref: 3061491156
Ref: 3062491285
Ref: 3063491733
Ref: 3064491734
Ref: 3065491734
Ref: 3066491734
Ref: 3067491818
Ref: 3068491962
Ref: 3069492694
Ref: 3070492694
Ref: 3071492694
Ref: 3072492909
Ref: 3073492909
Ref: 3074492909
Ref: 3075493149
Ref: 3076493149
Ref: 3077493149
Ref: 3078493400
Ref: 3079493400
Ref: 3080493400
Ref: 3081493400
Ref: 3082493400
Ref: 3083493401
Ref: 3084493619
Ref: 3085494309
Node: 4.9495468
Ref: 3086495818
Ref: 3087495926
Ref: 3088495931
Ref: 3089497607
Ref: 3090498011
Ref: 3091498557
Ref: 3092498932
Ref: 3093499083
Ref: 3094499362
Ref: 3095499440
Ref: 3096499658
Ref: 3097500108
Ref: 3098500227
Ref: 3099500227
Ref: 3100500227
Ref: 3101500330
Ref: 3102500474
Ref: 3103500729
Ref: 3104501052
Ref: 3105503107
Node: 4.9.1505229
Ref: 3106505428
Ref: 3107505935
Ref: 3108506543
Ref: 3109506704
Ref: 3110506892
Ref: 3111507064
Node: 5507859
Node: 5.1509084
Ref: 3112509510
Ref: S0145509510
Ref: 3113509514
Ref: 3114509526
Ref: 3115509538
Ref: 3116509562
Ref: S0146509562
Ref: 3117509576
Ref: 3118509583
Ref: 3119509603
Ref: 3120509610
Ref: 3121509655
Ref: S0147509655
Ref: 3122509659
Ref: 3123509685
Ref: 3124509710
Ref: 3125509735
Ref: 3126509754
Ref: 3127509789
Ref: 3128509817
Ref: 3129509848
Ref: 3130509870
Ref: 3131509896
Ref: 3132509916
Ref: 3133509942
Ref: 3134509985
Ref: S0148509985
Ref: 3135510000
Ref: 3136510017
Ref: 3137510042
Ref: 3138510061
Ref: 3139510087
Ref: 3140510123
Ref: 3141510144
Ref: 3142510183
Ref: S0149510183
Ref: 3143510207
Ref: S0150510207
Ref: 3144510220
Ref: 3145510271
Ref: S0151510271
Ref: 3146510275
Ref: 3147511496
Ref: 3148511551
Ref: 3149512039
Node: 5.2512900
Ref: 3150513200
Ref: S0152513200
Ref: 3151513222
Ref: 3152513230
Ref: 3153513394
Ref: 3154513395
Ref: 3155513581
Ref: 3156513582
Ref: 3157513840
Ref: 3158513915
Ref: 3159514331
Ref: 3160514456
Ref: 3161514511
Ref: 3162514666
Ref: 3163514666
Ref: 3164514666
Ref: 3165515003
Ref: 3166515223
Ref: 3167515223
Ref: 3168515528
Node: 5.3517034
Ref: 3169517363
Ref: S0153517363
Ref: 3170517380
Ref: 3171517406
Ref: 3172517444
Ref: 3173517470
Ref: 3174517519
Ref: 3175517646
Node: 5.4518538
Ref: 3176518872
Ref: S0154518872
Ref: 3177518900
Ref: 3178518926
Ref: 3179518965
Ref: 3180519045
Ref: S0155519045
Ref: 3181519063
Ref: 3182519098
Ref: 3183519175
Ref: 3184519175
Ref: 3185519239
Ref: 3186520639
Ref: 3187520975
Ref: 3188520975
Ref: 3189520975
Node: 5.5522153
Ref: 3190522431
Ref: S0156522431
Ref: 3191522450
Ref: 3192522485
Ref: 3193522522
Ref: 3194522572
Ref: 3195522611
Ref: S0157522611
Ref: 3196522622
Ref: 3197522646
Ref: 3198522689
Ref: 3199522748
Ref: S0158522748
Ref: 3200522761
Ref: 3201522794
Ref: 3202523064
Ref: 3203523207
Ref: 3204523257
Ref: 3205523574
Ref: 3206523926
Ref: 3207523926
Ref: 3208524671
Node: 5.5.1526903
Ref: 3209527150
Ref: 3210527355
Ref: 3211527411
Ref: 3212527489
Ref: 3213527597
Ref: 3214527677
Ref: 3215527757
Ref: 3216528017
Ref: 3217528151
Ref: 3218528205
Ref: 3219528279
Ref: 3220528417
Ref: 3221529099
Ref: 3222529172
Ref: 3223529301
Ref: 3224529301
Ref: 3225529301
Ref: 3226529456
Ref: 3227529456
Ref: 3228529456
Ref: 3229529662
Ref: 3230529795
Ref: 3231529869
Ref: 3232529963
Ref: 3233530774
Ref: 3234531389
Node: 5.5.2531391
Ref: 3235531674
Ref: S0159531674
Ref: 3236531688
Ref: 3237531730
Ref: 3238531744
Ref: 3239531767
Ref: 3240531815
Ref: 3241531950
Ref: 3242531950
Ref: 3243532012
Ref: 3244532140
Ref: 3245532253
Ref: 3246532253
Ref: 3247532306
Ref: 3248532306
Ref: 3249532444
Ref: 3250532444
Ref: 3251532480
Ref: 3252532480
Ref: 3253534089
Ref: 3254535522
Ref: 3255536437
Ref: 3256536700
Ref: 3257537568
Ref: 3258537738
Ref: 3259537809
Node: 5.6539574
Ref: 3260539852
Ref: S0160539852
Ref: 3261539872
Ref: 3262539933
Ref: 3263539987
Ref: 3264540042
Ref: 3265540435
Node: 5.7540815
Ref: 3266541145
Ref: S0161541145
Ref: 3267541169
Ref: 3268541181
Ref: 3269541379
Ref: 3270542166
Node: 5.8543021
Ref: 3271543302
Ref: S0162543302
Ref: 3272543318
Ref: 3273543376
Ref: 3274543841
Node: 6544717
Ref: 3275544810
Ref: 3276544810
Ref: 3277544810
Ref: 3278545273
Ref: 3279545332
Ref: 3280545414
Node: 6.1545846
Ref: 3281546091
Ref: S0163546091
Ref: 3282546106
Ref: 3283546137
Ref: 3284546176
Ref: 3285546271
Ref: S0164546271
Ref: 3286546285
Ref: 3287546318
Ref: 3288546376
Ref: S0165546376
Ref: 3289546391
Ref: 3290546418
Ref: 3291546476
Ref: S0166546476
Ref: 3292546490
Ref: 3293546510
Ref: 3294546563
Ref: S0167546563
Ref: 3295546569
Ref: 3296546589
Ref: 3297546602
Ref: 3298546645
Ref: S0168546645
Ref: 3299546649
Ref: 3300546679
Ref: 3301546744
Ref: S0169546744
Ref: 3302546750
Ref: 3303546770
Ref: 3304546918
Ref: S0170546918
Ref: 3305546922
Ref: 3306547227
Ref: S0171547227
Ref: 3307547231
Ref: 3308547274
Ref: S0172547274
Ref: 3309547280
Ref: 3310547332
Ref: S0173547332
Ref: 3311547347
Ref: 3312547368
Ref: 3313547384
Ref: 3314547407
Ref: 3315547427
Ref: 3316547465
Ref: S0174547465
Ref: 3317547479
Ref: 3318547506
Ref: 3319547566
Ref: S0175547566
Ref: 3320547580
Ref: 3321547617
Ref: 3322547623
Ref: 3323547639
Ref: 3324547662
Ref: 3325547691
Ref: 3326547718
Ref: 3327547740
Ref: 3328547779
Ref: S0176547779
Ref: 3329547857
Ref: 3330548048
Ref: 3331548159
Ref: 3332548212
Ref: 3333548545
Ref: 3334548545
Ref: 3335549198
Ref: 3336549828
Ref: 3337550212
Ref: 3338550222
Ref: 3339550222
Ref: 3340550348
Ref: 3341550427
Ref: 3342550851
Ref: 3343551566
Ref: 3344552420
Node: 6.1.1554357
Ref: 3345554863
Ref: 3346554863
Ref: 3347555026
Ref: 3348555026
Ref: 3349555289
Ref: 3350555289
Ref: 3351555518
Ref: 3352555518
Ref: 3353555727
Ref: 3354555727
Ref: 3355555891
Ref: 3356555891
Ref: 3357556157
Ref: 3358556157
Ref: 3359556308
Ref: 3360556308
Ref: 3361556448
Ref: 3362556448
Ref: 3363558355
Ref: 3364558971
Ref: 3365559516
Ref: 3366559516
Ref: 3367560242
Ref: 3368560242
Ref: 3369560310
Ref: 3370560750
Ref: 3371560765
Ref: 3372562980
Ref: 3373562995
Ref: 3374564322
Ref: 3375564322
Ref: 3376564322
Ref: 3377564621
Ref: 3378564621
Ref: 3379564621
Ref: 3380565191
Ref: 3381565191
Ref: 3382565944
Ref: 3383565944
Ref: 3384565944
Ref: 3385565944
Ref: 3386565944
Node: 6.2568851
Ref: 3387569105
Ref: 3388569105
Ref: 3389569105
Ref: 3390569105
Ref: 3391569105
Ref: 3392569105
Ref: 3393569592
Ref: 3394569828
Ref: 3395570254
Ref: 3396570734
Ref: 3397570888
Ref: 3398570888
Ref: 3399570888
Ref: 3400570888
Ref: 3401571556
Node: 6.3572125
Ref: 3402572363
Ref: S0177572363
Ref: 3403572378
Ref: 3404572409
Ref: 3405572447
Ref: 3406572484
Ref: 3407572529
Ref: 3408572574
Ref: 3409573157
Ref: 3410573409
Ref: 3411573584
Node: 6.3.1574521
Ref: 3412574632
Ref: 3413574632
Ref: 3414574632
Ref: 3415574632
Ref: 3416574632
Ref: 3417574870
Ref: 3418574870
Ref: 3419575244
Ref: 3420575244
Ref: 3421575439
Ref: 3422575439
Ref: 3423576433
Ref: 3424576433
Ref: 3425576716
Ref: 3426576716
Ref: 3427577632
Ref: 3428577632
Ref: 3429577954
Ref: 3430577962
Ref: 3431577962
Ref: 3432578399
Ref: 3433578407
Ref: 3434578407
Ref: 3435578674
Ref: 3436578682
Ref: 3437578682
Ref: 3438579213
Ref: 3439580283
Ref: 3440580538
Ref: 3441580544
Ref: 3442580794
Node: 6.3.2581313
Ref: 3443582161
Ref: 3444582161
Node: 6.4582543
Ref: 3445582654
Ref: 3446582963
Ref: S0178582963
Ref: 3447582987
Ref: 3448583012
Ref: 3449583019
Ref: 3450583063
Ref: S0179583063
Ref: 3451583086
Ref: 3452583109
Ref: 3453583116
Ref: 3454583167
Ref: S0180583167
Ref: 3455583182
Ref: 3456583207
Ref: 3457583260
Ref: S0181583260
Ref: 3458583291
Ref: 3459583309
Ref: 3460583368
Ref: S0182583368
Ref: 3461583372
Ref: 3462583395
Ref: 3463583403
Ref: 3464583408
Ref: 3465584690
Ref: 3466585342
Ref: 3467585776
Ref: 3468586079
Ref: 3469586080
Node: 6.4.1588338
Ref: 3470588445
Ref: 3471588782
Ref: 3472588783
Ref: 3473588783
Ref: 3474588783
Ref: 3475589010
Ref: 3476589236
Ref: 3477590072
Ref: 3478590697
Ref: 3479591130
Ref: 3480592412
Ref: 3481594652
Ref: 3482595117
Ref: 3483595128
Ref: 3484595380
Ref: 3485596431
Ref: 3486597306
Ref: 3487597306
Ref: 3488597455
Ref: 3489597455
Ref: 3490597455
Ref: 3491597455
Ref: 3492597455
Ref: 3493597692
Ref: 3494597755
Ref: 3495597810
Node: 6.5598147
Ref: 3496598397
Ref: 3497598648
Ref: S0183598648
Ref: S0184598648
Ref: 3498598661
Ref: 3499598720
Ref: S0185598720
Ref: 3500598734
Ref: 3501598776
Ref: 3502598812
Ref: 3503598861
Ref: S0186598861
Ref: 3504598882
Ref: 3505598934
Ref: 3506599024
Ref: S0187599024
Ref: 3507599028
Ref: 3508599050
Ref: 3509599128
Ref: 3510599304
Ref: 3511599450
Ref: 3512599632
Ref: 3513600904
Ref: 3514602797
Ref: 3515603192
Ref: 3516603493
Ref: 3517603816
Ref: 3518603816
Ref: 3519603958
Ref: 3520603958
Ref: 3521603959
Ref: 3522603965
Ref: 3523604162
Ref: 3524604163
Ref: 3525604929
Ref: 3526604929
Ref: 3527604930
Ref: 3528604938
Ref: 3529604938
Ref: 3530605164
Ref: 3531605794
Ref: 3532605795
Ref: 3533605795
Node: 6.5.1608122
Ref: 3534608822
Ref: 3535608822
Ref: 3536608822
Ref: 3537609566
Ref: 3538610038
Node: 6.6610256
Ref: 3539610383
Ref: 3540610383
Ref: 3541610383
Ref: 3542611662
Node: 6.7612181
Ref: 3543612462
Ref: S0188612462
Ref: 3544612476
Ref: 3545612506
Ref: 3546612551
Ref: 3547612886
Ref: 3548612993
Ref: 3549612993
Ref: 3550613369
Node: 6.8613754
Ref: 3551614073
Ref: S0189614073
Ref: 3552614087
Ref: 3553614117
Ref: 3554614156
Ref: 3555614181
Ref: 3556614213
Ref: 3557614243
Ref: 3558614281
Ref: 3559614304
Ref: 3560614542
Ref: 3561614905
Ref: 3562615438
Ref: 3563615438
Ref: 3564615461
Ref: 3565616129
Node: 7616482
Ref: 3566616569
Ref: 3567616939
Ref: 3568616940
Ref: 3569616940
Ref: 3570616940
Node: 7.1617189
Ref: 3571617578
Ref: S0190617578
Ref: 3572617582
Ref: 3573617637
Ref: S0191617637
Ref: 3574617659
Ref: 3575617700
Ref: 3576617737
Ref: 3577617790
Ref: 3578617830
Ref: 3579617848
Ref: 3580618107
Ref: 3581618107
Ref: 3582618370
Ref: 3583618530
Ref: 3584618882
Ref: 3585619346
Node: 7.2620645
Ref: 3586621195
Ref: S0192621195
Ref: 3587621222
Ref: 3588621263
Ref: 3589621300
Ref: 3590621345
Ref: 3591621392
Ref: 3592621410
Ref: 3593622736
Ref: 3594623026
Node: 7.3625177
Ref: 3595625729
Ref: 3596625730
Ref: 3597625730
Ref: 3598625730
Ref: 3599625730
Ref: 3600625806
Ref: S0193625806
Ref: 3601625824
Ref: 3602625845
Ref: 3603625923
Ref: 3604625985
Ref: S0194625985
Ref: 3605626003
Ref: 3606626024
Ref: 3607626105
Ref: 3608626145
Ref: 3609626187
Ref: 3610626258
Ref: 3611626258
Ref: 3612628478
Ref: 3613628965
Ref: 3614629443
Ref: 3615630572
Ref: 3616630624
Ref: 3617630697
Ref: 3618632164
Ref: 3619632243
Node: 7.3.1634612
Ref: 3620634920
Ref: 3621636483
Ref: 3622636483
Ref: 3623636483
Ref: 3624636889
Ref: 3625639166
Ref: 3626639181
Node: 7.3.2642932
Ref: 3627643331
Ref: 3628643667
Ref: 3629643667
Ref: 3630644079
Ref: 3631644079
Ref: 3632644174
Ref: 3633644174
Ref: 3634644174
Ref: 3635644295
Ref: 3636645882
Ref: 3637645882
Ref: 3638649111
Ref: 3639649396
Node: 7.4650941
Ref: 3640651363
Ref: 3641651485
Ref: 3642651573
Ref: 3643651817
Ref: 3644653407
Node: 7.5654211
Ref: 3645656022
Ref: 3646656411
Ref: 3647656577
Ref: 3648656577
Ref: 3649657636
Ref: 3650657636
Ref: 3651657636
Node: 7.6660061
Ref: 3652660182
Ref: 3653660182
Ref: 3654660751
Ref: 3655660752
Ref: 3656660752
Ref: 3657660848
Ref: 3658660932
Ref: 3659660933
Ref: 3660660933
Ref: 3661661481
Ref: 3662661537
Ref: 3663661658
Ref: 3664661726
Ref: 3665661794
Ref: 3666661862
Ref: 3667662007
Ref: 3668662083
Ref: 3669662231
Ref: 3670662698
Ref: 3671662698
Ref: 3672663806
Ref: 3673664365
Ref: 3674664610
Ref: 3675664610
Ref: 3676664653
Ref: 3677664653
Ref: 3678664848
Ref: 3679664990
Ref: 3680665939
Ref: 3681665939
Ref: 3682666486
Ref: 3683666510
Ref: 3684666842
Node: 7.6.1669702
Ref: 3685670164
Ref: 3686670165
Ref: 3687670218
Ref: 3688670218
Ref: 3689670392
Ref: 3690670393
Ref: 3691670393
Ref: 3692670393
Ref: 3693670756
Ref: 3694670756
Ref: 3695670927
Ref: 3696671400
Ref: 3697671901
Ref: 3698672654
Ref: 3699673176
Ref: 3700673817
Ref: 3701673817
Ref: 3702673818
Ref: 3703673886
Ref: 3704674234
Ref: 3705674659
Ref: 3706675810
Ref: 3707676048
Ref: 3708676502
Ref: 3709676676
Ref: 3710676916
Ref: 3711677151
Ref: 3712678688
Node: 8679950
Node: 8.1681052
Ref: 3713681201
Ref: 3714682477
Ref: 3715682477
Ref: 3716682477
Ref: 3717682477
Ref: 3718682477
Ref: 3719682756
Ref: 3720683004
Node: 8.2684397
Ref: 3721684980
Ref: 3722685817
Ref: 3723685822
Ref: 3724685962
Ref: 3725686319
Ref: 3726686391
Ref: 3727686594
Ref: 3728687172
Ref: 3729687592
Ref: 3730687839
Ref: 3731687844
Ref: 3732687959
Ref: 3733688168
Node: 8.3688841
Ref: 3734688940
Ref: 3735689190
Ref: 3736689190
Ref: 3737689190
Ref: 3738689498
Ref: 3739689905
Ref: 3740689905
Ref: 3741689987
Ref: 3742690110
Ref: 3743690240
Ref: 3744690358
Ref: 3745690468
Ref: 3746690593
Ref: 3747690734
Ref: 3748690872
Ref: 3749691007
Ref: 3750691230
Ref: 3751691261
Ref: 3752692924
Ref: 3753693553
Ref: 3754693553
Ref: 3755693658
Ref: 3756693776
Ref: 3757694708
Ref: 3758695247
Ref: 3759696415
Ref: 3760696415
Ref: 3761696415
Ref: 3762696415
Ref: 3763696562
Ref: 3764696629
Ref: 3765696817
Ref: 3766696916
Ref: 3767696973
Ref: 3768697067
Ref: 3769697187
Ref: 3770698335
Ref: 3771698679
Node: 8.3.1699583
Ref: 3772699888
Ref: S0195699888
Ref: 3773700786
Node: 8.4702221
Ref: 3774702574
Ref: S0196702574
Ref: 3775702578
Ref: 3776702600
Ref: 3777702642
Ref: S0197702642
Ref: 3778702659
Ref: 3779702675
Ref: 3780702707
Ref: S0198702707
Ref: 3781702727
Ref: 3782702743
Ref: 3783702941
Ref: 3784703944
Ref: 3785703950
Ref: 3786705052
Ref: 3787705052
Ref: 3788705528
Node: 8.5705853
Ref: 3789706287
Ref: S0199706287
Ref: 3790706303
Ref: 3791706342
Ref: 3792706384
Ref: 3793706424
Ref: 3794706467
Ref: 3795706546
Ref: 3796706709
Ref: 3797706710
Node: 8.5.1707953
Ref: 3798708224
Ref: S0200708224
Ref: 3799708238
Ref: 3800708261
Ref: 3801708277
Ref: 3802708311
Ref: 3803708330
Ref: 3804708362
Ref: 3805708384
Ref: 3806708417
Ref: 3807708436
Ref: 3808709432
Ref: 3809709536
Ref: 3810710052
Ref: 3811710501
Node: 8.5.2711414
Ref: 3812711714
Ref: S0201711714
Ref: 3813711718
Ref: 3814711774
Ref: 3815711788
Node: 8.5.3712191
Ref: 3816712479
Ref: S0202712479
Ref: 3817712492
Ref: 3818712541
Ref: 3819712555
Node: 8.5.4713464
Ref: 3820713711
Ref: 3821713769
Ref: 3822714030
Ref: S0203714030
Ref: 3823714045
Ref: 3824714076
Ref: 3825714125
Ref: 3826714144
Ref: 3827714219
Ref: 3828714481
Ref: 3829715143
Ref: 3830715417
Ref: 3831715550
Ref: 3832715833
Ref: 3833717748
Ref: 3834717748
Node: 8.5.5720693
Ref: 3835720972
Ref: S0204720972
Ref: 3836721004
Ref: 3837721061
Ref: 3838721080
Ref: 3839721132
Ref: 3840721191
Ref: 3841721210
Ref: 3842721261
Ref: 3843721319
Ref: 3844721338
Node: 8.6722165
Ref: 3845722302
Ref: 3846722578
Ref: 3847723181
Ref: 3848723572
Ref: 3849723941
Ref: 3850723941
Ref: 3851724584
Ref: 3852724670
Ref: 3853724671
Ref: 3854724671
Ref: 3855724899
Ref: 3856725200
Ref: 3857725395
Ref: 3858726718
Ref: 3859727104
Ref: 3860727301
Ref: 3861727453
Ref: 3862727453
Ref: 3863727710
Ref: 3864728640
Ref: 3865728777
Ref: 3866728908
Ref: 3867728961
Ref: 3868729703
Ref: 3869729703
Ref: 3870730242
Ref: 3871731055
Ref: 3872731349
Ref: 3873731750
Node: 9732552
Ref: 3874732676
Ref: 3875732755
Ref: 3876732756
Ref: 3877732988
Ref: 3878732989
Ref: 3879732989
Ref: 3880732989
Ref: 3881733048
Ref: 3882734209
Ref: 3883734453
Ref: 3884734454
Ref: 3885734454
Ref: 3886734454
Ref: 3887734454
Ref: 3888734454
Ref: 3889734454
Ref: 3890734454
Ref: 3891734602
Node: 9.1735674
Ref: 3892735795
Ref: 3893736204
Ref: S0205736204
Ref: 3894736227
Ref: 3895736248
Ref: 3896736287
Ref: 3897736328
Ref: 3898736359
Ref: 3899736410
Ref: S0206736410
Ref: 3900736428
Ref: 3901736463
Ref: 3902736503
Ref: 3903736534
Ref: 3904736575
Ref: S0207736575
Ref: 3905736591
Ref: 3906736630
Ref: 3907736659
Ref: 3908736690
Ref: S0208736690
Ref: 3909736694
Ref: 3910736715
Ref: 3911736748
Ref: S0209736748
Ref: 3912736771
Ref: 3913736805
Ref: 3914736840
Ref: 3915736881
Ref: 3916736930
Ref: 3917737207
Ref: 3918737394
Ref: 3919738433
Ref: 3920738434
Ref: 3921738434
Ref: 3922738487
Ref: 3923739128
Ref: 3924739492
Ref: 3925739687
Ref: 3926739767
Ref: 3927739978
Ref: 3928740047
Ref: 3929740169
Ref: 3930740336
Ref: 3931740587
Node: 9.2743427
Ref: 3932743617
Ref: 3933743719
Ref: 3934743720
Ref: 3935743720
Ref: 3936743720
Ref: 3937743865
Ref: 3938745813
Ref: 3939745813
Ref: 3940745970
Node: 9.3747562
Ref: 3941747764
Ref: 3942747764
Ref: 3943747764
Ref: 3944747764
Ref: 3945748585
Ref: 3946749083
Node: 9.4751984
Ref: 3947752137
Ref: 3948752137
Ref: 3949752137
Ref: 3950752137
Ref: 3951752307
Ref: 3952752308
Ref: 3953752308
Ref: 3954752689
Ref: 3955752768
Ref: S0210752768
Ref: 3956752795
Ref: 3957752816
Ref: 3958752855
Ref: 3959752895
Ref: 3960752926
Ref: 3961752986
Ref: S0211752986
Ref: 3962753008
Ref: 3963753042
Ref: 3964753082
Ref: 3965753113
Ref: 3966753163
Ref: S0212753163
Ref: 3967753179
Ref: 3968753239
Ref: 3969753295
Ref: 3970753348
Ref: S0213753348
Ref: 3971753352
Ref: 3972753388
Ref: 3973753418
Ref: 3974753469
Ref: S0214753469
Ref: 3975753473
Ref: 3976753518
Ref: 3977753564
Ref: S0215753564
Ref: 3978753591
Ref: 3979753625
Ref: 3980753660
Ref: 3981753709
Ref: 3982753756
Ref: S0216753756
Ref: 3983753760
Ref: 3984753796
Ref: 3985753824
Ref: 3986753863
Ref: 3987753907
Ref: 3988753930
Ref: 3989754242
Ref: 3990754475
Ref: 3991755535
Ref: 3992755536
Ref: 3993755536
Ref: 3994755536
Ref: 3995755591
Ref: 3996756342
Ref: 3997756718
Ref: 3998756967
Ref: 3999757048
Ref: 4000757978
Ref: 4001758188
Ref: 4002758267
Ref: 4003758399
Ref: 4004758615
Ref: 4005758733
Ref: 4006759146
Ref: 4007759602
Ref: 4008759602
Ref: 4009759907
Node: 9.5762540
Ref: 4010762665
Ref: 4011762665
Ref: 4012763174
Ref: 4013763675
Ref: 4014763919
Ref: 4015764861
Ref: 4016764861
Ref: 4017764861
Ref: 4018765853
Ref: S0217765853
Ref: 4019766276
Ref: 4020766276
Ref: 4021767463
Node: 9.5.1767917
Ref: 4022768080
Ref: 4023768080
Ref: 4024768080
Ref: 4025769243
Ref: 4026769243
Ref: 4027769566
Ref: 4028769745
Ref: 4029770412
Ref: 4030770737
Ref: 4031770737
Ref: 4032771061
Ref: 4033771061
Ref: 4034771431
Ref: 4035771532
Ref: 4036771533
Ref: 4037772023
Node: 9.5.2774338
Ref: 4038774714
Ref: S0218774714
Ref: 4039774728
Ref: 4040774764
Ref: 4041774786
Ref: 4042774816
Ref: 4043774852
Ref: 4044774899
Ref: S0219774899
Ref: 4045774925
Ref: 4046774939
Ref: 4047774953
Ref: 4048774985
Ref: 4049775035
Ref: 4050775068
Ref: S0220775068
Ref: 4051775072
Ref: 4052775102
Ref: S0221775102
Ref: 4053775120
Ref: 4054775141
Ref: 4055775165
Ref: 4056775197
Ref: 4057775236
Ref: 4058775285
Ref: 4059775328
Ref: S0222775328
Ref: 4060775335
Ref: 4061775363
Ref: 4062775408
Ref: S0223775408
Ref: 4063775418
Ref: 4064775461
Ref: S0224775461
Ref: 4065775470
Ref: 4066775493
Ref: 4067776090
Ref: 4068776216
Ref: 4069777477
Ref: 4070778004
Ref: 4071778469
Ref: 4072778562
Ref: 4073778696
Ref: 4074778810
Ref: 4075779257
Ref: 4076779614
Ref: 4077779614
Ref: 4078779614
Ref: 4079780072
Ref: 4080780073
Ref: 4081780352
Ref: 4082780490
Ref: 4083781025
Ref: 4084781225
Ref: 4085781226
Ref: 4086781226
Ref: 4087781852
Ref: 4088782236
Node: 9.5.3784480
Ref: 4089784593
Ref: 4090784664
Ref: 4091784665
Ref: 4092784948
Ref: S0225784948
Ref: 4093784959
Ref: 4094784965
Ref: 4095785518
Ref: 4096785518
Ref: 4097785518
Ref: 4098785518
Ref: 4099785661
Ref: 4100785661
Ref: 4101785948
Ref: 4102785948
Ref: 4103786110
Ref: 4104786289
Ref: 4105786438
Ref: 4106786634
Ref: 4107787643
Ref: 4108787784
Ref: 4109787784
Ref: 4110788374
Ref: 4111788665
Ref: 4112788769
Ref: 4113788770
Ref: 4114789277
Ref: 4115789659
Ref: 4116790444
Node: 9.5.4793677
Ref: 4117793951
Ref: 4118794096
Ref: 4119794097
Ref: 4120794166
Ref: S0226794166
Ref: 4121794198
Ref: 4122794271
Ref: 4123794666
Ref: 4124795068
Ref: 4125796626
Ref: 4126797323
Ref: 4127797788
Ref: 4128798060
Ref: 4129799217
Ref: 4130800146
Node: 9.6800496
Ref: 4131800647
Ref: 4132801120
Ref: 4133801186
Ref: S0227801186
Ref: 4134801190
Ref: 4135801215
Ref: 4136801275
Ref: S0228801275
Ref: 4137801298
Ref: 4138801342
Ref: S0229801342
Ref: 4139801359
Ref: 4140801423
Ref: 4141801528
Ref: 4142801669
Ref: 4143801669
Ref: 4144801669
Ref: 4145802593
Ref: 4146802635
Ref: 4147802673
Ref: 4148802732
Ref: 4149802786
Ref: 4150802840
Ref: 4151802908
Ref: 4152802947
Ref: 4153803004
Ref: 4154803062
Ref: 4155803118
Ref: 4156803181
Ref: 4157803431
Ref: 4158804138
Ref: 4159804303
Ref: 4160804383
Ref: 4161804545
Ref: 4162804794
Ref: 4163804934
Ref: 4164805134
Ref: 4165808617
Ref: 4166808617
Ref: 4167809193
Ref: 4168809193
Node: 9.6.1809678
Ref: 4169809955
Ref: 4170810053
Ref: 4171810099
Ref: 4172810158
Ref: 4173810261
Ref: 4174810357
Ref: 4175810523
Ref: 4176810598
Ref: 4177811122
Ref: 4178811251
Ref: 4179811264
Ref: 4180811272
Ref: 4181811281
Ref: 4182811292
Ref: 4183811309
Ref: 4184811322
Ref: 4185811332
Ref: 4186811364
Ref: 4187811476
Ref: 4188811538
Ref: 4189811600
Ref: 4190811662
Ref: 4191811739
Ref: 4192811910
Ref: 4193812082
Ref: 4194812252
Ref: 4195812423
Ref: 4196812596
Ref: 4197812698
Ref: 4198812802
Ref: 4199813071
Ref: 4200813360
Ref: 4201813917
Ref: 4202814312
Ref: 4203814829
Ref: 4204815397
Ref: 4205815827
Ref: 4206816017
Ref: 4207816141
Ref: 4208816277
Node: 9.7829995
Ref: 4209830395
Ref: S0230830395
Ref: 4210830408
Ref: 4211830434
Ref: 4212830460
Ref: 4213830492
Node: 9.7.1830875
Ref: 4214831198
Ref: 4215831265
Ref: S0231831265
Ref: 4216831293
Ref: 4217831310
Ref: 4218831348
Ref: 4219831365
Ref: 4220831406
Ref: 4221831463
Ref: S0232831463
Ref: 4222831473
Ref: 4223831512
Ref: S0233831512
Ref: 4224831525
Ref: 4225831553
Ref: 4226831580
Ref: 4227831628
Ref: S0234831628
Ref: 4228831640
Ref: 4229831658
Ref: 4230831707
Ref: S0235831707
Ref: 4231831719
Ref: 4232831736
Ref: 4233831789
Ref: S0236831789
Ref: 4234832028
Ref: 4235832485
Ref: 4236832662
Ref: 4237833307
Ref: 4238833956
Ref: 4239835110
Node: 9.7.2836018
Ref: 4240836426
Ref: 4241836493
Ref: S0237836493
Ref: 4242836520
Ref: 4243836561
Ref: 4244836630
Ref: S0238836630
Ref: 4245836642
Ref: 4246836667
Ref: 4247836726
Ref: S0239836726
Ref: 4248836738
Ref: 4249836765
Ref: 4250837217
Node: 9.7.3838691
Ref: 4251839193
Ref: S0240839193
Ref: 4252839220
Ref: 4253839263
Ref: 4254839355
Node: 9.7.4840146
Ref: 4255840493
Ref: S0241840493
Ref: 4256840520
Ref: 4257840569
Ref: 4258840633
Ref: S0242840633
Ref: 4259840637
Ref: 4260840660
Ref: 4261840720
Ref: S0243840720
Ref: 4262840724
Ref: 4263840751
Ref: 4264840789
Ref: S0244840789
Ref: 4265840793
Ref: 4266840869
Ref: 4267840869
Ref: 4268841746
Ref: 4269842802
Ref: 4270842802
Ref: 4271842802
Ref: 4272843232
Ref: 4273843233
Ref: 4274843233
Ref: 4275843233
Ref: 4276843233
Node: 9.8843635
Ref: 4277844160
Ref: S0245844160
Ref: 4278844176
Ref: 4279844189
Ref: 4280844248
Ref: 4281844393
Ref: 4282844491
Ref: 4283844491
Ref: 4284844492
Ref: 4285844492
Ref: 4286844662
Ref: 4287844662
Ref: 4288845088
Ref: 4289845786
Ref: 4290846772
Ref: 4291847285
Ref: 4292847568
Ref: 4293847891
Ref: 4294847891
Ref: 4295847891
Ref: 4296847891
Node: 9.9848480
Ref: 4297848781
Ref: 4298848796
Ref: 4299848893
Ref: 4300848894
Ref: 4301849059
Ref: 4302849074
Ref: 4303849578
Ref: 4304849593
Node: 9.10850634
Ref: 4305850797
Ref: 4306850797
Ref: 4307851488
Ref: 4308851960
Ref: 4309853502
Ref: 4310853764
Node: 9.11854277
Node: 10857800
Ref: 4311858191
Ref: 4312858191
Ref: 4313858191
Ref: 4314858496
Node: 10.1858984
Ref: 4315859096
Ref: 4316859096
Ref: 4317859096
Ref: 4318859411
Ref: 4319859715
Ref: 4320859962
Node: 10.1.1860509
Ref: 4321860866
Ref: 4322861058
Ref: S0246861058
Ref: 4323861064
Ref: 4324861106
Ref: S0247861106
Ref: 4325861120
Ref: 4326861135
Ref: 4327861157
Ref: 4328861172
Ref: 4329861200
Ref: S0248861200
Ref: 4330861215
Ref: 4331861249
Ref: 4332861286
Ref: 4333861352
Ref: S0249861352
Ref: 4334861367
Ref: 4335861394
Ref: 4336861424
Ref: 4337861448
Ref: 4338861511
Ref: S0250861511
Ref: 4339861524
Ref: 4340861561
Ref: 4341861598
Ref: 4342861655
Ref: S0251861655
Ref: 4343861659
Ref: 4344861678
Ref: 4345861715
Ref: S0252861715
Ref: 4346861719
Ref: 4347861906
Ref: 4348861906
Ref: 4349861906
Ref: 4350861906
Ref: 4351861906
Ref: 4352862213
Ref: 4353862529
Ref: 4354862529
Ref: 4355862753
Ref: 4356863045
Ref: 4357863274
Ref: 4358863411
Ref: 4359863481
Ref: 4360863481
Ref: 4361863481
Ref: 4362863481
Ref: 4363863744
Ref: 4364863865
Ref: 4365864053
Ref: 4366867919
Ref: 4367867919
Node: 10.1.2871042
Ref: 4368871366
Ref: S0253871366
Ref: 4369871372
Ref: 4370871406
Ref: S0254871406
Ref: 4371871410
Ref: 4372871425
Ref: 4373871457
Ref: S0255871457
Ref: 4374871461
Ref: 4375871484
Ref: 4376871538
Ref: S0256871538
Ref: 4377871579
Ref: 4378871606
Ref: 4379871647
Ref: S0257871647
Ref: 4380871680
Ref: 4381871707
Ref: 4382871766
Ref: 4383872130
Ref: 4384872130
Ref: 4385872190
Ref: 4386872191
Node: 10.1.3877480
Ref: 4387878010
Ref: S0258878010
Ref: 4388878014
Ref: 4389878038
Ref: 4390878058
Ref: 4391878081
Ref: 4392878131
Ref: S0259878131
Ref: 4393878145
Ref: 4394878175
Ref: 4395878224
Ref: 4396878274
Ref: S0260878274
Ref: 4397878300
Ref: 4398878344
Ref: 4399878391
Ref: S0261878391
Ref: 4400878414
Ref: 4401878458
Ref: 4402878510
Ref: S0262878510
Ref: 4403878538
Ref: 4404878582
Ref: 4405878620
Ref: S0263878620
Ref: 4406878635
Ref: 4407878653
Ref: 4408878715
Ref: 4409878808
Ref: 4410879073
Ref: 4411879955
Ref: 4412880200
Node: 10.1.4882005
Ref: 4413882148
Ref: 4414882148
Ref: 4415883816
Ref: 4416883999
Ref: 4417885646
Ref: 4418886063
Node: 10.1.5886388
Ref: 4419886679
Ref: 4420886679
Ref: 4421886734
Ref: 4422888597
Ref: 4423888597
Ref: 4424888597
Ref: 4425888597
Ref: 4426889014
Ref: 4427889014
Node: 10.1.6890126
Ref: 4428890549
Ref: 4429890549
Ref: 4430890549
Ref: 4431890549
Ref: 4432891201
Ref: 4433891201
Ref: 4434891201
Ref: 4435891201
Ref: 4436891673
Ref: 4437891673
Ref: 4438891896
Ref: 4439891896
Ref: 4440892095
Node: 10.2892450
Ref: 4441892556
Ref: 4442892556
Ref: 4443892556
Ref: 4444892779
Ref: 4445892779
Ref: 4446892984
Ref: 4447893469
Ref: 4448893470
Ref: 4449893470
Ref: 4450893996
Ref: 4451894185
Ref: 4452894553
Ref: 4453894554
Ref: 4454895440
Ref: 4455897122
Ref: 4456897243
Ref: 4457897806
Ref: 4458897806
Ref: 4459898070
Ref: 4460898477
Node: 10.2.1900578
Ref: 4461900683
Ref: 4462900886
Ref: 4463900887
Ref: 4464900914
Ref: 4465900925
Ref: 4466900930
Ref: 4467901075
Ref: 4468901076
Ref: 4469901105
Ref: 4470901167
Ref: 4471902048
Ref: 4472902589
Ref: 4473902733
Ref: 4474902733
Ref: 4475903119
Ref: 4476903278
Ref: 4477903448
Ref: 4478905777
Ref: 4479906722
Ref: 4480906723
Ref: 4481906742
Ref: 4482906754
Ref: 4483906759
Ref: 4484906853
Ref: 4485908253
Ref: 4486908351
Ref: 4487908351
Ref: 4488908783
Ref: 4489910448
Ref: 4490910449
Ref: 4491910472
Ref: 4492910492
Ref: 4493910517
Ref: 4494910518
Ref: 4495910545
Ref: 4496910565
Ref: 4497910590
Ref: 4498910591
Ref: 4499910620
Ref: 4500910723
Ref: 4501910728
Ref: 4502910829
Ref: 4503910984
Ref: 4504911700
Ref: 4505911700
Node: 11911898
Ref: 4506912123
Ref: 4507912124
Ref: 4508912124
Ref: 4509912124
Ref: 4510912124
Ref: 4511912124
Ref: 4512912263
Ref: 4513912405
Node: 11.1913182
Ref: 4514913298
Ref: 4515913429
Ref: S0264913429
Ref: 4516913433
Ref: 4517913480
Ref: 4518914031
Ref: 4519914031
Ref: 4520914031
Ref: 4521914031
Ref: 4522914031
Ref: 4523914295
Ref: 4524914357
Ref: 4525914357
Ref: 4526914357
Ref: 4527914461
Node: 11.2914729
Ref: 4528915006
Ref: S0265915006
Ref: 4529915021
Ref: 4530915072
Ref: 4531915100
Ref: 4532915145
Ref: S0266915145
Ref: 4533915163
Ref: 4534915196
Ref: 4535915216
Ref: 4536915253
Ref: 4537915314
Ref: S0267915314
Ref: 4538915318
Ref: 4539915363
Ref: S0268915363
Ref: 4540915378
Ref: 4541915515
Ref: 4542916146
Ref: 4543916489
Node: 11.3917089
Ref: 4544917355
Ref: S0269917355
Ref: 4545917396
Ref: 4546917414
Ref: 4547917455
Ref: S0270917455
Ref: 4548917476
Ref: 4549917494
Ref: 4550918149
Ref: 4551918614
Ref: 4552918713
Ref: 4553919067
Node: 11.4919761
Ref: 4554920030
Ref: 4555920104
Ref: 4556920310
Ref: 4557920310
Ref: 4558920555
Ref: 4559920693
Ref: 4560921302
Ref: 4561921470
Ref: 4562921470
Ref: 4563921470
Node: 11.4.1922153
Ref: 4564922385
Ref: 4565922495
Ref: 4566922584
Ref: 4567922640
Ref: 4568922707
Ref: 4569922784
Ref: 4570922885
Ref: 4571923008
Ref: 4572923076
Ref: 4573923154
Ref: 4574923300
Ref: 4575923378
Ref: 4576923450
Ref: 4577923571
Ref: 4578923708
Ref: 4579923873
Ref: 4580924053
Ref: 4581924140
Ref: 4582924279
Ref: 4583925470
Ref: 4584925485
Ref: 4585926501
Ref: 4586927849
Node: 11.4.2929519
Ref: 4587930082
Ref: 4588930082
Ref: 4589930376
Ref: 4590930377
Ref: 4591930403
Ref: 4592930441
Ref: 4593930643
Ref: 4594930644
Ref: 4595930668
Ref: 4596930701
Ref: 4597930702
Ref: 4598930744
Ref: 4599930766
Ref: 4600930800
Ref: 4601930822
Ref: 4602930841
Ref: 4603930846
Ref: 4604933697
Ref: 4605933770
Ref: 4606933828
Ref: 4607933874
Ref: 4608934546
Ref: 4609934546
Node: 11.4.3936916
Node: 11.5939447
Ref: 4610939586
Ref: 4611939832
Ref: 4612939832
Ref: 4613939832
Ref: 4614939832
Ref: 4615939832
Ref: 4616940033
Ref: 4617940241
Ref: 4618940242
Ref: 4619940251
Ref: 4620940284
Ref: 4621940285
Ref: 4622940296
Ref: 4623940314
Ref: 4624940319
Ref: 4625940319
Ref: 4626940319
Ref: 4627941423
Ref: 4628942006
Ref: 4629942127
Ref: 4630942398
Ref: 4631942687
Ref: 4632942813
Ref: 4633943379
Ref: 4634943587
Ref: 4635943848
Ref: 4636944424
Ref: 4637944708
Ref: 4638944828
Ref: 4639944923
Ref: 4640945214
Ref: 4641945667
Ref: 4642945667
Ref: 4643946040
Ref: 4644946499
Ref: 4645946967
Ref: 4646947466
Ref: 4647947466
Node: 11.6948183
Ref: 4648948311
Ref: 4649948311
Ref: 4650948311
Ref: 4651948311
Ref: 4652948311
Ref: 4653948311
Ref: 4654948510
Ref: 4655949381
Ref: 4656949381
Ref: 4657950172
Ref: 4658950906
Ref: 4659951082
Ref: 4660951083
Ref: 4661951083
Node: 12951573
Ref: 4662951675
Ref: 4663951765
Ref: 4664951990
Ref: 4665951991
Ref: 4666951991
Node: 12.1953076
Ref: 4667953601
Ref: S0271953601
Ref: 4668953605
Ref: 4669953639
Ref: 4670953713
Ref: S0272953713
Ref: 4671953728
Ref: 4672953749
Ref: 4673953788
Ref: 4674953846
Ref: S0273953846
Ref: 4675953861
Ref: 4676953882
Ref: 4677953932
Ref: S0274953932
Ref: 4678953946
Ref: 4679953991
Ref: 4680954047
Ref: S0275954047
Ref: 4681954063
Ref: 4682954100
Ref: 4683954135
Ref: 4684954176
Ref: 4685954541
Ref: 4686954541
Ref: 4687954541
Ref: 4688954541
Ref: 4689954668
Ref: 4690955116
Node: 12.2957565
Ref: 4691957678
Ref: 4692957884
Node: 12.3959811
Ref: 4693959938
Ref: 4694960080
Ref: S0276960080
Ref: 4695960103
Ref: 4696960167
Ref: 4697960173
Ref: 4698960212
Ref: 4699960246
Ref: 4700960288
Ref: 4701960354
Ref: 4702960360
Ref: 4703960399
Ref: 4704960433
Ref: 4705960474
Ref: 4706960532
Ref: 4707960538
Ref: 4708960577
Ref: 4709960627
Ref: S0277960627
Ref: 4710960641
Ref: 4711960664
Ref: 4712960713
Ref: S0278960713
Ref: 4713960752
Ref: 4714960770
Ref: 4715960851
Ref: S0279960851
Ref: 4716960855
Ref: 4717960878
Ref: 4718960904
Ref: 4719960917
Ref: 4720960924
Ref: 4721960964
Ref: 4722960972
Ref: 4723960977
Ref: 4724961216
Ref: 4725961216
Ref: 4726961216
Ref: 4727963619
Ref: 4728963620
Ref: 4729963620
Ref: 4730963620
Ref: 4731963620
Ref: 4732963620
Ref: 4733963620
Ref: 4734963620
Ref: 4735965408
Ref: 4736966685
Ref: 4737967068
Ref: 4738967133
Node: 12.4968576
Ref: 4739968689
Ref: 4740968689
Ref: 4741968848
Ref: S0280968848
Ref: 4742968862
Ref: 4743968889
Ref: 4744968895
Ref: 4745968911
Ref: 4746968934
Ref: 4747968968
Ref: 4748969001
Ref: 4749969028
Ref: 4750969033
Ref: 4751969055
Ref: 4752969095
Ref: 4753969170
Ref: 4754969280
Ref: 4755969939
Ref: 4756970674
Ref: 4757970778
Ref: 4758971385
Ref: 4759971697
Ref: 4760971843
Ref: 4761972221
Ref: 4762972221
Ref: 4763972221
Ref: 4764972574
Ref: 4765972574
Ref: 4766972850
Node: 12.5973250
Ref: 4767973554
Ref: S0281973554
Ref: 4768973570
Ref: 4769973614
Ref: 4770973693
Ref: S0282973693
Ref: 4771973712
Ref: 4772973732
Ref: 4773973754
Ref: 4774973797
Ref: 4775973866
Ref: S0283973866
Ref: 4776973885
Ref: 4777973905
Ref: 4778973969
Ref: S0284973969
Ref: 4779973985
Ref: 4780974027
Ref: 4781974069
Ref: 4782974112
Ref: 4783974161
Ref: 4784974203
Ref: 4785974247
Ref: 4786974297
Ref: 4787974346
Ref: 4788974386
Ref: 4789974427
Ref: 4790974508
Ref: 4791974508
Ref: 4792974508
Ref: 4793974508
Ref: 4794974664
Ref: 4795974664
Ref: 4796974664
Ref: 4797974664
Ref: 4798974782
Ref: 4799974782
Node: 12.5.1977728
Ref: 4800978460
Ref: S0285978460
Ref: 4801978548
Ref: S0286978548
Ref: 4802978603
Ref: 4803978622
Ref: 4804978845
Ref: 4805978845
Ref: 4806981826
Ref: 4807984581
Ref: 4808984596
Ref: 4809985916
Node: 12.5.2986565
Ref: 4810987039
Ref: S0287987039
Ref: 4811987094
Ref: S0288987094
Ref: 4812987146
Ref: S0289987146
Ref: 4813987198
Ref: S0290987198
Ref: 4814987259
Ref: S0291987259
Ref: 4815987318
Ref: S0292987318
Node: 12.5.3987759
Ref: 4816988055
Ref: S0293988055
Ref: 4817988059
Ref: 4818988773
Ref: 4819988871
Node: 12.5.4989694
Ref: 4820989995
Ref: S0294989995
Ref: 4821989999
Ref: 4822990185
Ref: 4823990671
Node: 12.5.5991302
Ref: 4824991605
Ref: S0295991605
Ref: 4825991609
Node: 12.6992532
Ref: 4826992653
Ref: 4827992653
Ref: 4828992809
Ref: S0296992809
Ref: 4829992813
Ref: 4830992869
Ref: 4831992958
Ref: S0297992958
Ref: 4832992978
Ref: 4833993007
Ref: 4834993041
Ref: 4835993114
Ref: S0298993114
Ref: 4836993134
Ref: 4837993172
Ref: 4838993206
Ref: 4839993257
Ref: S0299993257
Ref: 4840993261
Ref: 4841993307
Ref: S0300993307
Ref: 4842993311
Ref: 4843993509
Ref: 4844993597
Ref: 4845993824
Ref: 4846993894
Ref: 4847994632
Ref: 4848995541
Ref: 4849997781
Node: 12.71001666
Ref: 48501001781
Ref: 48511001781
Ref: 48521002117
Ref: S03011002117
Ref: 48531002144
Ref: 48541002187
Ref: 48551002193
Ref: 48561002240
Ref: 48571002299
Ref: S03021002299
Ref: 48581002340
Ref: 48591002371
Ref: 48601002401
Ref: 48611002491
Ref: S03031002491
Ref: 48621002505
Ref: 48631002559
Ref: 48641002740
Ref: 48651005234
Ref: 48661005630
Node: 12.81008047
Node: 131010550
Node: 13.11011354
Ref: 48671011506
Ref: 48681012313
Ref: 48691012313
Ref: 48701012313
Ref: 48711012788
Ref: 48721013200
Ref: S03041013200
Ref: S03051013200
Ref: 48731013204
Ref: 48741013246
Ref: 48751013293
Ref: 48761013335
Ref: 48771013363
Ref: S03061013363
Ref: 48781013367
Ref: 48791013393
Ref: 48801013405
Ref: 48811013452
Ref: 48821013576
Ref: 48831015135
Ref: 48841015135
Ref: 48851015644
Ref: 48861015882
Ref: 48871015882
Ref: 48881015882
Ref: 48891016154
Ref: 48901016155
Ref: 48911016155
Ref: 48921016155
Ref: 48931016638
Ref: 48941016639
Ref: 48951016639
Ref: 48961016639
Ref: 48971018905
Ref: 48981020666
Ref: 48991020903
Ref: 49001021028
Ref: 49011021478
Ref: 49021021711
Ref: 49031021711
Ref: 49041021712
Ref: 49051021712
Ref: 49061021712
Ref: 49071021766
Ref: 49081022118
Ref: 49091022484
Node: 13.1.11024930
Ref: 49101025324
Ref: 49111025396
Ref: S03071025396
Ref: 49121025414
Ref: 49131025430
Ref: 49141025468
Ref: 49151025484
Ref: 49161025526
Ref: S03081025526
Ref: 49171025538
Ref: 49181025584
Ref: S03091025584
Ref: 49191025588
Ref: 49201025596
Ref: 49211025609
Ref: 49221025784
Ref: 49231026104
Ref: 49241026315
Ref: 49251026315
Ref: 49261026510
Ref: 49271029508
Ref: 49281029677
Ref: 49291029717
Ref: 49301030257
Ref: 49311031473
Ref: 49321031815
Ref: 49331031878
Ref: 49341031878
Ref: 49351032065
Ref: 49361032250
Ref: 49371033007
Node: 13.21034540
Ref: 49381035426
Ref: 49391035427
Ref: 49401035427
Ref: 49411035943
Node: 13.31037043
Ref: 49421037212
Ref: 49431037212
Ref: 49441037361
Ref: 49451037515
Ref: S03101037515
Ref: 49461037535
Ref: 49471037546
Ref: 49481037571
Ref: 49491037598
Ref: 49501037609
Ref: 49511037634
Ref: 49521037871
Ref: 49531038039
Ref: 49541038429
Ref: 49551038429
Ref: 49561038631
Ref: 49571038673
Ref: 49581039038
Ref: 49591039091
Ref: 49601039091
Ref: 49611039091
Ref: 49621039091
Ref: 49631039091
Ref: 49641039091
Ref: 49651039091
Ref: 49661039091
Ref: 49671039091
Ref: 49681039091
Ref: 49691039091
Ref: 49701039091
Ref: 49711039091
Ref: 49721039091
Ref: 49731039091
Ref: 49741039242
Ref: 49751039242
Ref: 49761039312
Ref: 49771039533
Ref: 49781040180
Ref: 49791040195
Ref: 49801040761
Ref: 49811040776
Ref: 49821040897
Ref: 49831040897
Ref: 49841040952
Ref: 49851041303
Ref: 49861042475
Ref: 49871042490
Ref: 49881042976
Ref: 49891042991
Ref: 49901043319
Ref: 49911043334
Ref: 49921043674
Ref: 49931043689
Ref: 49941043912
Ref: 49951043912
Ref: 49961043965
Ref: 49971044067
Ref: 49981044360
Ref: 49991045603
Ref: 50001046754
Ref: 50011046769
Ref: 50021046928
Ref: 50031046943
Ref: 50041047129
Ref: 50051047129
Ref: 50061047252
Ref: 50071047575
Ref: 50081047590
Ref: 50091048196
Ref: 50101048197
Ref: 50111048632
Ref: 50121048632
Ref: 50131049281
Ref: 50141051115
Ref: 50151051130
Ref: 50161052303
Ref: 50171052303
Ref: 50181052710
Ref: 50191052710
Ref: 50201052710
Ref: 50211053046
Ref: 50221053061
Ref: 50231053195
Ref: 50241053210
Ref: 50251053435
Ref: 50261053435
Ref: 50271053489
Ref: 50281054270
Ref: 50291054285
Ref: 50301055104
Ref: 50311055119
Ref: 50321056219
Ref: 50331056234
Ref: 50341056234
Ref: 50351056234
Ref: 50361056540
Ref: 50371056540
Node: 13.41059810
Ref: 50381060137
Ref: S03111060137
Ref: 50391060169
Ref: 50401060184
Ref: 50411060236
Ref: S03121060236
Ref: 50421060240
Ref: 50431060309
Ref: 50441061070
Ref: 50451061153
Ref: 50461061295
Ref: 50471061295
Ref: 50481061572
Node: 13.51062554
Ref: 50491062665
Ref: 50501062665
Ref: 50511062665
Ref: 50521062665
Ref: 50531062665
Ref: 50541062665
Ref: 50551062665
Ref: 50561062665
Ref: 50571062665
Node: 13.5.11063032
Ref: 50581063361
Ref: 50591063440
Ref: S03131063440
Ref: 50601063472
Ref: 50611063506
Ref: 50621063532
Ref: 50631063597
Ref: S03141063597
Ref: 50641063621
Ref: 50651063635
Ref: 50661063650
Ref: 50671063663
Ref: 50681063689
Ref: S03151063689
Ref: 50691063701
Ref: 50701063729
Ref: S03161063729
Ref: 50711063741
Ref: 50721063775
Ref: S03171063775
Ref: 50731063787
Ref: 50741063857
Ref: 50751063857
Ref: 50761063857
Ref: 50771063857
Ref: 50781068005
Node: 13.5.21071561
Ref: 50791071752
Ref: 50801071866
Ref: 50811071881
Ref: 50821072284
Ref: 50831072299
Ref: 50841072902
Ref: 50851072917
Ref: 50861073483
Ref: 50871073483
Node: 13.5.31073915
Ref: 50881074156
Ref: 50891074243
Ref: 50901074244
Ref: 50911074244
Ref: 50921074477
Ref: 50931074478
Ref: 50941074478
Ref: 50951074690
Ref: 50961074705
Ref: 50971074820
Ref: 50981074821
Ref: 50991075003
Ref: 51001075003
Ref: 51011075233
Ref: 51021075403
Node: 13.61075848
Ref: 51031075983
Ref: 51041075983
Node: 13.71077457
Ref: 51051077835
Ref: 51061077903
Ref: 51071077955
Ref: 51081078067
Ref: 51091078131
Ref: 51101078197
Ref: 51111078265
Ref: 51121078336
Ref: 51131078398
Ref: 51141078469
Ref: 51151078537
Ref: 51161078609
Ref: 51171078736
Ref: 51181078774
Ref: 51191078819
Ref: 51201078878
Ref: 51211078952
Ref: 51221079025
Ref: 51231079717
Ref: 51241079731
Ref: 51251079749
Ref: 51261079770
Ref: 51271079921
Ref: 51281079991
Ref: 51291080102
Ref: 51301080206
Ref: 51311083194
Node: 13.7.11083948
Ref: 51321084206
Ref: 51331084301
Ref: 51341084368
Ref: 51351084446
Ref: 51361084557
Ref: 51371084717
Ref: 51381085407
Ref: 51391085467
Ref: 51401085576
Ref: 51411085871
Ref: 51421085872
Ref: 51431086607
Node: 13.7.21086671
Ref: 51441086961
Ref: 51451087204
Ref: 51461087312
Ref: 51471087709
Node: 13.81088004
Ref: 51481088135
Ref: 51491088320
Ref: S03181088320
Ref: 51501088324
Ref: 51511089021
Ref: 51521089374
Ref: 51531089374
Node: 13.91090878
Ref: 51541091016
Ref: 51551091016
Ref: 51561091016
Ref: 51571091016
Ref: 51581091016
Ref: 51591091351
Ref: 51601092273
Ref: 51611092273
Ref: 51621093629
Ref: 51631093828
Ref: 51641093828
Node: 13.9.11094272
Ref: 51651094730
Ref: 51661094935
Ref: 51671094935
Ref: 51681095233
Ref: 51691096224
Ref: 51701096470
Ref: 51711096663
Ref: 51721096663
Ref: 51731096922
Ref: 51741096923
Ref: 51751097718
Ref: 51761098386
Node: 13.9.21099145
Ref: 51771099590
Ref: 51781099605
Ref: 51791099828
Node: 13.101101431
Ref: 51801101900
Ref: 51811101915
Ref: 51821102207
Node: 13.111102692
Ref: 51831102818
Ref: 51841102818
Ref: 51851102818
Ref: 51861102818
Ref: 51871103735
Ref: 51881103843
Ref: 51891104027
Ref: 51901104289
Ref: 51911104551
Ref: 51921104751
Ref: 51931104751
Ref: 51941104824
Ref: 51951104824
Ref: 51961104824
Ref: 51971105024
Ref: 51981105039
Ref: 51991105171
Ref: 52001105186
Ref: 52011105450
Ref: 52021105450
Ref: 52031105450
Ref: 52041105450
Ref: 52051105650
Ref: 52061105650
Ref: 52071105650
Ref: 52081105650
Ref: 52091105953
Ref: 52101106139
Ref: 52111106140
Ref: 52121106140
Ref: 52131106634
Ref: 52141107215
Ref: 52151107449
Ref: 52161109774
Ref: 52171109774
Ref: 52181109775
Node: 13.11.11115818
Ref: 52191116238
Ref: 52201116253
Ref: 52211116571
Ref: 52221116586
Node: 13.11.21117129
Ref: 52231117292
Ref: 52241117292
Ref: 52251117292
Ref: 52261117292
Ref: 52271117292
Ref: 52281117677
Ref: 52291118117
Ref: 52301119273
Ref: 52311119273
Ref: 52321119273
Ref: 52331119273
Ref: 52341119511
Ref: 52351119657
Ref: 52361119657
Ref: 52371119746
Ref: 52381119746
Ref: 52391120145
Ref: 52401120145
Ref: 52411120334
Ref: 52421120477
Ref: 52431120478
Ref: 52441120658
Ref: 52451120658
Node: 13.11.31121657
Ref: 52461122110
Ref: 52471122111
Ref: 52481122133
Ref: 52491122192
Ref: S03191122192
Ref: 52501122210
Ref: 52511123147
Ref: 52521123147
Ref: 52531123147
Ref: 52541124030
Ref: 52551124030
Node: 13.11.41126069
Ref: 52561126598
Ref: 52571126702
Ref: 52581126811
Ref: 52591126878
Ref: 52601126996
Ref: 52611127213
Ref: 52621127353
Ref: 52631127511
Ref: 52641127923
Ref: 52651128153
Ref: 52661128327
Ref: 52671128613
Ref: 52681128907
Ref: 52691129177
Ref: 52701129177
Ref: 52711129177
Ref: 52721129177
Ref: 52731129177
Ref: 52741129952
Ref: 52751131187
Ref: 52761131187
Ref: 52771131632
Ref: 52781132242
Ref: 52791132242
Ref: 52801132353
Ref: 52811132353
Ref: 52821132415
Ref: 52831132819
Ref: 52841132819
Ref: 52851132819
Ref: 52861132952
Node: 13.11.51135105
Ref: 52871135478
Ref: 52881135969
Ref: 52891136043
Node: 13.11.61136317
Node: 13.121142692
Ref: 52901143249
Ref: 52911143250
Ref: 52921143263
Ref: 52931143276
Ref: 52941143313
Ref: S03201143313
Ref: 52951143330
Ref: 52961143374
Ref: 52971143388
Ref: 52981143467
Ref: S03211143467
Ref: 52991143471
Ref: 53001143479
Ref: 53011143542
Ref: 53021143906
Ref: 53031143906
Ref: 53041146378
Ref: 53051146379
Ref: 53061146396
Ref: 53071146418
Ref: 53081146923
Ref: 53091146923
Node: 13.12.11147802
Ref: 53101148143
Ref: 53111148143
Ref: 53121148430
Ref: 53131148430
Ref: 53141148659
Ref: 53151148659
Ref: 53161151083
Ref: 53171151083
Ref: 53181151326
Ref: 53191151326
Ref: 53201151654
Ref: 53211151654
Ref: 53221152148
Ref: 53231152148
Ref: 53241152268
Ref: 53251152268
Ref: 53261152437
Ref: 53271152437
Ref: 53281152592
Ref: 53291152592
Ref: 53301153837
Node: 13.131154260
Ref: 53311154364
Ref: 53321154364
Node: 13.13.11154794
Ref: 53331155640
Ref: 53341155697
Ref: 53351155718
Ref: 53361155854
Ref: 53371155914
Ref: 53381155986
Ref: 53391156096
Ref: 53401156220
Ref: 53411156399
Node: 13.13.21157577
Ref: 53421157865
Ref: 53431157865
Ref: 53441158036
Ref: 53451158051
Ref: 53461158753
Ref: 53471158753
Ref: 53481159127
Ref: 53491159743
Ref: 53501159758
Ref: 53511160071
Ref: 53521160086
Ref: 53531163148
Ref: 53541163163
Ref: 53551163603
Ref: 53561163618
Ref: 53571164207
Ref: 53581164222
Ref: 53591164596
Ref: 53601164611
Ref: 53611166567
Ref: 53621166582
Ref: 53631167335
Ref: 53641167350
Ref: 53651168184
Ref: 53661168184
Ref: 53671168431
Ref: 53681169184
Ref: 53691169434
Ref: 53701169612
Ref: 53711169612
Ref: 53721169612
Ref: 53731169612
Ref: 53741169612
Ref: 53751169612
Ref: 53761169612
Ref: 53771169612
Ref: 53781170155
Ref: 53791170156
Ref: 53801170156
Ref: 53811170156
Ref: 53821170156
Ref: 53831170156
Ref: 53841170156
Ref: 53851170156
Ref: 53861170156
Ref: 53871170156
Ref: 53881170156
Ref: 53891170156
Ref: 53901170156
Ref: 53911170156
Ref: 53921170156
Ref: 53931170156
Ref: 53941170725
Ref: 53951172147
Ref: 53961173136
Ref: 53971173136
Ref: 53981173993
Node: 13.141176879
Ref: 53991177355
Ref: 54001177355
Ref: 54011177676
Ref: 54021178004
Ref: 54031178208
Ref: 54041178493
Ref: 54051178632
Ref: 54061178783
Ref: 54071179540
Ref: 54081179647
Ref: 54091180225
Ref: 54101180321
Ref: 54111180730
Ref: 54121180918
Ref: 54131181165
Ref: 54141181467
Ref: 54151181467
Ref: 54161181823
Ref: 54171181823
Ref: 54181182225
Ref: 54191182445
Ref: 54201182588
Ref: 54211182714
Ref: 54221182860
Ref: 54231182951
Ref: 54241183157
Ref: 54251183368
Ref: 54261183427
Ref: 54271183428
Ref: 54281183671
Ref: 54291183672
Ref: 54301184766
Node: Annex A1184768
Ref: 54311184926
Ref: 54321184926
Ref: 54331195586
Node: A.11197494
Ref: 54341197729
Ref: 54351197936
Ref: 54361198186
Ref: 54371198258
Ref: 54381199369
Ref: 54391199430
Ref: 54401199491
Ref: 54411201357
Ref: 54421203976
Ref: 54431207667
Ref: 54441207974
Ref: 54451208109
Ref: 54461208165
Ref: 54471208223
Ref: 54481209108
Ref: 54491209295
Ref: 54501209507
Ref: 54511209748
Ref: 54521209785
Ref: 54531209822
Ref: 54541209859
Ref: 54551210621
Node: A.21212757
Ref: 54561212976
Node: A.31213293
Node: A.3.11214227
Ref: 54571214547
Ref: 54581214712
Ref: 54591214897
Node: A.3.21215456
Ref: 54601215808
Ref: 54611215905
Ref: 54621215980
Ref: 54631216055
Ref: 54641216130
Ref: 54651216205
Ref: 54661216280
Ref: 54671216355
Ref: 54681216430
Ref: 54691216548
Ref: 54701216623
Ref: 54711216698
Ref: 54721216773
Ref: 54731216848
Ref: 54741216923
Ref: 54751216998
Ref: 54761217077
Ref: 54771217211
Ref: 54781217276
Ref: 54791217341
Ref: 54801217409
Ref: 54811217468
Ref: 54821217527
Ref: 54831217663
Ref: 54841217759
Ref: 54851217824
Ref: 54861217893
Ref: 54871218037
Ref: 54881218760
Ref: 54891218951
Ref: 54901219144
Ref: 54911219395
Ref: 54921219621
Ref: 54931219864
Ref: 54941220123
Ref: 54951220314
Ref: 54961220548
Ref: 54971220742
Node: A.3.31224715
Ref: 54981225106
Ref: 54991225168
Ref: 55001225176
Ref: 55011225248
Ref: 55021225320
Ref: 55031225392
Ref: 55041225464
Ref: 55051225536
Ref: 55061225608
Ref: 55071225680
Ref: 55081225752
Ref: 55091225824
Ref: 55101225896
Ref: 55111225969
Ref: 55121226042
Ref: 55131226115
Ref: 55141226188
Ref: 55151226261
Ref: 55161226337
Ref: 55171226410
Ref: 55181226483
Ref: 55191226556
Ref: 55201226629
Ref: 55211226702
Ref: 55221226775
Ref: 55231226848
Ref: 55241226921
Ref: 55251226994
Ref: 55261227067
Ref: 55271227140
Ref: 55281227213
Ref: 55291227286
Ref: 55301227359
Ref: 55311227432
Ref: 55321227547
Ref: 55331227628
Ref: 55341227709
Ref: 55351227790
Ref: 55361227871
Ref: 55371227952
Ref: 55381228033
Ref: 55391228114
Ref: 55401228195
Ref: 55411228276
Ref: 55421228357
Ref: 55431228438
Ref: 55441228519
Ref: 55451228600
Ref: 55461228681
Ref: 55471228739
Ref: 55481228820
Ref: 55491228981
Ref: 55501229062
Ref: 55511229143
Ref: 55521229224
Ref: 55531229305
Ref: 55541229386
Ref: 55551229467
Ref: 55561229623
Ref: 55571229704
Ref: 55581229785
Ref: 55591229866
Ref: 55601229947
Ref: 55611230032
Ref: 55621230113
Ref: 55631230194
Ref: 55641230275
Ref: 55651230356
Ref: 55661230438
Ref: 55671230520
Ref: 55681230602
Ref: 55691230684
Ref: 55701230766
Ref: 55711230848
Ref: 55721230930
Ref: 55731231012
Ref: 55741231094
Ref: 55751231176
Ref: 55761231258
Ref: 55771231344
Ref: 55781231426
Ref: 55791231508
Ref: 55801231590
Ref: 55811231672
Ref: 55821231754
Ref: 55831231836
Ref: 55841231918
Ref: 55851232000
Ref: 55861232082
Ref: 55871232164
Ref: 55881232246
Ref: 55891232328
Ref: 55901232410
Ref: 55911232492
Ref: 55921232574
Ref: 55931232684
Ref: 55941232693
Ref: 55951232747
Ref: 55961232801
Ref: 55971232855
Ref: 55981232913
Ref: 55991232987
Ref: 56001233061
Ref: 56011233135
Ref: 56021233209
Ref: 56031233283
Ref: 56041233357
Ref: 56051233431
Ref: 56061233505
Ref: 56071233579
Ref: 56081233653
Ref: 56091233727
Ref: 56101233801
Ref: 56111233875
Ref: 56121233949
Ref: 56131234023
Ref: 56141234101
Ref: 56151234175
Ref: 56161234249
Ref: 56171234323
Ref: 56181234397
Ref: 56191234471
Ref: 56201234545
Ref: 56211234619
Ref: 56221234697
Ref: 56231234771
Ref: 56241234845
Ref: 56251234919
Ref: 56261234993
Ref: 56271235067
Ref: 56281235141
Ref: 56291235215
Ref: 56301235391
Ref: 56311235477
Ref: 56321235549
Ref: 56331235635
Ref: 56341235721
Ref: 56351235807
Ref: 56361235893
Ref: 56371235979
Ref: 56381236065
Ref: 56391236151
Ref: 56401236237
Ref: 56411236323
Ref: 56421236409
Ref: 56431236495
Ref: 56441236581
Ref: 56451236661
Ref: 56461236747
Ref: 56471236895
Ref: 56481236981
Ref: 56491237050
Ref: 56501237136
Ref: 56511237222
Ref: 56521237308
Ref: 56531237394
Ref: 56541237480
Ref: 56551237566
Ref: 56561237636
Ref: 56571237722
Ref: 56581237808
Ref: 56591237894
Ref: 56601237980
Ref: 56611238066
Ref: 56621238152
Ref: 56631238238
Ref: 56641238324
Ref: 56651238472
Ref: 56661238558
Ref: 56671238644
Ref: 56681238730
Ref: 56691238816
Ref: 56701238902
Ref: 56711238988
Ref: 56721239074
Ref: 56731239160
Ref: 56741239246
Ref: 56751239332
Ref: 56761239418
Ref: 56771239504
Ref: 56781239590
Ref: 56791239676
Ref: 56801239762
Ref: 56811239910
Ref: 56821239996
Ref: 56831240082
Ref: 56841240168
Ref: 56851240254
Ref: 56861240340
Ref: 56871240426
Ref: 56881240512
Ref: 56891240598
Ref: 56901240684
Ref: 56911240770
Ref: 56921240856
Ref: 56931240942
Ref: 56941241028
Ref: 56951241114
Ref: 56961241200
Ref: 56971241348
Ref: 56981241434
Ref: 56991241520
Ref: 57001241606
Ref: 57011241692
Ref: 57021241778
Ref: 57031241864
Ref: 57041241950
Ref: 57051242036
Ref: 57061242122
Ref: 57071242208
Ref: 57081242294
Ref: 57091242380
Ref: 57101242466
Ref: 57111242552
Ref: 57121242638
Ref: 57131242786
Ref: 57141242872
Ref: 57151242958
Ref: 57161243044
Ref: 57171243130
Ref: 57181243216
Ref: 57191243302
Ref: 57201243388
Ref: 57211243474
Ref: 57221243560
Ref: 57231243646
Ref: 57241243732
Ref: 57251243818
Ref: 57261243904
Ref: 57271243990
Ref: 57281244076
Node: A.3.41244413
Ref: 57291244741
Ref: 57301244798
Ref: 57311244876
Ref: 57321244954
Ref: 57331245032
Ref: 57341245110
Ref: 57351245204
Ref: 57361245300
Ref: 57371245380
Ref: 57381245457
Ref: 57391245558
Ref: 57401245653
Ref: 57411245759
Ref: 57421245864
Ref: 57431246020
Ref: 57441246171
Ref: 57451246333
Ref: 57461246489
Ref: 57471246671
Node: A.3.51251020
Ref: 57481251488
Ref: 57491251542
Ref: 57501251601
Ref: 57511251674
Ref: 57521251746
Ref: 57531251817
Ref: 57541251888
Ref: 57551251960
Ref: 57561252068
Ref: 57571252152
Ref: 57581252231
Ref: 57591252305
Ref: 57601252387
Ref: 57611252458
Ref: 57621252537
Ref: 57631252625
Ref: 57641252697
Ref: 57651252771
Ref: 57661252844
Ref: 57671252923
Ref: 57681252990
Node: A.3.61259249
Ref: 57691259451
Node: A.41259653
Node: A.4.11260726
Ref: 57701261034
Ref: 57711261100
Ref: 57721261153
Ref: 57731261206
Ref: 57741261272
Ref: 57751261291
Ref: 57761261306
Ref: 57771261319
Ref: 57781261366
Ref: 57791261416
Ref: 57801261465
Ref: 57811261511
Ref: 57821261559
Node: A.4.21261617
Ref: 57831262012
Ref: 57841262147
Ref: 57851262239
Ref: 57861262295
Ref: 57871262479
Ref: 57881262565
Ref: 57891262647
Ref: 57901262729
Ref: 57911263284
Ref: 57921263415
Ref: 57931263775
Ref: 57941263826
Ref: 57951263911
Ref: 57961263992
Ref: 57971264140
Ref: 57981264255
Ref: 57991264378
Ref: 58001264443
Ref: 58011264547
Ref: 58021264641
Ref: 58031264735
Ref: 58041268321
Ref: 58051268438
Ref: 58061270041
Node: A.4.31270586
Ref: 58071271897
Ref: 58081272058
Ref: 58091272363
Ref: 58101272671
Ref: 58111272967
Ref: 58121273266
Ref: 58131273524
Ref: 58141273822
Ref: 58151274074
Ref: 58161274283
Ref: 58171274436
Ref: 58181274676
Ref: 58191274870
Ref: 58201275010
Ref: 58211275338
Ref: 58221275656
Ref: 58231275801
Ref: 58241275925
Ref: 58251276079
Ref: 58261276258
Ref: 58271276508
Ref: 58281276942
Ref: 58291277116
Ref: 58301277331
Ref: 58311277514
Ref: 58321277741
Ref: 58331277913
Ref: 58341278218
Ref: 58351278337
Ref: 58361278550
Ref: 58371278734
Ref: 58381279022
Ref: 58391279195
Ref: 58401279407
Ref: 58411279580
Ref: 58421296779
Node: A.4.41296907
Ref: 58431297844
Ref: 58441298023
Ref: 58451298058
Ref: 58461298121
Ref: 58471298157
Ref: 58481298231
Ref: 58491298301
Ref: 58501298448
Ref: 58511298620
Ref: 58521298703
Ref: 58531298885
Ref: 58541299054
Ref: 58551299257
Ref: 58561299460
Ref: 58571299666
Ref: 58581299873
Ref: 58591300065
Ref: 58601300249
Ref: 58611300984
Ref: 58621301129
Ref: 58631301324
Ref: 58641301513
Ref: 58651301713
Ref: 58661303402
Ref: 58671303737
Ref: 58681304060
Ref: 58691304383
Ref: 58701304664
Ref: 58711304988
Ref: 58721305263
Ref: 58731305492
Ref: 58741305662
Ref: 58751305924
Ref: 58761306138
Ref: 58771306295
Ref: 58781306649
Ref: 58791306993
Ref: 58801307163
Ref: 58811307301
Ref: 58821307480
Ref: 58831307676
Ref: 58841308027
Ref: 58851308349
Ref: 58861308614
Ref: 58871308849
Ref: 58881309130
Ref: 58891309381
Ref: 58901309581
Ref: 58911309792
Ref: 58921309932
Ref: 58931310044
Ref: 58941310256
Ref: 58951310437
Ref: 58961310698
Ref: 58971310929
Ref: 58981311190
Ref: 58991311867
Ref: 59001312075
Ref: 59011312280
Node: A.4.51318488
Ref: 59021319320
Ref: 59031319416
Ref: 59041319514
Ref: 59051319590
Ref: 59061319660
Ref: 59071319714
Ref: 59081319829
Ref: 59091319927
Ref: 59101320026
Ref: 59111320108
Ref: 59121320232
Ref: 59131320357
Ref: 59141320472
Ref: 59151321128
Ref: 59161321266
Ref: 59171321454
Ref: 59181321633
Ref: 59191321824
Ref: 59201323458
Ref: 59211323777
Ref: 59221324084
Ref: 59231324393
Ref: 59241324661
Ref: 59251324970
Ref: 59261325221
Ref: 59271325440
Ref: 59281325603
Ref: 59291325852
Ref: 59301326056
Ref: 59311326206
Ref: 59321326544
Ref: 59331326872
Ref: 59341327037
Ref: 59351327171
Ref: 59361327345
Ref: 59371327534
Ref: 59381327804
Ref: 59391328045
Ref: 59401328239
Ref: 59411328403
Ref: 59421328609
Ref: 59431328785
Ref: 59441328977
Ref: 59451329139
Ref: 59461329278
Ref: 59471329386
Ref: 59481329590
Ref: 59491329764
Ref: 59501329957
Ref: 59511330120
Ref: 59521330313
Ref: 59531330983
Node: A.4.61334703
Ref: 59541335184
Ref: 59551335265
Ref: 59561335321
Ref: 59571335377
Ref: 59581335433
Ref: 59591335489
Ref: 59601335545
Ref: 59611335601
Ref: 59621335657
Ref: 59631335713
Ref: 59641335769
Ref: 59651335825
Ref: 59661335884
Ref: 59671336002
Ref: 59681336120
Node: A.4.71336722
Ref: 59691337709
Ref: 59701337710
Ref: 59711337710
Ref: 59721337710
Ref: 59731337710
Ref: 59741337710
Ref: 59751337710
Ref: 59761337710
Ref: 59771337710
Ref: 59781337710
Ref: 59791337710
Ref: 59801337710
Ref: 59811337710
Ref: 59821337710
Ref: 59831337710
Ref: 59841337710
Ref: 59851337824
Ref: 59861337982
Ref: 59871338084
Ref: 59881338145
Ref: 59891338351
Ref: 59901338458
Ref: 59911338562
Ref: 59921338666
Ref: 59931339345
Ref: 59941339486
Ref: 59951339871
Ref: 59961339932
Ref: 59971340039
Ref: 59981340137
Ref: 59991340316
Ref: 60001340441
Ref: 60011340579
Ref: 60021340649
Ref: 60031340763
Ref: 60041340871
Ref: 60051340975
Ref: 60061343055
Ref: 60071343665
Node: A.4.81343808
Ref: 60081344945
Ref: 60091344946
Ref: 60101344946
Ref: 60111344946
Ref: 60121344946
Ref: 60131344946
Ref: 60141344946
Ref: 60151344946
Ref: 60161344946
Ref: 60171344946
Ref: 60181344946
Ref: 60191344946
Ref: 60201344946
Ref: 60211344946
Ref: 60221344946
Ref: 60231344946
Ref: 60241345119
Ref: 60251345250
Ref: 60261345364
Ref: 60271345432
Ref: 60281345662
Ref: 60291345784
Ref: 60301345900
Ref: 60311346014
Ref: 60321346774
Ref: 60331346930
Ref: 60341347350
Ref: 60351347423
Ref: 60361347544
Ref: 60371347657
Ref: 60381347869
Ref: 60391348006
Ref: 60401348164
Ref: 60411348241
Ref: 60421348370
Ref: 60431348493
Ref: 60441348611
Ref: 60451348862
Ref: 60461350897
Ref: 60471351086
Ref: 60481351763
Node: A.4.91351916
Ref: 60491352254
Ref: 60501352845
Ref: 60511353347
Ref: 60521353687
Ref: 60531354340
Ref: 60541354724
Ref: 60551355153
Node: A.4.101355607
Ref: 60561355943
Ref: 60571356618
Ref: 60581356994
Ref: 60591357415
Ref: 60601357819
Ref: 60611358209
Ref: 60621358584
Ref: 60631359002
Node: A.4.111359240
Ref: 60641359758
Ref: 60651359916
Ref: 60661359985
Ref: 60671360028
Ref: 60681360073
Ref: 60691360116
Ref: 60701360157
Ref: 60711360341
Ref: 60721360478
Ref: 60731360615
Ref: 60741360742
Ref: 60751360919
Ref: 60761361086
Ref: 60771361343
Ref: 60781361560
Ref: 60791361720
Ref: 60801361926
Ref: 60811362111
Ref: 60821362289
Ref: 60831362481
Ref: 60841362611
Ref: 60851362758
Ref: 60861362888
Ref: 60871362955
Ref: 60881363060
Ref: 60891363253
Ref: 60901363450
Ref: 60911363585
Ref: 60921363737
Ref: 60931363872
Ref: 60941363944
Ref: 60951364059
Ref: 60961364267
Ref: 60971364469
Ref: 60981364609
Ref: 60991364766
Ref: 61001364906
Ref: 61011364983
Ref: 61021365445
Ref: 61031365445
Ref: 61041365445
Ref: 61051365445
Node: A.51375205
Ref: 61061375893
Ref: 61071375928
Ref: 61081375964
Ref: 61091376097
Node: A.5.11376766
Ref: 61101377400
Ref: 61111377530
Ref: 61121377611
Ref: 61131377692
Ref: 61141377773
Ref: 61151377938
Ref: 61161378019
Ref: 61171378100
Ref: 61181378181
Ref: 61191378262
Ref: 61201378343
Ref: 61211378424
Ref: 61221378505
Ref: 61231378589
Ref: 61241378670
Ref: 61251378751
Ref: 61261378832
Ref: 61271378913
Ref: 61281379115
Ref: 61291379317
Ref: 61301379519
Ref: 61311379724
Ref: 61321379805
Ref: 61331379886
Ref: 61341379967
Ref: 61351380048
Ref: 61361380129
Ref: 61371380210
Ref: 61381380291
Ref: 61391380415
Ref: 61401384667
Ref: 61411384667
Ref: 61421384667
Ref: 61431385463
Ref: 61441385711
Ref: 61451386269
Node: A.5.21388594
Ref: 61461389019
Ref: 61471390111
Ref: 61481390159
Ref: 61491390208
Ref: 61501390274
Ref: 61511390350
Ref: 61521390451
Ref: 61531390537
Ref: 61541390577
Ref: 61551390680
Ref: 61561390772
Ref: 61571390866
Ref: 61581390927
Ref: 61591391113
Ref: 61601391225
Ref: 61611391370
Ref: 61621391421
Ref: 61631391491
Ref: 61641391592
Ref: 61651391678
Ref: 61661391718
Ref: 61671391821
Ref: 61681391913
Ref: 61691392007
Ref: 61701392068
Ref: 61711392257
Ref: 61721392568
Ref: 61731394241
Ref: 61741394477
Ref: 61751395536
Ref: 61761395536
Ref: 61771395536
Ref: 61781395828
Ref: 61791395829
Node: A.5.31403629
Ref: 61801403834
Ref: 61811403962
Ref: 61821403977
Ref: 61831404135
Ref: 61841404667
Ref: 61851404682
Ref: 61861405080
Ref: 61871405095
Ref: 61881405480
Ref: 61891405495
Ref: 61901405873
Ref: 61911405888
Ref: 61921406404
Ref: 61931406502
Ref: 61941406585
Ref: 61951406586
Ref: 61961406863
Ref: 61971406878
Ref: 61981407191
Ref: 61991407206
Ref: 62001407557
Ref: 62011407572
Ref: 62021408016
Ref: 62031408322
Ref: 62041408439
Ref: 62051408454
Ref: 62061408716
Ref: 62071408731
Ref: 62081409121
Ref: 62091409136
Ref: 62101409377
Ref: 62111409747
Ref: 62121409748
Ref: 62131409935
Ref: 62141409950
Ref: 62151410186
Ref: 62161410486
Ref: 62171410487
Ref: 62181410665
Ref: 62191410680
Ref: 62201411121
Ref: 62211411136
Ref: 62221411631
Ref: 62231411646
Ref: 62241412083
Ref: 62251412098
Ref: 62261412565
Ref: 62271412580
Ref: 62281413223
Ref: 62291413241
Ref: 62301413256
Ref: 62311413638
Ref: 62321413653
Ref: 62331413824
Ref: 62341414141
Ref: 62351414142
Ref: 62361414290
Ref: 62371414305
Ref: 62381414480
Ref: 62391414691
Ref: 62401414692
Ref: 62411414973
Ref: 62421414988
Ref: 62431415166
Ref: 62441415375
Ref: 62451415376
Ref: 62461415589
Ref: 62471415604
Ref: 62481416254
Ref: 62491416269
Ref: 62501416269
Ref: 62511416451
Ref: 62521416466
Ref: 62531416630
Ref: 62541416881
Ref: 62551416882
Ref: 62561417150
Ref: 62571417269
Ref: 62581417284
Ref: 62591417875
Ref: 62601417890
Ref: 62611418309
Ref: 62621418324
Ref: 62631418485
Ref: 62641418500
Ref: 62651418637
Ref: 62661418652
Ref: 62671419086
Ref: 62681419101
Ref: 62691419537
Ref: 62701419552
Node: A.5.41419973
Ref: 62711420158
Ref: 62721420283
Ref: 62731420298
Ref: 62741420473
Ref: 62751420488
Ref: 62761420800
Ref: 62771420815
Node: A.61421148
Ref: 62781421259
Ref: 62791421259
Node: A.71421950
Ref: 62801422143
Ref: 62811422143
Ref: 62821422143
Ref: 62831422719
Ref: 62841424440
Ref: 62851424441
Ref: 62861424441
Ref: 62871424504
Ref: 62881425768
Ref: 62891425769
Node: A.81426561
Ref: 62901426748
Ref: 62911426748
Ref: 62921426748
Ref: 62931427177
Ref: 62941427596
Ref: 62951427596
Ref: 62961427596
Ref: 62971428152
Node: A.8.11428651
Ref: 62981429033
Ref: 62991429050
Ref: 63001429096
Ref: 63011429194
Ref: 63021429404
Ref: 63031429596
Ref: 63041429647
Ref: 63051429698
Ref: 63061429770
Ref: 63071429823
Ref: 63081429887
Ref: 63091429948
Ref: 63101430013
Ref: 63111430084
Ref: 63121430178
Ref: 63131430250
Ref: 63141430324
Ref: 63151430406
Ref: 63161430475
Ref: 63171430542
Ref: 63181430609
Ref: 63191430675
Ref: 63201430744
Ref: 63211430810
Ref: 63221431007
Node: A.8.21431068
Node: A.8.31439173
Node: A.8.41440945
Ref: 63231441321
Ref: 63241441338
Ref: 63251441384
Ref: 63261441443
Ref: 63271441507
Ref: 63281441605
Ref: 63291441817
Ref: 63301442009
Ref: 63311442060
Ref: 63321442111
Ref: 63331442183
Ref: 63341442236
Ref: 63351442300
Ref: 63361442361
Ref: 63371442426
Ref: 63381442497
Ref: 63391442591
Ref: 63401442733
Ref: 63411442808
Ref: 63421442950
Ref: 63431443024
Ref: 63441443101
Ref: 63451443168
Ref: 63461443230
Ref: 63471443312
Ref: 63481443381
Ref: 63491443448
Ref: 63501443515
Ref: 63511443581
Ref: 63521443650
Ref: 63531443716
Ref: 63541443909
Node: A.8.51443966
Node: A.91447320
Ref: 63551447913
Ref: 63561447961
Ref: 63571448081
Ref: 63581448225
Ref: 63591448304
Ref: 63601448393
Node: A.101449149
Ref: 63611451375
Ref: 63621451375
Ref: 63631451766
Ref: 63641452090
Ref: 63651452090
Ref: 63661452090
Ref: 63671453384
Ref: 63681453389
Ref: 63691453389
Ref: 63701453389
Ref: 63711453389
Ref: 63721454202
Ref: 63731454202
Node: A.10.11455647
Ref: 63741455931
Ref: 63751455948
Ref: 63761455994
Ref: 63771456057
Ref: 63781456117
Ref: 63791456167
Ref: 63801456248
Ref: 63811456322
Ref: 63821456376
Ref: 63831456465
Ref: 63841456686
Ref: 63851456883
Ref: 63861456935
Ref: 63871456987
Ref: 63881457060
Ref: 63891457116
Ref: 63901457181
Ref: 63911457243
Ref: 63921457309
Ref: 63931457433
Ref: 63941457484
Ref: 63951457535
Ref: 63961457589
Ref: 63971457640
Ref: 63981457691
Ref: 63991457746
Ref: 64001457797
Ref: 64011457848
Ref: 64021457899
Ref: 64031457962
Ref: 64041458015
Ref: 64051458068
Ref: 64061458125
Ref: 64071458178
Ref: 64081458231
Ref: 64091458313
Ref: 64101458360
Ref: 64111458443
Ref: 64121458514
Ref: 64131458570
Ref: 64141458641
Ref: 64151458697
Ref: 64161458762
Ref: 64171458810
Ref: 64181458875
Ref: 64191458969
Ref: 64201459088
Ref: 64211459157
Ref: 64221459276
Ref: 64231459345
Ref: 64241459412
Ref: 64251459462
Ref: 64261459514
Ref: 64271459546
Ref: 64281459598
Ref: 64291459631
Ref: 64301459698
Ref: 64311459748
Ref: 64321459815
Ref: 64331459865
Ref: 64341459938
Ref: 64351459996
Ref: 64361460069
Ref: 64371460126
Ref: 64381460192
Ref: 64391460241
Ref: 64401460307
Ref: 64411460356
Ref: 64421460422
Ref: 64431460510
Ref: 64441460577
Ref: 64451460626
Ref: 64461460692
Ref: 64471460741
Ref: 64481460917
Ref: 64491461038
Ref: 64501461157
Ref: 64511461221
Ref: 64521461397
Ref: 64531461553
Ref: 64541461617
Ref: 64551461663
Ref: 64561461726
Ref: 64571461772
Ref: 64581461915
Ref: 64591461989
Ref: 64601462052
Ref: 64611462098
Ref: 64621462166
Ref: 64631462327
Ref: 64641462351
Ref: 64651462398
Ref: 64661462463
Ref: 64671462602
Ref: 64681462698
Ref: 64691462912
Ref: 64701463079
Ref: 64711463211
Ref: 64721463434
Ref: 64731463458
Ref: 64741463505
Ref: 64751463570
Ref: 64761463709
Ref: 64771463805
Ref: 64781464019
Ref: 64791464186
Ref: 64801464318
Ref: 64811464607
Ref: 64821464629
Ref: 64831464667
Ref: 64841464716
Ref: 64851464773
Ref: 64861464913
Ref: 64871465009
Ref: 64881465268
Ref: 64891465485
Ref: 64901465616
Ref: 64911465885
Ref: 64921465907
Ref: 64931465952
Ref: 64941465996
Ref: 64951466053
Ref: 64961466193
Ref: 64971466289
Ref: 64981466548
Ref: 64991466765
Ref: 65001466897
Ref: 65011467176
Ref: 65021467200
Ref: 65031467245
Ref: 65041467289
Ref: 65051467346
Ref: 65061467486
Ref: 65071467582
Ref: 65081467841
Ref: 65091468058
Ref: 65101468190
Ref: 65111468527
Ref: 65121468555
Ref: 65131468596
Ref: 65141468668
Ref: 65151468758
Ref: 65161468805
Ref: 65171469023
Ref: 65181469198
Ref: 65191469331
Ref: 65201469520
Ref: 65211469589
Ref: 65221469656
Ref: 65231469723
Ref: 65241469789
Ref: 65251469858
Ref: 65261469924
Ref: 65271469991
Ref: 65281470180
Node: A.10.21470201
Node: A.10.31472623
Ref: 65291475957
Node: A.10.41476575
Node: A.10.51479108
Node: A.10.61489138
Ref: 65301491224
Node: A.10.71495244
Ref: 65311497004
Ref: 65321498358
Ref: 65331500190
Ref: 65341500903
Node: A.10.81502968
Ref: 65351507481
Node: A.10.91508359
Ref: 65361515065
Node: A.10.101516711
Node: A.10.111521292
Ref: 65371521884
Ref: 65381521908
Ref: 65391522015
Ref: 65401522089
Ref: 65411522201
Ref: 65421522279
Ref: 65431522385
Ref: 65441522460
Ref: 65451522562
Node: A.10.121523979
Ref: 65461524437
Ref: 65471524461
Ref: 65481524580
Ref: 65491524666
Ref: 65501524790
Ref: 65511524880
Ref: 65521524998
Ref: 65531525085
Ref: 65541525199
Node: A.111526832
Ref: 65551527365
Ref: 65561527648
Ref: 65571527648
Ref: 65581527922
Ref: 65591528219
Ref: 65601528220
Ref: 65611528524
Ref: 65621528524
Ref: 65631529050
Ref: 65641529050
Node: A.121529596
Node: A.12.11530098
Ref: 65651530238
Ref: 65661531198
Ref: 65671531198
Ref: 65681531304
Ref: 65691531401
Ref: 65701531472
Ref: 65711531576
Ref: 65721531643
Ref: 65731531713
Ref: 65741531833
Ref: 65751532057
Ref: 65761532250
Ref: 65771532303
Ref: 65781532356
Ref: 65791532430
Ref: 65801532486
Ref: 65811532549
Ref: 65821532609
Ref: 65831532673
Ref: 65841532741
Ref: 65851532813
Ref: 65861533049
Ref: 65871533270
Ref: 65881533531
Ref: 65891533693
Ref: 65901533893
Ref: 65911533971
Ref: 65921534039
Ref: 65931534103
Ref: 65941534184
Ref: 65951534243
Ref: 65961534313
Ref: 65971534381
Ref: 65981534449
Ref: 65991534516
Ref: 66001534586
Ref: 66011534653
Ref: 66021534856
Ref: 66031538246
Node: A.12.21538579
Ref: 66041538977
Ref: 66051539032
Ref: 66061539112
Node: A.12.31539736
Ref: 66071540159
Ref: 66081540219
Ref: 66091540299
Node: A.12.41540486
Ref: 66101540925
Ref: 66111540990
Ref: 66121541072
Node: A.131541266
Ref: 66131541655
Ref: 66141541698
Ref: 66151541732
Ref: 66161541766
Ref: 66171541800
Ref: 66181541834
Ref: 66191541868
Ref: 66201541902
Ref: 66211541936
Ref: 66221545443
Ref: 66231545774
Ref: 66241545775
Node: A.141545777
Ref: 66251545938
Node: A.151546640
Ref: 66261547080
Ref: 66271547142
Ref: 66281547192
Ref: 66291547258
Ref: 66301547301
Ref: 66311547358
Ref: 66321547397
Ref: 66331547454
Ref: 66341548255
Node: A.161550119
Ref: 66351550561
Ref: 66361550631
Ref: 66371550687
Ref: 66381550749
Ref: 66391550887
Ref: 66401550952
Ref: 66411551081
Ref: 66421551142
Ref: 66431551198
Ref: 66441551263
Ref: 66451551478
Ref: 66461551545
Ref: 66471551614
Ref: 66481551692
Ref: 66491551759
Ref: 66501551826
Ref: 66511552037
Ref: 66521552153
Ref: 66531552281
Ref: 66541552355
Ref: 66551552426
Ref: 66561552491
Ref: 66571552556
Ref: 66581552621
Ref: 66591552741
Ref: 66601552801
Ref: 66611552865
Ref: 66621552921
Ref: 66631553182
Ref: 66641553247
Ref: 66651553326
Ref: 66661553794
Ref: 66671553900
Ref: 66681554004
Ref: 66691554106
Ref: 66701554208
Ref: 66711554317
Ref: 66721554390
Ref: 66731554461
Ref: 66741554531
Ref: 66751555058
Ref: 66761555059
Ref: 66771555059
Ref: 66781555266
Ref: 66791555267
Ref: 66801555929
Ref: 66811555930
Ref: 66821556119
Ref: 66831556255
Ref: 66841570614
Ref: 66851577462
Node: A.16.11579466
Ref: 66861580028
Ref: 66871580051
Ref: 66881580123
Ref: 66891580203
Ref: 66901580285
Ref: 66911580368
Ref: 66921580438
Ref: 66931580513
Ref: 66941580629
Ref: 66951580763
Ref: 66961580838
Ref: 66971580909
Node: A.171585497
Ref: 66981585655
Ref: 66991586133
Ref: 67001586208
Ref: 67011586272
Ref: 67021586355
Ref: 67031586420
Ref: 67041586486
Ref: 67051586530
Ref: 67061586560
Ref: 67071589654
Ref: 67081590030
Node: A.181591685
Ref: 67091592298
Ref: 67101592298
Ref: 67111592752
Ref: 67121592753
Ref: 67131593140
Ref: 67141593775
Node: A.18.11596753
Ref: 67151597093
Ref: 67161597145
Ref: 67171597204
Ref: 67181597263
Node: A.18.21597701
Ref: 67191598270
Ref: 67201598270
Ref: 67211598277
Ref: 67221598277
Ref: 67231598800
Ref: 67241599277
Ref: 67251599375
Ref: 67261599543
Ref: 67271599626
Ref: 67281599924
Ref: 67291600005
Ref: 67301600051
Ref: 67311600111
Ref: 67321600183
Ref: 67331600365
Ref: 67341600435
Ref: 67351600896
Ref: 67361600969
Ref: 67371601105
Ref: 67381601176
Ref: 67391601300
Ref: 67401601370
Ref: 67411601428
Ref: 67421601553
Ref: 67431601629
Ref: 67441601763
Ref: 67451601836
Ref: 67461602039
Ref: 67471602238
Ref: 67481602427
Ref: 67491602576
Ref: 67501602805
Ref: 67511603196
Ref: 67521603337
Ref: 67531603520
Ref: 67541603680
Ref: 67551603859
Ref: 67561604016
Ref: 67571604094
Ref: 67581604195
Ref: 67591604298
Ref: 67601604472
Ref: 67611604638
Ref: 67621604857
Ref: 67631605099
Ref: 67641605333
Ref: 67651605620
Ref: 67661605803
Ref: 67671606031
Ref: 67681606146
Ref: 67691606330
Ref: 67701606443
Ref: 67711606624
Ref: 67721606825
Ref: 67731607077
Ref: 67741607260
Ref: 67751607435
Ref: 67761607569
Ref: 67771607701
Ref: 67781607771
Ref: 67791607884
Ref: 67801607992
Ref: 67811608067
Ref: 67821608132
Ref: 67831608222
Ref: 67841608300
Ref: 67851608364
Ref: 67861608453
Ref: 67871608517
Ref: 67881608573
Ref: 67891608641
Ref: 67901608701
Ref: 67911608918
Ref: 67921609099
Ref: 67931609339
Ref: 67941609544
Ref: 67951609707
Ref: 67961609847
Ref: 67971610380
Ref: 67981610425
Ref: 67991610499
Ref: 68001610560
Ref: 68011611248
Ref: 68021611336
Ref: 68031613231
Ref: 68041613644
Ref: 68051613996
Ref: 68061613996
Ref: 68071624367
Ref: 68081648589
Ref: 68091650097
Ref: 68101650484
Ref: 68111651561
Ref: 68121651561
Ref: 68131652154
Ref: 68141652774
Ref: 68151652774
Ref: 68161653391
Ref: 68171653514
Node: A.18.31655667
Ref: 68181656087
Ref: 68191656088
Ref: 68201656094
Ref: 68211656605
Ref: 68221656976
Ref: 68231657095
Ref: 68241657389
Ref: 68251657469
Ref: 68261657510
Ref: 68271657569
Ref: 68281657640
Ref: 68291657818
Ref: 68301657886
Ref: 68311657954
Ref: 68321658010
Ref: 68331658094
Ref: 68341658291
Ref: 68351658440
Ref: 68361658829
Ref: 68371658970
Ref: 68381659147
Ref: 68391659302
Ref: 68401659376
Ref: 68411659434
Ref: 68421659533
Ref: 68431659765
Ref: 68441660050
Ref: 68451660276
Ref: 68461660458
Ref: 68471660637
Ref: 68481660810
Ref: 68491660942
Ref: 68501661072
Ref: 68511661140
Ref: 68521661247
Ref: 68531661366
Ref: 68541661525
Ref: 68551661736
Ref: 68561661896
Ref: 68571661959
Ref: 68581662047
Ref: 68591662109
Ref: 68601662196
Ref: 68611662259
Ref: 68621662327
Ref: 68631662384
Ref: 68641662444
Ref: 68651662623
Ref: 68661662826
Ref: 68671662986
Ref: 68681663124
Ref: 68691663647
Ref: 68701663692
Ref: 68711663764
Ref: 68721663823
Ref: 68731664569
Ref: 68741664651
Ref: 68751666110
Ref: 68761666725
Ref: 68771666980
Ref: 68781666980
Ref: 68791671244
Ref: 68801688871
Ref: 68811690389
Ref: 68821690684
Ref: 68831691074
Ref: 68841691606
Ref: 68851691606
Ref: 68861692339
Ref: 68871692340
Node: A.18.41693991
Ref: 68881694491
Ref: 68891694492
Ref: 68901695262
Ref: 68911695340
Ref: 68921695365
Ref: 68931695813
Ref: 68941695819
Ref: 68951695819
Ref: 68961695819
Ref: 68971696758
Ref: 68981697250
Ref: 68991697507
Ref: 69001697507
Ref: 69011703376
Ref: 69021712574
Ref: 69031712961
Ref: 69041713474
Ref: 69051713474
Ref: 69061714057
Ref: 69071714211
Node: A.18.51715107
Ref: 69081715825
Ref: 69091715928
Ref: 69101716220
Ref: 69111716300
Ref: 69121716339
Ref: 69131716398
Ref: 69141716469
Ref: 69151716643
Ref: 69161716712
Ref: 69171716845
Ref: 69181716912
Ref: 69191716979
Ref: 69201717034
Ref: 69211717098
Ref: 69221717171
Ref: 69231717367
Ref: 69241717588
Ref: 69251718031
Ref: 69261718172
Ref: 69271718348
Ref: 69281718501
Ref: 69291718679
Ref: 69301718835
Ref: 69311718907
Ref: 69321718991
Ref: 69331719088
Ref: 69341719366
Ref: 69351719585
Ref: 69361719756
Ref: 69371719930
Ref: 69381720104
Ref: 69391720218
Ref: 69401720330
Ref: 69411720439
Ref: 69421720512
Ref: 69431720577
Ref: 69441720634
Ref: 69451720751
Ref: 69461720880
Ref: 69471721034
Ref: 69481721123
Ref: 69491721258
Ref: 69501721394
Ref: 69511722004
Ref: 69521722011
Ref: 69531722540
Ref: 69541723044
Ref: 69551723271
Ref: 69561723278
Ref: 69571723278
Ref: 69581723278
Ref: 69591723464
Node: A.18.61727518
Ref: 69601728150
Ref: 69611728259
Ref: 69621728334
Ref: 69631728626
Ref: 69641728706
Ref: 69651728745
Ref: 69661728804
Ref: 69671728875
Ref: 69681729049
Ref: 69691729116
Ref: 69701729183
Ref: 69711729238
Ref: 69721729302
Ref: 69731729375
Ref: 69741729571
Ref: 69751729792
Ref: 69761730235
Ref: 69771730376
Ref: 69781730552
Ref: 69791730705
Ref: 69801730883
Ref: 69811731039
Ref: 69821731111
Ref: 69831731167
Ref: 69841731264
Ref: 69851731542
Ref: 69861731761
Ref: 69871731932
Ref: 69881732106
Ref: 69891732280
Ref: 69901732394
Ref: 69911732506
Ref: 69921732616
Ref: 69931732679
Ref: 69941732740
Ref: 69951732802
Ref: 69961732878
Ref: 69971732946
Ref: 69981733007
Ref: 69991733082
Ref: 70001733149
Ref: 70011733213
Ref: 70021733269
Ref: 70031733337
Ref: 70041733397
Ref: 70051733503
Ref: 70061733621
Ref: 70071733729
Ref: 70081733841
Ref: 70091734436
Ref: 70101734573
Ref: 70111735079
Ref: 70121735739
Ref: 70131735943
Ref: 70141735950
Ref: 70151735950
Ref: 70161735950
Ref: 70171735950
Node: A.18.71742569
Ref: 70181743052
Ref: 70191743052
Ref: 70201743823
Ref: 70211743901
Ref: 70221744213
Ref: 70231744219
Ref: 70241744219
Ref: 70251744219
Ref: 70261745188
Ref: 70271745688
Ref: 70281745804
Ref: 70291745804
Ref: 70301750996
Ref: 70311760431
Ref: 70321760638
Ref: 70331762727
Ref: 70341765099
Ref: 70351765487
Ref: 70361766000
Ref: 70371766000
Ref: 70381766600
Ref: 70391766754
Node: A.18.81767655
Ref: 70401768355
Ref: 70411768458
Ref: 70421768702
Ref: 70431768782
Ref: 70441768821
Ref: 70451768880
Ref: 70461768951
Ref: 70471769125
Ref: 70481769199
Ref: 70491769267
Ref: 70501769337
Ref: 70511769470
Ref: 70521769537
Ref: 70531769604
Ref: 70541769659
Ref: 70551769732
Ref: 70561769928
Ref: 70571770247
Ref: 70581770424
Ref: 70591770496
Ref: 70601770580
Ref: 70611770677
Ref: 70621770900
Ref: 70631771016
Ref: 70641771134
Ref: 70651771252
Ref: 70661771370
Ref: 70671771486
Ref: 70681771596
Ref: 70691771694
Ref: 70701771830
Ref: 70711771942
Ref: 70721772093
Ref: 70731772201
Ref: 70741772346
Ref: 70751772474
Ref: 70761772650
Ref: 70771772717
Ref: 70781772823
Ref: 70791772885
Ref: 70801772949
Ref: 70811773005
Ref: 70821773115
Ref: 70831773273
Ref: 70841773365
Ref: 70851773511
Ref: 70861773658
Ref: 70871774231
Ref: 70881774273
Ref: 70891774340
Ref: 70901774478
Ref: 70911774661
Ref: 70921774781
Ref: 70931774898
Ref: 70941775024
Ref: 70951775160
Ref: 70961775409
Ref: 70971775573
Ref: 70981775765
Ref: 70991775952
Ref: 71001776269
Ref: 71011776540
Ref: 71021777079
Ref: 71031777580
Ref: 71041777764
Ref: 71051777990
Ref: 71061777997
Ref: 71071777997
Ref: 71081777997
Ref: 71091778198
Ref: 71101782482
Ref: 71111782858
Node: A.18.91783250
Ref: 71121783853
Ref: 71131783962
Ref: 71141784045
Ref: 71151784289
Ref: 71161784369
Ref: 71171784408
Ref: 71181784467
Ref: 71191784538
Ref: 71201784712
Ref: 71211784787
Ref: 71221784855
Ref: 71231784922
Ref: 71241784989
Ref: 71251785044
Ref: 71261785117
Ref: 71271785313
Ref: 71281785632
Ref: 71291785809
Ref: 71301785881
Ref: 71311785937
Ref: 71321786034
Ref: 71331786257
Ref: 71341786373
Ref: 71351786491
Ref: 71361786609
Ref: 71371786727
Ref: 71381786843
Ref: 71391786953
Ref: 71401787016
Ref: 71411787078
Ref: 71421787176
Ref: 71431787312
Ref: 71441787424
Ref: 71451787575
Ref: 71461787683
Ref: 71471787828
Ref: 71481787956
Ref: 71491788133
Ref: 71501788200
Ref: 71511788306
Ref: 71521788368
Ref: 71531788444
Ref: 71541788505
Ref: 71551788580
Ref: 71561788644
Ref: 71571788700
Ref: 71581788768
Ref: 71591788828
Ref: 71601788949
Ref: 71611789072
Ref: 71621789199
Ref: 71631789858
Ref: 71641789995
Ref: 71651790622
Ref: 71661790665
Ref: 71671790764
Ref: 71681790832
Ref: 71691790974
Ref: 71701791160
Ref: 71711791282
Ref: 71721791401
Ref: 71731791530
Ref: 71741791661
Ref: 71751791796
Ref: 71761791920
Ref: 71771792173
Ref: 71781792337
Ref: 71791792529
Ref: 71801792716
Ref: 71811793165
Ref: 71821793710
Ref: 71831793894
Ref: 71841794103
Ref: 71851794110
Ref: 71861794110
Ref: 71871794110
Ref: 71881794110
Ref: 71891800441
Node: A.18.101801330
Ref: 71901801827
Ref: 71911801827
Ref: 71921801840
Ref: 71931802025
Ref: 71941802444
Ref: 71951802445
Ref: 71961802445
Ref: 71971802769
Ref: 71981802913
Ref: 71991803033
Ref: 72001803296
Ref: 72011803646
Ref: 72021803755
Ref: 72031804049
Ref: 72041804130
Ref: 72051804172
Ref: 72061804230
Ref: 72071804300
Ref: 72081804413
Ref: 72091804611
Ref: 72101804678
Ref: 72111804750
Ref: 72121804831
Ref: 72131804899
Ref: 72141804966
Ref: 72151805033
Ref: 72161805096
Ref: 72171805152
Ref: 72181805225
Ref: 72191805422
Ref: 72201805571
Ref: 72211805789
Ref: 72221805956
Ref: 72231806095
Ref: 72241806270
Ref: 72251806423
Ref: 72261806495
Ref: 72271806553
Ref: 72281806652
Ref: 72291806773
Ref: 72301806900
Ref: 72311807006
Ref: 72321807128
Ref: 72331807272
Ref: 72341807412
Ref: 72351807533
Ref: 72361807671
Ref: 72371807818
Ref: 72381807938
Ref: 72391808067
Ref: 72401808139
Ref: 72411808219
Ref: 72421808534
Ref: 72431808908
Ref: 72441809217
Ref: 72451809477
Ref: 72461809733
Ref: 72471809862
Ref: 72481810099
Ref: 72491810402
Ref: 72501810647
Ref: 72511810990
Ref: 72521811266
Ref: 72531811331
Ref: 72541811399
Ref: 72551811481
Ref: 72561811548
Ref: 72571811629
Ref: 72581811700
Ref: 72591811776
Ref: 72601811841
Ref: 72611811910
Ref: 72621812055
Ref: 72631812207
Ref: 72641812978
Ref: 72651813060
Ref: 72661814572
Ref: 72671815139
Ref: 72681815392
Ref: 72691815392
Ref: 72701822349
Ref: 72711853421
Ref: 72721853809
Ref: 72731854336
Ref: 72741854336
Ref: 72751854925
Node: A.18.111856305
Ref: 72761856918
Node: A.18.121857847
Ref: 72771858543
Node: A.18.131859290
Ref: 72781859894
Node: A.18.141860680
Ref: 72791861289
Node: A.18.151862076
Ref: 72801862665
Node: A.18.161863151
Ref: 72811863745
Node: A.18.171864232
Ref: 72821864842
Node: A.18.181865682
Ref: 72831866314
Ref: 72841866642
Ref: 72851866759
Ref: 72861866847
Ref: 72871866971
Ref: 72881867045
Ref: 72891867115
Ref: 72901867173
Ref: 72911867247
Ref: 72921867384
Ref: 72931867529
Ref: 72941867678
Ref: 72951867839
Ref: 72961867975
Ref: 72971868089
Ref: 72981868190
Ref: 72991868266
Ref: 73001868328
Ref: 73011869064
Ref: 73021869608
Ref: 73031870018
Ref: 73041870018
Ref: 73051873425
Ref: 73061875881
Ref: 73071876276
Ref: 73081876947
Node: A.18.191877605
Ref: 73091879083
Ref: 73101879614
Node: A.18.201880705
Ref: 73111882134
Ref: 73121882939
Ref: 73131883464
Node: A.18.211884462
Ref: 73141885977
Ref: 73151886299
Ref: 73161887106
Ref: 73171887628
Node: A.18.221888717
Ref: 73181890106
Ref: 73191890600
Ref: 73201891122
Node: A.18.231892214
Ref: 73211893712
Ref: 73221894034
Ref: 73231894837
Ref: 73241895359
Node: A.18.241896343
Ref: 73251897730
Ref: 73261898220
Ref: 73271898742
Node: A.18.251899729
Ref: 73281902054
Ref: 73291902579
Node: A.18.261903567
Ref: 73301904353
Ref: 73311905212
Ref: 73321905621
Ref: 73331906582
Ref: 73341906901
Ref: 73351908261
Node: A.18.271909046
Ref: 73361909741
Ref: 73371909812
Ref: 73381909868
Ref: 73391910038
Ref: 73401910207
Ref: 73411910287
Ref: 73421910630
Node: A.18.281911980
Ref: 73431912752
Ref: 73441912956
Ref: 73451913159
Ref: 73461913253
Ref: 73471913355
Ref: 73481913428
Node: A.18.291913795
Ref: 73491914599
Ref: 73501914801
Ref: 73511915062
Ref: 73521915156
Ref: 73531915258
Ref: 73541915331
Node: A.18.301915914
Ref: 73551916918
Ref: 73561917118
Ref: 73571917321
Ref: 73581917415
Ref: 73591917522
Ref: 73601917749
Ref: 73611917822
Node: A.18.311919349
Ref: 73621920385
Ref: 73631920583
Ref: 73641920842
Ref: 73651920936
Ref: 73661921043
Ref: 73671921270
Ref: 73681921343
Node: A.18.321921928
Node: A.191926704
Ref: 73691926829
Ref: 73701927126
Ref: 73711927221
Ref: 73721927371
Ref: 73731927515
Ref: 73741927575
Ref: 73751927651
Ref: 73761927699
Ref: 73771927777
Ref: 73781927777
Node: Annex B1928530
Ref: 73791928687
Ref: 73801928687
Ref: 73811928687
Node: B.11929799
Ref: 73821930046
Ref: 73831930046
Ref: 73841930052
Ref: 73851930052
Ref: 73861930319
Ref: 73871930320
Ref: 73881930891
Ref: 73891930891
Ref: 73901930891
Ref: 73911930891
Ref: 73921930891
Ref: 73931930892
Ref: 73941930892
Ref: 73951930892
Ref: 73961930892
Ref: 73971930919
Ref: 73981930919
Ref: 73991931659
Ref: 74001931660
Ref: 74011931682
Ref: 74021932005
Ref: 74031932038
Ref: 74041932136
Ref: 74051932579
Ref: 74061932647
Ref: 74071933053
Ref: 74081934398
Ref: 74091934515
Ref: 74101934515
Ref: 74111936227
Ref: 74121936423
Ref: 74131937304
Ref: 74141937304
Ref: 74151937616
Ref: 74161938461
Ref: 74171938462
Ref: 74181938462
Ref: 74191938462
Node: B.21940669
Ref: 74201941217
Ref: 74211941915
Ref: 74221941915
Ref: 74231941915
Ref: 74241941915
Ref: 74251941915
Ref: 74261942415
Ref: 74271942415
Ref: 74281942424
Ref: 74291942424
Node: B.31944093
Ref: 74301944232
Ref: 74311944232
Ref: 74321944950
Ref: 74331945032
Ref: 74341945104
Ref: 74351945179
Ref: 74361945253
Ref: 74371945380
Ref: 74381945432
Ref: 74391945484
Ref: 74401945539
Ref: 74411945643
Ref: 74421945702
Ref: 74431945761
Ref: 74441945824
Ref: 74451945925
Ref: 74461945980
Ref: 74471946040
Ref: 74481946125
Ref: 74491946188
Ref: 74501946251
Ref: 74511946353
Ref: 74521946411
Ref: 74531946484
Ref: 74541946547
Ref: 74551946608
Ref: 74561946757
Ref: 74571946835
Ref: 74581946976
Ref: 74591947114
Ref: 74601947328
Ref: 74611947586
Ref: 74621947647
Ref: 74631947728
Ref: 74641947795
Ref: 74651947871
Ref: 74661948011
Ref: 74671948090
Ref: 74681948237
Ref: 74691948381
Ref: 74701948601
Ref: 74711948910
Ref: 74721948974
Ref: 74731949062
Ref: 74741949128
Ref: 74751949200
Ref: 74761949348
Ref: 74771949424
Ref: 74781949572
Ref: 74791949721
Ref: 74801949947
Ref: 74811950169
Ref: 74821950234
Ref: 74831950323
Ref: 74841950394
Ref: 74851950472
Ref: 74861950622
Ref: 74871950698
Ref: 74881950852
Ref: 74891951007
Ref: 74901951238
Ref: 74911951450
Ref: 74921954588
Ref: 74931955030
Ref: 74941960533
Ref: 74951960533
Node: B.3.11965773
Ref: 74961966512
Ref: 74971966567
Ref: 74981966629
Ref: 74991966725
Ref: 75001966796
Ref: 75011966852
Ref: 75021967013
Ref: 75031967093
Ref: 75041967162
Ref: 75051967201
Ref: 75061967258
Ref: 75071967326
Ref: 75081967425
Ref: 75091967489
Ref: 75101967584
Ref: 75111967650
Ref: 75121967855
Ref: 75131968041
Ref: 75141972511
Ref: 75151972776
Ref: 75161972888
Ref: 75171972945
Node: B.3.21973558
Ref: 75181974838
Ref: 75191974894
Ref: 75201974945
Ref: 75211975099
Ref: 75221975211
Ref: 75231975798
Ref: 75241975890
Ref: 75251976024
Ref: 75261976196
Ref: 75271976432
Ref: 75281979471
Ref: 75291979560
Ref: 75301979704
Ref: 75311979922
Ref: 75321980075
Ref: 75331980402
Node: B.3.31982163
Ref: 75341982284
Ref: 75351983103
Ref: 75361983103
Ref: 75371983188
Ref: 75381983188
Ref: 75391983188
Ref: 75401984140
Ref: 75411986208
Ref: 75421986478
Node: B.41988124
Ref: 75431988255
Ref: 75441988255
Ref: 75451989266
Ref: 75461989385
Ref: 75471989446
Ref: 75481989511
Ref: 75491989569
Ref: 75501989621
Ref: 75511989690
Ref: 75521989775
Ref: 75531989836
Ref: 75541989938
Ref: 75551990003
Ref: 75561990094
Ref: 75571990197
Ref: 75581990301
Ref: 75591990367
Ref: 75601990438
Ref: 75611990608
Ref: 75621990763
Ref: 75631990909
Ref: 75641990943
Ref: 75651990999
Ref: 75661991055
Ref: 75671991111
Ref: 75681991167
Ref: 75691991237
Ref: 75701991270
Ref: 75711991322
Ref: 75721991374
Ref: 75731991440
Ref: 75741991473
Ref: 75751991525
Ref: 75761991660
Ref: 75771991710
Ref: 75781991787
Ref: 75791991901
Ref: 75801992022
Ref: 75811992145
Ref: 75821992221
Ref: 75831992350
Ref: 75841992559
Ref: 75851992688
Ref: 75861992763
Ref: 75871992898
Ref: 75881993116
Ref: 75891993241
Ref: 75901993312
Ref: 75911993443
Ref: 75921993659
Ref: 75931993726
Ref: 75941993797
Ref: 75951993864
Ref: 75961995625
Node: B.52007168
Ref: 75972007291
Ref: 75982007291
Ref: 75992008106
Ref: 76002008153
Ref: 76012008218
Ref: 76022008282
Ref: 76032008349
Ref: 76042008392
Ref: 76052008500
Ref: 76062008575
Ref: 76072008633
Ref: 76082008697
Ref: 76092008775
Ref: 76102008850
Ref: 76112008957
Ref: 76122009029
Ref: 76132009101
Ref: 76142009174
Ref: 76152009252
Ref: 76162009433
Node: Annex C2013219
Ref: 76172013358
Ref: 76182013358
Ref: 76192013358
Ref: 76202013358
Ref: 76212013358
Ref: 76222013358
Node: C.12013841
Ref: 76232014127
Ref: 76242014614
Ref: 76252014614
Ref: 76262014614
Ref: 76272014614
Node: C.22016963
Ref: 76282017277
Node: C.32017405
Ref: 76292017652
Ref: 76302017704
Ref: 76312017803
Ref: 76322017907
Ref: 76332018035
Ref: 76342018132
Ref: 76352018217
Ref: 76362018357
Ref: 76372018358
Ref: 76382018634
Ref: 76392018635
Ref: 76402019255
Node: C.3.12024803
Ref: 76412025484
Ref: 76422025484
Ref: 76432025676
Ref: 76442025676
Ref: 76452026027
Ref: 76462026509
Ref: 76472026509
Ref: 76482026834
Ref: 76492026835
Ref: 76502026900
Ref: 76512027013
Ref: 76522027013
Ref: 76532027013
Ref: 76542027368
Ref: 76552027420
Ref: 76562028220
Ref: 76572028487
Ref: 76582030271
Node: C.3.22031550
Ref: 76592031786
Ref: 76602031865
Ref: 76612031918
Ref: 76622032040
Ref: 76632032126
Ref: 76642032212
Ref: 76652032317
Ref: 76662032449
Ref: 76672032636
Ref: 76682032714
Ref: 76692032810
Ref: 76702033024
Ref: 76712034046
Ref: 76722034821
Ref: 76732035113
Ref: 76742035433
Node: C.42037375
Ref: 76752037863
Ref: 76762038242
Node: C.52039905
Ref: 76772040338
Ref: 76782040338
Ref: 76792040723
Ref: 76802040723
Ref: 76812040839
Ref: 76822040840
Ref: 76832040863
Ref: 76842041047
Ref: 76852041048
Ref: 76862041774
Ref: 76872041774
Node: C.62043066
Ref: 76882043636
Ref: 76892043636
Ref: 76902043713
Ref: 76912043713
Ref: 76922043784
Ref: 76932043784
Ref: 76942044066
Ref: 76952044066
Ref: 76962044159
Ref: 76972044159
Ref: 76982044433
Ref: 76992044433
Ref: 77002044625
Ref: 77012044958
Ref: 77022045734
Ref: 77032045734
Ref: 77042046009
Ref: 77052048659
Ref: 77062048766
Ref: 77072049177
Node: C.72050193
Node: C.7.12050732
Ref: 77082051016
Ref: 77092051080
Ref: 77102051158
Ref: 77112051281
Ref: 77122051351
Ref: 77132051402
Ref: 77142051453
Ref: 77152051517
Ref: 77162051588
Ref: 77172051659
Ref: 77182053254
Ref: 77192053269
Ref: 77202053463
Ref: 77212053478
Ref: 77222053795
Ref: 77232053922
Ref: 77242053922
Ref: 77252054047
Ref: 77262054178
Ref: 77272054324
Node: C.7.22055153
Ref: 77282055595
Ref: 77292055612
Ref: 77302055674
Ref: 77312055757
Ref: 77322055852
Ref: 77332055961
Ref: 77342057141
Ref: 77352057256
Ref: 77362057657
Ref: 77372058142
Ref: 77382058342
Ref: 77392058542
Node: C.7.32063490
Ref: 77402063828
Ref: 77412063894
Ref: 77422063977
Ref: 77432064209
Ref: 77442064303
Ref: 77452064384
Ref: 77462064525
Ref: 77472064707
Ref: 77482064707
Ref: 77492065804
Ref: 77502065804
Ref: 77512065804
Ref: 77522065804
Ref: 77532065804
Ref: 77542065804
Node: Annex D2068046
Ref: 77552068181
Ref: 77562068181
Node: D.12071465
Ref: 77572072210
Ref: 77582072210
Ref: 77592072346
Ref: 77602072346
Ref: 77612073869
Ref: 77622073869
Ref: 77632073869
Ref: 77642073869
Ref: 77652073869
Ref: 77662074848
Ref: 77672075254
Ref: 77682075255
Node: D.22077917
Node: D.2.12078436
Ref: 77692078818
Ref: 77702078884
Ref: 77712078900
Ref: 77722079490
Ref: 77732079490
Ref: 77742079490
Ref: 77752079490
Ref: 77762079880
Ref: 77772079880
Ref: 77782079880
Ref: 77792079880
Ref: 77802079880
Ref: 77812079880
Ref: 77822080665
Ref: 77832082133
Node: D.2.22083829
Ref: 77842084289
Ref: 77852084290
Ref: 77862084321
Ref: 77872084432
Ref: 77882084433
Ref: 77892084482
Ref: 77902084509
Ref: 77912084535
Ref: 77922086094
Ref: 77932086094
Ref: 77942086220
Ref: 77952086221
Ref: 77962086586
Ref: 77972087000
Node: D.2.32088386
Ref: 77982088709
Ref: 77992088709
Ref: 78002089798
Ref: 78012089798
Ref: 78022090210
Ref: 78032090538
Node: D.2.42091628
Ref: 78042091978
Ref: 78052091978
Ref: 78062092094
Ref: 78072092156
Ref: 78082092190
Ref: 78092093796
Ref: 78102093796
Node: D.2.52094988
Ref: 78112095369
Ref: 78122095369
Ref: 78132095521
Ref: 78142095524
Ref: 78152095642
Ref: 78162095771
Ref: 78172095903
Ref: 78182096008
Node: D.2.62098967
Ref: 78192099747
Ref: 78202099747
Ref: 78212099908
Ref: 78222099924
Ref: 78232099958
Ref: 78242100064
Ref: 78252100231
Ref: 78262100405
Ref: 78272100876
Ref: 78282100876
Ref: 78292105258
Ref: 78302105624
Node: D.32106658
Ref: 78312107104
Ref: 78322107105
Ref: 78332107127
Ref: 78342107199
Ref: 78352107270
Ref: 78362107335
Ref: 78372107335
Ref: 78382107438
Ref: 78392108244
Ref: 78402108740
Ref: 78412108741
Ref: 78422108836
Ref: 78432108836
Ref: 78442108847
Ref: 78452110222
Ref: 78462110222
Ref: 78472110222
Ref: 78482110696
Ref: 78492110848
Ref: 78502111144
Node: D.42113853
Ref: 78512113984
Ref: 78522114263
Ref: 78532114264
Ref: 78542114286
Ref: 78552114358
Ref: 78562114444
Ref: 78572114509
Ref: 78582114509
Ref: 78592114610
Ref: 78602115054
Ref: 78612115054
Ref: 78622115185
Ref: 78632115185
Ref: 78642115194
Node: D.52117879
Node: D.5.12118206
Ref: 78652118659
Ref: 78662118732
Ref: 78672118946
Ref: 78682119438
Ref: 78692119493
Ref: 78702119858
Node: D.5.22122670
Ref: 78712123083
Ref: 78722123098
Ref: 78732124155
Node: D.62125096
Node: D.72128175
Ref: 78742128593
Ref: 78752128593
Ref: 78762128711
Ref: 78772128711
Ref: 78782129144
Ref: 78792129144
Ref: 78802129299
Ref: 78812129299
Ref: 78822129418
Ref: 78832129418
Ref: 78842129870
Ref: 78852129874
Ref: 78862129874
Ref: 78872130351
Ref: 78882130352
Ref: 78892130359
Ref: 78902130359
Ref: 78912130646
Ref: 78922130646
Ref: 78932131218
Ref: 78942131218
Ref: 78952131322
Ref: 78962131322
Ref: 78972131418
Ref: 78982131418
Ref: 78992131901
Ref: 79002131910
Ref: 79012131910
Ref: 79022132137
Ref: 79032132137
Ref: 79042132215
Ref: 79052132215
Ref: 79062132291
Ref: 79072132291
Ref: 79082132492
Ref: 79092132492
Ref: 79102133012
Ref: 79112133012
Ref: 79122133307
Ref: 79132133307
Ref: 79142133433
Ref: 79152133433
Ref: 79162134108
Ref: 79172134109
Ref: 79182134229
Ref: 79192134229
Ref: 79202134640
Ref: 79212134640
Ref: 79222134945
Ref: 79232134946
Ref: 79242134946
Ref: 79252135019
Ref: 79262135019
Ref: 79272135527
Ref: 79282135528
Ref: 79292135528
Ref: 79302135600
Ref: 79312135600
Ref: 79322136075
Ref: 79332136076
Ref: 79342136076
Ref: 79352136150
Ref: 79362136150
Ref: 79372136428
Ref: 79382136437
Ref: 79392136437
Ref: 79402137147
Node: D.82137703
Ref: 79412138023
Ref: 79422138039
Ref: 79432138058
Ref: 79442138093
Ref: 79452138127
Ref: 79462138207
Ref: 79472138231
Ref: 79482138276
Ref: 79492138320
Ref: 79502138364
Ref: 79512138411
Ref: 79522138459
Ref: 79532139823
Ref: 79542139885
Ref: 79552139953
Ref: 79562140015
Ref: 79572140077
Ref: 79582140139
Ref: 79592140201
Ref: 79602140263
Ref: 79612140331
Ref: 79622140411
Ref: 79632140558
Ref: 79642140964
Ref: 79652140964
Ref: 79662142458
Ref: 79672144980
Ref: 79682146492
Node: D.92148204
Ref: 79692149202
Ref: 79702149202
Ref: 79712150779
Ref: 79722150779
Node: D.102152199
Ref: 79732152686
Ref: 79742152756
Ref: 79752152811
Ref: 79762152868
Ref: 79772152925
Ref: 79782152995
Ref: 79792153307
Ref: 79802153326
Ref: 79812154096
Ref: 79822154096
Ref: 79832154096
Node: D.10.12155199
Ref: 79842155621
Ref: 79852155694
Ref: 79862155773
Ref: 79872155872
Node: D.112157509
Ref: 79882158015
Ref: 79892158088
Ref: 79902158151
Ref: 79912158217
Ref: 79922158378
Ref: 79932158378
Ref: 79942158378
Ref: 79952159345
Ref: 79962159389
Ref: 79972159500
Node: D.122161713
Node: D.132164538
Ref: 79982164717
Node: D.142167760
Ref: 79992168183
Ref: 80002168202
Ref: 80012168226
Ref: 80022168270
Ref: 80032168314
Ref: 80042168387
Ref: 80052168445
Ref: 80062169171
Ref: 80072169272
Ref: 80082169388
Ref: 80092169476
Ref: 80102169597
Ref: 80112169734
Ref: 80122169734
Ref: 80132171220
Ref: 80142172625
Node: D.14.12174714
Ref: 80152175160
Ref: 80162175179
Ref: 80172175332
Ref: 80182175416
Ref: 80192175530
Ref: 80202175700
Ref: 80212175868
Ref: 80222175937
Ref: 80232176064
Ref: 80242176118
Ref: 80252176671
Ref: 80262176672
Ref: 80272176844
Ref: 80282177998
Ref: 80292179500
Node: D.14.22180427
Ref: 80302180898
Ref: 80312180916
Ref: 80322181086
Ref: 80332181194
Ref: 80342181316
Ref: 80352181430
Ref: 80362181552
Ref: 80372181678
Ref: 80382181804
Ref: 80392181902
Ref: 80402181971
Ref: 80412182045
Ref: 80422182118
Ref: 80432182189
Ref: 80442182267
Ref: 80452182393
Ref: 80462182485
Ref: 80472182601
Ref: 80482182880
Ref: 80492183337
Ref: 80502183337
Ref: 80512183337
Ref: 80522183596
Ref: 80532183597
Ref: 80542187456
Node: D.14.32188339
Ref: 80552188782
Ref: 80562188800
Ref: 80572188895
Node: D.152190082
Ref: 80582190534
Ref: 80592190552
Ref: 80602190604
Ref: 80612190720
Ref: 80622190896
Ref: 80632191076
Ref: 80642191173
Ref: 80652191302
Ref: 80662191579
Ref: 80672191793
Ref: 80682191794
Ref: 80692191979
Node: D.162195151
Ref: 80702195521
Ref: 80712195586
Ref: 80722195637
Ref: 80732195704
Ref: 80742195770
Ref: 80752196297
Ref: 80762196297
Node: D.16.12197793
Ref: 80772198301
Ref: 80782198310
Ref: 80792198371
Ref: 80802198423
Ref: 80812198507
Ref: 80822198595
Ref: 80832198673
Ref: 80842198755
Ref: 80852198822
Ref: 80862198896
Ref: 80872198977
Ref: 80882199180
Ref: 80892199449
Ref: 80902199629
Ref: 80912199808
Ref: 80922200050
Ref: 80932200915
Ref: 80942200915
Node: Annex E2206409
Ref: 80952206768
Ref: 80962206768
Ref: 80972206768
Ref: 80982207069
Ref: 80992207210
Node: E.12208507
Ref: 81002208736
Ref: 81012208736
Ref: 81022209513
Ref: 81032209655
Ref: 81042209948
Ref: 81052209948
Ref: 81062209948
Ref: 81072209948
Ref: 81082210537
Ref: 81092210552
Ref: 81102210929
Ref: 81112211060
Node: E.22212770
Ref: 81122213183
Ref: 81132213183
Ref: 81142213183
Ref: 81152213183
Ref: 81162213183
Ref: 81172213183
Ref: 81182213872
Ref: 81192214006
Ref: 81202214139
Ref: 81212214247
Node: E.2.12215797
Ref: 81222216305
Ref: 81232216310
Ref: 81242216377
Ref: 81252216378
Ref: 81262216407
Ref: 81272216465
Ref: 81282216599
Ref: 81292216599
Ref: 81302217400
Ref: 81312217400
Ref: 81322217719
Ref: 81332217921
Ref: 81342217921
Ref: 81352217921
Node: E.2.22218219
Ref: 81362218528
Ref: 81372218533
Ref: 81382218598
Ref: 81392218599
Ref: 81402218626
Ref: 81412218684
Ref: 81422218812
Ref: 81432218812
Ref: 81442219505
Ref: 81452219641
Ref: 81462219642
Node: E.2.32223488
Ref: 81472223832
Ref: 81482223837
Ref: 81492223911
Ref: 81502223912
Ref: 81512223948
Ref: 81522224033
Ref: 81532224034
Ref: 81542224065
Ref: 81552224076
Ref: 81562224081
Ref: 81572224183
Ref: 81582224183
Ref: 81592224183
Ref: 81602224183
Ref: 81612224183
Ref: 81622224331
Ref: 81632224331
Ref: 81642225713
Ref: 81652225714
Ref: 81662226184
Ref: 81672226184
Ref: 81682226184
Node: E.32227552
Ref: 81692227978
Ref: 81702227993
Ref: 81712228189
Ref: 81722228204
Ref: 81732228418
Ref: 81742228759
Ref: 81752229146
Ref: 81762229146
Ref: 81772229558
Node: E.42229725
Ref: 81782229856
Ref: 81792229856
Ref: 81802229856
Ref: 81812229856
Ref: 81822229856
Ref: 81832231357
Ref: 81842231357
Ref: 81852231357
Ref: 81862232044
Ref: 81872232044
Ref: 81882232345
Ref: 81892232785
Ref: 81902233785
Ref: 81912233785
Ref: 81922233885
Ref: 81932233885
Ref: 81942234176
Ref: 81952234333
Ref: 81962234333
Ref: 81972234686
Node: E.4.12236181
Ref: 81982236917
Ref: 81992236917
Ref: 82002237776
Ref: 82012237776
Node: E.4.22238392
Node: E.52242372
Ref: 82022242513
Ref: 82032242513
Ref: 82042242909
Ref: 82052242926
Ref: 82062242983
Ref: 82072243037
Ref: 82082243200
Ref: 82092243388
Ref: 82102243547
Ref: 82112243750
Ref: 82122243909
Ref: 82132244068
Ref: 82142245364
Ref: 82152245739
Ref: 82162246405
Ref: 82172246405
Node: Annex F2249098
Ref: 82182249237
Node: F.12251096
Ref: 82192251297
Ref: 82202251297
Ref: 82212251579
Ref: 82222251579
Node: F.22251926
Ref: 82232252184
Ref: 82242252221
Ref: 82252252277
Ref: 82262252336
Ref: 82272252388
Ref: 82282252443
Ref: 82292252760
Node: F.32254439
Ref: 82302254729
Node: F.3.12259645
Ref: 82312259772
Ref: 82322259772
Node: F.3.22266796
Ref: 82332268037
Node: F.3.32279010
Ref: 82342279765
Ref: 82352279782
Ref: 82362279822
Ref: 82372279957
Ref: 82382280113
Ref: 82392280180
Ref: 82402280237
Ref: 82412280306
Ref: 82422280351
Ref: 82432280408
Ref: 82442280465
Ref: 82452280522
Ref: 82462281052
Ref: 82472281090
Ref: 82482281245
Ref: 82492281444
Ref: 82502281873
Ref: 82512282320
Ref: 82522282714
Node: F.3.42289831
Ref: 82532290032
Ref: 82542290032
Node: F.3.52290669
Ref: 82552290868
Ref: 82562290868
Node: Annex G2291555
Ref: 82572291672
Node: G.12293247
Node: G.1.12294186
Ref: 82582294442
Ref: 82592294586
Ref: 82602294690
Ref: 82612294774
Ref: 82622294806
Ref: 82632294855
Ref: 82642294909
Ref: 82652294963
Ref: 82662295021
Ref: 82672295118
Ref: 82682295215
Ref: 82692295316
Ref: 82702295393
Ref: 82712295470
Ref: 82722295550
Ref: 82732295692
Ref: 82742295756
Ref: 82752295868
Ref: 82762295970
Ref: 82772296198
Ref: 82782296717
Ref: 82792299459
Ref: 82802303155
Ref: 82812303155
Ref: 82822303155
Ref: 82832303497
Ref: 82842303852
Node: G.1.22309923
Ref: 82852310284
Ref: 82862310554
Ref: 82872310608
Ref: 82882310662
Ref: 82892310716
Ref: 82902311001
Ref: 82912311052
Ref: 82922311103
Ref: 82932311154
Ref: 82942311208
Ref: 82952311262
Ref: 82962311316
Ref: 82972311370
Ref: 82982311427
Ref: 82992311479
Ref: 83002311531
Ref: 83012311583
Ref: 83022311638
Ref: 83032311693
Ref: 83042311748
Ref: 83052311803
Ref: 83062311909
Ref: 83072316412
Ref: 83082316412
Ref: 83092316412
Ref: 83102317362
Ref: 83112317746
Ref: 83122320310
Ref: 83132321112
Node: G.1.32321990
Ref: 83142322668
Ref: 83152322841
Ref: 83162322876
Ref: 83172322925
Ref: 83182322978
Ref: 83192323116
Ref: 83202323211
Ref: 83212323464
Ref: 83222323676
Ref: 83232323806
Ref: 83242324029
Node: G.1.42330701
Ref: 83252330908
Ref: 83262330908
Node: G.1.52331319
Ref: 83272331524
Ref: 83282331524
Node: G.22331955
Ref: 83292332156
Ref: 83302332156
Ref: 83312332636
Node: G.2.12333229
Ref: 83322334251
Ref: 83332334539
Ref: 83342334640
Ref: 83352335019
Ref: 83362335408
Ref: 83372336367
Ref: 83382336367
Ref: 83392336646
Node: G.2.22337610
Ref: 83402338149
Ref: 83412338149
Ref: 83422338843
Ref: 83432338843
Ref: 83442339185
Ref: 83452339185
Ref: 83462339982
Ref: 83472339982
Ref: 83482340779
Ref: 83492340781
Ref: 83502340781
Ref: 83512341117
Ref: 83522341118
Node: G.2.32342574
Ref: 83532343938
Ref: 83542344105
Ref: 83552349653
Ref: 83562349654
Ref: 83572349805
Node: G.2.42350024
Ref: 83582350375
Ref: 83592350375
Ref: 83602350837
Ref: 83612350838
Ref: 83622350990
Ref: 83632352003
Node: G.2.52355694
Node: G.2.62357461
Ref: 83642358129
Ref: 83652358594
Ref: 83662358867
Ref: 83672359252
Ref: 83682359253
Ref: 83692359500
Node: G.32364998
Node: G.3.12365756
Ref: 83702366117
Ref: 83712366200
Ref: 83722366267
Ref: 83732367410
Ref: 83742367892
Ref: 83752368843
Ref: 83762368921
Ref: 83772368985
Ref: 83782369048
Ref: 83792369187
Ref: 83802369261
Ref: 83812369487
Ref: 83822369716
Ref: 83832371177
Ref: 83842373444
Ref: 83852380828
Node: G.3.22383452
Ref: 83862384115
Ref: 83872384201
Ref: 83882384269
Ref: 83892384535
Ref: 83902384596
Ref: 83912384663
Ref: 83922384769
Ref: 83932384879
Ref: 83942384976
Ref: 83952385079
Ref: 83962385291
Ref: 83972385362
Ref: 83982385490
Ref: 83992385594
Ref: 84002385978
Ref: 84012387892
Ref: 84022388203
Ref: 84032388264
Ref: 84042388332
Ref: 84052388438
Ref: 84062388549
Ref: 84072388646
Ref: 84082388749
Ref: 84092388967
Ref: 84102389038
Ref: 84112389166
Ref: 84122389270
Ref: 84132389652
Ref: 84142389727
Ref: 84152392618
Ref: 84162392716
Ref: 84172392786
Ref: 84182392855
Ref: 84192392990
Ref: 84202393066
Ref: 84212393298
Ref: 84222393533
Ref: 84232395291
Ref: 84242402696
Ref: 84252417688
Node: Annex H2420901
Ref: 84262421048
Ref: 84272421048
Ref: 84282421709
Ref: 84292421838
Ref: 84302421839
Node: H.12422322
Ref: 84312422689
Ref: 84322422690
Ref: 84332422761
Ref: 84342422761
Node: H.22424134
Ref: 84352424352
Node: H.32425151
Node: H.3.12425453
Ref: 84362425948
Ref: 84372425949
Ref: 84382426013
Ref: 84392426013
Node: H.3.22428808
Ref: 84402429334
Ref: 84412429335
Ref: 84422429360
Ref: 84432429375
Ref: 84442429645
Ref: 84452429780
Node: H.42431506
Ref: 84462432037
Ref: 84472432037
Ref: 84482432199
Ref: 84492432199
Ref: 84502432275
Ref: 84512432275
Ref: 84522432420
Ref: 84532432420
Ref: 84542432517
Ref: 84552432517
Ref: 84562432603
Ref: 84572432603
Ref: 84582433123
Ref: 84592433124
Ref: 84602433164
Ref: 84612433164
Ref: 84622433454
Ref: 84632433454
Ref: 84642433640
Ref: 84652433640
Ref: 84662433965
Ref: 84672433966
Ref: 84682433971
Ref: 84692433971
Ref: 84702434009
Ref: 84712434010
Ref: 84722434057
Ref: 84732434057
Ref: 84742434173
Ref: 84752434173
Ref: 84762434373
Ref: 84772434373
Ref: 84782434494
Ref: 84792434494
Ref: 84802434619
Ref: 84812434619
Ref: 84822436181
Ref: 84832436366
Node: H.52437014
Ref: 84842437384
Ref: 84852437385
Ref: 84862437456
Ref: 84872437456
Node: H.62438126
Ref: 84882438479
Ref: 84892438480
Ref: 84902438517
Ref: 84912438701
Ref: 84922438701
Ref: 84932439103
Node: Annex J2441311
Ref: 84942441454
Node: J.12442412
Node: J.22443510
Node: J.32444675
Ref: 84952445190
Ref: S03222445190
Ref: 84962445208
Ref: 84972445227
Ref: 84982445305
Ref: 84992445615
Ref: 85002446817
Ref: 85012447039
Ref: 85022447278
Node: J.42447378
Ref: 85032447629
Ref: 85042447629
Node: J.52448159
Node: J.62450763
Node: J.72451054
Ref: 85052451214
Ref: S03232451214
Ref: 85062451223
Ref: 85072451242
Node: J.7.12451473
Ref: 85082452000
Ref: 85092452002
Ref: 85102452002
Ref: 85112452404
Ref: 85122452564
Ref: 85132452839
Ref: 85142452989
Ref: 85152453658
Node: J.82456193
Ref: 85162456356
Ref: S03242456356
Ref: 85172456375
Node: J.92456686
Ref: 85182456935
Ref: 85192456935
Ref: 85202457146
Node: J.102457450
Ref: 85212457793
Ref: 85222457794
Ref: 85232457803
Ref: 85242457822
Node: J.112459087
Ref: 85252459463
Ref: 85262459463
Node: J.122459754
Node: J.132460100
Ref: 85272460542
Ref: 85282460689
Ref: 85292460840
Node: J.142460992
Node: J.152462256
Node: J.15.12462960
Ref: 85302463217
Ref: 85312463217
Ref: 85322463237
Ref: 85332463238
Ref: 85342463246
Ref: 85352463252
Node: J.15.22463966
Ref: 85362464247
Ref: 85372464247
Ref: 85382464267
Ref: 85392464268
Ref: 85402464289
Ref: 85412464312
Node: J.15.32464767
Ref: 85422465033
Ref: 85432465033
Ref: 85442465053
Ref: 85452465054
Ref: 85462465074
Node: J.15.42465400
Ref: 85472465650
Ref: 85482465651
Ref: 85492465665
Ref: 85502465901
Node: J.15.52466137
Ref: 85512466315
Ref: 85522466320
Ref: 85532466320
Ref: 85542466320
Ref: 85552466320
Ref: 85562466320
Ref: 85572466320
Ref: 85582466320
Ref: 85592466320
Ref: 85602466320
Ref: 85612466320
Ref: 85622466320
Ref: 85632466320
Ref: 85642466479
Ref: 85652466480
Ref: 85662466525
Ref: 85672466548
Ref: 85682466610
Ref: 85692466664
Ref: 85702466696
Ref: 85712466697
Ref: 85722466742
Ref: 85732466765
Ref: 85742466827
Ref: 85752466881
Ref: 85762466913
Ref: 85772466914
Ref: 85782466952
Ref: 85792466979
Ref: 85802467231
Ref: 85812467231
Ref: 85822467574
Node: J.15.62469156
Ref: 85832469455
Ref: 85842469455
Ref: 85852469475
Ref: 85862469476
Ref: 85872469507
Node: J.15.72469917
Ref: 85882470222
Ref: 85892470223
Ref: 85902470250
Ref: 85912470336
Ref: 85922470337
Ref: 85932470361
Ref: 85942470366
Ref: 85952470701
Ref: 85962471075
Node: J.15.82471730
Ref: 85972472087
Ref: 85982472088
Ref: 85992472096
Ref: 86002472127
Ref: 86012472128
Ref: 86022472138
Ref: 86032472169
Ref: 86042472170
Ref: 86052472193
Ref: 86062472224
Ref: 86072472225
Ref: 86082472250
Ref: 86092472281
Ref: 86102472282
Ref: 86112472309
Ref: 86122472340
Ref: 86132472341
Ref: 86142472365
Ref: 86152473306
Ref: 86162473307
Ref: 86172473307
Ref: 86182473307
Ref: 86192473307
Ref: 86202473307
Ref: 86212473307
Ref: 86222473307
Ref: 86232473307
Ref: 86242473307
Ref: 86252473307
Ref: 86262473307
Node: J.15.92473479
Ref: 86272473703
Ref: 86282473704
Ref: 86292473709
Ref: 86302473865
Node: J.15.102474572
Ref: 86312474844
Ref: 86322474845
Ref: 86332475034
Node: J.15.112475485
Ref: 86342475776
Ref: 86352475777
Ref: 86362475883
Ref: 86372475884
Ref: 86382476064
Ref: 86392476064
Node: J.15.122477503
Ref: 86402477773
Ref: 86412477774
Ref: 86422477954
Node: J.15.132478589
Ref: 86432478868
Ref: 86442478868
Ref: 86452478888
Ref: 86462478889
Ref: 86472478903
Node: Annex K2479324
Node: K.12479754
Ref: 86482479877
Node: K.22490426
Ref: 86492490555
Ref: 86502492168
Ref: 86512492379
Ref: 86522492380
Ref: 86532496768
Ref: 86542496783
Ref: 86552498160
Ref: 86562498530
Ref: 86572498531
Ref: 86582499336
Ref: 86592499545
Ref: 86602499546
Ref: 86612502482
Ref: 86622502497
Ref: 86632502803
Ref: 86642502803
Ref: 86652512965
Ref: 86662512980
Ref: 86672512980
Ref: 86682514164
Ref: 86692514415
Ref: 86702514416
Ref: 86712518463
Ref: 86722528059
Ref: 86732528224
Ref: 86742528225
Ref: 86752528726
Ref: 86762528727
Ref: 86772531430
Ref: 86782531747
Ref: 86792531748
Ref: 86802535016
Ref: 86812535610
Ref: 86822535910
Ref: 86832535911
Ref: 86842539937
Ref: 86852540102
Ref: 86862540103
Ref: 86872540589
Ref: 86882540590
Ref: 86892543395
Ref: 86902543410
Ref: 86912543920
Ref: 86922545076
Ref: 86932546278
Node: Annex L2549354
Ref: 86942549503
Ref: 86952549599
Ref: 86962549600
Ref: 86972549631
Ref: 86982549674
Ref: 86992549675
Ref: 87002549701
Ref: 87012549734
Ref: 87022549785
Ref: 87032549786
Ref: 87042549810
Ref: 87052549859
Ref: 87062549860
Ref: 87072549897
Ref: 87082549919
Ref: 87092549948
Ref: 87102549970
Ref: 87112550054
Ref: 87122550055
Ref: 87132550069
Ref: 87142550153
Ref: 87152550154
Ref: 87162550162
Ref: 87172550245
Ref: 87182550246
Ref: 87192550271
Ref: 87202550354
Ref: 87212550355
Ref: 87222550379
Ref: 87232550384
Ref: 87242550502
Ref: 87252550503
Ref: 87262550541
Ref: 87272550563
Ref: 87282550613
Ref: 87292550614
Ref: 87302550619
Ref: 87312550668
Ref: 87322550669
Ref: 87332550691
Ref: 87342550753
Ref: 87352550754
Ref: 87362550800
Ref: 87372550801
Ref: 87382550824
Ref: 87392550872
Ref: 87402550873
Ref: 87412550940
Ref: 87422550941
Ref: 87432550964
Ref: 87442550984
Ref: 87452551025
Ref: 87462551026
Ref: 87472551053
Ref: 87482551073
Ref: 87492551114
Ref: 87502551115
Ref: 87512551144
Ref: 87522551224
Ref: 87532551225
Ref: 87542551265
Ref: 87552551288
Ref: 87562551345
Ref: 87572551394
Ref: 87582551480
Ref: 87592551481
Ref: 87602551521
Ref: 87612551544
Ref: 87622551601
Ref: 87632551650
Ref: 87642551701
Ref: 87652551702
Ref: 87662551725
Ref: 87672551775
Ref: 87682551776
Ref: 87692551800
Ref: 87702551885
Ref: 87712551886
Ref: 87722551894
Ref: 87732551900
Ref: 87742551942
Ref: 87752551943
Ref: 87762551968
Ref: 87772551983
Ref: 87782552063
Ref: 87792552064
Ref: 87802552091
Ref: 87812552170
Ref: 87822552171
Ref: 87832552240
Ref: 87842552241
Ref: 87852552263
Ref: 87862552306
Ref: 87872552307
Ref: 87882552312
Ref: 87892552355
Ref: 87902552356
Ref: 87912552378
Ref: 87922552462
Ref: 87932552463
Ref: 87942552484
Ref: 87952552507
Ref: 87962552554
Ref: 87972552555
Ref: 87982552604
Ref: 87992552605
Ref: 88002552614
Ref: 88012552696
Ref: 88022552697
Ref: 88032552717
Ref: 88042552763
Ref: 88052552764
Ref: 88062552804
Ref: 88072552805
Ref: 88082552842
Ref: 88092552889
Ref: 88102552890
Ref: 88112552919
Ref: 88122552966
Ref: 88132552967
Ref: 88142552994
Ref: 88152553074
Ref: 88162553075
Ref: 88172553136
Ref: 88182553137
Ref: 88192553181
Ref: 88202553208
Ref: 88212553234
Ref: 88222553284
Ref: 88232553285
Ref: 88242553302
Ref: 88252553324
Ref: 88262553425
Ref: 88272553426
Ref: 88282553445
Ref: 88292553486
Ref: 88302553487
Ref: 88312553509
Ref: 88322553593
Ref: 88332553594
Ref: 88342553678
Ref: 88352553679
Ref: 88362553715
Ref: 88372553755
Ref: 88382553756
Ref: 88392553783
Ref: 88402553823
Ref: 88412553824
Ref: 88422553837
Ref: 88432553850
Ref: 88442553898
Ref: 88452553899
Ref: 88462553943
Ref: 88472553944
Ref: 88482553973
Ref: 88492554052
Ref: 88502554053
Ref: 88512554067
Ref: 88522554113
Ref: 88532554114
Ref: 88542554123
Ref: 88552554167
Ref: 88562554168
Ref: 88572554199
Ref: 88582554285
Ref: 88592554286
Ref: 88602554317
Ref: 88612554367
Ref: 88622554368
Ref: 88632554379
Ref: 88642554462
Ref: 88652554463
Ref: 88662554473
Ref: 88672554558
Ref: 88682554559
Ref: 88692554586
Node: Annex M2554623
Ref: 88702554800
Node: M.12555545
Ref: 88712555690
Ref: 88722555690
Node: M.22562959
Ref: 88732563122
Ref: 88742563201
Ref: 88752577718
Node: M.32584277
Ref: 88762584394
Ref: 88772584394
Node: Annex N2614791
Ref: 88782614910
Ref: 88792615132
Ref: 88802615286
Ref: 88812615450
Ref: 88822615767
Ref: 88832616010
Ref: 88842616145
Ref: 88852616345
Ref: 88862616629
Ref: 88872616837
Ref: 88882616932
Ref: 88892616949
Ref: 88902617213
Ref: 88912617473
Ref: 88922617531
Ref: 88932617672
Ref: 88942617902
Ref: 88952618047
Ref: 88962618149
Ref: 88972618150
Ref: 88982618412
Ref: 88992618947
Ref: 89002619114
Ref: 89012619285
Ref: 89022619552
Ref: 89032619704
Ref: 89042619771
Ref: 89052619919
Ref: 89062620068
Ref: 89072620219
Ref: 89082620361
Ref: 89092620467
Ref: 89102620561
Ref: 89112620562
Ref: 89122620680
Ref: 89132620796
Ref: 89142621439
Ref: 89152621692
Ref: 89162621859
Ref: 89172622322
Ref: 89182622664
Ref: 89192622828
Ref: 89202622997
Ref: 89212623212
Ref: 89222623474
Ref: 89232623576
Ref: 89242623750
Ref: 89252623998
Ref: 89262624174
Ref: 89272624563
Ref: 89282624741
Ref: 89292625073
Ref: 89302625195
Ref: 89312625420
Ref: 89322625537
Ref: 89332625645
Ref: 89342626262
Ref: 89352626401
Ref: 89362626680
Ref: 89372626805
Ref: 89382627049
Ref: 89392627234
Ref: 89402627567
Ref: 89412627757
Ref: 89422627895
Ref: 89432628006
Ref: 89442628136
Ref: 89452628272
Ref: 89462628412
Ref: 89472628490
Ref: 89482628795
Ref: 89492628974
Ref: 89502629289
Ref: 89512629534
Ref: 89522629782
Ref: 89532630231
Ref: 89542630460
Ref: 89552630738
Ref: 89562630776
Node: Annex P2630899
Ref: 89572631026
Ref: 89582631026
Ref: 89592631026
Ref: 89602631026
Ref: 89612631026
Ref: 89622631192
Ref: 89632631210
Ref: 89642631229
Ref: 89652631304
Ref: 89662631331
Ref: 89672631358
Ref: 89682631385
Ref: 89692631411
Ref: 89702631434
Ref: 89712631505
Ref: 89722631532
Ref: 89732631565
Ref: 89742631590
Ref: 89752631656
Ref: 89762631674
Ref: 89772631734
Ref: 89782631744
Ref: 89792631754
Ref: 89802631802
Ref: 89812631810
Ref: 89822631821
Ref: 89832631873
Ref: 89842631887
Ref: 89852632022
Ref: 89862632029
Ref: 89872632045
Ref: 89882632063
Ref: 89892632108
Ref: 89902632169
Ref: 89912632186
Ref: 89922632197
Ref: 89932632258
Ref: 89942632335
Ref: 89952632399
Ref: 89962632483
Ref: 89972632556
Ref: 89982632618
Ref: 89992632631
Ref: 90002632662
Ref: 90012632784
Ref: 90022632799
Ref: 90032632831
Ref: 90042632846
Ref: 90052632883
Ref: 90062632899
Ref: 90072632930
Ref: 90082632946
Ref: 90092633014
Ref: 90102633035
Ref: 90112633065
Ref: 90122633088
Ref: 90132633117
Ref: 90142633144
Ref: 90152633186
Ref: 90162633217
Ref: 90172633259
Ref: 90182633283
Ref: 90192633314
Ref: 90202633340
Ref: 90212633370
Ref: 90222633440
Ref: 90232633499
Ref: 90242633531
Ref: 90252633569
Ref: 90262633604
Ref: 90272633702
Ref: 90282633723
Ref: 90292633751
Ref: 90302633787
Ref: 90312633820
Ref: 90322633852
Ref: 90332633936
Ref: 90342633968
Ref: 90352634002
Ref: 90362634027
Ref: 90372634059
Ref: 90382634086
Ref: 90392634119
Ref: 90402634147
Ref: 90412634240
Ref: 90422634263
Ref: 90432634296
Ref: 90442634370
Ref: 90452634386
Ref: 90462634400
Ref: 90472634463
Ref: 90482634509
Ref: 90492634529
Ref: 90502634609
Ref: 90512634628
Ref: 90522634648
Ref: 90532634727
Ref: 90542634746
Ref: 90552634829
Ref: 90562634877
Ref: 90572634906
Ref: 90582634932
Ref: 90592634964
Ref: 90602635012
Ref: 90612635040
Ref: 90622635066
Ref: 90632635098
Ref: 90642635146
Ref: 90652635178
Ref: 90662635204
Ref: 90672635236
Ref: 90682635269
Ref: 90692635361
Ref: 90702635384
Ref: 90712635465
Ref: 90722635511
Ref: 90732635617
Ref: 90742635642
Ref: 90752635664
Ref: 90762635739
Ref: 90772635780
Ref: 90782635816
Ref: 90792635837
Ref: 90802635923
Ref: 90812635960
Ref: 90822636067
Ref: 90832636089
Ref: 90842636179
Ref: 90852636251
Ref: 90862636284
Ref: 90872636388
Ref: 90882636422
Ref: 90892636505
Ref: 90902636576
Ref: 90912636604
Ref: 90922636705
Ref: 90932636717
Ref: 90942636819
Ref: 90952636847
Ref: 90962636918
Ref: 90972636952
Ref: 90982637073
Ref: 90992637085
Ref: 91002637193
Ref: 91012637218
Ref: 91022637230
Ref: 91032637333
Ref: 91042637352
Ref: 91052637429
Ref: 91062637462
Ref: 91072637565
Ref: 91082637593
Ref: 91092637623
Ref: 91102637703
Ref: 91112637798
Ref: 91122637829
Ref: 91132637868
Ref: 91142637954
Ref: 91152637975
Ref: 91162638049
Ref: 91172638086
Ref: 91182638153
Ref: 91192638171
Ref: 91202638242
Ref: 91212638263
Ref: 91222638315
Ref: 91232638343
Ref: 91242638494
Ref: 91252638524
Ref: 91262638617
Ref: 91272638645
Ref: 91282638661
Ref: 91292638678
Ref: 91302638712
Ref: 91312638739
Ref: 91322638761
Ref: 91332638834
Ref: 91342638909
Ref: 91352638937
Ref: 91362639042
Ref: 91372639072
Ref: 91382639091
Ref: 91392639189
Ref: 91402639288
Ref: 91412639399
Ref: 91422639415
Ref: 91432639442
Ref: 91442639458
Ref: 91452639531
Ref: 91462639555
Ref: 91472639628
Ref: 91482639655
Ref: 91492639680
Ref: 91502639720
Ref: 91512639813
Ref: 91522639840
Ref: 91532639860
Ref: 91542639939
Ref: 91552639974
Ref: 91562640040
Ref: 91572640059
Ref: 91582640122
Ref: 91592640151
Ref: 91602640178
Ref: 91612640250
Ref: 91622640341
Ref: 91632640372
Ref: 91642640423
Ref: 91652640571
Ref: 91662640648
Ref: 91672640676
Ref: 91682640759
Ref: 91692640775
Ref: 91702640813
Ref: 91712640829
Ref: 91722640936
Ref: 91732640961
Ref: 91742641148
Ref: 91752641204
Ref: 91762641344
Ref: 91772641378
Ref: 91782641401
Ref: 91792641446
Ref: 91802641474
Ref: 91812641518
Ref: 91822641617
Ref: 91832641638
Ref: 91842641723
Ref: 91852641797
Ref: 91862641822
Ref: 91872641889
Ref: 91882641909
Ref: 91892641925
Ref: 91902641970
Ref: 91912641984
Ref: 91922642045
Ref: 91932642063
Ref: 91942642078
Ref: 91952642090
Ref: 91962642149
Ref: 91972642165
Ref: 91982642196
Ref: 91992642218
Ref: 92002642234
Ref: 92012642257
Ref: 92022642287
Ref: 92032642307
Ref: 92042642331
Ref: 92052642353
Ref: 92062642384
Ref: 92072642410
Ref: 92082642471
Ref: 92092642484
Ref: 92102642535
Ref: 92112642542
Ref: 92122642612
Ref: 92132642670
Ref: 92142642723
Ref: 92152642730
Ref: 92162642744
Ref: 92172642793
Ref: 92182642800
Ref: 92192642865
Ref: 92202642874
Ref: 92212642932
Ref: 92222642945
Ref: 92232642965
Ref: 92242643031
Ref: 92252643038
Ref: 92262643120
Ref: 92272643139
Ref: 92282643247
Ref: 92292643254
Ref: 92302643352
Ref: 92312643434
Ref: 92322643517
Ref: 92332643524
Ref: 92342643590
Ref: 92352643609
Ref: 92362643631
Ref: 92372643701
Ref: 92382643810
Ref: 92392643842
Ref: 92402643963
Ref: 92412643989
Ref: 92422644010
Ref: 92432644111
Ref: 92442644138
Ref: 92452644231
Ref: 92462644250
Ref: 92472644329
Ref: 92482644342
Ref: 92492644409
Ref: 92502644438
Ref: 92512644528
Ref: 92522644540
Ref: 92532644554
Ref: 92542644577
Ref: 92552644591
Ref: 92562644614
Ref: 92572644636
Ref: 92582644650
Ref: 92592644740
Ref: 92602644771
Ref: 92612644869
Ref: 92622644893
Ref: 92632644913
Ref: 92642644990
Ref: 92652645004
Ref: 92662645019
Ref: 92672645038
Ref: 92682645058
Ref: 92692645071
Ref: 92702645086
Ref: 92712645104
Ref: 92722645124
Ref: 92732645138
Ref: 92742645205
Ref: 92752645226
Ref: 92762645253
Ref: 92772645273
Ref: 92782645300
Ref: 92792645321
Ref: 92802645348
Ref: 92812645374
Ref: 92822645401
Ref: 92832645426
Ref: 92842645498
Ref: 92852645517
Ref: 92862645537
Ref: 92872645604
Ref: 92882645623
Ref: 92892645643
Ref: 92902645679
Ref: 92912645706
Ref: 92922645739
Ref: 92932645807
Ref: 92942645828
Ref: 92952645900
Ref: 92962645920
Ref: 92972645928
Ref: 92982645994
Ref: 92992646017
Ref: 93002646023
Ref: 93012646052
Ref: 93022646091
Ref: 93032646099
Ref: 93042646120
Ref: 93052646163
Ref: 93062646175
Ref: 93072646190
Ref: 93082646204
Ref: 93092646257
Ref: 93102646282
Ref: 93112646299
Ref: 93122646317
Ref: 93132646324
Ref: 93142646337
Ref: 93152646358
Ref: 93162646385
Ref: 93172646890
Ref: 93182646906
Ref: 93192646978
Ref: 93202647003
Ref: 93212647029
Ref: 93222647054
Ref: 93232647090
Ref: 93242647150
Ref: 93252647232
Ref: 93262647255
Ref: 93272647295
Ref: 93282647397
Ref: 93292647444
Ref: 93302647511
Ref: 93312647522
Ref: 93322647560
Ref: 93332647583
Ref: 93342647594
Ref: 93352647620
Ref: 93362647730
Ref: 93372647795
Ref: 93382647808
Ref: 93392647829
Ref: 93402647842
Ref: 93412647906
Ref: 93422647920
Ref: 93432647934
Ref: 93442647947
Ref: 93452648009
Ref: 93462648032
Ref: 93472648064
Ref: 93482648087
Ref: 93492648174
Ref: 93502648231
Ref: 93512648242
Ref: 93522648254
Ref: 93532648309
Ref: 93542648316
Ref: 93552648336
Ref: 93562648343
Ref: 93572648407
Ref: 93582648432
Ref: 93592648457
Ref: 93602648482
Ref: 93612648501
Ref: 93622648536
Ref: 93632648564
Ref: 93642648595
Ref: 93652648617
Ref: 93662648643
Ref: 93672648663
Ref: 93682648689
Ref: 93692648762
Ref: 93702648779
Ref: 93712648804
Ref: 93722648823
Ref: 93732648849
Ref: 93742648885
Ref: 93752648906
Ref: 93762649014
Ref: 93772649086
Ref: 93782649165
Ref: 93792649173
Ref: 93802649239
Ref: 93812649265
Ref: 93822649303
Ref: 93832649329
Ref: 93842649378
Ref: 93852649486
Ref: 93862649512
Ref: 93872649551
Ref: 93882649666
Ref: 93892649701
Ref: 93902649782
Ref: 93912649817
Ref: 93922649854
Ref: 93932649904
Ref: 93942649968
Ref: 93952649992
Ref: 93962650035
Ref: 93972650124
Ref: 93982650157
Ref: 93992650248
Ref: 94002650290
Ref: 94012650304
Ref: 94022650327
Ref: 94032650375
Ref: 94042650440
Ref: 94052650501
Ref: 94062650555
Ref: 94072650610
Ref: 94082650686
Ref: 94092650698
Ref: 94102650764
Ref: 94112650832
Ref: 94122650863
Ref: 94132650902
Ref: 94142650988
Ref: 94152651021
Ref: 94162651106
Ref: 94172651133
Ref: 94182651217
Ref: 94192651237
Ref: 94202651312
Ref: 94212651332
Ref: 94222651345
Ref: 94232651409
Ref: 94242651438
Ref: 94252651525
Ref: 94262651545
Ref: 94272651615
Ref: 94282651683
Ref: 94292651746
Ref: 94302651827
Ref: 94312651848
Ref: 94322651864
Ref: 94332651887
Ref: 94342651907
Ref: 94352651975
Ref: 94362652002
Ref: 94372652090
Ref: 94382652127
Ref: 94392652133
Ref: 94402652149
Ref: 94412652172
Ref: 94422652201
Ref: 94432652228
Ref: 94442652250
Ref: 94452652384
Ref: 94462652415
Ref: 94472652453
Ref: 94482652490
Ref: 94492652535
Ref: 94502652580
Ref: 94512652666
Ref: 94522652691
Ref: 94532652698
Ref: 94542652782
Ref: 94552652805
Ref: 94562652812
Ref: 94572652895
Ref: 94582652920
Ref: 94592653021
Ref: 94602653039
Ref: 94612653119
Ref: 94622653141
Ref: 94632653206
Ref: 94642653292
Ref: 94652653334
Ref: 94662653370
Ref: 94672653453
Ref: 94682653505
Ref: 94692653612
Ref: 94702653633
Ref: 94712653722
Ref: 94722653752
Ref: 94732653797
Ref: 94742653890
Ref: 94752653920
Ref: 94762653959
Ref: 94772653984
Ref: 94782654016
Ref: 94792654046
Ref: 94802654084
Ref: 94812654107
Ref: 94822654178
Ref: 94832654269
Ref: 94842654310
Ref: 94852654347
Ref: 94862654400
Ref: 94872654440
Ref: 94882654458
Ref: 94892654534
Ref: 94902654575
Ref: 94912654612
Ref: 94922654657
Ref: 94932654704
Ref: 94942654722
Ref: 94952654802
Ref: 94962654823
Ref: 94972654901
Ref: 94982654996
Ref: 94992655017
Ref: 95002655098
Ref: 95012655138
Ref: 95022655180
Ref: 95032655310
Ref: 95042655331
Ref: 95052655406
Ref: 95062655422
Ref: 95072655488
Ref: 95082655504
Ref: 95092655580
Ref: 95102655619
Ref: 95112655661
Ref: 95122655701
Ref: 95132655744
Ref: 95142655841
Ref: 95152655864
Ref: 95162655880
Ref: 95172655914
Ref: 95182655933
Ref: 95192655965
Ref: 95202655987
Ref: 95212656020
Ref: 95222656039
Ref: 95232656123
Ref: 95242656179
Ref: 95252656193
Ref: 95262656283
Ref: 95272656332
Ref: 95282656346
Ref: 95292656442
Ref: 95302656473
Ref: 95312656522
Ref: 95322656541
Ref: 95332656651
Ref: 95342656708
Ref: 95352656727
Ref: 95362656779
Ref: 95372656838
Ref: 95382656857
Ref: 95392656908
Ref: 95402656966
Ref: 95412656985
Ref: 95422657077
Ref: 95432657098
Ref: 95442657137
Ref: 95452657178
Ref: 95462657209
Ref: 95472657293
Ref: 95482657328
Ref: 95492657368
Ref: 95502657399
Ref: 95512657473
Ref: 95522657512
Ref: 95532657541
Ref: 95542657591
Ref: 95552657611
Ref: 95562657682
Ref: 95572657716
Ref: 95582657751
Ref: 95592657792
Ref: 95602657841
Ref: 95612657932
Ref: 95622657953
Ref: 95632657992
Ref: 95642658032
Ref: 95652658063
Ref: 95662658160
Ref: 95672658194
Ref: 95682658234
Ref: 95692658265
Ref: 95702658348
Ref: 95712658408
Ref: 95722658464
Ref: 95732658536
Ref: 95742658571
Ref: 95752658601
Ref: 95762658673
Ref: 95772658717
Ref: 95782658805
Ref: 95792658839
Ref: 95802658874
Ref: 95812658923
Ref: 95822658989
Ref: 95832659024
Ref: 95842659052
Ref: 95852659091
Ref: 95862659135
Ref: 95872659158
Ref: 95882659324
Ref: 95892659360
Ref: 95902659382
Ref: 95912659412
Ref: 95922659448
Ref: 95932659540
Ref: 95942659554
Ref: 95952659568
Ref: 95962659600
Ref: 95972659650
Ref: 95982659706
Ref: 95992659772
Ref: 96002659793
Ref: 96012659817
Ref: 96022659849
Ref: 96032659888
Ref: 96042659937
Ref: 96052660005
Ref: 96062660033
Ref: 96072660106
Ref: 96082660176
Ref: 96092660199
Ref: 96102660290
Ref: 96112660296
Ref: 96122660395
Ref: 96132660458
Ref: 96142660482
Ref: 96152660581
Ref: 96162660658
Ref: 96172660724
Ref: 96182660750
Ref: 96192660776
Ref: 96202660808
Ref: 96212660899
Ref: 96222660916
Ref: 96232660954
Ref: 96242660971
Ref: 96252661012
Ref: 96262661097
Ref: 96272661168
Ref: 96282661196
Ref: 96292661223
Ref: 96302661302
Ref: 96312661320
Ref: 96322661400
Ref: 96332661417
Ref: 96342661574
Ref: 96352661615
Ref: 96362661713
Ref: 96372661738
Ref: 96382661824
Ref: 96392661851
Ref: 96402661948
Ref: 96412661991
Ref: 96422662106
Ref: 96432662155
Ref: 96442662242
Ref: 96452662264
Ref: 96462662345
Ref: 96472662371
Ref: 96482662432
Ref: 96492662510
Ref: 96502662523
Ref: 96512662574
Ref: 96522662650
Ref: 96532662665
Ref: 96542662687
Ref: 96552662702
Ref: 96562662764
Ref: 96572662798
Ref: 96582662835
Ref: 96592662936
Ref: 96602662963
Ref: 96612662993
Ref: 96622663017
Ref: 96632663113
Ref: 96642663150
Ref: 96652663187
Ref: 96662663268
Ref: 96672663286
Ref: 96682663347
Ref: 96692663399
Ref: 96702663457
Ref: 96712663471
Ref: 96722663525
Ref: 96732663547
Ref: 96742663657
Ref: 96752663684
Ref: 96762663773
Ref: 96772663800
Ref: 96782663848
Ref: 96792663871
Ref: 96802663891
Ref: 96812663914
Ref: 96822663996
Ref: 96832664026
Ref: 96842664075
Ref: 96852664169
Ref: 96862664213
Ref: 96872664301
Ref: 96882664345
Ref: 96892664443
Ref: 96902664487
Ref: 96912664559
Ref: 96922664577
Ref: 96932664640
Ref: 96942664686
Ref: 96952664780
Ref: 96962664831
Ref: 96972664859
Ref: 96982664940
Ref: 96992664973
Ref: 97002664993
Ref: 97012665030
Ref: 97022665113
Ref: 97032665189
Ref: 97042665284
Ref: 97052665302
Ref: 97062665377
Ref: 97072665395
Ref: 97082665469
Ref: 97092665502
Ref: 97102665607
Ref: 97112665628
Ref: 97122665667
Ref: 97132665758
Ref: 97142665779
Ref: 97152665860
Ref: 97162665905
Ref: 97172665995
Ref: 97182666032
Ref: 97192666067
Ref: 97202666108
Ref: 97212666205
Ref: 97222666269
Ref: 97232666275
Ref: 97242666314
Ref: 97252666348
Ref: 97262666390
Ref: 97272666456
Ref: 97282666462
Ref: 97292666501
Ref: 97302666535
Ref: 97312666576
Ref: 97322666634
Ref: 97332666640
Ref: 97342666679
Ref: 97352666761
Ref: 97362666784
Ref: 97372666890
Ref: 97382666908
Ref: 97392667011
Ref: 97402667033
Ref: 97412667059
Ref: 97422667072
Ref: 97432667079
Ref: 97442667119
Ref: 97452667189
Ref: 97462667216
Ref: 97472667222
Ref: 97482667238
Ref: 97492667261
Ref: 97502667295
Ref: 97512667328
Ref: 97522667355
Ref: 97532667360
Ref: 97542667382
Ref: 97552667422
Ref: 97562667510
Ref: 97572667554
Ref: 97582667666
Ref: 97592667686
Ref: 97602667708
Ref: 97612667751
Ref: 97622667853
Ref: 97632667873
Ref: 97642667969
Ref: 97652668011
Ref: 97662668053
Ref: 97672668096
Ref: 97682668145
Ref: 97692668187
Ref: 97702668231
Ref: 97712668281
Ref: 97722668330
Ref: 97732668370
Ref: 97742668411
Ref: 97752668657
Ref: 97762668676
Ref: 97772669227
Ref: 97782669310
Ref: 97792669397
Ref: 97802669482
Ref: 97812669538
Ref: 97822669661
Ref: 97832669690
Ref: 97842669724
Ref: 97852669831
Ref: 97862669869
Ref: 97872669903
Ref: 97882669974
Ref: 97892670041
Ref: 97902670125
Ref: 97912670168
Ref: 97922670174
Ref: 97932670221
Ref: 97942670337
Ref: 97952670368
Ref: 97962670398
Ref: 97972670516
Ref: 97982670570
Ref: 97992670633
Ref: 98002670674
Ref: 98012670721
Ref: 98022670763
Ref: 98032670813
Ref: 98042670838
Ref: 98052670850
Ref: 98062670897
Ref: 98072670968
Ref: 98082670984
Ref: 98092671022
Ref: 98102671038
Ref: 98112671109
Ref: 98122671177
Ref: 98132671184
Ref: 98142671197
Ref: 98152671281
Ref: 98162671292
Ref: 98172671317
Ref: 98182671344
Ref: 98192671355
Ref: 98202671380
Ref: 98212671477
Ref: 98222671492
Ref: 98232671566
Ref: 98242671670
Ref: 98252671704
Ref: 98262671730
Ref: 98272671839
Ref: 98282671853
Ref: 98292671868
Ref: 98302671881
Ref: 98312671938
Ref: 98322671997
Ref: 98332672062
Ref: 98342672124
Ref: 98352672214
Ref: 98362672291
Ref: 98372672335
Ref: 98382672349
Ref: 98392672447
Ref: 98402672454
Ref: 98412672523
Ref: 98422672542
Ref: 98432672608
Ref: 98442672627
Ref: 98452672692
Ref: 98462672729
Ref: 98472672729
Ref: 98482672729
Ref: 98492672729
Ref: 98502672729
Node: Annex Q2718273
Node: Q.12718839
Ref: 98512719015
Node: Q.22730364
Ref: 98522730582
Ref: 98532730582
Node: Q.32746509
Ref: 98542746706
Node: Q.42813784
Ref: 98552813978
Node: Q.52817631
Ref: 98562817858
Ref: 98572817858
Ref: 98582817858
Node: Index2841560
Node: operators2841854
Node: A2843302
Node: B2881021
Node: C2888763
Node: D2923948
Node: E2945220
Node: F2976727
Node: G2990166
Node: H2997716
Node: I3001860
Node: J3028159
Node: K3028349
Node: L3029129
Node: M3044518
Node: N3054008
Node: O3068443
Node: P3075647
Node: Q3102270
Node: R3104071
Node: S3126171
Node: T3155488
Node: U3173459
Node: V3184415
Node: W3188470
Node: X3194655
Node: Y3194789

End Tag Table


Local Variables:
coding: iso-8859-1
End:
